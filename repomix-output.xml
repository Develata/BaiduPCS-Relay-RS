This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.devcontainer/
  devcontainer.json
.github/
  workflows/
    ci.yml
src/
  baidupcs/
    mod.rs
    parser.rs
    share.rs
    transfer.rs
    types.rs
  config.rs
  lib.rs
  main.rs
  state.rs
templates/
  index.html
tests/
  integration_test.rs
.gitignore
angey40-baidupcs-go-8a5edab282632443.txt
Cargo.toml
config.example.toml
diagnose.sh
docker-compose.yml
felixonmars-baidupcs-go-8a5edab282632443 (1).txt
README.md
share_page.html
test_debug_list.sh
test_extract.sh
TRANSFER_FIX.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo build --release
      - run: cargo clippy -- -D warnings
      - run: cargo fmt -- --check

  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo audit
</file>

<file path="src/baidupcs/mod.rs">
//! ç™¾åº¦ç½‘ç›˜æ ¸å¿ƒåŠŸèƒ½

pub mod types;
pub mod share;
pub mod transfer;
pub mod parser;

pub use share::get_share_info;
pub use transfer::transfer_files;
pub use types::ShareFileInfo;
pub use parser::extract_surl;
</file>

<file path="src/baidupcs/parser.rs">
//! é“¾æ¥è§£æï¼ˆä»…ä¿ç•™è½¬å­˜æ‰€éœ€ï¼‰

/// ä»åˆ†äº«é“¾æ¥ä¸­æå– surl
///
/// æ”¯æŒï¼š
/// - https://pan.baidu.com/s/1xxxx
/// - https://pan.baidu.com/share/init?surl=xxxx
/// - ...?surl=xxxx
pub fn extract_surl(share_url: &str) -> Option<String> {
    let url = share_url.trim();

    if let Some(pos) = url.find("/s/") {
        let start = pos + 3;
        if start >= url.len() {
            return None;
        }

        let surl = &url[start..];
        let end = surl
            .find(|c: char| !c.is_alphanumeric() && c != '_' && c != '-')
            .unwrap_or(surl.len());

        if end > 0 {
            return Some(surl[..end].to_string());
        }
    }

    if let Some(pos) = url.find("surl=") {
        let start = pos + 5;
        if start >= url.len() {
            return None;
        }

        let surl = &url[start..];
        let end = surl
            .find(|c: char| !c.is_alphanumeric() && c != '_' && c != '-')
            .unwrap_or(surl.len());

        if end > 0 {
            return Some(surl[..end].to_string());
        }
    }

    None
}
</file>

<file path="src/baidupcs/share.rs">
//! åˆ†äº«æ–‡ä»¶å¤„ç†ï¼ˆå‚è€ƒ baidupcs-go å®ç°ï¼‰

use anyhow::{anyhow, Result};
use serde::Deserialize;
use std::sync::Arc;
use tracing::{debug, info, warn};

use crate::AppState;
use super::types::ShareFileInfo;

#[derive(Debug, Deserialize)]
struct ListResponse {
    errno: i32,
    #[serde(default)]
    list: Vec<FileItem>,
}

#[derive(Debug, Deserialize)]
struct FileItem {
    fs_id: u64,
    #[serde(default)]
    server_filename: String,
}

impl FileItem {
    fn get_fs_id(&self) -> u64 {
        self.fs_id
    }
}

/// è·å–åˆ†äº«æ–‡ä»¶ä¿¡æ¯ï¼ˆå‚è€ƒ baidupcs-go çš„ç®€æ´å®ç°ï¼‰
pub async fn get_share_info(
    state: &Arc<AppState>,
    _share_url: &str,
    surl: &str,
    pwd: &str,
) -> Result<ShareFileInfo> {
    info!("ğŸ“¥ è·å–åˆ†äº«ä¿¡æ¯: surl={}", surl);

    // Baidu çš„ share/init?surl= å‚æ•°é€šå¸¸æ˜¯ä¸å¸¦å‰ç¼€ '1' çš„çŸ­ç ï¼›
    // ä¾‹å¦‚ /s/1nv3DPGX å¯¹åº” surl=nv3DPGXã€‚
    let surl_param = surl.strip_prefix('1').unwrap_or(surl);

    let init_url = format!("https://pan.baidu.com/share/init?surl={}", surl_param);

    // Step 1: è·å– init é¡µé¢ï¼ˆç”¨äºå»ºç«‹æ­£ç¡®çš„ Cookie/ä¸Šä¸‹æ–‡ï¼Œå¹¶æå– shareid/uk/bdstokenï¼‰
    let resp = state
        .client
        .get(&init_url)
        .header("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
        .send()
        .await?;

    let html = resp.text().await?;
    debug!("é¡µé¢é•¿åº¦: {} å­—èŠ‚", html.len());

    // Step 2: æå– shareid å’Œ ukï¼ˆä» HTMLï¼‰
    let (shareid, uk) = extract_share_ids(&html)?;
    debug!("æå–åˆ°: shareid={}, uk={}", shareid, uk);

    // Step 3: æå– bdstoken
    let bdstoken = extract_bdstoken(&html);
    debug!("bdstoken: {}", bdstoken);

    // âœ… Step 4: å¦‚æœæœ‰æå–ç ï¼Œå…ˆéªŒè¯
    if !pwd.is_empty() {
        verify_password(state, surl_param, pwd, &bdstoken).await?;
        info!("âœ… æå–ç éªŒè¯æˆåŠŸ");
    }

    // Step 5: è·å–æ–‡ä»¶åˆ—è¡¨ï¼ˆæ”¯æŒæ–‡ä»¶å’Œæ–‡ä»¶å¤¹ï¼‰
    let (fs_ids, filenames) = get_file_list(state, &shareid, &uk, surl_param, &bdstoken).await?;
    
    if fs_ids.is_empty() {
        return Err(anyhow!("æœªè·å–åˆ°æ–‡ä»¶åˆ—è¡¨"));
    }

    info!("âœ… è·å–åˆ° {} ä¸ªæ–‡ä»¶", fs_ids.len());

    Ok(ShareFileInfo {
        shareid,
        uk,
        fs_ids,
        bdstoken,
        filenames,
    })
}

/// âœ… éªŒè¯æå–ç ï¼ˆå‚è€ƒ baidupcs-goï¼‰
async fn verify_password(
    state: &Arc<AppState>,
    surl: &str,
    pwd: &str,
    bdstoken: &str,
) -> Result<()> {
    let url = "https://pan.baidu.com/share/verify";

    let params = [
        ("surl", surl),
        ("pwd", pwd),
        ("vcode", ""),
        ("vcode_str", ""),
        ("web", "1"),
        ("channel", "chunlei"),
        ("clienttype", "0"),
        ("bdstoken", bdstoken),
    ];

    debug!("éªŒè¯æå–ç : surl={}", surl);

    let resp = state.client
        .post(url)
        .header("User-Agent", "Mozilla/5.0")
        .header("Referer", format!("https://pan.baidu.com/share/init?surl={}", surl))
        .form(&params)
        .send()
        .await?;

    let text = resp.text().await?;
    debug!("verify å“åº”: {}", text);

    #[derive(Deserialize)]
    struct VerifyResponse {
        errno: i32,
    }

    let result: VerifyResponse = serde_json::from_str(&text)?;

    if result.errno != 0 {
        return Err(anyhow!("æå–ç éªŒè¯å¤±è´¥: errno={}", result.errno));
    }

    Ok(())
}

/// è·å–æ–‡ä»¶åˆ—è¡¨ï¼ˆå‚è€ƒ baidupcs-goï¼‰
async fn get_file_list(
    state: &Arc<AppState>,
    shareid: &str,
    uk: &str,
    surl: &str,
    bdstoken: &str,
) -> Result<(Vec<u64>, Vec<String>)> {
    // share/list å¯¹å‚æ•°è¾ƒæ•æ„Ÿï¼šshorturl/root/bdstoken ç¼ºå¤±æ—¶å¸¸è§ errno=-7
    let url = format!(
        "https://pan.baidu.com/share/list?shareid={}&uk={}&shorturl={}&root=1&dir=%2F&page=1&num=1000&order=name&desc=1&showempty=0&web=1&channel=chunlei&clienttype=0&bdstoken={}",
        shareid, uk, surl, bdstoken
    );

    debug!("è°ƒç”¨ list API: {}", url);

    let resp = state.client
        .get(&url)
        .header("User-Agent", "Mozilla/5.0")
        .header("Referer", format!("https://pan.baidu.com/share/init?surl={}", surl))
        .send()
        .await?;

    let text = resp.text().await?;
    debug!("list å“åº”: {}", &text[..200.min(text.len())]);

    let res: ListResponse = serde_json::from_str(&text)
        .map_err(|e| anyhow!("è§£æå“åº”å¤±è´¥: {}", e))?;

    if res.errno != 0 {
        warn!("list API è¿”å›é”™è¯¯: errno={}", res.errno);
        
        // âœ… æä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
        let error_msg = match res.errno {
            -7 => "é“¾æ¥å‡ºé”™ï¼ˆå¯èƒ½éœ€è¦æå–ç æˆ–é“¾æ¥å·²å¤±æ•ˆï¼‰",
            -9 => "æå–ç é”™è¯¯",
            105 => "åˆ†äº«ä¸å­˜åœ¨",
            110 => "åˆ†äº«å·²è¢«å–æ¶ˆ",
            _ => "æœªçŸ¥é”™è¯¯",
        };
        
        return Err(anyhow!("errno={}: {}", res.errno, error_msg));
    }

    let mut fs_ids = Vec::new();
    let mut filenames = Vec::new();
    
    for file in res.list {
        fs_ids.push(file.get_fs_id());
        filenames.push(file.server_filename);
    }

    Ok((fs_ids, filenames))
}


/// ä» HTML æå– shareid å’Œ uk
fn extract_share_ids(html: &str) -> Result<(String, String)> {
    use regex::Regex;

    // æå– shareid
    let shareid_re = Regex::new(r#"shareid['":\s]+(\d+)"#).unwrap();
    let shareid = shareid_re
        .captures(html)
        .and_then(|c| c.get(1))
        .map(|m| m.as_str().to_string())
        .ok_or_else(|| anyhow!("æœªæ‰¾åˆ° shareid"))?;

    // æå– uk
    let uk_re = Regex::new(r#"uk['":\s]+(\d+)"#).unwrap();
    let uk = uk_re
        .captures(html)
        .and_then(|c| c.get(1))
        .map(|m| m.as_str().to_string())
        .ok_or_else(|| anyhow!("æœªæ‰¾åˆ° uk"))?;

    Ok((shareid, uk))
}

/// æå– bdstoken
fn extract_bdstoken(html: &str) -> String {
    use regex::Regex;
    
    let re = Regex::new(r#"bdstoken['":\s]+"?([a-f0-9]+)"?"#).unwrap();
    re.captures(html)
        .and_then(|c| c.get(1))
        .map(|m| m.as_str().to_string())
        .unwrap_or_else(|| "null".to_string())
}
</file>

<file path="src/baidupcs/transfer.rs">
//! è½¬å­˜åŠŸèƒ½ï¼ˆå‚è€ƒ baidupcs-goï¼‰

use anyhow::{anyhow, Result};
use serde::Deserialize;
use std::sync::Arc;
use tracing::{debug, info, warn};

use crate::AppState;

#[derive(Debug, Deserialize)]
struct TransferResult {
    #[serde(default)]
    errno: i32,
    #[serde(default)]
    show_msg: String,
}

/// è½¬å­˜æ–‡ä»¶åˆ°ç½‘ç›˜ï¼ˆå‚è€ƒ baidupcs-go æ­£ç¡®å®ç°ï¼‰
pub async fn transfer_files(
    state: &Arc<AppState>,
    shareid: &str,
    uk: &str,
    fs_ids: &[u64],
    bdstoken: &str,
    surl: &str,
) -> Result<()> {
    info!("ğŸ“¦ å¼€å§‹è½¬å­˜ {} ä¸ªæ–‡ä»¶", fs_ids.len());

    // âœ… å…³é”®ï¼šURL å‚æ•°å®Œå…¨å¯¹é½ baidupcs-go
    let url = format!(
        "https://pan.baidu.com/share/transfer?shareid={}&from={}&ondup=newcopy&async=1&channel=chunlei&clienttype=0&web=1&bdstoken={}",
        shareid, uk, bdstoken
    );

    let fs_id_list = serde_json::to_string(fs_ids)?;
    let save_path = &state.config.baidu.save_path;
    
    let params = [
        ("fsidlist", fs_id_list.as_str()),
        ("path", save_path.as_str()),
    ];

    let surl_param = surl.strip_prefix('1').unwrap_or(surl);
    let referer = format!("https://pan.baidu.com/share/init?surl={}", surl_param);
    
    info!("=== è½¬å­˜å‚æ•° ===");
    info!("URL: {}", url);
    info!("shareid: {}, from(uk): {}", shareid, uk);
    info!("fsidlist: {}", fs_id_list);
    info!("ä¿å­˜è·¯å¾„: {}", save_path);
    info!("Referer: {}", referer);
    
    // å…ˆè®¿é—®åˆ†äº«é¡µé¢å»ºç«‹ä¼šè¯
    debug!("é¢„å…ˆè®¿é—®åˆ†äº«é¡µé¢: {}", referer);
    let _ = state.client
        .get(&referer)
        .header("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
        .send()
        .await;
    
    // âœ… ä½¿ç”¨ baidupcs-go çš„ User-Agent å’Œå®Œæ•´ headers
    let resp = state.client
        .post(&url)
        .header("User-Agent", "netdisk;2.2.51.6;netdisk;10.0.63;PC;android-android")
        .header("Referer", &referer)
        .header("Host", "pan.baidu.com")
        .header("Origin", "https://pan.baidu.com")
        .header("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
        .header("Accept", "application/json, text/javascript, */*; q=0.01")
        .header("Accept-Language", "zh-CN,zh;q=0.9,en;q=0.8")
        .header("X-Requested-With", "XMLHttpRequest")
        .form(&params)
        .send()
        .await?;

    let status = resp.status();
    debug!("è½¬å­˜å“åº”çŠ¶æ€: {}", status);

    let text = resp.text().await?;
    info!("ğŸ“‹ è½¬å­˜å®Œæ•´å“åº”: {}", text);

    let result: TransferResult = serde_json::from_str(&text)
        .map_err(|e| anyhow!("è§£æå“åº”å¤±è´¥: {}, body: {}", e, text))?;

    // âœ… å‚è€ƒ baidupcs-go çš„é”™è¯¯å¤„ç†
    match result.errno {
        0 => {
            info!("âœ… è½¬å­˜æˆåŠŸ (errno=0)");
            Ok(())
        }
        2 => {
            if result.show_msg.contains("æˆåŠŸ") 
                || result.show_msg.contains("ä¿å­˜æˆåŠŸ")
                || result.show_msg.contains("è½¬å­˜æˆåŠŸ") {
                info!("âœ… è½¬å­˜æˆåŠŸ: {}", result.show_msg);
                Ok(())
            } else if result.show_msg.contains("å·²å­˜åœ¨") {
                warn!("âš ï¸ API è¿”å›'æ–‡ä»¶å·²å­˜åœ¨'ï¼Œå¯èƒ½æ˜¯ Cookie æ— æ•ˆ");
                warn!("âš ï¸ BDUSS å‰20å­—ç¬¦: {}...", 
                      &state.config.baidu.cookie_bduss.chars().take(20).collect::<String>());
                warn!("âš ï¸ STOKEN å‰20å­—ç¬¦: {}...", 
                      &state.config.baidu.cookie_stoken.chars().take(20).collect::<String>());
                
                Err(anyhow!(
                    "è½¬å­˜å¤±è´¥ï¼š{}ã€‚\n\
                    å¯èƒ½åŸå› ï¼š\n\
                    1. Cookie (BDUSS/STOKEN) å·²è¿‡æœŸï¼Œè¯·æ›´æ–° config.toml\n\
                    2. è¿™æ˜¯æ‚¨è‡ªå·±çš„åˆ†äº«ï¼Œæ— éœ€è½¬å­˜\n\
                    3. æ–‡ä»¶ç¡®å®å·²å­˜åœ¨äºç½‘ç›˜ä¸­\n\
                    å®Œæ•´å“åº”: {}",
                    result.show_msg, text
                ))
            } else {
                warn!("âš ï¸ errno=2 ä½†æ¶ˆæ¯ä¸æ˜ç¡®: {}", result.show_msg);
                Err(anyhow!("è½¬å­˜å¤±è´¥: {}", result.show_msg))
            }
        }
        12 => {
            info!("âœ… è½¬å­˜æˆåŠŸ (errno=12)");
            Ok(())
        }
        -20 => {
            Err(anyhow!("åˆ†äº«å·²å¤±æ•ˆæˆ–è¢«å–æ¶ˆ"))
        }
        _ => {
            Err(anyhow!(
                "è½¬å­˜å¤±è´¥: errno={}, show_msg='{}', å®Œæ•´å“åº”: {}",
                result.errno, result.show_msg, text
            ))
        }
    }
}

/// å…¼å®¹æ—§ä»£ç ï¼šdo_transfer
pub async fn do_transfer(
    state: Arc<AppState>,
    shareid: String,
    uk: String,
    fs_ids: Vec<u64>,
    bdstoken: String,
    surl: &str,
    _savepath: &str,
) -> Result<Vec<u64>> {
    transfer_files(&state, &shareid, &uk, &fs_ids, &bdstoken, surl).await?;
    Ok(fs_ids)
}
</file>

<file path="src/baidupcs/types.rs">
//! æ•°æ®ç±»å‹

#[derive(Debug, Clone)]
pub struct ShareFileInfo {
    pub shareid: String,
    pub uk: String,
    pub fs_ids: Vec<u64>,
    pub bdstoken: String,
    pub filenames: Vec<String>,  // æ–‡ä»¶ååˆ—è¡¨
}
</file>

<file path="src/config.rs">
//! é…ç½®æ–‡ä»¶åŠ è½½

use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::fs;

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Config {
    pub baidu: BaiduConfig,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct BaiduConfig {
    pub cookie_bduss: String,
    pub cookie_stoken: String,
    #[serde(default = "default_save_path")]
    pub save_path: String,
    #[serde(default = "default_http_timeout_secs")]
    pub http_timeout_secs: u64,
}

fn default_save_path() -> String {
    "/æˆ‘çš„èµ„æº".to_string()
}

fn default_http_timeout_secs() -> u64 {
    30
}

impl Config {
    pub fn load(path: &str) -> Result<Self> {
        let content = fs::read_to_string(path)?;
        let config: Config = toml::from_str(&content)?;
        Ok(config)
    }

    /// è·å–åº”ç”¨ User-Agent
    pub fn app_ua() -> &'static str {
        "netdisk;2.2.51.6;netdisk;10.0.63;PC;android-android"
    }

    /// è·å–æµè§ˆå™¨ User-Agent
    pub fn browser_ua() -> &'static str {
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    }
}
</file>

<file path="src/lib.rs">
//! ç™¾åº¦ç½‘ç›˜è½¬å­˜ï¼ˆç²¾ç®€ç‰ˆï¼‰

pub mod baidupcs;
pub mod config;
pub mod state;

pub use config::Config;
pub use state::AppState;

/// åº“ç‰ˆæœ¬
pub const VERSION: &str = env!("CARGO_PKG_VERSION");  // âœ… ä¿®å¤ï¼šç§»é™¤äº†åæ–œæ 
</file>

<file path="src/state.rs">
//! æœ€å°åº”ç”¨çŠ¶æ€ï¼ˆä»…ç”¨äºç™¾åº¦ç½‘ç›˜è½¬å­˜ï¼‰

use anyhow::{anyhow, Result};
use reqwest::{cookie::Jar, Client, Url};
use std::sync::Arc;

use crate::config::Config;

pub struct AppState {
    pub config: Config,
    pub client: Client,
}

impl AppState {
    pub fn new(config: Config) -> Result<Self> {
        if config.baidu.cookie_bduss.is_empty() || config.baidu.cookie_bduss.len() < 50 {
            return Err(anyhow!("BDUSS æœªé…ç½®æˆ–é•¿åº¦ä¸è¶³ï¼Œè¯·åœ¨ config.toml ä¸­è®¾ç½®å®Œæ•´çš„ BDUSS"));
        }
        if config.baidu.cookie_stoken.is_empty() || config.baidu.cookie_stoken.len() < 30 {
            return Err(anyhow!("STOKEN æœªé…ç½®æˆ–é•¿åº¦ä¸è¶³ï¼Œè¯·åœ¨ config.toml ä¸­è®¾ç½®å®Œæ•´çš„ STOKEN"));
        }

        let jar = Arc::new(Jar::default());
        let domains = [
            "https://baidu.com",
            "https://pan.baidu.com",
            "https://passport.baidu.com",
        ];

        for domain in domains {
            let url = domain.parse::<Url>()?;
            jar.add_cookie_str(
                &format!("BDUSS={}; Domain=.baidu.com; Path=/", config.baidu.cookie_bduss),
                &url,
            );
            jar.add_cookie_str(
                &format!("STOKEN={}; Domain=.baidu.com; Path=/", config.baidu.cookie_stoken),
                &url,
            );
        }

        let client = Client::builder()
            .cookie_provider(jar)
            .timeout(std::time::Duration::from_secs(config.baidu.http_timeout_secs))
            .build()?;

        Ok(Self { config, client })
    }
}
</file>

<file path="templates/index.html">
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç™¾åº¦ç½‘ç›˜ç›´é“¾è½¬æ¢</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #667eea;
            margin-bottom: 30px;
            text-align: center;
            font-size: 2em;
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
        }
        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border 0.3s;
        }
        input:focus {
            outline: none;
            border-color: #667eea;
        }
        button {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }
        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .file-item {
            background: #f8f9fa;
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .download-btn {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”— ç™¾åº¦ç½‘ç›˜ç›´é“¾è½¬æ¢</h1>
        <form action="/api/convert" method="post">
            <div class="form-group">
                <label>è®¿é—®å¯†ç </label>
                <input type="password" name="token" placeholder="è¯·è¾“å…¥è®¿é—®å¯†ç " required>
            </div>
            <div class="form-group">
                <label>åˆ†äº«é“¾æ¥</label>
                <input type="text" name="link" placeholder="https://pan.baidu.com/s/xxxxx" required>
            </div>
            <div class="form-group">
                <label>æå–ç ï¼ˆå¯é€‰ï¼‰</label>
                <input type="text" name="pwd" placeholder="è‹¥æœ‰æå–ç è¯·è¾“å…¥">
            </div>
            <button type="submit">å¼€å§‹è½¬æ¢</button>
        </form>
    </div>
</body>
</html>
</file>

<file path="tests/integration_test.rs">
#[cfg(test)]
mod tests {
    #[test]
    fn test_basic() {
        assert_eq!(1 + 1, 2);
    }
}
</file>

<file path=".gitignore">
/target/
config.toml
*.log
.env
.DS_Store

# Tokenæ–‡ä»¶
token.json
*.encrypted
</file>

<file path="angey40-baidupcs-go-8a5edab282632443.txt">
Directory structure:
â””â”€â”€ angey40-baidupcs-go/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ build.sh
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ main.go
    â”œâ”€â”€ baidupcs/
    â”‚   â”œâ”€â”€ baidupcs.go
    â”‚   â”œâ”€â”€ download.go
    â”‚   â”œâ”€â”€ error.go
    â”‚   â”œâ”€â”€ file_directory.go
    â”‚   â”œâ”€â”€ quota.go
    â”‚   â”œâ”€â”€ rm_mkdir.go
    â”‚   â””â”€â”€ util.go
    â”œâ”€â”€ command/
    â”‚   â”œâ”€â”€ cd.go
    â”‚   â”œâ”€â”€ command.go
    â”‚   â”œâ”€â”€ download.go
    â”‚   â”œâ”€â”€ ls.go
    â”‚   â”œâ”€â”€ meta.go
    â”‚   â”œâ”€â”€ quota.go
    â”‚   â”œâ”€â”€ rm_mkdir.go
    â”‚   â””â”€â”€ util.go
    â”œâ”€â”€ config/
    â”‚   â”œâ”€â”€ check_bduss.go
    â”‚   â”œâ”€â”€ config.go
    â”‚   â”œâ”€â”€ deleter.go
    â”‚   â”œâ”€â”€ get_checker.go
    â”‚   â””â”€â”€ seter.go
    â”œâ”€â”€ downloader/
    â”‚   â”œâ”€â”€ downloader.go
    â”‚   â”œâ”€â”€ downloader_block.go
    â”‚   â”œâ”€â”€ downloader_config.go
    â”‚   â”œâ”€â”€ example.go
    â”‚   â”œâ”€â”€ fetch.go
    â”‚   â”œâ”€â”€ http_client.go
    â”‚   â””â”€â”€ resume_breakpoint.go
    â””â”€â”€ util/
        â”œâ”€â”€ convert.go
        â”œâ”€â”€ error.go
        â”œâ”€â”€ log_colorable_prefix.go
        â”œâ”€â”€ regexp_pre.go
        â”œâ”€â”€ tieba_client_signature.go
        â”œâ”€â”€ time.go
        â”œâ”€â”€ unsafe_strconv_test.go
        â”œâ”€â”€ util.go
        â”œâ”€â”€ wait_group.go
        â””â”€â”€ wait_group_test.go

================================================
FILE: README.md
================================================
[Binary file]


================================================
FILE: build.sh
================================================
name="BaiduPCS-Go"
version="beta-v2"

Build(){
    echo "Building $1..."
    export GOOS=$2 GOARCH=$3 GO386=sse2 CGO_ENABLED=0
    if [ $2 = "windows" ];then
        go build -ldflags "-s -w" -o "out/$1/$name.exe"
    else
        go build -ldflags "-s -w" -o "out/$1/$name"
    fi
    mkdir "out/$1/download"
    cd out
    zip -q -r "$1.zip" "$1"
    cd ..
    echo Done!
}

ArmBuild(){
    echo "Building $1..."
    export GOOS=$2 GOARCH=$3 GOARM=$4 CGO_ENABLED=1
    go build -ldflags '-s -w -linkmode=external -extldflags=-pie' -o "out/$1/$name"
    if [ $2 = "darwin" -a $3 = "arm64" ];then
        ldid -S "out/$1/$name"
    fi
    mkdir "out/$1/download"
    cd out
    zip -q -r "$1.zip" "$1"
    cd ..
    echo Done!
}

# android
export NDK_INSTALL=$ANDROID_NDK_ROOT/bin
# CC=$NDK_INSTALL/arm-linux-androideabi/bin/arm-linux-androideabi-gcc ArmBuild $name-$version"-android-16-armv5" android arm 5
# CC=$NDK_INSTALL/arm-linux-androideabi/bin/arm-linux-androideabi-gcc ArmBuild $name-$version"-android-16-armv6" android arm 6
CC=$NDK_INSTALL/arm-linux-androideabi/bin/arm-linux-androideabi-gcc ArmBuild $name-$version"-android-16-armv7" android arm 7
CC=$NDK_INSTALL/aarch64-linux-android/bin/aarch64-linux-android-gcc ArmBuild $name-$version"-android-21-arm64" android arm64 7
CC=$NDK_INSTALL/i686-linux-android/bin/i686-linux-android-gcc ArmBuild $name-$version"-android-16-386" android 386 7
CC=$NDK_INSTALL/x86_64-linux-android/bin/x86_64-linux-android-gcc ArmBuild $name-$version"-android-21-amd64" android amd64 7

# ios 
CC=/usr/local/go/misc/ios/clangwrap.sh ArmBuild $name-$version"-darwin-ios-5.0-armv7" darwin arm 7
CC=/usr/local/go/misc/ios/clangwrap.sh ArmBuild $name-$version"-darwin-ios-5.0-arm64" darwin arm64 7

# OS X / macOS
Build $name-$version"-darwin-osx-amd64" darwin amd64
# Build $name-$version"-darwin-osx-386" darwin 386

# Windows
Build $name-$version"-windows-x86" windows 386
Build $name-$version"-windows-x64" windows amd64

# Linux
Build $name-$version"-linux-386" linux 386
Build $name-$version"-linux-amd64" linux amd64
Build $name-$version"-linux-arm" linux arm
Build $name-$version"-linux-arm64" linux arm64
# Build $name-$version"-linux-mips" linux mips
# Build $name-$version"-linux-mips64" linux mips64
# Build $name-$version"-linux-mipsel" linux mipsle
# Build $name-$version"-linux-mips64el" linux mips64le
# Build $name-$version"-linux-ppc64" linux ppc64
# Build $name-$version"-linux-ppc64le" linux ppc64le
# Build $name-$version"-linux-s390x" linux s390x

# other
# $name-$version
# Build $name-$version"-solaris-amd64" solaris amd64
Build $name-$version"-freebsd-386" freebsd 386
# Build $name-$version"-freebsd-amd64" freebsd amd64
# Build $name-$version"-freebsd-arm" freebsd arm
# Build $name-$version"-netbsd-386" netbsd	386
# Build $name-$version"-netbsd-amd64" netbsd amd64
# Build $name-$version"-netbsd-arm" netbsd	arm
# Build $name-$version"-openbsd-386" openbsd 386
# Build $name-$version"-openbsd-amd64" openbsd	amd64
# Build $name-$version"-openbsd-arm" openbsd arm
# Build $name-$version"-plan9-386" plan9 386
# Build $name-$version"-plan9-amd64" plan9 amd64
# Build $name-$version"-plan9-arm" plan9 arm
# Build $name-$version"-nacl-386" nacl 386
# Build $name-$version"-nacl-amd64p32" nacl amd64p32
# Build $name-$version"-nacl-arm" nacl arm
# Build $name-$version"-dragonflybsd-amd64" dragonfly amd64



================================================
FILE: LICENSE
================================================
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.




================================================
FILE: main.go
================================================
[Binary file]


================================================
FILE: baidupcs/baidupcs.go
================================================
package baidupcs

import (
	"fmt"
	"net/url"
)

var (
	appid = 260149
)

// PCSApi ç™¾åº¦ PCS API è¯¦æƒ…
type PCSApi struct {
	url   url.URL
	bduss string

	writed bool
}

// NewPCS æä¾› ç™¾åº¦BDUSS, è¿”å› PCSApi æŒ‡é’ˆå¯¹è±¡
func NewPCS(bduss string) *PCSApi {
	return &PCSApi{
		url: url.URL{
			Scheme:   "http",
			Host:     "pcs.baidu.com",
			Path:     "/rest/2.0/pcs/",
			RawQuery: fmt.Sprintf("app_id=%d", appid)},
		bduss:  bduss,
		writed: false,
	}
}

func (p *PCSApi) addItem(subPath, method string, param ...map[string]string) {
	if p.writed {
		panic("addItem: Already writed")
	}
	p.url.Path += subPath
	uv := p.url.Query()
	uv.Set("method", method)
	for k := range param {
		for k2 := range param[k] {
			uv.Set(k2, param[k][k2])
		}
	}
	p.url.RawQuery = uv.Encode()
	p.writed = true
}



================================================
FILE: baidupcs/download.go
================================================
package baidupcs

import (
	"fmt"
	"github.com/iikira/BaiduPCS-Go/config"
	"github.com/iikira/BaiduPCS-Go/downloader"
	"github.com/iikira/BaiduPCS-Go/util"
	"net/http"
	"net/http/cookiejar"
	"os"
	"strings"
	"time"
)

// FileDownload ä¸‹è½½ç½‘ç›˜å†…æ–‡ä»¶
func (p PCSApi) FileDownload(path string, size int64) (err error) {
	// addItem æ”¾åœ¨æœ€å
	p.addItem("file", "download", map[string]string{
		"path": path,
	})

	h := downloader.NewHTTPClient()
	jar, _ := cookiejar.New(nil)
	jar.SetCookies(&p.url, []*http.Cookie{
		&http.Cookie{
			Name:  "BDUSS",
			Value: p.bduss,
		},
	})
	h.SetCookiejar(jar)
	h.SetKeepAlive(true)
	h.SetTimeout(2 * time.Minute)

	fileDl, err := downloader.NewFileDl(h, p.url.String(), pcsconfig.GetSavePath(path), size)
	if err != nil {
		return err
	}

	pa := make(chan struct{})

	var exit = make(chan bool)

	fileDl.OnStart(func() {
		t1 := time.Now()
	for_1:
		for {
			status := fileDl.GetStatus()

			select {
			case <-exit:
				break for_1
			default:
				time.Sleep(time.Second * 1)
				fmt.Printf("\r%v/%v %v/s time: %s %v",
					pcsutil.ConvertFileSize(status.Downloaded, 2),
					pcsutil.ConvertFileSize(fileDl.Size, 2),
					pcsutil.ConvertFileSize(status.Speeds, 2),
					time.Since(t1)/1000000*1000000,
					"[DOWNLOADING]"+strings.Repeat(" ", 10),
				)
				os.Stdout.Sync()
			}
		}
	})

	fileDl.OnFinish(func() {
		exit <- true
		pa <- struct{}{}
	})

	fileDl.Start()
	<-pa
	fmt.Printf("\n\nä¸‹è½½å®Œæˆ, ä¿å­˜ä½ç½®: %s\n\n", pcsconfig.GetSavePath(path))
	return nil
}



================================================
FILE: baidupcs/error.go
================================================
package baidupcs



================================================
FILE: baidupcs/file_directory.go
================================================
package baidupcs

import (
	"fmt"
	"github.com/bitly/go-simplejson"
	"github.com/iikira/BaiduPCS-Go/downloader"
	"github.com/iikira/BaiduPCS-Go/util"
)

// FileDirectory æ–‡ä»¶æˆ–ç›®å½•çš„è¯¦ç»†ä¿¡æ¯
type FileDirectory struct {
	FsID        int64
	Path        string
	Filename    string
	Ctime       int64
	MD5         string
	Size        int64
	Isdir       bool
	Ifhassubdir bool
}

// FileDirectoryList FileDirectory çš„ æ•°ç»„
type FileDirectoryList []FileDirectory

// FilesDirectoriesMeta è·å–å•ä¸ªæ–‡ä»¶/ç›®å½•çš„å…ƒä¿¡æ¯
//
// å¯ç”¨ä¿¡æ¯: æ˜¯å¦æ˜¯ç›®å½•isdir æ˜¯å¦å«æœ‰å­ç›®å½•ifhassubdir ä¿®æ”¹æ—¶é—´mtime æ–‡ä»¶å¤§å°size
func (p PCSApi) FilesDirectoriesMeta(path string) (data FileDirectory, err error) {
	if path == "" {
		path = "/"
	}

	p.addItem("file", "meta", map[string]string{
		"path": path,
	})

	h := downloader.NewHTTPClient()
	body, err := h.Fetch("GET", p.url.String(), nil, map[string]string{
		"Cookie": "BDUSS=" + p.bduss,
	})
	if err != nil {
		return
	}

	json, err := simplejson.NewJson(body)

	code, err := checkErr(json)
	if err != nil {
		err = fmt.Errorf("è·å–å•ä¸ªæ–‡ä»¶/ç›®å½•çš„å…ƒä¿¡æ¯é‡åˆ°é”™è¯¯, è·¯å¾„: %s, é”™è¯¯ä»£ç : %d, æ¶ˆæ¯: %s", path, code, err)
		return
	}

	json = json.Get("list").GetIndex(0)

	data = FileDirectory{
		FsID:        json.Get("fs_id").MustInt64(),
		Path:        json.Get("path").MustString(),
		Filename:    json.Get("server_filename").MustString(),
		Ctime:       json.Get("ctime").MustInt64(),
		MD5:         json.Get("md5").MustString(),
		Size:        json.Get("size").MustInt64(),
		Isdir:       pcsutil.IntToBool(json.Get("isdir").MustInt()),
		Ifhassubdir: pcsutil.IntToBool(json.Get("ifhassubdir").MustInt()),
	}

	return
}

// FileList è·å–ç›®å½•ä¸‹çš„æ–‡ä»¶åˆ—è¡¨
func (p PCSApi) FileList(path string) (data FileDirectoryList, err error) {
	if path == "" {
		path = "/"
	}

	p.addItem("file", "list", map[string]string{
		"path":  path,
		"by":    "name",
		"order": "asc",
		"limit": "0-2147483647",
	})

	h := downloader.NewHTTPClient()
	body, err := h.Fetch("GET", p.url.String(), nil, map[string]string{
		"Cookie": "BDUSS=" + p.bduss,
	})
	if err != nil {
		return
	}

	json, err := simplejson.NewJson(body)
	if err != nil {
		return
	}

	code, err := checkErr(json)
	if err != nil {
		return nil, fmt.Errorf("è·å–ç›®å½•ä¸‹çš„æ–‡ä»¶åˆ—è¡¨é‡åˆ°é”™è¯¯, è·¯å¾„: %s, é”™è¯¯ä»£ç : %d, æ¶ˆæ¯: %s", path, code, err)
	}

	json = json.Get("list")

	for i := 0; ; i++ {
		index := json.GetIndex(i)
		fsID := index.Get("fs_id").MustInt64()
		if fsID == 0 {
			break
		}
		data = append(data, FileDirectory{
			FsID:     fsID,
			Path:     index.Get("path").MustString(),
			Filename: index.Get("server_filename").MustString(),
			Ctime:    index.Get("ctime").MustInt64(),
			MD5:      index.Get("md5").MustString(),
			Size:     index.Get("size").MustInt64(),
			Isdir:    pcsutil.IntToBool(index.Get("isdir").MustInt()),
		})
	}
	return
}

func (f FileDirectory) String() string {
	if f.Isdir {
		return fmt.Sprintf("ç±»å‹: ç›®å½• \nç›®å½•åç§°: %s \nç›®å½•è·¯å¾„: %s \nfs_id: %d \nåˆ›å»ºæ—¶é—´: %s \næ˜¯å¦å«æœ‰å­ç›®å½•: %t\n",
			f.Filename,
			f.Path,
			f.FsID,
			pcsutil.FormatTime(f.Ctime),
			f.Ifhassubdir,
		)
	}

	return fmt.Sprintf("ç±»å‹: æ–‡ä»¶ \næ–‡ä»¶å: %s \næ–‡ä»¶è·¯å¾„: %s \næ–‡ä»¶å¤§å°: %d \nmd5: %s \nfs_id: %d \nåˆ›å»ºæ—¶é—´: %s \n",
		f.Filename,
		f.Path,
		f.Size,
		f.MD5,
		f.FsID,
		pcsutil.FormatTime(f.Ctime),
	)
}

// TotalSize è·å–æ€»æ–‡ä»¶å¤§å°
func (f *FileDirectoryList) TotalSize() int64 {
	var size int64
	for k := range *f {
		size += (*f)[k].Size
	}
	return size
}

// Count è·å–æ–‡ä»¶æ€»æ•°å’Œç›®å½•æ€»æ•°
func (f *FileDirectoryList) Count() (fileN, directoryN int64) {
	for k := range *f {
		if (*f)[k].Isdir {
			directoryN++
		} else {
			fileN++
		}
	}
	return
}



================================================
FILE: baidupcs/quota.go
================================================
package baidupcs

import (
	"fmt"
	"github.com/bitly/go-simplejson"
	"github.com/iikira/BaiduPCS-Go/downloader"
)

// QuotaInfo è·å–å½“å‰ç”¨æˆ·ç©ºé—´é…é¢ä¿¡æ¯
func (p PCSApi) QuotaInfo() (quota, used int64, err error) {
	p.addItem("quota", "info")

	h := downloader.NewHTTPClient()
	body, err := h.Fetch("GET", p.url.String(), nil, map[string]string{
		"Cookie": "BDUSS=" + p.bduss,
	})
	if err != nil {
		return
	}

	json, err := simplejson.NewJson(body)
	if err != nil {
		return
	}

	code, err := checkErr(json)
	if err != nil {
		return 0, 0, fmt.Errorf("è·å–å½“å‰ç”¨æˆ·ç©ºé—´é…é¢ä¿¡æ¯, é”™è¯¯ä»£ç : %d, æ¶ˆæ¯: %s", code, err)
	}

	quota = json.Get("quota").MustInt64()
	used = json.Get("used").MustInt64()

	return
}



================================================
FILE: baidupcs/rm_mkdir.go
================================================
[Binary file]


================================================
FILE: baidupcs/util.go
================================================
package baidupcs

import (
	"errors"
	"github.com/bitly/go-simplejson"
)

func checkErr(json *simplejson.Json) (code int, msg error) {
	codeJSON, ok1 := json.CheckGet("error_code")
	msgJSON, ok2 := json.CheckGet("error_msg")
	if !ok1 && !ok2 { // æ²¡æœ‰é”™è¯¯
		return 0, nil
	}

	errCode := codeJSON.MustInt()
	errMsg := msgJSON.MustString()
	switch errCode {
	case 31045: // user not exists
		errMsg = "æ“ä½œå¤±è´¥, å¯èƒ½BDUSSå·²è¿‡æœŸ, è¯·å°è¯•è¿è¡Œ login å‘½ä»¤é‡æ–°ç™»å½•, æ¶ˆæ¯: " + errMsg
	}
	return errCode, errors.New(errMsg)
}



================================================
FILE: command/cd.go
================================================
package baidupcscmd

import (
	"fmt"
	"github.com/iikira/BaiduPCS-Go/config"
)

// RunChangeDirectory æ‰§è¡Œæ›´æ”¹å·¥ä½œç›®å½•
func RunChangeDirectory(path string) {
	path, err := toAbsPath(path)
	if err != nil {
		fmt.Println(err)
		return
	}

	data, err := info.FilesDirectoriesMeta(path)
	if err != nil {
		fmt.Println(err)
		return
	}

	if !data.Isdir {
		fmt.Printf("é”™è¯¯: %s ä¸æ˜¯ä¸€ä¸ªç›®å½• (æ–‡ä»¶å¤¹)\n", path)
		return
	}

	pcsconfig.ActiveBaiduUser.Workdir = path
	pcsconfig.Config.Save()

	fmt.Printf("æ”¹å˜å·¥ä½œç›®å½•: %s\n", path)
}



================================================
FILE: command/command.go
================================================
package baidupcscmd

import (
	"github.com/iikira/BaiduPCS-Go/baidupcs"
	"github.com/iikira/BaiduPCS-Go/config"
	"os"
)

var (
	info = new(baidupcs.PCSApi)
)

func init() {
	ReloadInfo()
}

// ReloadInfo é‡è½½é…ç½®
func ReloadInfo() {
	pcsconfig.Reload()
	info = baidupcs.NewPCS(pcsconfig.ActiveBaiduUser.BDUSS)
}

// ReloadIfInConsole ç¨‹åºåœ¨ Console æ¨¡å¼ä¸‹æ‰å›é‡è½½é…ç½®
func ReloadIfInConsole() {
	if len(os.Args) == 1 {
		ReloadInfo()
	}
}



================================================
FILE: command/download.go
================================================
package baidupcscmd

import (
	"fmt"
	"github.com/iikira/BaiduPCS-Go/config"
	"github.com/iikira/BaiduPCS-Go/downloader"
	"github.com/iikira/BaiduPCS-Go/util"
	"os"
)

// RunDownload æ‰§è¡Œä¸‹è½½ç½‘ç›˜å†…æ–‡ä»¶
func RunDownload(paths ...string) {
	downloader.SetCacheSize(2048)
	downloader.SetMaxParallel(pcsconfig.Config.MaxParallel)

	paths = getAllPaths(paths...)

	fmt.Println()
	for k := range paths {
		fmt.Printf("æ·»åŠ ä¸‹è½½ä»»åŠ¡: %s\n", paths[k])
	}
	fmt.Println()

	for k, path := range paths {
		downloadInfo, err := info.FilesDirectoriesMeta(path)
		if err != nil {
			fmt.Println(err)
			continue
		}

		fmt.Printf("[ %d / %d ] %s\n", k+1, len(paths), downloadInfo.String())

		// å¦‚æœæ˜¯ä¸€ä¸ªç›®å½•, é€’å½’ä¸‹è½½è¯¥ç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶
		if downloadInfo.Isdir {
			fmt.Printf("å³å°†ä¸‹è½½ç›®å½•: %s\n\n", path)

			fileN, directoryN, size := recurseFDCountTotalSize(path)
			statText := fmt.Sprintf("ç»Ÿè®¡: ç›®å½•æ€»æ•°: %d, æ–‡ä»¶æ€»æ•°: %d, æ–‡ä»¶æ€»å¤§å°: %s\n\n",
				directoryN,
				fileN,
				pcsutil.ConvertFileSize(size),
			)

			fmt.Printf(statText)
			downloadDirectory(path)
			fmt.Printf("ç›®å½• %s ä¸‹è½½å®Œæˆ, %s", path, statText)
			continue
		}

		fmt.Printf("å³å°†å¼€å§‹ä¸‹è½½æ–‡ä»¶\n\n")

		err = info.FileDownload(path, downloadInfo.Size)
		if err != nil {
			fmt.Printf("ä¸‹è½½æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: %s (è·³è¿‡...)\n\n", err)
		}
	}
}

func downloadDirectory(path string) {
	di, err := info.FileList(path)
	if err != nil {
		fmt.Println("å‘ç”Ÿé”™è¯¯,", err)
	}

	// é‡åˆ°ç©ºç›®å½•, åˆ™åˆ›å»ºç›®å½•
	if len(di) == 0 {
		os.MkdirAll(pcsconfig.GetSavePath(path), 0777)
		return
	}

	for k := range di {
		if di[k].Isdir {
			downloadDirectory(di[k].Path)
			continue
		}

		// å¦‚æœæ–‡ä»¶å­˜åœ¨, è·³è¿‡
		if pcsconfig.CheckFileExist(di[k].Path) {
			fmt.Printf("æ–‡ä»¶å·²å­˜åœ¨ (è‡ªåŠ¨è·³è¿‡): %s\n\n", pcsconfig.GetSavePath(di[k].Path))
			continue
		}

		fmt.Println(di[k])
		fmt.Printf("å³å°†å¼€å§‹ä¸‹è½½æ–‡ä»¶: %s\n\n", di[k].Filename)

		err = info.FileDownload(di[k].Path, di[k].Size)
		if err != nil {
			fmt.Println(err)
		}
		fmt.Println("------------------------------------------------------------")
	}
}



================================================
FILE: command/ls.go
================================================
package baidupcscmd

import (
	"fmt"
	"github.com/iikira/BaiduPCS-Go/util"
	"os"
	"text/template"
)

// RunLs æ‰§è¡Œåˆ—ç›®å½•
func RunLs(path string) {
	path, err := toAbsPath(path)
	if err != nil {
		fmt.Println(err)
		return
	}
	files, err := info.FileList(path)

	if err != nil {
		fmt.Println(err)
		return
	}

	if len(files) == 0 {
		RunGetMeta(path)
		return
	}

	for k := range files {
		if files[k].Isdir {
			files[k].Path += "/"
		}
	}

	tmpl, err := template.New("ls").Funcs(
		template.FuncMap{
			"convertFileSize": func(size int64) string {
				res := pcsutil.ConvertFileSize(size)
				if res == "0" {
					return "-       "
				}
				return res
			},
			"timeFmt": pcsutil.FormatTime,
			"totalSize": func() string {
				return pcsutil.ConvertFileSize(files.TotalSize())
			},
			"fdCount": func() string {
				fN, dN := files.Count()
				return fmt.Sprintf("æ–‡ä»¶æ€»æ•°: %d,\tç›®å½•æ€»æ•°: %d", fN, dN)
			},
		},
	).Parse(
		`
æ–‡ä»¶å¤§å°	åˆ›å»ºæ—¥æœŸ		æ–‡ä»¶(ç›®å½•)
------------------------------------------------------------------------------{{range .}}
{{convertFileSize .Size}}	{{timeFmt .Ctime}}	{{.Path}} {{end}}
------------------------------------------------------------------------------
æ€»å¤§å°: {{totalSize}}	{{fdCount}}
`)
	if err != nil {
		panic(err)
	}

	err = tmpl.Execute(os.Stdout, files)
	if err != nil {
		panic(err)
	}
}



================================================
FILE: command/meta.go
================================================
package baidupcscmd

import (
	"fmt"
)

// RunGetMeta æ‰§è¡Œ è·å–å•ä¸ªæ–‡ä»¶/ç›®å½•çš„å…ƒä¿¡æ¯
func RunGetMeta(path string) {
	p, err := toAbsPath(path)
	if err != nil {
		fmt.Println(err)
		return
	}

	data, err := info.FilesDirectoriesMeta(p)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println()
	fmt.Println(data)
}



================================================
FILE: command/quota.go
================================================
package baidupcscmd

import (
	"fmt"
	"github.com/iikira/BaiduPCS-Go/util"
)

// RunGetQuota æ‰§è¡Œ è·å–å½“å‰ç”¨æˆ·ç©ºé—´é…é¢ä¿¡æ¯, å¹¶è¾“å‡º
func RunGetQuota() {
	quota, used, err := info.QuotaInfo()
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("æ€»ç©ºé—´: %s, å·²ç”¨ç©ºé—´: %s, æ¯”ç‡: %f%%\n",
		pcsutil.ConvertFileSize(quota),
		pcsutil.ConvertFileSize(used),
		100*float64(used)/float64(quota),
	)
}



================================================
FILE: command/rm_mkdir.go
================================================
package baidupcscmd

import (
	"fmt"
)

// RunRemove æ‰§è¡Œ æ‰¹é‡åˆ é™¤æ–‡ä»¶/ç›®å½•
func RunRemove(paths ...string) {
	paths = getAllPaths(paths...)

	pnt := func() {
		for k := range paths {
			fmt.Printf("%d: %s\n", k+1, paths[k])
		}
	}

	err := info.Remove(paths...)
	if err != nil {
		fmt.Println(err)
		fmt.Println("æ“ä½œå¤±è´¥, ä»¥ä¸‹æ–‡ä»¶/ç›®å½•åˆ é™¤å¤±è´¥: ")
		pnt()
		return
	}

	fmt.Println("æ“ä½œæˆåŠŸ, ä»¥ä¸‹æ–‡ä»¶/ç›®å½•å·²åˆ é™¤: ")
	pnt()
}

// RunMkdir æ‰§è¡Œ åˆ›å»ºç›®å½•
func RunMkdir(path string) {
	path = getAbsPath(path)

	err := info.Mkdir(path)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println("åˆ›å»ºç›®å½•æˆåŠŸ:", path)
}



================================================
FILE: command/util.go
================================================
package baidupcscmd

import (
	"fmt"
	"github.com/iikira/BaiduPCS-Go/config"
	fpath "path"
	"regexp"
	"strings"
)

var (
	patternRE = regexp.MustCompile(`[\[\]\*\?]`)
)

// getAbsPath è·å–ç»å¯¹è·¯å¾„, å¿½ç•¥é€šé…ç¬¦
func getAbsPath(path string) string {
	if !fpath.IsAbs(path) {
		path = fpath.Dir(pcsconfig.ActiveBaiduUser.Workdir + "/" + path + "/")
	}
	return path
}

func getAllPaths(paths ...string) (_paths []string) {
	for k := range paths {
		_paths = append(_paths, parsePath(paths[k])...)
	}
	return
}

func toAbsPath(path string) (string, error) {
	p := parsePath(path)
	if len(p) == 0 {
		return "", fmt.Errorf("æ–‡ä»¶è·¯å¾„åŒ¹é…å¤±è´¥, è¯·æ£€æŸ¥é€šé…ç¬¦")
	}
	return p[0], nil
}

// parsePath é€’å½’è§£æé€šé…ç¬¦
func parsePath(path string) (paths []string) {
	path = getAbsPath(path)

	if !patternRE.MatchString(path) {
		paths = []string{path}
		return
	}

	if _, err := fpath.Match(path, ""); err != nil {
		return nil
	}

	names := strings.Split(path, "/")

	for k := range names {
		if names[k] == "" || !patternRE.MatchString(names[k]) {
			continue
		}

		pfiles, err := info.FileList(strings.Join(names[:k], "/"))
		if err != nil {
			fmt.Println(err)
			return nil
		}

		for k2 := range pfiles {
			ok, _ := fpath.Match(names[k], pfiles[k2].Filename)
			if ok {
				if k >= len(names)-1 {
					paths = append(paths, strings.Join(names[:k], "/")+"/"+pfiles[k2].Filename)
				} else if pfiles[k2].Isdir {
					paths = append(paths, parsePath(pfiles[k2].Path+"/"+strings.Join(names[k+1:], "/"))...)
				}
			}
		}
		break
	}

	return
}

func recurseFDCountTotalSize(path string) (fileN, directoryN, size int64) {
	di, err := info.FileList(path)
	if err != nil {
		fmt.Println(err)
	}

	for k := range di {
		if di[k].Isdir {
			f, d, s := recurseFDCountTotalSize(di[k].Path)
			fileN += f
			directoryN += d
			size += s
		}
	}
	f, d := di.Count()
	s := di.TotalSize()
	fileN += f
	directoryN += d
	size += s
	return
}



================================================
FILE: config/check_bduss.go
================================================
package pcsconfig

import (
	"fmt"
	"github.com/bitly/go-simplejson"
	"github.com/iikira/BaiduPCS-Go/downloader"
	"github.com/iikira/BaiduPCS-Go/util"
	"strconv"
)

type Baidu struct {
	UID   uint64 `json:"uid"`
	Name  string `json:"name"`
	BDUSS string `json:"bduss"`

	Workdir string `json:"workdir"`
}

// NewWithBDUSS æ£€æµ‹BDUSSæœ‰æ•ˆæ€§, åŒæ—¶è·å–ç™¾åº¦è¯¦ç»†ä¿¡æ¯
func NewWithBDUSS(bduss string) (*Baidu, error) {
	h := downloader.NewHTTPClient()
	timestamp := pcsutil.BeijingTimeOption("")
	post := map[string]string{
		"bdusstoken":  bduss + "|null",
		"channel_id":  "",
		"channel_uid": "",
		"stErrorNums": "0",
		"subapp_type": "mini",
		"timestamp":   timestamp + "922",
	}
	pcsutil.TiebaClientSignature(post)

	header := map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
		"Cookie":       "ka=open",
		"net":          "1",
		"User-Agent":   "bdtb for Android 6.9.2.1",
		"client_logid": timestamp + "416",
		"Connection":   "Keep-Alive",
	}

	body, err := h.Fetch("POST", "http://tieba.baidu.com/c/s/login", post, header) // è·å–ç™¾åº¦IDçš„TBSï¼ŒUIDï¼ŒBDUSSç­‰
	if err != nil {
		return nil, fmt.Errorf("æ£€æµ‹BDUSSæœ‰æ•ˆæ€§å¤±è´¥, %s", err)
	}

	json, err := simplejson.NewJson(body)
	if err != nil {
		return nil, fmt.Errorf("æ£€æµ‹BDUSSæœ‰æ•ˆæ€§jsonè§£æå‡ºé”™: %s", err)
	}

	errCode := json.Get("error_code").MustString()
	errMsg := json.Get("error_msg").MustString()

	switch errCode {
	case "0":
	case "1":
		return nil, fmt.Errorf("æ£€æµ‹BDUSSæœ‰æ•ˆæ€§é”™è¯¯, ç™¾åº¦BDUSSæ ¼å¼ä¸æ­£ç¡®æˆ–è€…å·²è¿‡æœŸ")
	default:
		return nil, fmt.Errorf("æ£€æµ‹BDUSSæœ‰æ•ˆæ€§é”™è¯¯ä»£ç : %s, æ¶ˆæ¯: %s", errCode, errMsg)
	}

	uidStr := json.GetPath("user", "id").MustString()
	uid, _ := strconv.ParseUint(uidStr, 10, 64)

	username, err := GetUserNameByUID(uid)
	if err != nil {
		return nil, err
	}

	return &Baidu{
		UID:     uid,
		Name:    username,
		BDUSS:   bduss,
		Workdir: "/",
	}, nil
}

func GetUserNameByUID(uid uint64) (username string, err error) {
	rawQuery := "has_plist=0&need_post_count=1&rn=1&uid=" + fmt.Sprint(uid)
	urlStr := "http://c.tieba.baidu.com/c/u/user/profile?" + pcsutil.TiebaClientRawQuerySignature(rawQuery)
	body, err := downloader.HTTPGet(urlStr)
	if err != nil {
		return "", err
	}
	json, err := simplejson.NewJson(body)
	if err != nil {
		return "", err
	}
	userJSON := json.GetPath("user")
	username = userJSON.Get("name").MustString()
	return
}



================================================
FILE: config/config.go
================================================
package pcsconfig

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
)

var (
	// Config é…ç½®ä¿¡æ¯, ç”±å¤–éƒ¨è°ƒç”¨
	Config = new(PCSConfig)

	// ActiveBaiduUser å½“å‰ç™¾åº¦å¸å·
	ActiveBaiduUser *Baidu

	configFileName = "pcs_config.json"

	// SaveDir ä¿å­˜æ–‡ä»¶çš„ç›®å½•
	SaveDir = "download/"
)

// PCSConfig é…ç½®è¯¦æƒ…
type PCSConfig struct {
	BaiduActiveUID uint64   `json:"baidu_active_uid"`
	BaiduUserList  []*Baidu `json:"baidu_user_list"`
	MaxParallel    int      `json:"max_parallel"`
}

// Init åˆå§‹åŒ–é…ç½®
func Init() {
	// æ£€æŸ¥é…ç½®
	cfg, err := loadConfig()
	if err != nil {
		fmt.Printf("é”™è¯¯: %s, è‡ªåŠ¨åˆå§‹åŒ–é…ç½®æ–‡ä»¶\n", err)

		cfg = &PCSConfig{
			BaiduActiveUID: 0,
			MaxParallel:    100,
		}

		err = cfg.Save()
		if err != nil {
			fmt.Println(err)
		}
	}
	Config = cfg

	if UpdateActiveBaiduUser() != nil {
		ActiveBaiduUser = new(Baidu)
	}
}

func loadConfig() (*PCSConfig, error) {
	data, err := ioutil.ReadFile(configFileName)
	if err != nil {
		return nil, err
	}
	conf := new(PCSConfig)
	err = json.Unmarshal(data, conf)
	if err != nil {
		return nil, err
	}
	return conf, nil
}

// Reload ä»é…ç½®æ–‡ä»¶é‡è½½æ›´æ–° Config
func Reload() error {
	cfg, err := loadConfig()
	if err != nil {
		return err
	}
	Config = cfg

	// æ›´æ–° å½“å‰ç™¾åº¦å¸å·
	return UpdateActiveBaiduUser()
}

// Save ä¿å­˜é…ç½®ä¿¡æ¯åˆ°é…ç½®æ–‡ä»¶, å¹¶é‡è½½é…ç½®
func (c *PCSConfig) Save() error {
	data, err := json.MarshalIndent(c, "", "\t")
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(configFileName, data, 0666)
	if err != nil {
		return err
	}

	return Reload()
}

// UpdateActiveBaiduUser æ›´æ–° å½“å‰ç™¾åº¦å¸å·
func UpdateActiveBaiduUser() error {
	baidu, err := Config.GetBaiduUserByUID(Config.BaiduActiveUID)
	if err == nil {
		ActiveBaiduUser = baidu
		return nil
	}
	return err
}



================================================
FILE: config/deleter.go
================================================
package pcsconfig

import (
	"fmt"
)

func (c *PCSConfig) DeleteBaiduUserByUID(uid uint64) bool {
	for k := range c.BaiduUserList {
		if c.BaiduUserList[k].UID == uid {
			c.BaiduUserList = append(c.BaiduUserList[:k], c.BaiduUserList[k+1:]...)

			// ä¿®æ”¹ æ­£åœ¨ä½¿ç”¨çš„ ç™¾åº¦å¸å·
			if c.BaiduActiveUID == uid {
				if len(c.BaiduUserList) != 0 {
					c.BaiduActiveUID = c.BaiduUserList[0].UID
				} else {
					c.BaiduActiveUID = 0
				}
			}

			err := c.Save()
			if err != nil {
				fmt.Println(err)
				return false
			}
			return true
		}
	}
	return false
}



================================================
FILE: config/get_checker.go
================================================
package pcsconfig

import (
	"bytes"
	"fmt"
	"github.com/iikira/BaiduPCS-Go/downloader"
	"os"
	"path/filepath"
)

func (c *PCSConfig) GetBaiduUserByUID(uid uint64) (*Baidu, error) {
	for k := range c.BaiduUserList {
		if uid == c.BaiduUserList[k].UID {
			return c.BaiduUserList[k], nil
		}
	}
	return nil, fmt.Errorf("æœªæ‰¾åˆ°ç™¾åº¦å¸å·")
}

func (c *PCSConfig) GetAllBaiduUser() string {
	var s bytes.Buffer
	s.WriteString("\nindex\t\tuid\tç”¨æˆ·å\n")

	for k := range c.BaiduUserList {
		s.WriteString(fmt.Sprintf("%4d", k) + "\t" + fmt.Sprintf("%11d", c.BaiduUserList[k].UID) + "\t" + c.BaiduUserList[k].Name + "\n")
	}
	s.WriteString("\n")
	return s.String()
}

func (c *PCSConfig) CheckUIDExist(uid uint64) bool {
	for k := range c.BaiduUserList {
		if uid == c.BaiduUserList[k].UID {
			return true
		}
	}
	return false
}

// GetSavePath æ ¹æ®æä¾›çš„ç½‘ç›˜æ–‡ä»¶è·¯å¾„ path, è¿”å›æœ¬åœ°å‚¨å­˜è·¯å¾„
func GetSavePath(path string) string {
	return filepath.Dir(fmt.Sprintf("%s/%d_%s%s/..",
		SaveDir,
		ActiveBaiduUser.UID,
		ActiveBaiduUser.Name,
		path,
	))
}

// CheckFileExist æ£€æŸ¥æœ¬åœ°æ–‡ä»¶æ˜¯å¦ä¸ç½‘ç›˜çš„æ–‡ä»¶é‡å
func CheckFileExist(path string) bool {
	savePath := GetSavePath(path)
	if _, err := os.Stat(savePath); err == nil {
		if _, err = os.Stat(savePath + downloader.DownloadingFileSuffix); err != nil {
			return true
		}
	}
	return false
}



================================================
FILE: config/seter.go
================================================
package pcsconfig

import (
	"fmt"
)

// SetBDUSS è®¾ç½®ç™¾åº¦ bduss å¹¶ä¿å­˜
func (c *PCSConfig) SetBDUSS(bduss string) (username string, err error) {
	b, err := NewWithBDUSS(bduss)
	if err != nil {
		return "", err
	}
	if c.CheckUIDExist(b.UID) {
		return "", fmt.Errorf("ç™»å½•å¤±è´¥, ç”¨æˆ· %s å·²å­˜åœ¨", b.Name)
	}
	c.BaiduUserList = append(c.BaiduUserList, b)
	c.BaiduActiveUID = b.UID
	return b.Name, c.Save()
}



================================================
FILE: downloader/downloader.go
================================================
/*
 Copyright 2015 Bluek404

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

 è¡¥å……: æ­¤ inplememt åŸºäº https://github.com/Bluek404/downloader
 é’ˆå¯¹ç™¾åº¦ç½‘ç›˜ä¸‹è½½, åšå‡ºä¸€äº›ä¿®æ”¹

 å¢åŠ åŠŸèƒ½: çº¿ç¨‹æ§åˆ¶
 åˆ å»åŠŸèƒ½: æš‚åœä¸‹è½½, æ¢å¤ä¸‹è½½
*/

package downloader

import (
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"time"
)

var parallel int

// FileDl ä¸‹è½½è¯¦æƒ…
type FileDl struct {
	URL  string   // ä¸‹è½½åœ°å€
	Size int64    // æ–‡ä»¶å¤§å°
	File *os.File // è¦å†™å…¥çš„æ–‡ä»¶

	BlockList blockList // ç”¨äºè®°å½•æœªä¸‹è½½çš„æ–‡ä»¶å—èµ·å§‹ä½ç½®

	*HTTPClient // http client

	onStart  func()
	onFinish func()
	onError  func(int, error)

	status status // ä¸‹è½½çŠ¶æ€
}

// NewFileDl åˆ›å»ºæ–°çš„æ–‡ä»¶ä¸‹è½½
//
// å¦‚æœ size <= 0 åˆ™è‡ªåŠ¨è·å–æ–‡ä»¶å¤§å°
func NewFileDl(h *HTTPClient, url, savePath string, size int64) (*FileDl, error) {

	// è·å–æ–‡ä»¶ä¿¡æ¯
	request, err := http.NewRequest("HEAD", url, nil)
	if err != nil {
		return nil, err
	}

	resp, err := h.Client.Do(request)
	if err != nil {
		return nil, err
	}

	if savePath == "" {
		finds := FileNameRE.FindStringSubmatch(
			resp.Header.Get("Content-Disposition"),
		)
		if len(finds) >= 2 {
			savePath = finds[1]
		} else {
			// æ‰¾ä¸åˆ°æ–‡ä»¶å, å‡‘åˆå§
			savePath = filepath.Base(url)
		}
	}

	// å¦‚æœæ–‡ä»¶å­˜åœ¨, å–æ¶ˆä¸‹è½½
	if _, err = os.Stat(savePath); err == nil {
		if _, err = os.Stat(savePath + DownloadingFileSuffix); err != nil {
			return nil, fmt.Errorf("æ–‡ä»¶å·²å­˜åœ¨: %s", savePath)
		}
	}

	// æ£€æµ‹è¦ä¿å­˜ä¸‹è½½å†…å®¹çš„ç›®å½•æ˜¯å¦å­˜åœ¨
	// ä¸å­˜åœ¨åˆ™åˆ›å»ºè¯¥ç›®å½•
	if _, err = os.Stat(filepath.Dir(savePath)); err != nil {
		err = os.MkdirAll(filepath.Dir(savePath), 0777)
		if err != nil {
			return nil, err
		}
	}

	// ç§»é™¤æ—§çš„æ–­ç‚¹ç»­ä¼ æ–‡ä»¶
	if _, err = os.Stat(savePath); err != nil {
		if _, err = os.Stat(savePath + DownloadingFileSuffix); err == nil {
			os.Remove(savePath + DownloadingFileSuffix)
		}
	}

	// æ£€æµ‹è¦ä¸‹è½½çš„æ–‡ä»¶æ˜¯å¦å­˜åœ¨
	// å¦‚æœå­˜åœ¨, åˆ™æ‰“å¼€æ–‡ä»¶
	// ä¸å­˜åœ¨åˆ™åˆ›å»ºæ–‡ä»¶
	file, err := os.OpenFile(savePath, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return nil, err
	}

	if size != resp.ContentLength {
		size = resp.ContentLength
	}

	resp.Body.Close()

	f := &FileDl{
		URL:        url,
		Size:       size,
		File:       file,
		HTTPClient: h,
	}

	return f, nil
}

// Start å¼€å§‹ä¸‹è½½
func (f *FileDl) Start() {
	// æ§åˆ¶çº¿ç¨‹
	parallel = maxParallel

	// å¦‚æœæ–‡ä»¶ä¸å¤§, æˆ–è€…çº¿ç¨‹æ•°è®¾ç½®è¿‡é«˜, åˆ™è°ƒä½çº¿ç¨‹æ•°
	if int64(maxParallel) > f.Size/int64(10*cacheSize) {
		parallel = int(f.Size/int64(10*cacheSize)) + 1
	}

	if err := f.loadBreakPoint(); err != nil {
		if f.Size <= 0 { // è·å–ä¸åˆ°æ–‡ä»¶çš„å¤§å°, å…³é—­å¤šçº¿ç¨‹ä¸‹è½½ (æš‚æ—¶)
			f.BlockList = append(f.BlockList, Block{
				Begin: 0,
				End:   -1,
			})
		} else {
			blockSize := f.Size / int64(parallel)
			var begin int64
			// æ•°æ®å¹³å‡åˆ†é…ç»™å„ä¸ªçº¿ç¨‹
			for i := 0; i < parallel; i++ {
				var end = (int64(i) + 1) * blockSize
				f.BlockList = append(f.BlockList, Block{
					Begin: begin,
					End:   end,
				})
				begin = end + 1
			}
			// å°†ä½™å‡ºæ•°æ®åˆ†é…ç»™æœ€åä¸€ä¸ªçº¿ç¨‹
			f.BlockList[parallel-1].End += f.Size - f.BlockList[parallel-1].End
			f.BlockList[parallel-1].Final = true
		}
	}

	go func() {
		f.touch(f.onStart)
		// å¼€å§‹ä¸‹è½½
		err := f.download()
		if err != nil {
			f.touchOnError(0, err)
			return
		}
	}()
}

func (f *FileDl) download() error {
	f.startGetSpeeds() // å¯ç”¨é€Ÿåº¦ç›‘æµ‹

	for i := range f.BlockList {
		go func(id int) {
			f.downloadBlockFn(id)
		}(i)
	}
	<-f.blockMonitor()

	f.touch(f.onFinish)

	f.File.Close()

	return nil
}

func (f *FileDl) startGetSpeeds() {
	go func() {
		var old = f.status.Downloaded
		for {
			time.Sleep(time.Second * 1)
			f.status.Speeds = f.status.Downloaded - old
			old = f.status.Downloaded

			if f.status.Speeds > f.status.MaxSpeeds {
				f.status.MaxSpeeds = f.status.Speeds
			}
		}
	}()
}

// GetStatus è·å–ä¸‹è½½ç»Ÿè®¡ä¿¡æ¯
func (f FileDl) GetStatus() status {
	return f.status
}

// OnStart ä»»åŠ¡å¼€å§‹æ—¶è§¦å‘çš„äº‹ä»¶
func (f *FileDl) OnStart(fn func()) {
	f.onStart = fn
}

// OnFinish ä»»åŠ¡å®Œæˆæ—¶è§¦å‘çš„äº‹ä»¶
func (f *FileDl) OnFinish(fn func()) {
	f.onFinish = fn
}

// OnError ä»»åŠ¡å‡ºé”™æ—¶è§¦å‘çš„äº‹ä»¶
//
// errCodeä¸ºé”™è¯¯ç ï¼ŒerrSträ¸ºé”™è¯¯æè¿°
func (f *FileDl) OnError(fn func(int, error)) {
	f.onError = fn
}

// ç”¨äºè§¦å‘äº‹ä»¶
func (f FileDl) touch(fn func()) {
	if fn != nil {
		go fn()
	}
}

// è§¦å‘Erroräº‹ä»¶
func (f FileDl) touchOnError(errCode int, err error) {
	if f.onError != nil {
		go f.onError(errCode, err)
	}
}

// status çŠ¶æ€
type status struct {
	Downloaded int64 `json:"downloaded"`
	Speeds     int64
	MaxSpeeds  int64
}



================================================
FILE: downloader/downloader_block.go
================================================
[Binary file]


================================================
FILE: downloader/downloader_config.go
================================================
package downloader

import (
	"regexp"
)

var (
	maxParallel       = 5
	cacheSize   int64 = 2048

	// FileNameRE æ­£åˆ™è¡¨è¾¾å¼: åŒ¹é…æ–‡ä»¶å
	FileNameRE = regexp.MustCompile("filename=\"(.*?)\"")
)

// SetMaxParallel è®¾ç½®æœ€å¤§çº¿ç¨‹
func SetMaxParallel(t int) {
	if t <= 0 {
		panic("downloader.SetMaxParallel: zero or negative parallel")
	}
	maxParallel = t
}

// SetCacheSize è®¾ç½®ç¼“å†²å¤§å°
func SetCacheSize(size int64) {
	if size < 1024 {
		cacheSize = 1024
		return
	}
	cacheSize = size
}



================================================
FILE: downloader/example.go
================================================
package downloader

import (
	"fmt"
	"os"
	"strings"
	"time"
)

// DoDownload ç®€å•ç½‘ç»œä¸‹è½½å™¨, ä½¿ç”¨é»˜è®¤ä¸‹è½½çº¿ç¨‹,
// é€šè¿‡è°ƒç”¨ SetMaxThread æ¥ä¿®æ”¹é»˜è®¤ä¸‹è½½çº¿ç¨‹
func DoDownload(url string, fileName string, sizeofFile int64) {
	h := NewHTTPClient()
	fileDl, err := NewFileDl(h, url, fileName, sizeofFile)
	if err != nil {
		return
	}

	done := make(chan struct{})

	var exit = make(chan bool)
	fileDl.OnStart(func() {
		fmt.Println("download started")
		format := "\r%v/%v [%s] %v byte/s %v"

	for_1:
		for {
			status := fileDl.GetStatus()
			var i = float64(status.Downloaded) / float64(fileDl.Size) * 50
			h := strings.Repeat("=", int(i)) + strings.Repeat(" ", 50-int(i))

			select {
			case <-exit:
				fmt.Printf(format, status.Downloaded, fileDl.Size, h, 0, "[FINISH]")
				fmt.Println("\ndownload finished")
				break for_1
			default:
				time.Sleep(time.Second * 1)
				fmt.Printf(format, status.Downloaded, fileDl.Size, h, status.Speeds, "[DOWNLOADING]")
				os.Stdout.Sync()
			}
		}
	})

	fileDl.OnFinish(func() {
		exit <- true
		done <- struct{}{}
	})

	fileDl.OnError(func(errCode int, e error) {
		err = e
	})

	fileDl.Start()
	<-done
}



================================================
FILE: downloader/fetch.go
================================================
package downloader

import (
	"bytes"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// HTTPGet ç®€å•å®ç° http è®¿é—® GET è¯·æ±‚
func HTTPGet(urlStr string) (body []byte, err error) {
	resp, err := http.Get(urlStr)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	return ioutil.ReadAll(resp.Body)
}

// Fetch å®ç° httpï¼https è®¿é—® å’Œ GETï¼POST è¯·æ±‚ï¼Œ
// æ ¹æ®ç»™å®šçš„ method (GET, POST, HEAD, PUT ç­‰ç­‰), urlStr (ç½‘å€),
// post (post æ•°æ®), header (header è¯·æ±‚å¤´æ•°æ®), è¿›è¡Œç½‘ç«™è®¿é—®ã€‚
// è¿”å›å€¼åˆ†åˆ«ä¸º ç½‘ç«™ä¸»ä½“, é”™è¯¯
func (h *HTTPClient) Fetch(method string, urlStr string, post interface{}, header map[string]string) (body []byte, err error) {
	var (
		req   *http.Request
		obody io.Reader
	)

	if post != nil {
		switch value := post.(type) {
		case map[string]string:
			query := url.Values{}
			for k := range value {
				query.Set(k, value[k])
			}
			obody = strings.NewReader(query.Encode())
		case string:
			obody = strings.NewReader(value)
		case []byte:
			obody = bytes.NewReader(value[:])
		}
	}
	req, err = http.NewRequest(method, urlStr, obody)
	if err != nil {
		return nil, err
	}

	if header != nil {
		for key := range header {
			req.Header.Add(key, header[key])
		}
	}

	resp, err := h.Client.Do(req)
	if err != nil {
		return nil, err
	}

	body, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	return
}



================================================
FILE: downloader/http_client.go
================================================
package downloader

import (
	"crypto/tls"
	"net/http"
	"net/http/cookiejar"
	"time"
)

// HTTPClient http client
type HTTPClient struct {
	Client http.Client
}

// NewHTTPClient è¿”å› HTTPClient çš„æŒ‡é’ˆ,
// é¢„è®¾äº†ä¸€äº›é…ç½®
func NewHTTPClient() *HTTPClient {
	return &HTTPClient{
		Client: http.Client{
			Transport: &http.Transport{
				TLSClientConfig: &tls.Config{
					InsecureSkipVerify: true,
				},
				TLSHandshakeTimeout:   10 * time.Second,
				DisableKeepAlives:     false,
				DisableCompression:    false,
				ResponseHeaderTimeout: 10 * time.Second,
				ExpectContinueTimeout: 10 * time.Second,
			},
		},
	}
}

// SetCookiejar è®¾ç½® cookie
func (h *HTTPClient) SetCookiejar(c *cookiejar.Jar) {
	h.Client.Jar = c
}

// ClearCookiejar æ¸…ç©º cookie
func (h *HTTPClient) ClearCookiejar() {
	h.Client.Jar, _ = cookiejar.New(nil)
}

// SetHTTPSecure æ˜¯å¦å¯ç”¨ https å®‰å…¨æ£€æŸ¥
func (h *HTTPClient) SetHTTPSecure(b bool) {
	h.Client.Transport.(*http.Transport).TLSClientConfig.InsecureSkipVerify = !b
}

// SetKeepAlive è®¾ç½® Keep-Alive
func (h *HTTPClient) SetKeepAlive(b bool) {
	h.Client.Transport.(*http.Transport).DisableKeepAlives = !b
}

//SetGzip æ˜¯å¦å¯ç”¨Gzip
func (h *HTTPClient) SetGzip(b bool) {
	h.Client.Transport.(*http.Transport).DisableCompression = !b
}

//SetResponseHeaderTimeout è®¾ç½®ç›®æ ‡æœåŠ¡å™¨å“åº”è¶…æ—¶æ—¶é—´
func (h *HTTPClient) SetResponseHeaderTimeout(t time.Duration) {
	h.Client.Transport.(*http.Transport).ResponseHeaderTimeout = t
}

// SetTimeout è®¾ç½® http è¯·æ±‚è¶…æ—¶æ—¶é—´ é»˜è®¤30s
func (h *HTTPClient) SetTimeout(t time.Duration) {
	h.Client.Timeout = t
}



================================================
FILE: downloader/resume_breakpoint.go
================================================
package downloader

import (
	"encoding/json"
	"io/ioutil"
)

var (
	// DownloadingFileSuffix æ–­ç‚¹ç»­ä¼ ä¸´æ—¶æ–‡ä»¶åç¼€
	DownloadingFileSuffix = ".baidupcs_go_downloading"
)

type downloadStatus struct {
	Downloaded int64     `json:"downloaded"`
	BlockList  blockList `json:"block_list"`
}

// recordBreakPoint ä¿å­˜ä¸‹è½½æ–­ç‚¹åˆ°æ–‡ä»¶, ç”¨äºæ–­ç‚¹ç»­ä¼ 
func (f *FileDl) recordBreakPoint() error {
	byt, err := json.Marshal(downloadStatus{
		Downloaded: f.status.Downloaded,
		BlockList:  f.BlockList,
	})
	if err != nil {
		return err
	}
	return ioutil.WriteFile(f.File.Name()+DownloadingFileSuffix, byt, 0644)
}

// loadBreakPoint å°è¯•ä»æ–‡ä»¶è½½å…¥ä¸‹è½½æ–­ç‚¹
func (f *FileDl) loadBreakPoint() error {
	byt, err := ioutil.ReadFile(f.File.Name() + DownloadingFileSuffix)
	if err != nil {
		return err
	}
	downloadStatus := new(downloadStatus)
	err = json.Unmarshal(byt, downloadStatus)
	if err != nil {
		return err
	}
	f.status.Downloaded = downloadStatus.Downloaded
	f.BlockList = downloadStatus.BlockList
	return nil
}



================================================
FILE: util/convert.go
================================================
package pcsutil

import (
	"fmt"
	"time"
)

const (
	b = (int64)(1 << (10 * iota))
	kb
	mb
	gb
	tb
	pb
)

// ConvertFileSize æ–‡ä»¶å¤§å°æ ¼å¼åŒ–è¾“å‡º
func ConvertFileSize(size int64, precision ...int) string {
	p := 6
	if len(precision) == 1 {
		p = precision[0]
	}
	pint := fmt.Sprint(p)
	if size <= 0 {
		return "0"
	}
	if size < kb {
		return fmt.Sprintf("%."+pint+"fB", float64(size)/float64(b))
	}
	if size < mb {
		return fmt.Sprintf("%."+pint+"fKB", float64(size)/float64(kb))
	}
	if size < gb {
		return fmt.Sprintf("%."+pint+"fMB", float64(size)/float64(mb))
	}
	if size < tb {
		return fmt.Sprintf("%."+pint+"fGB", float64(size)/float64(gb))
	}
	if size < pb {
		return fmt.Sprintf("%."+pint+"fTB", float64(size)/float64(tb))
	}
	return fmt.Sprintf("%."+pint+"fPB", float64(size)/float64(pb))
}

// IntToBool int ç±»å‹è½¬æ¢ä¸º bool
func IntToBool(i int) bool {
	if i == 0 {
		return false
	}
	return true
}

// FormatTime è®² Unix æ—¶é—´æˆ³, è½¬æ¢ä¸ºå­—ç¬¦ä¸²
func FormatTime(t int64) string {
	return time.Unix(t, 0).Format("2006-01-02 03:04:05")
}



================================================
FILE: util/error.go
================================================
package pcsutil

import (
	"log"
	"os"
)

// PrintErrIfExist ç®€æ˜“é”™è¯¯å¤„ç†, å¦‚æœ err å­˜åœ¨, å°±åªå‘å±å¹•è¾“å‡º err ã€‚
func PrintErrIfExist(err error) {
	if err != nil {
		log.Println(err)
	}
}

// PrintErrAndExit ç®€æ˜“é”™è¯¯å¤„ç†, å¦‚æœ err å­˜åœ¨, å‘å±å¹•è¾“å‡º err å¹¶é€€å‡º, annotate æ˜¯åŠ åœ¨ err ä¹‹å‰çš„æ³¨é‡Šä¿¡æ¯ã€‚
func PrintErrAndExit(annotate string, err error) {
	if err != nil {
		log.Println(annotate, err)
		os.Exit(1)
	}
}



================================================
FILE: util/log_colorable_prefix.go
================================================
package pcsutil

import (
	"fmt"
	"github.com/fatih/color"
	"log"
)

var (
	// ErrorColor è®¾ç½®è¾“å‡ºé”™è¯¯çš„é¢œè‰²
	ErrorColor = color.New(color.FgRed).SprintFunc()
)

// è‡ªå®šä¹‰log writer
type logWriter struct{}

func (logWriter) Write(bytes []byte) (int, error) {
	return fmt.Fprint(color.Output, "["+BeijingTimeOption("Refer")+"] "+string(bytes))
}

// SetLogPrefix è®¾ç½®æ—¥å¿—è¾“å‡ºçš„æ—¶é—´å‰ç¼€
func SetLogPrefix() {
	log.SetFlags(0)
	log.SetOutput(new(logWriter))
}



================================================
FILE: util/regexp_pre.go
================================================
package pcsutil

import (
	"regexp"
)

var (
	// HTTPSRE https regexp
	HTTPSRE = regexp.MustCompile("^https")
	// ChinaPhoneRE https regexp
	ChinaPhoneRE = regexp.MustCompile("^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\\d{8}$")
)



================================================
FILE: util/tieba_client_signature.go
================================================
package pcsutil

import (
	"bytes"
	"sort"
	"strings"
)

// TiebaClientSignature æ ¹æ®ç»™å®šè´´å§å®¢æˆ·ç«¯çš„ post (postæ•°æ®æŒ‡é’ˆ) è¿›è¡Œç­¾å, ä»¥é€šè¿‡ç™¾åº¦æœåŠ¡å™¨éªŒè¯ã€‚è¿”å›å€¼ä¸º: sign ç­¾åå­—ç¬¦ä¸²
func TiebaClientSignature(post map[string]string) {
	if post == nil {
		return
	}
	// é¢„è®¾
	post["_client_type"] = "2"
	post["_client_version"] = "6.9.2.1"
	post["_phone_imei"] = "860983036542682"
	post["from"] = "mini_ad_wandoujia"
	post["model"] = "HUAWEI NXT-AL10"
	post["cuid"] = "61464018582906C485355A89D105ECFB|286245630389068"
	var keys []string
	for key := range post {
		keys = append(keys, key)
	}
	sort.Sort(sort.StringSlice(keys))

	var bb bytes.Buffer
	for _, key := range keys {
		bb.WriteString(key + "=" + post[key])
	}
	bb.WriteString("tiebaclient!!!")
	post["sign"] = Md5Encrypt(bb.Bytes()[:])
}

// TiebaClientRawQuerySignature ç»™ rawQuery è¿›è¡Œè´´å§å®¢æˆ·ç«¯ç­¾å
func TiebaClientRawQuerySignature(rawQuery string) (sign string) {
	return rawQuery + "&sign=" + Md5Encrypt(strings.Replace(rawQuery, "&", "", -1)+"tiebaclient!!!")
}



================================================
FILE: util/time.go
================================================
package pcsutil

import (
	"fmt"
	"time"
)

var (
	// CSTLocation CST Location
	CSTLocation = time.FixedZone("CST", 8*3600)
)

/*
BeijingTimeOption æ ¹æ®ç»™å®šçš„ get è¿”å›æ—¶é—´æ ¼å¼.

	get:        æ—¶é—´æ ¼å¼

	"Refer":    2017-7-21 12:02:32.000
	"printLog": 2017-7-21_12:02:32
	"day":      21
	"ymd":      2017-7-21
	"hour":     12
	é»˜è®¤æ—¶é—´æˆ³:   1500609752
*/
func BeijingTimeOption(get string) string {
	//è·å–åŒ—äº¬ï¼ˆä¸œå…«åŒºï¼‰æ—¶é—´
	CSTLoc := time.FixedZone("CST", 8*3600) // ä¸œ8åŒº
	now := time.Now().In(CSTLoc)
	year, mon, day := now.Date()
	hour, min, sec := now.Clock()
	millisecond := now.Nanosecond() / 1e6
	switch get {
	case "Refer":
		return fmt.Sprintf("%d-%d-%d %02d:%02d:%02d.%03d", year, mon, day, hour, min, sec, millisecond)
	case "printLog":
		return fmt.Sprintf("%d-%d-%d_%02dh%02dm%02ds", year, mon, day, hour, min, sec)
	case "day":
		return fmt.Sprint(day)
	case "ymd":
		return fmt.Sprintf("%d-%d-%d", year, mon, day)
	case "hour":
		return fmt.Sprint(hour)
	default:
		return fmt.Sprint(time.Now().Unix())
	}
}



================================================
FILE: util/unsafe_strconv_test.go
================================================
// go test -test.bench=".*"
package pcsutil

import (
	"testing"
)

var str = "asddsadfaalkdjsksajdfkashjkdfhashfliuhsadifhasifhaishdfiashdihaisdfhiuassfasdff"

func BenchmarkToBytes(b *testing.B) {
	for i := 0; i <= b.N; i++ {
		_ = ToBytes(str)
	}
}

func BenchmarkBytes(b *testing.B) {
	for i := 0; i <= b.N; i++ {
		_ = []byte(str)
	}
}



================================================
FILE: util/util.go
================================================
package pcsutil

import (
	"compress/gzip"
	"crypto/md5"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"net/http/cookiejar"
	"net/url"
	"os"
	"strings"
	"unsafe"
)

var (
	// PipeInput å‘½ä»¤ä¸­æ˜¯å¦ä¸ºç®¡é“è¾“å…¥
	PipeInput bool
)

func init() {
	fileInfo, err := os.Stdin.Stat()
	if err != nil {
		return
	}
	PipeInput = (fileInfo.Mode() & os.ModeNamedPipe) == os.ModeNamedPipe
}

// ToString å°† []byte è½¬æ¢ä¸º string
func ToString(p []byte) string {
	return *(*string)(unsafe.Pointer(&p))
}

// ToBytes å°† string è½¬æ¢ä¸º []byte
func ToBytes(str string) []byte {
	return *(*[]byte)(unsafe.Pointer(&str))
}

// GetURLCookieString è¿”å›cookieå­—ä¸²
func GetURLCookieString(urlString string, jar *cookiejar.Jar) string {
	url, _ := url.Parse(urlString)
	cookies := jar.Cookies(url)
	cookieString := ""
	for _, v := range cookies {
		cookieString += v.String() + "; "
	}
	cookieString = strings.TrimRight(cookieString, "; ")
	return cookieString
}

// Md5Encrypt å¯¹ str è¿›è¡Œmd5åŠ å¯†, è¿”å›å€¼ä¸º str åŠ å¯†åçš„å¯†æ–‡
func Md5Encrypt(str interface{}) string {
	md5Ctx := md5.New()
	switch value := str.(type) {
	case string:
		md5Ctx.Write([]byte(str.(string)))
	case *string:
		md5Ctx.Write([]byte(*str.(*string)))
	case []byte:
		md5Ctx.Write(str.([]byte))
	case *[]byte:
		md5Ctx.Write(*str.(*[]byte))
	default:
		fmt.Println("MD5Encrypt: undefined type:", value)
		return ""
	}
	return fmt.Sprintf("%X", md5Ctx.Sum(nil))
}

// DecompressGZIP å¯¹ io.Reader æ•°æ®, è¿›è¡Œ gzip è§£å‹
func DecompressGZIP(r io.Reader) ([]byte, error) {
	gzipReader, err := gzip.NewReader(r)
	if err != nil {
		return nil, err
	}
	gzipReader.Close()
	return ioutil.ReadAll(gzipReader)
}

// FlagProvided æ£€æµ‹å‘½ä»¤è¡Œæ˜¯å¦æä¾›åä¸º name çš„ flag, æ”¯æŒå¤šä¸ªname(names)
func FlagProvided(names ...string) bool {
	if len(names) == 0 {
		return false
	}
	var targetFlag *flag.Flag
	for _, name := range names {
		targetFlag = flag.Lookup(name)
		if targetFlag == nil {
			return false
		}
		if targetFlag.DefValue == targetFlag.Value.String() {
			return false
		}
	}
	return true
}



================================================
FILE: util/wait_group.go
================================================
package pcsutil

import "sync"

// WaitGroup åœ¨ sync.WaitGroup çš„åŸºç¡€ä¸Š, æ–°å¢çº¿ç¨‹æ§åˆ¶åŠŸèƒ½
type WaitGroup struct {
	wg sync.WaitGroup
	p  chan struct{}
}

// NewWaitGroup returns a pointer to a new `WaitGroup` object.
// parallel ä¸ºæœ€å¤§å¹¶å‘æ•°, 0 ä»£è¡¨æ— é™åˆ¶
func NewWaitGroup(parallel int) (w *WaitGroup) {
	w = &WaitGroup{}
	if parallel <= 0 {
		return
	}
	w.p = make(chan struct{}, parallel)
	return
}

// AddDelta åœ¨ sync.WaitGroup çš„åŸºç¡€ä¸Š, æ–°å¢çº¿ç¨‹æ§åˆ¶åŠŸèƒ½
func (w *WaitGroup) AddDelta() {
	w.wg.Add(1)
	if w.p == nil {
		return
	}
	w.p <- struct{}{}
}

// Done åœ¨ sync.WaitGroup çš„åŸºç¡€ä¸Š, æ–°å¢çº¿ç¨‹æ§åˆ¶åŠŸèƒ½
func (w *WaitGroup) Done() {
	w.wg.Done()
	if w.p == nil {
		return
	}
	<-w.p
}

// Wait å‚ç…§ sync.WaitGroup çš„ Wait æ–¹æ³•
func (w *WaitGroup) Wait() {
	w.wg.Wait()
}

// Parallel è¿”å›å½“å‰æ­£åœ¨è¿›è¡Œçš„ä»»åŠ¡æ•°é‡
func (w *WaitGroup) Parallel() int {
	return len(w.p)
}



================================================
FILE: util/wait_group_test.go
================================================
package pcsutil

import (
	"fmt"
	"testing"
	"time"
)

func TestWg(t *testing.T) {
	wg := NewWaitGroup(2)
	for i := 0; i < 60; i++ {
		wg.AddDelta()
		go func() {
			fmt.Println(i, wg.Parallel())
			time.Sleep(1e9)
			wg.Done()
		}()
	}
	wg.Wait()
}
</file>

<file path="config.example.toml">
[baidu]
# ä»…ä¿ç•™è½¬å­˜æ‰€éœ€é…ç½®

# è·å–æ–¹æ³•ï¼šæµè§ˆå™¨ç™»å½•ç™¾åº¦ç½‘ç›˜ -> F12 å¼€å‘è€…å·¥å…· -> Application -> Cookies -> BDUSS / STOKEN
cookie_bduss = "YOUR_BDUSS"
cookie_stoken = "YOUR_STOKEN"

# è½¬å­˜ä¿å­˜è·¯å¾„ï¼ˆç½‘ç›˜ç›®å½•ï¼‰
save_path = "/æˆ‘çš„èµ„æº"

# HTTP è¯·æ±‚è¶…æ—¶ï¼ˆç§’ï¼‰
http_timeout_secs = 30
</file>

<file path="diagnose.sh">
#!/bin/bash

echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘  ç™¾åº¦ç½‘ç›˜ç›´é“¾ç³»ç»Ÿ - é—®é¢˜è¯Šæ–­å·¥å…·                           â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# 1. æ£€æŸ¥é…ç½®æ–‡ä»¶
echo "ã€1/5ã€‘æ£€æŸ¥é…ç½®æ–‡ä»¶..."
if [ ! -f config.toml ]; then
    echo "âŒ config.toml ä¸å­˜åœ¨"
    exit 1
fi

BDUSS=$(grep 'cookie_bduss' config.toml | cut -d'"' -f2)
STOKEN=$(grep 'cookie_stoken' config.toml | cut -d'"' -f2)

if [ -z "$BDUSS" ] || [ "$BDUSS" = "YOUR_BDUSS" ]; then
    echo "âŒ BDUSS æœªé…ç½®æˆ–ä¸ºé»˜è®¤å€¼"
    exit 1
fi

echo "âœ… é…ç½®æ–‡ä»¶å­˜åœ¨"
echo "   BDUSS é•¿åº¦: ${#BDUSS}"
echo "   STOKEN é•¿åº¦: ${#STOKEN}"

# 2. æµ‹è¯• Cookie æœ‰æ•ˆæ€§
echo ""
echo "ã€2/5ã€‘æµ‹è¯• Cookie æœ‰æ•ˆæ€§..."
response=$(curl -s -w "%{http_code}" -o /tmp/cookie_test.html \
    "https://pan.baidu.com/api/user/getinfo" \
    -H "Cookie: BDUSS=$BDUSS; STOKEN=$STOKEN")

if [ "$response" = "200" ]; then
    if grep -q '"errno":0' /tmp/cookie_test.html; then
        echo "âœ… Cookie æœ‰æ•ˆ"
    else
        echo "âŒ Cookie æ— æ•ˆæˆ–å·²è¿‡æœŸ"
        echo "   éœ€è¦é‡æ–°è·å– Cookie"
        exit 1
    fi
else
    echo "âŒ æ— æ³•è¿æ¥åˆ°ç™¾åº¦æœåŠ¡å™¨ (HTTP $response)"
fi

# 3. æµ‹è¯•åˆ†äº«é“¾æ¥
echo ""
echo "ã€3/5ã€‘æµ‹è¯•åˆ†äº«é“¾æ¥è®¿é—®..."
SHARE_URL="https://pan.baidu.com/s/158pDc"
curl -s "$SHARE_URL" \
    -H "Cookie: BDUSS=$BDUSS; STOKEN=$STOKEN" \
    -H "User-Agent: Mozilla/5.0" \
    > /tmp/share_test.html

if grep -q "yunData" /tmp/share_test.html; then
    echo "âœ… åˆ†äº«é“¾æ¥å¯è®¿é—®"
elif grep -q "ä¸å­˜åœ¨\|å·²è¿‡æœŸ\|å·²å–æ¶ˆ" /tmp/share_test.html; then
    echo "âŒ åˆ†äº«é“¾æ¥å·²å¤±æ•ˆ"
else
    echo "âš ï¸  åˆ†äº«é“¾æ¥çŠ¶æ€æœªçŸ¥"
fi

# 4. æµ‹è¯• API
echo ""
echo "ã€4/5ã€‘æµ‹è¯• wxlist API..."
SURL="58pDc"
result=$(curl -s -X POST "https://pan.baidu.com/share/wxlist?channel=weixin&version=2.2.2&clienttype=25&web=1&t=$(date +%s)" \
    -H "Cookie: BDUSS=$BDUSS; STOKEN=$STOKEN" \
    -d "shorturl=$SURL" \
    -d "pwd=" \
    -d "root=1")

errno=$(echo "$result" | grep -o '"errno":[0-9-]*' | cut -d':' -f2)

if [ "$errno" = "0" ]; then
    echo "âœ… API è°ƒç”¨æˆåŠŸ"
elif [ "$errno" = "2" ]; then
    echo "âŒ API è¿”å› errno:2 (Cookie å¤±æ•ˆ)"
else
    echo "âŒ API è¿”å› errno:$errno"
fi

# 5. æ€»ç»“
echo ""
echo "ã€5/5ã€‘è¯Šæ–­æ€»ç»“"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

if [ "$errno" = "2" ]; then
    echo "é—®é¢˜åŸå› : Cookie å·²å¤±æ•ˆ"
    echo ""
    echo "è§£å†³æ–¹æ³•:"
    echo "1. æµè§ˆå™¨æ‰“å¼€ https://pan.baidu.com"
    echo "2. ç™»å½•ä½ çš„ç™¾åº¦è´¦å·"
    echo "3. F12 â†’ Application â†’ Cookies â†’ https://pan.baidu.com"
    echo "4. å¤åˆ¶ BDUSS å’Œ STOKEN çš„å®Œæ•´å€¼"
    echo "5. æ›´æ–° config.toml æ–‡ä»¶"
    echo "6. é‡å¯æœåŠ¡å™¨: cargo run --release"
else
    echo "è¯·æŸ¥çœ‹ä¸Šè¿°æ£€æŸ¥ç»“æœ"
fi

rm -f /tmp/cookie_test.html /tmp/share_test.html
</file>

<file path="felixonmars-baidupcs-go-8a5edab282632443 (1).txt">
Directory structure:
â””â”€â”€ felixonmars-baidupcs-go/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ BaiduPCS-Go.exe.manifest
    â”œâ”€â”€ build.sh
    â”œâ”€â”€ entitlements.xml
    â”œâ”€â”€ go.mod
    â”œâ”€â”€ go.sum
    â”œâ”€â”€ Info.plist
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ versioninfo.json
    â”œâ”€â”€ baidupcs/
    â”‚   â”œâ”€â”€ baidupcs.go
    â”‚   â”œâ”€â”€ cache.go
    â”‚   â”œâ”€â”€ cloud_dl.go
    â”‚   â”œâ”€â”€ cp_mv_rename.go
    â”‚   â”œâ”€â”€ download.go
    â”‚   â”œâ”€â”€ extends.go
    â”‚   â”œâ”€â”€ file_directory.go
    â”‚   â”œâ”€â”€ jsontable.go
    â”‚   â”œâ”€â”€ prepare.go
    â”‚   â”œâ”€â”€ publicsuffix.go
    â”‚   â”œâ”€â”€ quota.go
    â”‚   â”œâ”€â”€ recycle.go
    â”‚   â”œâ”€â”€ rm_mkdir.go
    â”‚   â”œâ”€â”€ share.go
    â”‚   â”œâ”€â”€ upload.go
    â”‚   â”œâ”€â”€ util.go
    â”‚   â”œâ”€â”€ expires/
    â”‚   â”‚   â”œâ”€â”€ dataexpires.go
    â”‚   â”‚   â”œâ”€â”€ expires.go
    â”‚   â”‚   â”œâ”€â”€ expires.s
    â”‚   â”‚   â””â”€â”€ cachemap/
    â”‚   â”‚       â”œâ”€â”€ cachemap.go
    â”‚   â”‚       â”œâ”€â”€ cachemap_test.go
    â”‚   â”‚       â”œâ”€â”€ cacheunit.go
    â”‚   â”‚       â””â”€â”€ utils.go
    â”‚   â”œâ”€â”€ internal/
    â”‚   â”‚   â””â”€â”€ panhome/
    â”‚   â”‚       â”œâ”€â”€ cache.go
    â”‚   â”‚       â”œâ”€â”€ panhome.go
    â”‚   â”‚       â”œâ”€â”€ parse.go
    â”‚   â”‚       â””â”€â”€ sign.go
    â”‚   â”œâ”€â”€ netdisksign/
    â”‚   â”‚   â”œâ”€â”€ devuid.go
    â”‚   â”‚   â”œâ”€â”€ locatedownloadsign.go
    â”‚   â”‚   â”œâ”€â”€ locatedownloadsign_test.go
    â”‚   â”‚   â”œâ”€â”€ share_sign.go
    â”‚   â”‚   â”œâ”€â”€ sign2.go
    â”‚   â”‚   â”œâ”€â”€ sign2.js
    â”‚   â”‚   â””â”€â”€ sign2_test.go
    â”‚   â””â”€â”€ pcserror/
    â”‚       â”œâ”€â”€ dlinkerrinfo.go
    â”‚       â”œâ”€â”€ panerrorinfo.go
    â”‚       â”œâ”€â”€ pcserror.go
    â”‚       â””â”€â”€ pcserrorinfo.go
    â”œâ”€â”€ cmd/
    â”‚   â””â”€â”€ AndroidNDKBuild/
    â”‚       â””â”€â”€ main.go
    â”œâ”€â”€ debian/
    â”‚   â”œâ”€â”€ copyright
    â”‚   â”œâ”€â”€ Packages.sh
    â”‚   â”œâ”€â”€ iphoneos-arm/
    â”‚   â”‚   â””â”€â”€ control
    â”‚   â””â”€â”€ linux-amd64/
    â”‚       â””â”€â”€ control
    â”œâ”€â”€ docs/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ file_data_apis_error.md
    â”‚   â”œâ”€â”€ overview.md
    â”‚   â”œâ”€â”€ structured_data_apis_error.md
    â”‚   â””â”€â”€ structured_data_apis_overview.md
    â”œâ”€â”€ internal/
    â”‚   â”œâ”€â”€ pcscommand/
    â”‚   â”‚   â”œâ”€â”€ cd.go
    â”‚   â”‚   â”œâ”€â”€ cloud_dl.go
    â”‚   â”‚   â”œâ”€â”€ cp_mv.go
    â”‚   â”‚   â”œâ”€â”€ download.go
    â”‚   â”‚   â”œâ”€â”€ export.go
    â”‚   â”‚   â”œâ”€â”€ fixmd5.go
    â”‚   â”‚   â”œâ”€â”€ locatedonwload.go
    â”‚   â”‚   â”œâ”€â”€ login.go
    â”‚   â”‚   â”œâ”€â”€ ls_search.go
    â”‚   â”‚   â”œâ”€â”€ meta.go
    â”‚   â”‚   â”œâ”€â”€ pcscommand.go
    â”‚   â”‚   â”œâ”€â”€ quota.go
    â”‚   â”‚   â”œâ”€â”€ recycle.go
    â”‚   â”‚   â”œâ”€â”€ rm_mkdir.go
    â”‚   â”‚   â”œâ”€â”€ runner.go
    â”‚   â”‚   â”œâ”€â”€ share.go
    â”‚   â”‚   â”œâ”€â”€ tree.go
    â”‚   â”‚   â”œâ”€â”€ upload.go
    â”‚   â”‚   â””â”€â”€ util.go
    â”‚   â”œâ”€â”€ pcsconfig/
    â”‚   â”‚   â”œâ”€â”€ baidu.go
    â”‚   â”‚   â”œâ”€â”€ errors.go
    â”‚   â”‚   â”œâ”€â”€ export.go
    â”‚   â”‚   â”œâ”€â”€ maniper.go
    â”‚   â”‚   â”œâ”€â”€ pcsconfig.go
    â”‚   â”‚   â””â”€â”€ util.go
    â”‚   â”œâ”€â”€ pcsfunctions/
    â”‚   â”‚   â”œâ”€â”€ common.go
    â”‚   â”‚   â”œâ”€â”€ statistic.go
    â”‚   â”‚   â”œâ”€â”€ pcscaptcha/
    â”‚   â”‚   â”‚   â”œâ”€â”€ captchapath.go
    â”‚   â”‚   â”‚   â””â”€â”€ pcscaptcha.go
    â”‚   â”‚   â”œâ”€â”€ pcsdownload/
    â”‚   â”‚   â”‚   â”œâ”€â”€ download_link.go
    â”‚   â”‚   â”‚   â”œâ”€â”€ download_statistic.go
    â”‚   â”‚   â”‚   â”œâ”€â”€ download_task_unit.go
    â”‚   â”‚   â”‚   â”œâ”€â”€ errors.go
    â”‚   â”‚   â”‚   â”œâ”€â”€ pcsdownload.go
    â”‚   â”‚   â”‚   â””â”€â”€ utils.go
    â”‚   â”‚   â””â”€â”€ pcsupload/
    â”‚   â”‚       â”œâ”€â”€ pcsupload.go
    â”‚   â”‚       â”œâ”€â”€ upload.go
    â”‚   â”‚       â”œâ”€â”€ upload2.go
    â”‚   â”‚       â”œâ”€â”€ upload_database.go
    â”‚   â”‚       â”œâ”€â”€ upload_statistic.go
    â”‚   â”‚       â”œâ”€â”€ upload_task_unit.go
    â”‚   â”‚       â””â”€â”€ utils.go
    â”‚   â”œâ”€â”€ pcsinit/
    â”‚   â”‚   â”œâ”€â”€ pcsinit.go
    â”‚   â”‚   â””â”€â”€ pcsinit.s
    â”‚   â””â”€â”€ pcsupdate/
    â”‚       â”œâ”€â”€ github.go
    â”‚       â”œâ”€â”€ pcsupdate.go
    â”‚       â””â”€â”€ updatefile.go
    â”œâ”€â”€ pcsliner/
    â”‚   â”œâ”€â”€ clear.go
    â”‚   â”œâ”€â”€ clear.s
    â”‚   â”œâ”€â”€ clear_windows.go
    â”‚   â”œâ”€â”€ linehistory.go
    â”‚   â”œâ”€â”€ pcsliner.go
    â”‚   â””â”€â”€ args/
    â”‚       â”œâ”€â”€ args.go
    â”‚       â””â”€â”€ args_test.go
    â”œâ”€â”€ pcstable/
    â”‚   â””â”€â”€ pcstable.go
    â”œâ”€â”€ pcsutil/
    â”‚   â”œâ”€â”€ addr.go
    â”‚   â”œâ”€â”€ crypto.go
    â”‚   â”œâ”€â”€ error.go
    â”‚   â”œâ”€â”€ file.go
    â”‚   â”œâ”€â”€ file_test.go
    â”‚   â”œâ”€â”€ log_colorable_prefix.go
    â”‚   â”œâ”€â”€ pcsutil.go
    â”‚   â”œâ”€â”€ regexp_pre.go
    â”‚   â”œâ”€â”€ cachepool/
    â”‚   â”‚   â”œâ”€â”€ cachepool.go
    â”‚   â”‚   â”œâ”€â”€ idcachepool.go
    â”‚   â”‚   â”œâ”€â”€ malloc.go
    â”‚   â”‚   â”œâ”€â”€ malloc.s
    â”‚   â”‚   â”œâ”€â”€ malloc_test.go
    â”‚   â”‚   â””â”€â”€ syncpool.go
    â”‚   â”œâ”€â”€ checkaccess/
    â”‚   â”‚   â”œâ”€â”€ check_others.go
    â”‚   â”‚   â”œâ”€â”€ check_unix.go
    â”‚   â”‚   â”œâ”€â”€ check_windows.go
    â”‚   â”‚   â””â”€â”€ checkaccess.go
    â”‚   â”œâ”€â”€ checksum/
    â”‚   â”‚   â”œâ”€â”€ checksum.go
    â”‚   â”‚   â”œâ”€â”€ checksum_test.go
    â”‚   â”‚   â”œâ”€â”€ checksum_write.go
    â”‚   â”‚   â”œâ”€â”€ errors.go
    â”‚   â”‚   â””â”€â”€ file.go
    â”‚   â”œâ”€â”€ converter/
    â”‚   â”‚   â”œâ”€â”€ converter.go
    â”‚   â”‚   â”œâ”€â”€ converter_test.go
    â”‚   â”‚   â”œâ”€â”€ short_display_test.go
    â”‚   â”‚   â”œâ”€â”€ size.go
    â”‚   â”‚   â””â”€â”€ size_test.go
    â”‚   â”œâ”€â”€ delay/
    â”‚   â”‚   â””â”€â”€ delay.go
    â”‚   â”œâ”€â”€ escaper/
    â”‚   â”‚   â”œâ”€â”€ escaper.go
    â”‚   â”‚   â””â”€â”€ escaper_test.go
    â”‚   â”œâ”€â”€ getip/
    â”‚   â”‚   â”œâ”€â”€ errors.go
    â”‚   â”‚   â”œâ”€â”€ getip.go
    â”‚   â”‚   â”œâ”€â”€ getip_netease.go
    â”‚   â”‚   â”œâ”€â”€ getip_techain.go
    â”‚   â”‚   â””â”€â”€ getip_test.go
    â”‚   â”œâ”€â”€ jsonhelper/
    â”‚   â”‚   â””â”€â”€ jsonhelper.go
    â”‚   â”œâ”€â”€ jwted25519/
    â”‚   â”‚   â””â”€â”€ jwted25519.go
    â”‚   â”œâ”€â”€ pcstime/
    â”‚   â”‚   â””â”€â”€ time.go
    â”‚   â”œâ”€â”€ prealloc/
    â”‚   â”‚   â”œâ”€â”€ errors.go
    â”‚   â”‚   â”œâ”€â”€ prealloc.go
    â”‚   â”‚   â”œâ”€â”€ prealloc_plan9.go
    â”‚   â”‚   â””â”€â”€ prealloc_windows.go
    â”‚   â”œâ”€â”€ taskframework/
    â”‚   â”‚   â”œâ”€â”€ executor.go
    â”‚   â”‚   â”œâ”€â”€ task_unit.go
    â”‚   â”‚   â”œâ”€â”€ taskframework_test.go
    â”‚   â”‚   â””â”€â”€ taskinfo.go
    â”‚   â””â”€â”€ waitgroup/
    â”‚       â”œâ”€â”€ wait_group.go
    â”‚       â””â”€â”€ wait_group_test.go
    â”œâ”€â”€ pcsverbose/
    â”‚   â”œâ”€â”€ pcsverbose.go
    â”‚   â”œâ”€â”€ utils.go
    â”‚   â””â”€â”€ pcsdebug/
    â”‚       â”œâ”€â”€ cpu.go
    â”‚       â””â”€â”€ pprof.go
    â”œâ”€â”€ requester/
    â”‚   â”œâ”€â”€ dial.go
    â”‚   â”œâ”€â”€ fetch.go
    â”‚   â”œâ”€â”€ http_client.go
    â”‚   â”œâ”€â”€ requester.go
    â”‚   â”œâ”€â”€ tcpaddr_cache.go
    â”‚   â”œâ”€â”€ util.go
    â”‚   â”œâ”€â”€ downloader/
    â”‚   â”‚   â”œâ”€â”€ config.go
    â”‚   â”‚   â”œâ”€â”€ download_firstinfo.go
    â”‚   â”‚   â”œâ”€â”€ download_test.go
    â”‚   â”‚   â”œâ”€â”€ downloader.go
    â”‚   â”‚   â”œâ”€â”€ example.go
    â”‚   â”‚   â”œâ”€â”€ instance_state.go
    â”‚   â”‚   â”œâ”€â”€ loadbalance.go
    â”‚   â”‚   â”œâ”€â”€ monitor.go
    â”‚   â”‚   â”œâ”€â”€ range_test.go
    â”‚   â”‚   â”œâ”€â”€ resetcontroler.go
    â”‚   â”‚   â”œâ”€â”€ sort.go
    â”‚   â”‚   â”œâ”€â”€ status.go
    â”‚   â”‚   â”œâ”€â”€ utils.go
    â”‚   â”‚   â”œâ”€â”€ worker.go
    â”‚   â”‚   â””â”€â”€ writer.go
    â”‚   â”œâ”€â”€ multipartreader/
    â”‚   â”‚   â””â”€â”€ multipartreader.go
    â”‚   â”œâ”€â”€ rio/
    â”‚   â”‚   â”œâ”€â”€ buf.go
    â”‚   â”‚   â”œâ”€â”€ file.go
    â”‚   â”‚   â”œâ”€â”€ multi.go
    â”‚   â”‚   â”œâ”€â”€ multi_test.go
    â”‚   â”‚   â”œâ”€â”€ rio.go
    â”‚   â”‚   â””â”€â”€ speeds/
    â”‚   â”‚       â”œâ”€â”€ ratelimit.go
    â”‚   â”‚       â”œâ”€â”€ ratelimit_test.go
    â”‚   â”‚       â””â”€â”€ speeds.go
    â”‚   â”œâ”€â”€ transfer/
    â”‚   â”‚   â”œâ”€â”€ download_instanceinfo.go
    â”‚   â”‚   â”œâ”€â”€ download_status.go
    â”‚   â”‚   â”œâ”€â”€ rangelist.go
    â”‚   â”‚   â”œâ”€â”€ transfer.pb.go
    â”‚   â”‚   â””â”€â”€ transfer.proto
    â”‚   â””â”€â”€ uploader/
    â”‚       â”œâ”€â”€ block.go
    â”‚       â”œâ”€â”€ block_test.go
    â”‚       â”œâ”€â”€ error.go
    â”‚       â”œâ”€â”€ example.go
    â”‚       â”œâ”€â”€ instance_state.go
    â”‚       â”œâ”€â”€ multiuploader.go
    â”‚       â”œâ”€â”€ multiworker.go
    â”‚       â”œâ”€â”€ readed.go
    â”‚       â”œâ”€â”€ status.go
    â”‚       â””â”€â”€ uploader.go
    â””â”€â”€ .github/
        â””â”€â”€ RELEASE_TEMPLATE.md

================================================
FILE: README.md
================================================
# BaiduPCS-Go ç™¾åº¦ç½‘ç›˜å®¢æˆ·ç«¯

[![Build status](https://ci.appveyor.com/api/projects/status/nhx92nqyrfq9su7y?svg=true)](https://ci.appveyor.com/project/iikira/baidupcs-go)
[![GoDoc](https://godoc.org/github.com/iikira/BaiduPCS-Go?status.svg)](https://godoc.org/github.com/iikira/BaiduPCS-Go)

ä»¿ Linux shell æ–‡ä»¶å¤„ç†å‘½ä»¤çš„ç™¾åº¦ç½‘ç›˜å‘½ä»¤è¡Œå®¢æˆ·ç«¯.

This project was largely inspired by [GangZhuo/BaiduPCS](https://github.com/GangZhuo/BaiduPCS)

## æ³¨æ„

æ­¤æ–‡æ¡£åªé’ˆå¯¹äºæœ€æ–°çš„commit, å¯èƒ½ä¸é€‚ç”¨äºå·²å‘å¸ƒçš„æœ€æ–°ç‰ˆæœ¬.

<!-- toc -->
## ç›®å½•

- [ç‰¹è‰²](#ç‰¹è‰²)
- [ç¼–è¯‘/äº¤å‰ç¼–è¯‘ è¯´æ˜](#ç¼–è¯‘äº¤å‰ç¼–è¯‘-è¯´æ˜)
- [ä¸‹è½½/è¿è¡Œ è¯´æ˜](#ä¸‹è½½è¿è¡Œ-è¯´æ˜)
  * [Windows](#windows)
  * [Linux / macOS](#linux--macos)
  * [Android / iOS](#android--ios)
- [å‘½ä»¤åˆ—è¡¨åŠè¯´æ˜](#å‘½ä»¤åˆ—è¡¨åŠè¯´æ˜)
  * [æ³¨æ„ ! ! !](#æ³¨æ„---)
  * [æ£€æµ‹ç¨‹åºæ›´æ–°](#æ£€æµ‹ç¨‹åºæ›´æ–°)
  * [ç™»å½•ç™¾åº¦å¸å·](#ç™»å½•ç™¾åº¦å¸å·)
  * [åˆ—å‡ºå¸å·åˆ—è¡¨](#åˆ—å‡ºå¸å·åˆ—è¡¨)
  * [è·å–å½“å‰å¸å·](#è·å–å½“å‰å¸å·)
  * [åˆ‡æ¢ç™¾åº¦å¸å·](#åˆ‡æ¢ç™¾åº¦å¸å·)
  * [é€€å‡ºç™¾åº¦å¸å·](#é€€å‡ºç™¾åº¦å¸å·)
  * [è·å–ç½‘ç›˜é…é¢](#è·å–ç½‘ç›˜é…é¢)
  * [åˆ‡æ¢å·¥ä½œç›®å½•](#åˆ‡æ¢å·¥ä½œç›®å½•)
  * [è¾“å‡ºå·¥ä½œç›®å½•](#è¾“å‡ºå·¥ä½œç›®å½•)
  * [åˆ—å‡ºç›®å½•](#åˆ—å‡ºç›®å½•)
  * [åˆ—å‡ºç›®å½•æ ‘å½¢å›¾](#åˆ—å‡ºç›®å½•æ ‘å½¢å›¾)
  * [è·å–æ–‡ä»¶/ç›®å½•çš„å…ƒä¿¡æ¯](#è·å–æ–‡ä»¶ç›®å½•çš„å…ƒä¿¡æ¯)
  * [æœç´¢æ–‡ä»¶](#æœç´¢æ–‡ä»¶)
  * [ä¸‹è½½æ–‡ä»¶/ç›®å½•](#ä¸‹è½½æ–‡ä»¶ç›®å½•)
  * [ä¸Šä¼ æ–‡ä»¶/ç›®å½•](#ä¸Šä¼ æ–‡ä»¶ç›®å½•)
  * [è·å–ä¸‹è½½ç›´é“¾](#è·å–ä¸‹è½½ç›´é“¾)
  * [æ‰‹åŠ¨ç§’ä¼ æ–‡ä»¶](#æ‰‹åŠ¨ç§’ä¼ æ–‡ä»¶)
  * [ä¿®å¤æ–‡ä»¶MD5](#ä¿®å¤æ–‡ä»¶MD5)
  * [è·å–æœ¬åœ°æ–‡ä»¶çš„ç§’ä¼ ä¿¡æ¯](#è·å–æœ¬åœ°æ–‡ä»¶çš„ç§’ä¼ ä¿¡æ¯)
  * [å¯¼å‡ºæ–‡ä»¶/ç›®å½•](#å¯¼å‡ºæ–‡ä»¶ç›®å½•)
  * [åˆ›å»ºç›®å½•](#åˆ›å»ºç›®å½•)
  * [åˆ é™¤æ–‡ä»¶/ç›®å½•](#åˆ é™¤æ–‡ä»¶ç›®å½•)
  * [æ‹·è´æ–‡ä»¶/ç›®å½•](#æ‹·è´æ–‡ä»¶ç›®å½•)
  * [ç§»åŠ¨/é‡å‘½åæ–‡ä»¶/ç›®å½•](#ç§»åŠ¨é‡å‘½åæ–‡ä»¶ç›®å½•)
  * [åˆ†äº«æ–‡ä»¶/ç›®å½•](#åˆ†äº«æ–‡ä»¶ç›®å½•)
    + [è®¾ç½®åˆ†äº«æ–‡ä»¶/ç›®å½•](#è®¾ç½®åˆ†äº«æ–‡ä»¶ç›®å½•)
    + [åˆ—å‡ºå·²åˆ†äº«æ–‡ä»¶/ç›®å½•](#åˆ—å‡ºå·²åˆ†äº«æ–‡ä»¶ç›®å½•)
    + [å–æ¶ˆåˆ†äº«æ–‡ä»¶/ç›®å½•](#å–æ¶ˆåˆ†äº«æ–‡ä»¶ç›®å½•)
  * [ç¦»çº¿ä¸‹è½½](#ç¦»çº¿ä¸‹è½½)
    + [æ·»åŠ ç¦»çº¿ä¸‹è½½ä»»åŠ¡](#æ·»åŠ ç¦»çº¿ä¸‹è½½ä»»åŠ¡)
    + [ç²¾ç¡®æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡](#ç²¾ç¡®æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡)
    + [æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡åˆ—è¡¨](#æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡åˆ—è¡¨)
    + [å–æ¶ˆç¦»çº¿ä¸‹è½½ä»»åŠ¡](#å–æ¶ˆç¦»çº¿ä¸‹è½½ä»»åŠ¡)
    + [åˆ é™¤ç¦»çº¿ä¸‹è½½ä»»åŠ¡](#åˆ é™¤ç¦»çº¿ä¸‹è½½ä»»åŠ¡)
  * [å›æ”¶ç«™](#å›æ”¶ç«™)
    + [åˆ—å‡ºå›æ”¶ç«™æ–‡ä»¶åˆ—è¡¨](#åˆ—å‡ºå›æ”¶ç«™æ–‡ä»¶åˆ—è¡¨)
    + [è¿˜åŸå›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•](#è¿˜åŸå›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•)
    + [åˆ é™¤å›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•/æ¸…ç©ºå›æ”¶ç«™](#åˆ é™¤å›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•æ¸…ç©ºå›æ”¶ç«™)
  * [æ˜¾ç¤ºå’Œä¿®æ”¹ç¨‹åºé…ç½®é¡¹](#æ˜¾ç¤ºå’Œä¿®æ”¹ç¨‹åºé…ç½®é¡¹)
  * [æµ‹è¯•é€šé…ç¬¦](#æµ‹è¯•é€šé…ç¬¦)
  * [å·¥å…·ç®±](#å·¥å…·ç®±)
- [åˆçº§ä½¿ç”¨æ•™ç¨‹](#åˆçº§ä½¿ç”¨æ•™ç¨‹)
  * [1. æŸ¥çœ‹ç¨‹åºä½¿ç”¨è¯´æ˜](#1-æŸ¥çœ‹ç¨‹åºä½¿ç”¨è¯´æ˜)
  * [2. ç™»å½•ç™¾åº¦å¸å· (å¿…åš)](#2-ç™»å½•ç™¾åº¦å¸å·-å¿…åš)
  * [3. åˆ‡æ¢ç½‘ç›˜å·¥ä½œç›®å½•](#3-åˆ‡æ¢ç½‘ç›˜å·¥ä½œç›®å½•)
  * [4. ç½‘ç›˜å†…åˆ—å‡ºæ–‡ä»¶å’Œç›®å½•](#4-ç½‘ç›˜å†…åˆ—å‡ºæ–‡ä»¶å’Œç›®å½•)
  * [5. ä¸‹è½½æ–‡ä»¶](#5-ä¸‹è½½æ–‡ä»¶)
  * [6. è®¾ç½®ä¸‹è½½æœ€å¤§å¹¶å‘é‡](#6-è®¾ç½®ä¸‹è½½æœ€å¤§å¹¶å‘é‡)
  * [7. é€€å‡ºç¨‹åº](#7-é€€å‡ºç¨‹åº)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
- [TODO](#todo)
- [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)
- [äº¤æµåé¦ˆ](#äº¤æµåé¦ˆ)
- [æåŠ©](#æåŠ©)

<!-- tocstop -->

# ç‰¹è‰²

å¤šå¹³å°æ”¯æŒ, æ”¯æŒ Windows, macOS, linux, ç§»åŠ¨è®¾å¤‡ç­‰.

ç™¾åº¦å¸å·å¤šç”¨æˆ·æ”¯æŒ;

é€šé…ç¬¦åŒ¹é…ç½‘ç›˜è·¯å¾„å’Œ Tab è‡ªåŠ¨è¡¥é½å‘½ä»¤å’Œè·¯å¾„, [é€šé…ç¬¦_ç™¾åº¦ç™¾ç§‘](https://baike.baidu.com/item/é€šé…ç¬¦);

[ä¸‹è½½](#ä¸‹è½½æ–‡ä»¶ç›®å½•)ç½‘ç›˜å†…æ–‡ä»¶, æ”¯æŒå¤šä¸ªæ–‡ä»¶æˆ–ç›®å½•ä¸‹è½½, æ”¯æŒæ–­ç‚¹ç»­ä¼ å’Œå•æ–‡ä»¶å¹¶è¡Œä¸‹è½½;

[ä¸Šä¼ ](#ä¸Šä¼ æ–‡ä»¶ç›®å½•)æœ¬åœ°æ–‡ä»¶, æ”¯æŒä¸Šä¼ å¤§æ–‡ä»¶(>2GB), æ”¯æŒå¤šä¸ªæ–‡ä»¶æˆ–ç›®å½•ä¸Šä¼ ;

[ç¦»çº¿ä¸‹è½½](#ç¦»çº¿ä¸‹è½½), æ”¯æŒhttp/https/ftp/ç”µé©´/ç£åŠ›é“¾åè®®.

# ç¼–è¯‘/äº¤å‰ç¼–è¯‘ è¯´æ˜
å‚è§ [ç¼–è¯‘/äº¤å‰ç¼–è¯‘å¸®åŠ©](https://github.com/iikira/BaiduPCS-Go/wiki/ç¼–è¯‘-äº¤å‰ç¼–è¯‘å¸®åŠ©)

# ä¸‹è½½/è¿è¡Œ è¯´æ˜

Goè¯­è¨€ç¨‹åº, å¯ç›´æ¥åœ¨[å‘å¸ƒé¡µ](https://github.com/iikira/BaiduPCS-Go/releases)ä¸‹è½½ä½¿ç”¨.

å¯åœ¨è¿™é‡Œä¸‹è½½æœ€æ–°commitå¯¹åº”çš„**æµ‹è¯•ç‰ˆ**: https://ci.appveyor.com/project/iikira/baidupcs-go/build/artifacts

å¦‚æœç¨‹åºè¿è¡Œæ—¶è¾“å‡ºä¹±ç , è¯·æ£€æŸ¥ä¸‹ç»ˆç«¯çš„ç¼–ç æ–¹å¼æ˜¯å¦ä¸º `UTF-8`.

ä½¿ç”¨æœ¬ç¨‹åºä¹‹å‰, å»ºè®®å­¦ä¹ ä¸€äº› linux åŸºç¡€çŸ¥è¯† å’Œ åŸºç¡€å‘½ä»¤.

å¦‚æœæœªå¸¦ä»»ä½•å‚æ•°è¿è¡Œç¨‹åº, ç¨‹åºå°†ä¼šè¿›å…¥ä»¿Linux shellç³»ç»Ÿç”¨æˆ·ç•Œé¢çš„cliäº¤äº’æ¨¡å¼, å¯ç›´æ¥è¿è¡Œç›¸å…³å‘½ä»¤.

cliäº¤äº’æ¨¡å¼ä¸‹, å…‰æ ‡æ‰€åœ¨è¡Œçš„å‰ç¼€åº”ä¸º `BaiduPCS-Go >`, å¦‚æœç™»å½•äº†ç™¾åº¦å¸å·åˆ™æ ¼å¼ä¸º `BaiduPCS-Go:<å·¥ä½œç›®å½•> <ç™¾åº¦ID>$ `

ç¨‹åºä¼šæä¾›ç›¸å…³å‘½ä»¤çš„ä½¿ç”¨è¯´æ˜.

## Windows

ç¨‹åºåº”åœ¨ å‘½ä»¤æç¤ºç¬¦ (Command Prompt) æˆ– PowerShell ä¸­è¿è¡Œ, åœ¨ mintty (ä¾‹å¦‚: GitBash) å¯èƒ½ä¼šæœ‰æ˜¾ç¤ºé—®é¢˜.

ä¹Ÿå¯ç›´æ¥åŒå‡»ç¨‹åºè¿è¡Œ, å…·ä½“ä½¿ç”¨æ–¹æ³•è¯·å‚è§ [å‘½ä»¤åˆ—è¡¨åŠè¯´æ˜](#å‘½ä»¤åˆ—è¡¨åŠè¯´æ˜) å’Œ [åˆçº§ä½¿ç”¨æ•™ç¨‹](#åˆçº§ä½¿ç”¨æ•™ç¨‹).

## Linux / macOS

ç¨‹åºåº”åœ¨ ç»ˆç«¯ (Terminal) è¿è¡Œ.

å…·ä½“ä½¿ç”¨æ–¹æ³•è¯·å‚è§ [å‘½ä»¤åˆ—è¡¨åŠè¯´æ˜](#å‘½ä»¤åˆ—è¡¨åŠè¯´æ˜) å’Œ [åˆçº§ä½¿ç”¨æ•™ç¨‹](#åˆçº§ä½¿ç”¨æ•™ç¨‹).

## Android / iOS

> Android / iOS ç§»åŠ¨è®¾å¤‡æ“ä½œæ¯”è¾ƒéº»çƒ¦, ä¸å»ºè®®åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šä½¿ç”¨æœ¬ç¨‹åº.

å®‰å“, å»ºè®®ä½¿ç”¨ [Termux](https://termux.com) æˆ– [NeoTerm](https://github.com/NeoTerm/NeoTerm) æˆ– ç»ˆç«¯æ¨¡æ‹Ÿå™¨, ä»¥æä¾›ç»ˆç«¯ç¯å¢ƒ.

ç¤ºä¾‹: [Android è¿è¡Œæœ¬é¡¹ç›®ç¨‹åºå‚è€ƒç¤ºä¾‹](https://github.com/iikira/BaiduPCS-Go/wiki/Android-è¿è¡Œæœ¬é¡¹ç›®ç¨‹åºå‚è€ƒç¤ºä¾‹), æœ‰å…´è¶£çš„å¯ä»¥å‚è€ƒä¸€ä¸‹.

è‹¹æœiOS, éœ€è¦è¶Šç‹±, åœ¨ Cydia æœç´¢ä¸‹è½½å¹¶å®‰è£… MobileTerminal, æˆ–è€…å…¶ä»–æä¾›ç»ˆç«¯ç¯å¢ƒçš„è½¯ä»¶.

ç¤ºä¾‹: [iOS è¿è¡Œæœ¬é¡¹ç›®ç¨‹åºå‚è€ƒç¤ºä¾‹](https://github.com/iikira/BaiduPCS-Go/wiki/iOS-è¿è¡Œæœ¬é¡¹ç›®ç¨‹åºå‚è€ƒç¤ºä¾‹), æœ‰å…´è¶£çš„å¯ä»¥å‚è€ƒä¸€ä¸‹.

å…·ä½“ä½¿ç”¨æ–¹æ³•è¯·å‚è§ [å‘½ä»¤åˆ—è¡¨åŠè¯´æ˜](#å‘½ä»¤åˆ—è¡¨åŠè¯´æ˜) å’Œ [åˆçº§ä½¿ç”¨æ•™ç¨‹](#åˆçº§ä½¿ç”¨æ•™ç¨‹).

# å‘½ä»¤åˆ—è¡¨åŠè¯´æ˜

## æ³¨æ„ ! ! !

å‘½ä»¤çš„å‰ç¼€ `BaiduPCS-Go` ä¸ºæŒ‡å‘ç¨‹åºè¿è¡Œçš„å…¨è·¯å¾„å (ARGv çš„ç¬¬ä¸€ä¸ªå‚æ•°)

ç›´æ¥è¿è¡Œç¨‹åºæ—¶, æœªå¸¦ä»»ä½•å…¶ä»–å‚æ•°, åˆ™ç¨‹åºè¿›å…¥cliäº¤äº’æ¨¡å¼, è¿è¡Œä»¥ä¸‹å‘½ä»¤æ—¶, è¦æŠŠå‘½ä»¤çš„å‰ç¼€ `BaiduPCS-Go` å»æ‰!

cliäº¤äº’æ¨¡å¼å·²æ”¯æŒæŒ‰tabé”®è‡ªåŠ¨è¡¥å…¨å‘½ä»¤å’Œè·¯å¾„.

## æ£€æµ‹ç¨‹åºæ›´æ–°
```
BaiduPCS-Go update
```

## ç™»å½•ç™¾åº¦å¸å·

### å¸¸è§„ç™»å½•ç™¾åº¦å¸å·

æ”¯æŒåœ¨çº¿éªŒè¯ç»‘å®šçš„æ‰‹æœºå·æˆ–é‚®ç®±,
```
BaiduPCS-Go login
```

### ä½¿ç”¨ç™¾åº¦ BDUSS æ¥ç™»å½•ç™¾åº¦å¸å·

[å…³äº è·å–ç™¾åº¦ BDUSS](https://github.com/iikira/BaiduPCS-Go/wiki/å…³äº-è·å–ç™¾åº¦-BDUSS)

```
BaiduPCS-Go login -bduss=<BDUSS>
```

#### ä¾‹å­
```
BaiduPCS-Go login -bduss=1234567
```
```
BaiduPCS-Go login
è¯·è¾“å…¥ç™¾åº¦ç”¨æˆ·å(æ‰‹æœºå·/é‚®ç®±/ç”¨æˆ·å), å›è½¦é”®æäº¤ > 1234567
```

## åˆ—å‡ºå¸å·åˆ—è¡¨

```
BaiduPCS-Go loglist
```

åˆ—å‡ºæ‰€æœ‰å·²ç™»å½•çš„ç™¾åº¦å¸å·

## è·å–å½“å‰å¸å·

```
BaiduPCS-Go who
```

## åˆ‡æ¢ç™¾åº¦å¸å·

åˆ‡æ¢å·²ç™»å½•çš„ç™¾åº¦å¸å·
```
BaiduPCS-Go su <uid>
```
```
BaiduPCS-Go su

è¯·è¾“å…¥è¦åˆ‡æ¢å¸å·çš„ # å€¼ >
```

## é€€å‡ºç™¾åº¦å¸å·

é€€å‡ºå½“å‰ç™»å½•çš„ç™¾åº¦å¸å·
```
BaiduPCS-Go logout
```

ç¨‹åºä¼šè¿›ä¸€æ­¥ç¡®è®¤é€€å‡ºå¸å·, é˜²æ­¢è¯¯æ“ä½œ.

## è·å–ç½‘ç›˜é…é¢

```
BaiduPCS-Go quota
```
è·å–ç½‘ç›˜çš„æ€»å‚¨å­˜ç©ºé—´, å’Œå·²ä½¿ç”¨çš„å‚¨å­˜ç©ºé—´

## åˆ‡æ¢å·¥ä½œç›®å½•
```
BaiduPCS-Go cd <ç›®å½•>
```

### åˆ‡æ¢å·¥ä½œç›®å½•åè‡ªåŠ¨åˆ—å‡ºå·¥ä½œç›®å½•ä¸‹çš„æ–‡ä»¶å’Œç›®å½•
```
BaiduPCS-Go cd -l <ç›®å½•>
```

#### ä¾‹å­
```
# åˆ‡æ¢ /æˆ‘çš„èµ„æº å·¥ä½œç›®å½•
BaiduPCS-Go cd /æˆ‘çš„èµ„æº

# åˆ‡æ¢ ä¸Šçº§ç›®å½•
BaiduPCS-Go cd ..

# åˆ‡æ¢ æ ¹ç›®å½•
BaiduPCS-Go cd /

# åˆ‡æ¢ /æˆ‘çš„èµ„æº å·¥ä½œç›®å½•, å¹¶è‡ªåŠ¨åˆ—å‡º /æˆ‘çš„èµ„æº ä¸‹çš„æ–‡ä»¶å’Œç›®å½•
BaiduPCS-Go cd -l æˆ‘çš„èµ„æº

# ä½¿ç”¨é€šé…ç¬¦
BaiduPCS-Go cd /æˆ‘çš„*
```

## è¾“å‡ºå·¥ä½œç›®å½•
```
BaiduPCS-Go pwd
```

## åˆ—å‡ºç›®å½•

åˆ—å‡ºå½“å‰å·¥ä½œç›®å½•çš„æ–‡ä»¶å’Œç›®å½•æˆ–æŒ‡å®šç›®å½•
```
BaiduPCS-Go ls
```
```
BaiduPCS-Go ls <ç›®å½•>
```

### å¯é€‰å‚æ•°
```
-asc: å‡åºæ’åº
-desc: é™åºæ’åº
-time: æ ¹æ®æ—¶é—´æ’åº
-name: æ ¹æ®æ–‡ä»¶åæ’åº
-size: æ ¹æ®å¤§å°æ’åº
```

#### ä¾‹å­
```
# åˆ—å‡º æˆ‘çš„èµ„æº å†…çš„æ–‡ä»¶å’Œç›®å½•
BaiduPCS-Go ls æˆ‘çš„èµ„æº

# ç»å¯¹è·¯å¾„
BaiduPCS-Go ls /æˆ‘çš„èµ„æº

# é™åºæ’åº
BaiduPCS-Go ls -desc æˆ‘çš„èµ„æº

# æŒ‰æ–‡ä»¶å¤§å°é™åºæ’åº
BaiduPCS-Go ls -size -desc æˆ‘çš„èµ„æº

# ä½¿ç”¨é€šé…ç¬¦
BaiduPCS-Go ls /æˆ‘çš„*
```

## åˆ—å‡ºç›®å½•æ ‘å½¢å›¾

åˆ—å‡ºå½“å‰å·¥ä½œç›®å½•çš„æ–‡ä»¶å’Œç›®å½•æˆ–æŒ‡å®šç›®å½•çš„æ ‘å½¢å›¾
```
BaiduPCS-Go tree <ç›®å½•>

# é»˜è®¤è·å–å·¥ä½œç›®å½•å…ƒä¿¡æ¯
BaiduPCS-Go tree
```

## è·å–æ–‡ä»¶/ç›®å½•çš„å…ƒä¿¡æ¯
```
BaiduPCS-Go meta <æ–‡ä»¶/ç›®å½•1> <æ–‡ä»¶/ç›®å½•2> <æ–‡ä»¶/ç›®å½•3> ...

# é»˜è®¤è·å–å·¥ä½œç›®å½•å…ƒä¿¡æ¯
BaiduPCS-Go meta
```

#### ä¾‹å­
```
BaiduPCS-Go meta æˆ‘çš„èµ„æº
BaiduPCS-Go meta /
```

## æœç´¢æ–‡ä»¶

æŒ‰æ–‡ä»¶åæœç´¢æ–‡ä»¶ï¼ˆä¸æ”¯æŒæŸ¥æ‰¾ç›®å½•ï¼‰ã€‚

é»˜è®¤åœ¨å½“å‰å·¥ä½œç›®å½•æœç´¢.

```
BaiduPCS-Go search [-path=<éœ€è¦æ£€ç´¢çš„ç›®å½•>] [-r] <å…³é”®å­—>
```

#### ä¾‹å­
```
# æœç´¢æ ¹ç›®å½•çš„æ–‡ä»¶
BaiduPCS-Go search -path=/ å…³é”®å­—

# æœç´¢å½“å‰å·¥ä½œç›®å½•çš„æ–‡ä»¶
BaiduPCS-Go search å…³é”®å­—

# é€’å½’æœç´¢å½“å‰å·¥ä½œç›®å½•çš„æ–‡ä»¶
BaiduPCS-Go search -r å…³é”®å­—
```

## ä¸‹è½½æ–‡ä»¶/ç›®å½•
```
BaiduPCS-Go download <ç½‘ç›˜æ–‡ä»¶æˆ–ç›®å½•çš„è·¯å¾„1> <æ–‡ä»¶æˆ–ç›®å½•2> <æ–‡ä»¶æˆ–ç›®å½•3> ...
BaiduPCS-Go d <ç½‘ç›˜æ–‡ä»¶æˆ–ç›®å½•çš„è·¯å¾„1> <æ–‡ä»¶æˆ–ç›®å½•2> <æ–‡ä»¶æˆ–ç›®å½•3> ...
```

### å¯é€‰å‚æ•°
```
  --test          æµ‹è¯•ä¸‹è½½, æ­¤æ“ä½œä¸ä¼šä¿å­˜æ–‡ä»¶åˆ°æœ¬åœ°
  --ow            overwrite, è¦†ç›–å·²å­˜åœ¨çš„æ–‡ä»¶
  --status        è¾“å‡ºæ‰€æœ‰çº¿ç¨‹çš„å·¥ä½œçŠ¶æ€
  --save          å°†ä¸‹è½½çš„æ–‡ä»¶ç›´æ¥ä¿å­˜åˆ°å½“å‰å·¥ä½œç›®å½•
  --saveto value  å°†ä¸‹è½½çš„æ–‡ä»¶ç›´æ¥ä¿å­˜åˆ°æŒ‡å®šçš„ç›®å½•
  -x              ä¸ºæ–‡ä»¶åŠ ä¸Šæ‰§è¡Œæƒé™, (windowsç³»ç»Ÿæ— æ•ˆ)
  --mode value    ä¸‹è½½æ¨¡å¼, å¯é€‰å€¼: pcs, stream, locate, é»˜è®¤ä¸º locate, ç›¸å…³è¯´æ˜è§ä¸Šé¢çš„å¸®åŠ© (default: "locate")
  -p value        æŒ‡å®šä¸‹è½½çº¿ç¨‹æ•° (default: 0)
  -l value        æŒ‡å®šåŒæ—¶è¿›è¡Œä¸‹è½½æ–‡ä»¶çš„æ•°é‡ (default: 0)
  --retry value   ä¸‹è½½å¤±è´¥æœ€å¤§é‡è¯•æ¬¡æ•° (default: 3)
  --nocheck       ä¸‹è½½æ–‡ä»¶å®Œæˆåä¸æ ¡éªŒæ–‡ä»¶

```

ä¸‹è½½çš„æ–‡ä»¶é»˜è®¤ä¿å­˜åˆ° **ç¨‹åºæ‰€åœ¨ç›®å½•** çš„ download/ ç›®å½•, æ”¯æŒè®¾ç½®æŒ‡å®šç›®å½•, é‡åçš„æ–‡ä»¶ä¼šè‡ªåŠ¨è·³è¿‡!

ä¸‹è½½çš„æ–‡ä»¶é»˜è®¤ä¿å­˜åˆ°, **ç¨‹åºæ‰€åœ¨ç›®å½•**çš„ **download/** ç›®å½•.

é€šè¿‡ `BaiduPCS-Go config set -savedir <savedir>`, è‡ªå®šä¹‰ä¿å­˜çš„ç›®å½•.

æ”¯æŒå¤šä¸ªæ–‡ä»¶æˆ–ç›®å½•ä¸‹è½½.
 
æ”¯æŒä¸‹è½½å®Œæˆåè‡ªåŠ¨æ ¡éªŒæ–‡ä»¶, ä½†å¹¶ä¸æ˜¯æ‰€æœ‰çš„æ–‡ä»¶éƒ½æ”¯æŒæ ¡éªŒ!
 
è‡ªåŠ¨è·³è¿‡ä¸‹è½½é‡åçš„æ–‡ä»¶!

[å…³äºä¸‹è½½çš„ç®€å•è¯´æ˜](https://github.com/iikira/BaiduPCS-Go/wiki/%E5%85%B3%E4%BA%8E%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E)

#### ä¸‹è½½æ¨¡å¼è¯´æ˜

* pcs: é€šè¿‡ç™¾åº¦ç½‘ç›˜çš„ PCS API ä¸‹è½½

* stream: é€šè¿‡ç™¾åº¦ç½‘ç›˜çš„ PCS API, ä»¥æµå¼æ–‡ä»¶çš„æ–¹å¼ä¸‹è½½, æ•ˆæœåŒ pcs

* locate: é»˜è®¤çš„ä¸‹è½½æ¨¡å¼ã€‚ä»ç™¾åº¦ç½‘ç›˜ Android å®¢æˆ·ç«¯, è·å–ä¸‹è½½é“¾æ¥çš„æ–¹å¼æ¥ä¸‹è½½

#### ä¾‹å­
```
# è®¾ç½®ä¿å­˜ç›®å½•, ä¿å­˜åˆ° D:\Downloads
# æ³¨æ„åŒºåˆ«åæ–œæ  "\" å’Œ æ–œæ  "/" !!!
BaiduPCS-Go config set -savedir D:/Downloads

# ä¸‹è½½ /æˆ‘çš„èµ„æº/1.mp4
BaiduPCS-Go d /æˆ‘çš„èµ„æº/1.mp4

# ä¸‹è½½ /æˆ‘çš„èµ„æº æ•´ä¸ªç›®å½•!!
BaiduPCS-Go d /æˆ‘çš„èµ„æº

# ä¸‹è½½ç½‘ç›˜å†…çš„å…¨éƒ¨æ–‡ä»¶!!
BaiduPCS-Go d /
BaiduPCS-Go d *
```

## ä¸Šä¼ æ–‡ä»¶/ç›®å½•
```
BaiduPCS-Go upload <æœ¬åœ°æ–‡ä»¶/ç›®å½•çš„è·¯å¾„1> <æ–‡ä»¶/ç›®å½•2> <æ–‡ä»¶/ç›®å½•3> ... <ç›®æ ‡ç›®å½•>
BaiduPCS-Go u <æœ¬åœ°æ–‡ä»¶/ç›®å½•çš„è·¯å¾„1> <æ–‡ä»¶/ç›®å½•2> <æ–‡ä»¶/ç›®å½•3> ... <ç›®æ ‡ç›®å½•>
```

* ä¸Šä¼ é»˜è®¤é‡‡ç”¨åˆ†ç‰‡ä¸Šä¼ çš„æ–¹å¼, ä¸Šä¼ çš„æ–‡ä»¶å°†ä¼šä¿å­˜åˆ°, <ç›®æ ‡ç›®å½•>.

* é‡åˆ°åŒåæ–‡ä»¶å°†ä¼šè‡ªåŠ¨è¦†ç›–!!

* å½“ä¸Šä¼ çš„æ–‡ä»¶åå’Œç½‘ç›˜çš„ç›®å½•åç§°ç›¸åŒæ—¶, ä¸ä¼šè¦†ç›–ç›®å½•, é˜²æ­¢ä¸¢å¤±æ•°æ®.


#### æ³¨æ„:

* åˆ†ç‰‡ä¸Šä¼ ä¹‹å, æœåŠ¡å™¨å¯èƒ½ä¼šè®°å½•åˆ°é”™è¯¯çš„æ–‡ä»¶md5, å¯ä½¿ç”¨ fixmd5 å‘½ä»¤å°è¯•ä¿®å¤æ–‡ä»¶çš„MD5å€¼, ä¿®å¤md5ä¸ä¸€å®šèƒ½æˆåŠŸ, ä½†æ–‡ä»¶çš„å®Œæ•´æ€§æ˜¯æ²¡é—®é¢˜çš„.

fixmd5 å‘½ä»¤ä½¿ç”¨æ–¹æ³•:
```
BaiduPCS-Go fixmd5 -h
```

* ç¦ç”¨åˆ†ç‰‡ä¸Šä¼ å¯ä»¥ä¿è¯æœåŠ¡å™¨è®°å½•åˆ°æ­£ç¡®çš„md5.

* ç¦ç”¨åˆ†ç‰‡ä¸Šä¼ æ—¶åªèƒ½ä½¿ç”¨å•çº¿ç¨‹ä¸Šä¼ , æŒ‡å®šçš„å•ä¸ªæ–‡ä»¶ä¸Šä¼ æœ€å¤§çº¿ç¨‹æ•°å°†ä¼šæ— æ•ˆ.

#### ä¾‹å­:
```
# å°†æœ¬åœ°çš„ C:\Users\Administrator\Desktop\1.mp4 ä¸Šä¼ åˆ°ç½‘ç›˜ /è§†é¢‘ ç›®å½•
# æ³¨æ„åŒºåˆ«åæ–œæ  "\" å’Œ æ–œæ  "/" !!!
BaiduPCS-Go upload C:/Users/Administrator/Desktop/1.mp4 /è§†é¢‘

# å°†æœ¬åœ°çš„ C:\Users\Administrator\Desktop\1.mp4 å’Œ C:\Users\Administrator\Desktop\2.mp4 ä¸Šä¼ åˆ°ç½‘ç›˜ /è§†é¢‘ ç›®å½•
BaiduPCS-Go upload C:/Users/Administrator/Desktop/1.mp4 C:/Users/Administrator/Desktop/2.mp4 /è§†é¢‘

# å°†æœ¬åœ°çš„ C:\Users\Administrator\Desktop æ•´ä¸ªç›®å½•ä¸Šä¼ åˆ°ç½‘ç›˜ /è§†é¢‘ ç›®å½•
BaiduPCS-Go upload C:/Users/Administrator/Desktop /è§†é¢‘
```

## è·å–ä¸‹è½½ç›´é“¾
```
BaiduPCS-Go locate <æ–‡ä»¶1> <æ–‡ä»¶2> ...
```

#### æ³¨æ„

è‹¥è¯¥åŠŸèƒ½æ— æ³•æ­£å¸¸ä½¿ç”¨, æç¤º`user is not authorized, hitcode:xxx`, å°è¯•æ›´æ¢ User-Agent ä¸º `netdisk;2.2.51.6;netdisk;10.0.63;PC;android-android`:
```
BaiduPCS-Go config set -user_agent "netdisk;2.2.51.6;netdisk;10.0.63;PC;android-android"
```

## æ‰‹åŠ¨ç§’ä¼ æ–‡ä»¶
```
BaiduPCS-Go rapidupload -length=<æ–‡ä»¶çš„å¤§å°> -md5=<æ–‡ä»¶çš„md5å€¼> -slicemd5=<æ–‡ä»¶å‰256KBåˆ‡ç‰‡çš„md5å€¼(å¯é€‰)> -crc32=<æ–‡ä»¶çš„crc32å€¼(å¯é€‰)> <ä¿å­˜çš„ç½‘ç›˜è·¯å¾„, éœ€åŒ…å«æ–‡ä»¶å>
BaiduPCS-Go ru -length=<æ–‡ä»¶çš„å¤§å°> -md5=<æ–‡ä»¶çš„md5å€¼> -slicemd5=<æ–‡ä»¶å‰256KBåˆ‡ç‰‡çš„md5å€¼(å¯é€‰)> -crc32=<æ–‡ä»¶çš„crc32å€¼(å¯é€‰)> <ä¿å­˜çš„ç½‘ç›˜è·¯å¾„, éœ€åŒ…å«æ–‡ä»¶å>
```

æ³¨æ„: ä½¿ç”¨æ­¤åŠŸèƒ½ç§’ä¼ æ–‡ä»¶, å‰ææ˜¯çŸ¥é“æ–‡ä»¶çš„å¤§å°, md5, å‰256KBåˆ‡ç‰‡çš„ md5 (å¯é€‰), crc32 (å¯é€‰), ä¸”ç™¾åº¦ç½‘ç›˜ä¸­å­˜åœ¨ä¸€æ¨¡ä¸€æ ·çš„æ–‡ä»¶.

ä¸Šä¼ çš„æ–‡ä»¶å°†ä¼šä¿å­˜åˆ°ç½‘ç›˜çš„ç›®æ ‡ç›®å½•.

é‡åˆ°åŒåæ–‡ä»¶å°†ä¼šè‡ªåŠ¨è¦†ç›–! 

å¯èƒ½æ— æ³•ç§’ä¼  20GB ä»¥ä¸Šçš„æ–‡ä»¶!!

#### ä¾‹å­:
```
# å¦‚æœç§’ä¼ æˆåŠŸ, åˆ™ä¿å­˜åˆ°ç½‘ç›˜è·¯å¾„ /test
BaiduPCS-Go rapidupload -length=56276137 -md5=fbe082d80e90f90f0fb1f94adbbcfa7f -slicemd5=38c6a75b0ec4499271d4ea38a667ab61 -crc32=314332359 /test
```


## ä¿®å¤æ–‡ä»¶MD5
```
BaiduPCS-Go fixmd5 <æ–‡ä»¶1> <æ–‡ä»¶2> <æ–‡ä»¶3> ...
```

å°è¯•ä¿®å¤æ–‡ä»¶çš„MD5å€¼, ä»¥ä¾¿äºæ ¡éªŒæ–‡ä»¶çš„å®Œæ•´æ€§å’Œå¯¼å‡ºæ–‡ä»¶.

ä½¿ç”¨åˆ†ç‰‡ä¸Šä¼ æ–‡ä»¶, å½“æ–‡ä»¶åˆ†ç‰‡æ•°å¤§äº1æ—¶, ç™¾åº¦ç½‘ç›˜æœåŠ¡ç«¯æœ€ç»ˆè®¡ç®—æ‰€å¾—çš„md5å€¼å’Œæœ¬åœ°çš„ä¸ä¸€è‡´, è¿™å¯èƒ½æ˜¯ç™¾åº¦ç½‘ç›˜çš„bug.

ä¸è¿‡æŠŠä¸Šä¼ çš„æ–‡ä»¶ä¸‹è½½åˆ°æœ¬åœ°åï¼Œå¯¹æ¯”md5å€¼æ˜¯åŒ¹é…çš„, ä¹Ÿå°±æ˜¯æ–‡ä»¶åœ¨ä¼ è¾“ä¸­æ²¡æœ‰å‘ç”ŸæŸå.

å¯¹äºMD5å€¼å¯èƒ½æœ‰è¯¯çš„æ–‡ä»¶, ç¨‹åºä¼šåœ¨è·å–æ–‡ä»¶çš„å…ƒä¿¡æ¯æ—¶, ç»™å‡ºMD5å€¼ "å¯èƒ½ä¸æ­£ç¡®" çš„æç¤º, è¡¨ç¤ºæ­¤æ–‡ä»¶å¯ä»¥å°è¯•è¿›è¡ŒMD5å€¼ä¿®å¤.

ä¿®å¤æ–‡ä»¶MD5ä¸ä¸€å®šèƒ½æˆåŠŸ, åŸå› å¯èƒ½æ˜¯æœåŠ¡å™¨æœªåˆ·æ–°, å¯è¿‡å‡ å¤©åå†å°è¯•.

ä¿®å¤æ–‡ä»¶MD5çš„åŸç†ä¸ºç§’ä¼ æ–‡ä»¶, å³ä¿®å¤æ–‡ä»¶MD5æˆåŠŸå, æ–‡ä»¶çš„**åˆ›å»ºæ—¥æœŸ, ä¿®æ”¹æ—¥æœŸ, fs_id, ç‰ˆæœ¬å†å²ç­‰ä¿¡æ¯**å°†ä¼šè¢«è¦†ç›–, ä¿®å¤çš„MD5å€¼å°†è¦†ç›–åŸå…ˆçš„MD5å€¼, ä½†ä¸å½±å“æ–‡ä»¶çš„å®Œæ•´æ€§.

æ³¨æ„: æ— æ³•ä¿®å¤ **20GB** ä»¥ä¸Šæ–‡ä»¶çš„ md5!!

#### ä¾‹å­:
```
# ä¿®å¤ /æˆ‘çš„èµ„æº/1.mp4 çš„ MD5 å€¼
BaiduPCS-Go fixmd5 /æˆ‘çš„èµ„æº/1.mp4
```

## è·å–æœ¬åœ°æ–‡ä»¶çš„ç§’ä¼ ä¿¡æ¯
```
BaiduPCS-Go sumfile <æœ¬åœ°æ–‡ä»¶çš„è·¯å¾„>
BaiduPCS-Go sf <æœ¬åœ°æ–‡ä»¶çš„è·¯å¾„>
```

è·å–æœ¬åœ°æ–‡ä»¶çš„å¤§å°, md5, å‰256KBåˆ‡ç‰‡çš„ md5, crc32, å¯ç”¨äºç§’ä¼ æ–‡ä»¶.

#### ä¾‹å­:
```
# è·å– C:\Users\Administrator\Desktop\1.mp4 çš„ç§’ä¼ ä¿¡æ¯
BaiduPCS-Go sumfile C:/Users/Administrator/Desktop/1.mp4
```

## å¯¼å‡ºæ–‡ä»¶/ç›®å½•
```
BaiduPCS-Go export <æ–‡ä»¶/ç›®å½•1> <æ–‡ä»¶/ç›®å½•2> ...
BaiduPCS-Go ep <æ–‡ä»¶/ç›®å½•1> <æ–‡ä»¶/ç›®å½•2> ...
```

å¯¼å‡ºç½‘ç›˜å†…çš„æ–‡ä»¶æˆ–ç›®å½•, åŸç†ä¸ºç§’ä¼ æ–‡ä»¶, æ­¤æ“ä½œä¼šç”Ÿæˆå¯¼å‡ºæ–‡ä»¶æˆ–ç›®å½•çš„å‘½ä»¤.

#### æ³¨æ„

**æ— æ³•å¯¼å‡º 20GB ä»¥ä¸Šçš„æ–‡ä»¶!!**

**æ— æ³•å¯¼å‡ºæ–‡ä»¶çš„ç‰ˆæœ¬å†å²ç­‰æ•°æ®!!**

å¹¶ä¸æ˜¯æ‰€æœ‰çš„æ–‡ä»¶éƒ½èƒ½å¯¼å‡ºæˆåŠŸ, ç¨‹åºä¼šåˆ—å‡ºæ— æ³•å¯¼å‡ºçš„æ–‡ä»¶åˆ—è¡¨

#### ä¾‹å­:
```
# å¯¼å‡ºå½“å‰å·¥ä½œç›®å½•:
BaiduPCS-Go export

# å¯¼å‡ºæ‰€æœ‰æ–‡ä»¶å’Œç›®å½•, å¹¶è®¾ç½®æ–°çš„æ ¹ç›®å½•ä¸º /root
BaiduPCS-Go export -root=/root /

# å¯¼å‡º /æˆ‘çš„èµ„æº
BaiduPCS-Go export /æˆ‘çš„èµ„æº
```

## åˆ›å»ºç›®å½•
```
BaiduPCS-Go mkdir <ç›®å½•>
```

#### ä¾‹å­
```
BaiduPCS-Go mkdir 123
```

## åˆ é™¤æ–‡ä»¶/ç›®å½•
```
BaiduPCS-Go rm <ç½‘ç›˜æ–‡ä»¶æˆ–ç›®å½•çš„è·¯å¾„1> <æ–‡ä»¶æˆ–ç›®å½•2> <æ–‡ä»¶æˆ–ç›®å½•3> ...
```

æ³¨æ„: åˆ é™¤å¤šä¸ªæ–‡ä»¶å’Œç›®å½•æ—¶, è¯·ç¡®ä¿æ¯ä¸€ä¸ªæ–‡ä»¶å’Œç›®å½•éƒ½å­˜åœ¨, å¦åˆ™åˆ é™¤æ“ä½œä¼šå¤±è´¥.

è¢«åˆ é™¤çš„æ–‡ä»¶æˆ–ç›®å½•å¯åœ¨ç½‘ç›˜æ–‡ä»¶å›æ”¶ç«™æ‰¾å›.

#### ä¾‹å­
```
# åˆ é™¤ /æˆ‘çš„èµ„æº/1.mp4
BaiduPCS-Go rm /æˆ‘çš„èµ„æº/1.mp4

# åˆ é™¤ /æˆ‘çš„èµ„æº/1.mp4 å’Œ /æˆ‘çš„èµ„æº/2.mp4
BaiduPCS-Go rm /æˆ‘çš„èµ„æº/1.mp4 /æˆ‘çš„èµ„æº/2.mp4

# åˆ é™¤ /æˆ‘çš„èµ„æº å†…çš„æ‰€æœ‰æ–‡ä»¶å’Œç›®å½•, ä½†ä¸åˆ é™¤è¯¥ç›®å½•
BaiduPCS-Go rm /æˆ‘çš„èµ„æº/*

# åˆ é™¤ /æˆ‘çš„èµ„æº æ•´ä¸ªç›®å½• !!
BaiduPCS-Go rm /æˆ‘çš„èµ„æº
```

## æ‹·è´æ–‡ä»¶/ç›®å½•
```
BaiduPCS-Go cp <æ–‡ä»¶/ç›®å½•> <ç›®æ ‡ æ–‡ä»¶/ç›®å½•>
BaiduPCS-Go cp <æ–‡ä»¶/ç›®å½•1> <æ–‡ä»¶/ç›®å½•2> <æ–‡ä»¶/ç›®å½•3> ... <ç›®æ ‡ç›®å½•>
```

æ³¨æ„: æ‹·è´å¤šä¸ªæ–‡ä»¶å’Œç›®å½•æ—¶, è¯·ç¡®ä¿æ¯ä¸€ä¸ªæ–‡ä»¶å’Œç›®å½•éƒ½å­˜åœ¨, å¦åˆ™æ‹·è´æ“ä½œä¼šå¤±è´¥.

#### ä¾‹å­
```
# å°† /æˆ‘çš„èµ„æº/1.mp4 å¤åˆ¶åˆ° æ ¹ç›®å½• /
BaiduPCS-Go cp /æˆ‘çš„èµ„æº/1.mp4 /

# å°† /æˆ‘çš„èµ„æº/1.mp4 å’Œ /æˆ‘çš„èµ„æº/2.mp4 å¤åˆ¶åˆ° æ ¹ç›®å½• /
BaiduPCS-Go cp /æˆ‘çš„èµ„æº/1.mp4 /æˆ‘çš„èµ„æº/2.mp4 /
```

## ç§»åŠ¨/é‡å‘½åæ–‡ä»¶/ç›®å½•
```
# ç§»åŠ¨:
BaiduPCS-Go mv <æ–‡ä»¶/ç›®å½•1> <æ–‡ä»¶/ç›®å½•2> <æ–‡ä»¶/ç›®å½•3> ... <ç›®æ ‡ç›®å½•>
# é‡å‘½å:
BaiduPCS-Go mv <æ–‡ä»¶/ç›®å½•> <é‡å‘½åçš„æ–‡ä»¶/ç›®å½•>
```

æ³¨æ„: ç§»åŠ¨å¤šä¸ªæ–‡ä»¶å’Œç›®å½•æ—¶, è¯·ç¡®ä¿æ¯ä¸€ä¸ªæ–‡ä»¶å’Œç›®å½•éƒ½å­˜åœ¨, å¦åˆ™ç§»åŠ¨æ“ä½œä¼šå¤±è´¥.

#### ä¾‹å­
```
# å°† /æˆ‘çš„èµ„æº/1.mp4 ç§»åŠ¨åˆ° æ ¹ç›®å½• /
BaiduPCS-Go mv /æˆ‘çš„èµ„æº/1.mp4 /

# å°† /æˆ‘çš„èµ„æº/1.mp4 é‡å‘½åä¸º /æˆ‘çš„èµ„æº/3.mp4
BaiduPCS-Go mv /æˆ‘çš„èµ„æº/1.mp4 /æˆ‘çš„èµ„æº/3.mp4
```

## åˆ†äº«æ–‡ä»¶/ç›®å½•
```
BaiduPCS-Go share
```

### è®¾ç½®åˆ†äº«æ–‡ä»¶/ç›®å½•
```
BaiduPCS-Go share set <æ–‡ä»¶/ç›®å½•1> <æ–‡ä»¶/ç›®å½•2> ...
BaiduPCS-Go share s <æ–‡ä»¶/ç›®å½•1> <æ–‡ä»¶/ç›®å½•2> ...
```

### åˆ—å‡ºå·²åˆ†äº«æ–‡ä»¶/ç›®å½•
```
BaiduPCS-Go share list
BaiduPCS-Go share l
```

### å–æ¶ˆåˆ†äº«æ–‡ä»¶/ç›®å½•
```
BaiduPCS-Go share cancel <shareid_1> <shareid_2> ...
BaiduPCS-Go share c <shareid_1> <shareid_2> ...
```

ç›®å‰åªæ”¯æŒé€šè¿‡åˆ†äº«id (shareid) æ¥å–æ¶ˆåˆ†äº«.

## ç¦»çº¿ä¸‹è½½
```
BaiduPCS-Go offlinedl
BaiduPCS-Go clouddl
BaiduPCS-Go od
```

ç¦»çº¿ä¸‹è½½æ”¯æŒhttp/https/ftp/ç”µé©´/ç£åŠ›é“¾åè®®

ç¦»çº¿ä¸‹è½½åŒæ—¶è¿›è¡Œçš„ä»»åŠ¡æ•°é‡æœ‰é™, è¶…å‡ºé™åˆ¶çš„éƒ¨åˆ†å°†æ— æ³•æ·»åŠ .

### æ·»åŠ ç¦»çº¿ä¸‹è½½ä»»åŠ¡
```
BaiduPCS-Go offlinedl add -path=<ç¦»çº¿ä¸‹è½½æ–‡ä»¶ä¿å­˜çš„è·¯å¾„> èµ„æºåœ°å€1 åœ°å€2 ...
```

æ·»åŠ ä»»åŠ¡æˆåŠŸä¹‹å, è¿”å›ç¦»çº¿ä¸‹è½½çš„ä»»åŠ¡ID.

### ç²¾ç¡®æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡
```
BaiduPCS-Go offlinedl query ä»»åŠ¡ID1 ä»»åŠ¡ID2 ...
```

### æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡åˆ—è¡¨
```
BaiduPCS-Go offlinedl list
```

### å–æ¶ˆç¦»çº¿ä¸‹è½½ä»»åŠ¡
```
BaiduPCS-Go offlinedl cancel ä»»åŠ¡ID1 ä»»åŠ¡ID2 ...
```

### åˆ é™¤ç¦»çº¿ä¸‹è½½ä»»åŠ¡
```
BaiduPCS-Go offlinedl delete ä»»åŠ¡ID1 ä»»åŠ¡ID2 ...

# æ¸…ç©ºç¦»çº¿ä¸‹è½½ä»»åŠ¡è®°å½•, ç¨‹åºä¸ä¼šè¿›è¡ŒäºŒæ¬¡ç¡®è®¤, è°¨æ…æ“ä½œ!!!
BaiduPCS-Go offlinedl delete -all
```

#### ä¾‹å­
```
# å°†ç™¾åº¦å’Œè…¾è®¯ä¸»é¡µ, ç¦»çº¿ä¸‹è½½åˆ°æ ¹ç›®å½• /
BaiduPCS-Go offlinedl add -path=/ http://baidu.com http://qq.com

# æ·»åŠ ç£åŠ›é“¾æ¥ä»»åŠ¡
BaiduPCS-Go offlinedl add magnet:?xt=urn:btih:xxx

# æŸ¥è¯¢ä»»åŠ¡IDä¸º 12345 çš„ç¦»çº¿ä¸‹è½½ä»»åŠ¡çŠ¶æ€
BaiduPCS-Go offlinedl query 12345

# å–æ¶ˆä»»åŠ¡IDä¸º 12345 çš„ç¦»çº¿ä¸‹è½½ä»»åŠ¡
BaiduPCS-Go offlinedl cancel 12345
```

## å›æ”¶ç«™
```
BaiduPCS-Go recycle
```

å›æ”¶ç«™æ“ä½œ.

### åˆ—å‡ºå›æ”¶ç«™æ–‡ä»¶åˆ—è¡¨
```
BaiduPCS-Go recycle list
```

#### å¯é€‰å‚æ•°
```
  --page value  å›æ”¶ç«™æ–‡ä»¶åˆ—è¡¨é¡µæ•° (default: 1)
```

### è¿˜åŸå›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•
```
BaiduPCS-Go recycle restore <fs_id 1> <fs_id 2> <fs_id 3> ...
```

æ ¹æ®æ–‡ä»¶/ç›®å½•çš„ fs_id, è¿˜åŸå›æ”¶ç«™æŒ‡å®šçš„æ–‡ä»¶æˆ–ç›®å½•.

### åˆ é™¤å›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•/æ¸…ç©ºå›æ”¶ç«™
```
BaiduPCS-Go recycle delete [-all] <fs_id 1> <fs_id 2> <fs_id 3> ...
```

æ ¹æ®æ–‡ä»¶/ç›®å½•çš„ fs_id æˆ– -all å‚æ•°, åˆ é™¤å›æ”¶ç«™æŒ‡å®šçš„æ–‡ä»¶æˆ–ç›®å½•æˆ–æ¸…ç©ºå›æ”¶ç«™.

#### ä¾‹å­
```
# ä»å›æ”¶ç«™è¿˜åŸä¸¤ä¸ªæ–‡ä»¶, å…¶ä¸­çš„ä¸¤ä¸ªæ–‡ä»¶çš„ fs_id åˆ†åˆ«ä¸º 1013792297798440 å’Œ 643596340463870
BaiduPCS-Go recycle restore 1013792297798440 643596340463870

# ä»å›æ”¶ç«™åˆ é™¤ä¸¤ä¸ªæ–‡ä»¶, å…¶ä¸­çš„ä¸¤ä¸ªæ–‡ä»¶çš„ fs_id åˆ†åˆ«ä¸º 1013792297798440 å’Œ 643596340463870
BaiduPCS-Go recycle delete 1013792297798440 643596340463870

# æ¸…ç©ºå›æ”¶ç«™, ç¨‹åºä¸ä¼šè¿›è¡ŒäºŒæ¬¡ç¡®è®¤, è°¨æ…æ“ä½œ!!!
BaiduPCS-Go recycle delete -all
```

## æ˜¾ç¤ºç¨‹åºç¯å¢ƒå˜é‡
```
BaiduPCS-Go env
```

BAIDUPCS_GO_CONFIG_DIR: é…ç½®æ–‡ä»¶è·¯å¾„,

BAIDUPCS_GO_VERBOSE: æ˜¯å¦å¯ç”¨è°ƒè¯•.

## æ˜¾ç¤ºå’Œä¿®æ”¹ç¨‹åºé…ç½®é¡¹
```
# æ˜¾ç¤ºé…ç½®
BaiduPCS-Go config

# è®¾ç½®é…ç½®
BaiduPCS-Go config set
```

æ³¨æ„: v3.5 ä»¥å, ç¨‹åºå¯¹é…ç½®æ–‡ä»¶å‚¨å­˜è·¯å¾„çš„å¯»æ‰¾åšäº†è°ƒæ•´, é…ç½®æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•å¯ä»¥æ˜¯ç¨‹åºæœ¬èº«æ‰€åœ¨ç›®å½•, ä¹Ÿå¯ä»¥æ˜¯å®¶ç›®å½•.

é…ç½®æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•ä¸ºå®¶ç›®å½•çš„æƒ…å†µ:

Windows: `%APPDATA%\BaiduPCS-Go`

å…¶ä»–æ“ä½œç³»ç»Ÿ: `$HOME/.config/BaiduPCS-Go`

å¯é€šè¿‡è®¾ç½®ç¯å¢ƒå˜é‡ `BAIDUPCS_GO_CONFIG_DIR`, æŒ‡å®šé…ç½®æ–‡ä»¶å­˜æ”¾çš„ç›®å½•.

è°¨æ…ä¿®æ”¹ `appid`, `user_agent`, `pcs_ua`, `pan_ua` çš„å€¼, å¦åˆ™è®¿é—®ç½‘ç›˜æœåŠ¡å™¨æ—¶, å¯èƒ½ä¼šå‡ºç°é”™è¯¯.

`cache_size` çš„å€¼æ”¯æŒå¯é€‰è®¾ç½®å•ä½äº†, å•ä½ä¸åŒºåˆ†å¤§å°å†™, `b` å’Œ `B` å‡è¡¨ç¤ºå­—èŠ‚çš„æ„æ€, å¦‚ `64KB`, `1MB`, `32kb`, `65536b`, `65536`.

`max_upload_parallel`, `max_download_load` çš„å€¼æ”¯æŒå¯é€‰è®¾ç½®å•ä½äº†, å•ä½ä¸ºæ¯ç§’çš„ä¼ è¾“é€Ÿç‡, åç¼€`/s` å¯çœç•¥, å¦‚ `2MB/s`, `2MB`, `2m`, `2mb` å‡ä¸ºä¸€ä¸ªæ„æ€.

#### ä¾‹å­
```
# æ˜¾ç¤ºæ‰€æœ‰å¯ä»¥è®¾ç½®çš„å€¼
BaiduPCS-Go config -h
BaiduPCS-Go config set -h

# è®¾ç½®ä¸‹è½½æ–‡ä»¶çš„å‚¨å­˜ç›®å½•
BaiduPCS-Go config set -savedir D:/Downloads

# è®¾ç½®ä¸‹è½½æœ€å¤§å¹¶å‘é‡ä¸º 150
BaiduPCS-Go config set -max_parallel 150

# ç»„åˆè®¾ç½®
BaiduPCS-Go config set -max_parallel 150 -savedir D:/Downloads
```

## æµ‹è¯•é€šé…ç¬¦
```
BaiduPCS-Go match <é€šé…ç¬¦è¡¨è¾¾å¼>
```

æµ‹è¯•é€šé…ç¬¦åŒ¹é…è·¯å¾„, æ“ä½œæˆåŠŸåˆ™è¾“å‡ºæ‰€æœ‰åŒ¹é…åˆ°çš„è·¯å¾„.

#### ä¾‹å­
```
# åŒ¹é… /æˆ‘çš„èµ„æº ç›®å½•ä¸‹æ‰€æœ‰mp4æ ¼å¼çš„æ–‡ä»¶
BaiduPCS-Go match /æˆ‘çš„èµ„æº/*.mp4
```

## å·¥å…·ç®±
```
BaiduPCS-Go tool
```

ç›®å‰å·¥å…·ç®±æ”¯æŒåŠ è§£å¯†æ–‡ä»¶ç­‰.

# åˆçº§ä½¿ç”¨æ•™ç¨‹

æ–°æ‰‹å»ºè®®: **åŒå‡»è¿è¡Œç¨‹åº**, è¿›å…¥ä»¿ Linux shell çš„ cli äº¤äº’æ¨¡å¼;

cliäº¤äº’æ¨¡å¼ä¸‹, å…‰æ ‡æ‰€åœ¨è¡Œçš„å‰ç¼€åº”ä¸º `BaiduPCS-Go >`, å¦‚æœç™»å½•äº†ç™¾åº¦å¸å·åˆ™æ ¼å¼ä¸º `BaiduPCS-Go:<å·¥ä½œç›®å½•> <ç™¾åº¦ID>$ `

ä»¥ä¸‹ä¾‹å­çš„å‘½ä»¤, å‡ä¸º cliäº¤äº’æ¨¡å¼ä¸‹çš„å‘½ä»¤

è¿è¡Œå‘½ä»¤çš„æ­£ç¡®æ“ä½œ: **è¾“å…¥å‘½ä»¤, æŒ‰ä¸€ä¸‹å›è½¦é”® (é”®ç›˜ä¸Šçš„ Enter é”®)**, ç¨‹åºä¼šæ¥æ”¶åˆ°å‘½ä»¤å¹¶è¾“å‡ºç»“æœ

## 1. æŸ¥çœ‹ç¨‹åºä½¿ç”¨è¯´æ˜

cliäº¤äº’æ¨¡å¼ä¸‹, è¿è¡Œå‘½ä»¤ `help`

## 2. ç™»å½•ç™¾åº¦å¸å· (å¿…åš)

cliäº¤äº’æ¨¡å¼ä¸‹, è¿è¡Œå‘½ä»¤ `login -h` (æ³¨æ„ç©ºæ ¼) æŸ¥çœ‹å¸®åŠ©

cliäº¤äº’æ¨¡å¼ä¸‹, è¿è¡Œå‘½ä»¤ `login` ç¨‹åºå°†ä¼šæç¤ºä½ è¾“å…¥ç™¾åº¦ç”¨æˆ·å(æ‰‹æœºå·/é‚®ç®±/ç”¨æˆ·å)å’Œå¯†ç , å¿…è¦æ—¶è¿˜å¯ä»¥åœ¨çº¿éªŒè¯ç»‘å®šçš„æ‰‹æœºå·æˆ–é‚®ç®±

## 3. åˆ‡æ¢ç½‘ç›˜å·¥ä½œç›®å½•

cliäº¤äº’æ¨¡å¼ä¸‹, è¿è¡Œå‘½ä»¤ `cd /æˆ‘çš„èµ„æº` å°†å·¥ä½œç›®å½•åˆ‡æ¢ä¸º `/æˆ‘çš„èµ„æº` (å‰æ: è¯¥ç›®å½•å­˜åœ¨äºç½‘ç›˜)

ç›®å½•æ”¯æŒé€šé…ç¬¦åŒ¹é…, æ‰€ä»¥ä½ ä¹Ÿå¯ä»¥è¿™æ ·: è¿è¡Œå‘½ä»¤ `cd /æˆ‘çš„*` æˆ– `cd /æˆ‘çš„??` å°†å·¥ä½œç›®å½•åˆ‡æ¢ä¸º `/æˆ‘çš„èµ„æº`, ç®€åŒ–è¾“å…¥.

å°†å·¥ä½œç›®å½•åˆ‡æ¢ä¸º `/æˆ‘çš„èµ„æº` æˆåŠŸå, è¿è¡Œå‘½ä»¤ `cd ..` åˆ‡æ¢ä¸Šçº§ç›®å½•, å³å°†å·¥ä½œç›®å½•åˆ‡æ¢ä¸º `/`

ä¸ºä»€ä¹ˆè¦è¿™æ ·è®¾è®¡å‘¢, ä¸¾ä¸ªä¾‹å­,

å‡è®¾ ä½ è¦ä¸‹è½½ `/æˆ‘çš„èµ„æº` å†…åä¸º `1.mp4` å’Œ `2.mp4` ä¸¤ä¸ªæ–‡ä»¶, è€Œæœªåˆ‡æ¢å·¥ä½œç›®å½•, ä½ éœ€è¦ä¾æ¬¡è¿è¡Œä»¥ä¸‹å‘½ä»¤:

```
d /æˆ‘çš„èµ„æº/1.mp4
d /æˆ‘çš„èµ„æº/2.mp4
```

è€Œåˆ‡æ¢ç½‘ç›˜å·¥ä½œç›®å½•ä¹‹å, ä¾æ¬¡è¿è¡Œä»¥ä¸‹å‘½ä»¤:

```
cd /æˆ‘çš„èµ„æº
d 1.mp4
d 2.mp4
```

è¿™æ ·å°±è¾¾åˆ°äº†ç®€åŒ–è¾“å…¥çš„ç›®çš„

## 4. ç½‘ç›˜å†…åˆ—å‡ºæ–‡ä»¶å’Œç›®å½•

cliäº¤äº’æ¨¡å¼ä¸‹, è¿è¡Œå‘½ä»¤ `ls -h` (æ³¨æ„ç©ºæ ¼) æŸ¥çœ‹å¸®åŠ©

cliäº¤äº’æ¨¡å¼ä¸‹, è¿è¡Œå‘½ä»¤ `ls` æ¥åˆ—å‡ºå½“å‰æ‰€åœ¨ç›®å½•çš„æ–‡ä»¶å’Œç›®å½•

cliäº¤äº’æ¨¡å¼ä¸‹, è¿è¡Œå‘½ä»¤ `ls /æˆ‘çš„èµ„æº` æ¥åˆ—å‡º `/æˆ‘çš„èµ„æº` å†…çš„æ–‡ä»¶å’Œç›®å½•

cliäº¤äº’æ¨¡å¼ä¸‹, è¿è¡Œå‘½ä»¤ `ls ..` æ¥åˆ—å‡ºå½“å‰æ‰€åœ¨ç›®å½•çš„ä¸Šçº§ç›®å½•çš„æ–‡ä»¶å’Œç›®å½•

## 5. ä¸‹è½½æ–‡ä»¶

è¯´æ˜: ä¸‹è½½çš„æ–‡ä»¶é»˜è®¤ä¿å­˜åˆ° download/ ç›®å½• (æ–‡ä»¶å¤¹)

cliäº¤äº’æ¨¡å¼ä¸‹, è¿è¡Œå‘½ä»¤ `d -h` (æ³¨æ„ç©ºæ ¼) æŸ¥çœ‹å¸®åŠ©

cliäº¤äº’æ¨¡å¼ä¸‹, è¿è¡Œå‘½ä»¤ `d /æˆ‘çš„èµ„æº/1.mp4` æ¥ä¸‹è½½ä½äº `/æˆ‘çš„èµ„æº/1.mp4` çš„æ–‡ä»¶ `1.mp4` , è¯¥æ“ä½œç­‰æ•ˆäºè¿è¡Œä»¥ä¸‹å‘½ä»¤:

```
cd /æˆ‘çš„èµ„æº
d 1.mp4
```

ç°åœ¨å·²ç»æ”¯æŒç›®å½• (æ–‡ä»¶å¤¹) ä¸‹è½½, æ‰€ä»¥, è¿è¡Œä»¥ä¸‹å‘½ä»¤, ä¼šä¸‹è½½ `/æˆ‘çš„èµ„æº` å†…çš„æ‰€æœ‰æ–‡ä»¶ (è¿è§„æ–‡ä»¶é™¤å¤–):

```
d /æˆ‘çš„èµ„æº
```

## 6. è®¾ç½®ä¸‹è½½æœ€å¤§å¹¶å‘é‡

cliäº¤äº’æ¨¡å¼ä¸‹, è¿è¡Œå‘½ä»¤ `config set -h` (æ³¨æ„ç©ºæ ¼) æŸ¥çœ‹è®¾ç½®å¸®åŠ©ä»¥åŠå¯ä¾›è®¾ç½®çš„å€¼

cliäº¤äº’æ¨¡å¼ä¸‹, è¿è¡Œå‘½ä»¤ `config set -max_parallel 2` å°†ä¸‹è½½æœ€å¤§å¹¶å‘é‡è®¾ç½®ä¸º 2

æ³¨æ„ï¼šä¸‹è½½æœ€å¤§å¹¶å‘é‡çš„å€¼ä¸æ˜“è®¾ç½®è¿‡é«˜, å¯èƒ½ä¼šå¯¼è‡´ç™¾åº¦å¸å·è¢«é™åˆ¶ä¸‹è½½

## 7. é€€å‡ºç¨‹åº

è¿è¡Œå‘½ä»¤ `quit` æˆ– `exit` æˆ– ç»„åˆé”® `Ctrl+C` æˆ– ç»„åˆé”® `Ctrl+D`

# å·²çŸ¥é—®é¢˜

* åˆ†ç‰‡ä¸Šä¼ æ–‡ä»¶æ—¶, å½“æ–‡ä»¶åˆ†ç‰‡æ•°å¤§äº1, ç½‘ç›˜ç«¯æœ€ç»ˆè®¡ç®—æ‰€å¾—çš„md5å€¼å’Œæœ¬åœ°çš„ä¸ä¸€è‡´, è¿™å¯èƒ½æ˜¯ç™¾åº¦ç½‘ç›˜çš„bug, æµ‹è¯•æŠŠä¸Šä¼ çš„æ–‡ä»¶ä¸‹è½½åˆ°æœ¬åœ°åï¼Œå¯¹æ¯”md5å€¼æ˜¯åŒ¹é…çš„. å¯é€šè¿‡ç§’ä¼ çš„åŸç†æ¥ä¿®å¤md5å€¼.

# å¸¸è§é—®é¢˜

å‚è§ [å¸¸è§é—®é¢˜](https://github.com/iikira/BaiduPCS-Go/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98)

# TODO


# ç›¸å…³æ–‡æ¡£
è¯¦è§: https://github.com/iikira/BaiduPCS-Go/tree/master/docs

# äº¤æµåé¦ˆ

æäº¤Issue: [Issues](https://github.com/iikira/BaiduPCS-Go/issues)

é‚®ç®±: i@mail.iikira.com

QQç¾¤: 178324706



================================================
FILE: BaiduPCS-Go.exe.manifest
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
	<assemblyIdentity version="1.0.0.0" processorArchitecture="*" name="com.iikira.baidupcsgo" type="win32"/>
	<dependency>
		<dependentAssembly>
			<assemblyIdentity type="win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*"/>
		</dependentAssembly>
	</dependency>
	<asmv3:application>
		<asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
			<dpiAware>true</dpiAware>
		</asmv3:windowsSettings>
	</asmv3:application>
</assembly>


================================================
FILE: build.sh
================================================
#!/bin/sh

name="BaiduPCS-Go"
version=$1

if [ "$1" = "" ]; then
  version=v3.6.2
fi

output="out/"

GOROOT=/usr

old_golang() {
  #GOROOT=/usr/local/go1.10.8
  go=$GOROOT/bin/go
}

new_golang() {
  #GOROOT=/usr/local/go
  go=$GOROOT/bin/go
}

Build() {
  old_golang
  goarm=$4
  if [ "$4" = "" ]; then
    goarm=7
  fi

  echo "Building $1..."
  export GOOS=$2 GOARCH=$3 GO386=sse2 CGO_ENABLED=0 GOARM=$4
  if [ $2 = "windows" ]; then
    goversioninfo -o=resource_windows_386.syso
    goversioninfo -64 -o=resource_windows_amd64.syso
    $go build -ldflags "-X main.Version=$version -s -w" -o "$output/$1/$name.exe"
    RicePack $1 $name.exe
  else
    $go build -ldflags "-X main.Version=$version -s -w" -o "$output/$1/$name"
    RicePack $1 $name
  fi

  Pack $1
}

AndroidBuild() {
  new_golang
  echo "Building $1..."
  export GOOS=$2 GOARCH=$3 GOARM=$4 CGO_ENABLED=1
  go build -ldflags "-X main.Version=$version -s -w -linkmode=external -extldflags=-pie" -o "$output/$1/$name"

  RicePack $1 $name
  Pack $1
}

IOSBuild() {
  old_golang
  echo "Building $1..."
  mkdir -p "$output/$1"
  cd "$output/$1"
  export CC=/usr/local/go/misc/ios/clangwrap.sh GOOS=darwin GOARCH=arm GOARM=7 CGO_ENABLED=1
  $go build -ldflags "-X main.Version=$version -s -w" -o "armv7" github.com/felixonmars/BaiduPCS-Go
  jtool --sign --inplace --ent ../../entitlements.xml "armv7"
  export GOARCH=arm64
  $go build -ldflags "-X main.Version=$version -s -w" -o "arm64" github.com/felixonmars/BaiduPCS-Go
  jtool --sign --inplace --ent ../../entitlements.xml "arm64"
  lipo -create "armv7" "arm64" -output $name # merge
  rm "armv7" "arm64"
  cd ../..
  RicePack $1 $name
  Pack $1
}

# zip æ‰“åŒ…
Pack() {
  cp README.md "$output/$1"

  cd $output
  zip -q -r "$1.zip" "$1"

  # åˆ é™¤
  rm -rf "$1"

  cd ..
}

# rice æ‰“åŒ…é™æ€èµ„æº
RicePack() {
  return # å·²å–æ¶ˆwebåŠŸèƒ½
  rice -i github.com/felixonmars/BaiduPCS-Go/internal/pcsweb append --exec "$output/$1/$2"
}

touch ./vendor/golang.org/x/sys/windows/windows.s

# Android
export NDK_INSTALL=$ANDROID_NDK_ROOT/bin
# CC=$NDK_INSTALL/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-gcc AndroidBuild $name-$version"-android-16-armv5" android arm 5
# CC=$NDK_INSTALL/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-gcc AndroidBuild $name-$version"-android-16-armv6" android arm 6
#CC=$NDK_INSTALL/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-gcc AndroidBuild $name-$version"-android-16-armv7" android arm 7
#CC=$NDK_INSTALL/aarch64-linux-android-4.9/bin/aarch64-linux-android-gcc AndroidBuild $name-$version"-android-21-arm64" android arm64 7
#CC=$NDK_INSTALL/i686-linux-android-4.9/bin/i686-linux-android-gcc AndroidBuild $name-$version"-android-16-386" android 386 7
#CC=$NDK_INSTALL/x86_64-linux-android-4.9/bin/x86_64-linux-android-gcc AndroidBuild $name-$version"-android-21-amd64" android amd64 7

# iOS
IOSBuild $name-$version"-darwin-ios-arm"

# OS X / macOS
Build $name-$version"-darwin-osx-amd64" darwin amd64
# Build $name-$version"-darwin-osx-386" darwin 386

# Windows
Build $name-$version"-windows-x86" windows 386
Build $name-$version"-windows-x64" windows amd64

# Linux
Build $name-$version"-linux-386" linux 386
Build $name-$version"-linux-amd64" linux amd64
Build $name-$version"-linux-armv5" linux arm 5
Build $name-$version"-linux-armv7" linux arm 7
Build $name-$version"-linux-arm64" linux arm64
GOMIPS=softfloat Build $name-$version"-linux-mips" linux mips
Build $name-$version"-linux-mips64" linux mips64
GOMIPS=softfloat Build $name-$version"-linux-mipsle" linux mipsle
Build $name-$version"-linux-mips64le" linux mips64le
# Build $name-$version"-linux-ppc64" linux ppc64
# Build $name-$version"-linux-ppc64le" linux ppc64le
# Build $name-$version"-linux-s390x" linux s390x

# Others
# Build $name-$version"-solaris-amd64" solaris amd64
Build $name-$version"-freebsd-386" freebsd 386
Build $name-$version"-freebsd-amd64" freebsd amd64
# Build $name-$version"-freebsd-arm" freebsd arm
# Build $name-$version"-netbsd-386" netbsd	386
# Build $name-$version"-netbsd-amd64" netbsd amd64
# Build $name-$version"-netbsd-arm" netbsd	arm
# Build $name-$version"-openbsd-386" openbsd 386
# Build $name-$version"-openbsd-amd64" openbsd	amd64
# Build $name-$version"-openbsd-arm" openbsd arm
# Build $name-$version"-plan9-386" plan9 386
# Build $name-$version"-plan9-amd64" plan9 amd64
# Build $name-$version"-plan9-arm" plan9 arm
# Build $name-$version"-nacl-386" nacl 386
# Build $name-$version"-nacl-amd64p32" nacl amd64p32
# Build $name-$version"-nacl-arm" nacl arm
# Build $name-$version"-dragonflybsd-amd64" dragonfly amd64



================================================
FILE: entitlements.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>application-identifier</key>
        <string>com.iikira.baidupcsgo</string>
        <key>get-task-allow</key>
        <true/>
        <key>platform-application</key>
        <true/>
        <key>keychain-access-groups</key>
        <array>
            <string>com.iikira.baidupcsgo</string>
        </array>
    </dict>
</plist>


================================================
FILE: go.mod
================================================
module github.com/felixonmars/BaiduPCS-Go

go 1.12

require (
	github.com/GeertJohan/go.incremental v1.0.0
	github.com/GeertJohan/go.rice v0.0.0-20170420135705-c02ca9a983da // indirect
	github.com/astaxie/beego v1.10.1 // indirect
	github.com/bitly/go-simplejson v0.5.0 // indirect
	github.com/daaku/go.zipexe v0.0.0-20150329023125-a5fe2436ffcb // indirect
	github.com/dgrijalva/jwt-go v3.2.0+incompatible
	github.com/fatih/color v0.0.0-20150510220652-1b35f289c47d
	github.com/felixonmars/Baidu-Login v1.2.2-0.20180427090606-ecf146973528
	github.com/felixonmars/baidu-tools v0.0.0-20190609113215-4dd64618064d
	github.com/golang/protobuf v1.3.2
	github.com/iikira/Baidu-Login v1.2.2 // indirect
	github.com/iikira/BaiduPCS-Go v3.5.6+incompatible // indirect
	github.com/iikira/baidu-tools v0.0.0-20190609113215-4dd64618064d // indirect
	github.com/json-iterator/go v1.1.7
	github.com/kardianos/osext v0.0.0-20170510131534-ae77be60afb1
	github.com/mattn/go-runewidth v0.0.5-0.20181218000649-703b5e6b11ae
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/oleiade/lane v0.0.0-20160817071224-3053869314bb
	github.com/olekukonko/tablewriter v0.0.2-0.20190618033246-cc27d85e17ce
	github.com/peterh/liner v1.1.1-0.20190305032635-6f820f8f90ce
	github.com/shiena/ansicolor v0.0.0-20151119151921-a422bbe96644 // indirect
	github.com/urfave/cli v1.21.1-0.20190817182405-23c83030263f
	golang.org/x/crypto v0.0.0-20190820162420-60c769a6c586
	golang.org/x/sys v0.0.0-20191025090151-53bf42e6b339
)



================================================
FILE: go.sum
================================================
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/GeertJohan/go.incremental v1.0.0 h1:7AH+pY1XUgQE4Y1HcXYaMqAI0m9yrFqo/jt0CW30vsg=
github.com/GeertJohan/go.incremental v1.0.0/go.mod h1:6fAjUhbVuX1KcMD3c8TEgVUqmo4seqhv0i0kdATSkM0=
github.com/GeertJohan/go.rice v0.0.0-20170420135705-c02ca9a983da h1:UVU3a9pRUyLdnBtn60WjRl0s4SEyJc2ChCY56OAR6wI=
github.com/GeertJohan/go.rice v0.0.0-20170420135705-c02ca9a983da/go.mod h1:DgrzXonpdQbfN3uYaGz1EG4Sbhyum/MMIn6Cphlh2bw=
github.com/GeertJohan/go.rice v1.0.0 h1:KkI6O9uMaQU3VEKaj01ulavtF7o1fWT7+pk/4voiMLQ=
github.com/GeertJohan/go.rice v1.0.0/go.mod h1:eH6gbSOAUv07dQuZVnBmoDP8mgsM1rtixis4Tib9if0=
github.com/akavel/rsrc v0.8.0/go.mod h1:uLoCtb9J+EyAqh+26kdrTgmzRBFPGOolLWKpdxkKq+c=
github.com/astaxie/beego v1.10.1 h1:M2ciUnyiZycuTpGEA+idJF0gX24h58EbPvGqjnO/DCg=
github.com/astaxie/beego v1.10.1/go.mod h1:0R4++1tUqERR0WYFWdfkcrsyoVBCG4DgpDGokT3yb+U=
github.com/bitly/go-simplejson v0.5.0 h1:6IH+V8/tVMab511d5bn4M7EwGXZf9Hj6i2xSwkNEM+Y=
github.com/bitly/go-simplejson v0.5.0/go.mod h1:cXHtHw4XUPsvGaxgjIAn8PhEWG9NfngEKAMDJEczWVA=
github.com/cpuguy83/go-md2man v1.0.10 h1:BSKMNlYxDvnunlTymqtgONjNnaRV1sTpcovwwjF22jk=
github.com/cpuguy83/go-md2man v1.0.10/go.mod h1:SmD6nW6nTyfqj6ABTjUi3V3JVMnlJmwcJI5acqYI6dE=
github.com/daaku/go.zipexe v0.0.0-20150329023125-a5fe2436ffcb h1:tUf55Po0vzOendQ7NWytcdK0VuzQmfAgvGBUOQvN0WA=
github.com/daaku/go.zipexe v0.0.0-20150329023125-a5fe2436ffcb/go.mod h1:U0vRfAucUOohvdCxt5MWLF+TePIL0xbCkbKIiV8TQCE=
github.com/daaku/go.zipexe v1.0.0 h1:VSOgZtH418pH9L16hC/JrgSNJbbAL26pj7lmD1+CGdY=
github.com/daaku/go.zipexe v1.0.0/go.mod h1:z8IiR6TsVLEYKwXAoE/I+8ys/sDkgTzSL0CLnGVd57E=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dgrijalva/jwt-go v3.2.0+incompatible h1:7qlOGliEKZXTDg6OTjfoBKDXWrumCAMpl/TFQ4/5kLM=
github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=
github.com/fatih/color v0.0.0-20150510220652-1b35f289c47d h1:wMOLsfJ92CRGk3+GtVk+aaUme+jWTH21jH3cVL1jzmI=
github.com/fatih/color v0.0.0-20150510220652-1b35f289c47d/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=
github.com/felixonmars/Baidu-Login v0.0.0-20180427090606-ecf146973528 h1:WaZCDfR+C0z17lO7syZFXpJ7d8YUxv5iG1/PeYzjKiM=
github.com/felixonmars/Baidu-Login v0.0.0-20180427090606-ecf146973528/go.mod h1:iANGZirDaKKKiijrX6J9Tqy4D+BYIBi/NkoZ0weUdbo=
github.com/felixonmars/Baidu-Login v1.2.2-0.20180427090606-ecf146973528 h1:FzumOZ5hWbUnCe3ZE6uN/2D5F6WVUtOmHRPiRPPqneU=
github.com/felixonmars/Baidu-Login v1.2.2-0.20180427090606-ecf146973528/go.mod h1:iANGZirDaKKKiijrX6J9Tqy4D+BYIBi/NkoZ0weUdbo=
github.com/felixonmars/baidu-tools v0.0.0-20180922000818-79c93d8033cd h1:meH/UWnJi8GuWEjMFivCnwp2NWdqhDnTsIIkb5SptZQ=
github.com/felixonmars/baidu-tools v0.0.0-20180922000818-79c93d8033cd/go.mod h1:pThvOx25nUwZM1zTireFAPHxT8Yj75oR4P5MbGJbKQ0=
github.com/felixonmars/baidu-tools v0.0.0-20190609113215-4dd64618064d h1:DwIXGc5ac7cp6wXYgach2ZHYqFLFIiQFsoLszR/BsgU=
github.com/felixonmars/baidu-tools v0.0.0-20190609113215-4dd64618064d/go.mod h1:pThvOx25nUwZM1zTireFAPHxT8Yj75oR4P5MbGJbKQ0=
github.com/golang/protobuf v1.3.2 h1:6nsPYzhq5kReh6QImI3k5qWzO4PEbvbIW2cwSfR/6xs=
github.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
github.com/iikira/Baidu-Login v1.2.2 h1:1R/ptmJdMIIMUaXSdtcrgf6JuULmo9ZyDYn9m3kiMBQ=
github.com/iikira/Baidu-Login v1.2.2/go.mod h1:oMWxZOoEMgQG+0rq8xhEIdxvXwkyG4aN3sZoOQ59R4Q=
github.com/iikira/BaiduPCS-Go v3.5.6+incompatible h1:oKsLtn0zPCsuQZs8AXuLTdd3PVyFnzjqcFnv7jGb8v8=
github.com/iikira/BaiduPCS-Go v3.5.6+incompatible/go.mod h1:/Dv6EqOSD+ihyltwf0i//5shl8feBdebd92bqB9faYM=
github.com/iikira/baidu-tools v0.0.0-20190609113215-4dd64618064d h1:nmsuPx1si1QI3boPuaQjxp536X7RAeLW26DBmcdRXO0=
github.com/iikira/baidu-tools v0.0.0-20190609113215-4dd64618064d/go.mod h1:UHD1R9RGXz5nDsKm3KbdD3yxCJZ18nmR+1ZAc5GkrNw=
github.com/jessevdk/go-flags v1.4.0/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=
github.com/json-iterator/go v1.1.5 h1:gL2yXlmiIo4+t+y32d4WGwOjKGYcGOuyrg46vadswDE=
github.com/json-iterator/go v1.1.5/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=
github.com/json-iterator/go v1.1.7 h1:KfgG9LzI+pYjr4xvmz/5H4FXjokeP+rlHLhv3iH62Fo=
github.com/json-iterator/go v1.1.7/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=
github.com/kardianos/osext v0.0.0-20170510131534-ae77be60afb1 h1:PJPDf8OUfOK1bb/NeTKd4f1QXZItOX389VN3B6qC8ro=
github.com/kardianos/osext v0.0.0-20170510131534-ae77be60afb1/go.mod h1:1NbS8ALrpOvjt0rHPNLyCIeMtbizbir8U//inJ+zuB8=
github.com/mattn/go-runewidth v0.0.3 h1:a+kO+98RDGEfo6asOGMmpodZq4FNtnGP54yps8BzLR4=
github.com/mattn/go-runewidth v0.0.3/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=
github.com/mattn/go-runewidth v0.0.4/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=
github.com/mattn/go-runewidth v0.0.5-0.20181218000649-703b5e6b11ae h1:575usOHCDzxtuyWeSjPySew7uvoOuaCsM0uUesjgAo4=
github.com/mattn/go-runewidth v0.0.5-0.20181218000649-703b5e6b11ae/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=
github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742 h1:Esafd1046DLDQ0W1YjYsBW+p8U2u7vzgW2SQVmlNazg=
github.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=
github.com/nkovacs/streamquote v0.0.0-20170412213628-49af9bddb229/go.mod h1:0aYXnNPJ8l7uZxf45rWW1a/uME32OF0rhiYGNQ2oF2E=
github.com/oleiade/lane v0.0.0-20160817071224-3053869314bb h1:x0yCvYsspui5SAxSRvLd2zFg7PfFijzKdCo7QAtN92I=
github.com/oleiade/lane v0.0.0-20160817071224-3053869314bb/go.mod h1:ym0w0flrmBtGvApLDgFLa0sfGJkWxDQqnm0/0ok5w3Y=
github.com/olekukonko/tablewriter v0.0.1 h1:b3iUnf1v+ppJiOfNX4yxxqfWKMQPZR5yoh8urCTFX88=
github.com/olekukonko/tablewriter v0.0.1/go.mod h1:vsDQFd/mU46D+Z4whnwzcISnGGzXWMclvtLoiIKAKIo=
github.com/olekukonko/tablewriter v0.0.2-0.20190618033246-cc27d85e17ce h1:RLmZmfx/K62HKpbwPqtW3tg+V2GgugN/XNNx+uiMH/Y=
github.com/olekukonko/tablewriter v0.0.2-0.20190618033246-cc27d85e17ce/go.mod h1:rSAaSIOAGT9odnlyGlUfAJaoc5w2fSBUmeGDbRWPxyQ=
github.com/peterh/liner v1.1.0 h1:f+aAedNJA6uk7+6rXsYBnhdo4Xux7ESLe+kcuVUF5os=
github.com/peterh/liner v1.1.0/go.mod h1:CRroGNssyjTd/qIG2FyxByd2S8JEAZXBl4qUrZf8GS0=
github.com/peterh/liner v1.1.1-0.20190305032635-6f820f8f90ce h1:Lz+a/i+oS4A7tb6J6IyH4ZFiWgqvNv2yslv0Qn79wok=
github.com/peterh/liner v1.1.1-0.20190305032635-6f820f8f90ce/go.mod h1:CRroGNssyjTd/qIG2FyxByd2S8JEAZXBl4qUrZf8GS0=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/russross/blackfriday v1.5.2 h1:HyvC0ARfnZBqnXwABFeSZHpKvJHJJfPz81GNueLj0oo=
github.com/russross/blackfriday v1.5.2/go.mod h1:JO/DiYxRf+HjHt06OyowR9PTA263kcR/rfWxYHBV53g=
github.com/shiena/ansicolor v0.0.0-20151119151921-a422bbe96644 h1:X+yvsM2yrEktyI+b2qND5gpH8YhURn0k8OCaeRnkINo=
github.com/shiena/ansicolor v0.0.0-20151119151921-a422bbe96644/go.mod h1:nkxAfR/5quYxwPZhyDxgasBMnRtBZd0FCEpawpjMUFg=
github.com/shurcooL/httpfs v0.0.0-20190707220628-8d4bc4ba7749/go.mod h1:ZY1cvUeJuFPAdZ/B6v7RHavJWZn2YPVFQ1OSXhCGOkg=
github.com/shurcooL/vfsgen v0.0.0-20181202132449-6a9ea43bcacd/go.mod h1:TrYk7fJVaAttu97ZZKrO9UbRa8izdowaMIZcxYMbVaw=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/urfave/cli v1.20.0 h1:fDqGv3UG/4jbVl/QkFwEdddtEDjh/5Ov6X+0B/3bPaw=
github.com/urfave/cli v1.20.0/go.mod h1:70zkFmudgCuE/ngEzBv17Jvp/497gISqfk5gWijbERA=
github.com/urfave/cli v1.21.1-0.20190817182405-23c83030263f h1:xKDKjIsL76VUyHcA0G4Qe1cIAUB/nrq6Pt8D411bd1g=
github.com/urfave/cli v1.21.1-0.20190817182405-23c83030263f/go.mod h1:qXyCeJubPqsgeiLd3kvHOGHHSrQcNdjZ2ScXIcVZK/I=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/fasttemplate v1.0.1/go.mod h1:UQGH1tvbgY+Nz5t2n7tXsz52dQxojPUpymEIMZ47gx8=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20190820162420-60c769a6c586 h1:7KByu05hhLed2MO29w7p1XfZvZ13m8mub3shuVftRs0=
golang.org/x/crypto v0.0.0-20190820162420-60c769a6c586/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d h1:+R4KGOnez64A81RvjARKc4UT5/tI9ujCIVX+P5KiHuI=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191025090151-53bf42e6b339 h1:zSqWKgm/o7HAnlAzBQ+aetp9fpuyytsXnKA8eiLHYQM=
golang.org/x/sys v0.0.0-20191025090151-53bf42e6b339/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=



================================================
FILE: Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<dict>
		<key>CFBundleName</key>
		<string>BaiduPCS-Go</string>
		<key>CFBundleSupportedPlatforms</key>
		<array>
			<string>iPhoneOS</string>
		</array>
		<key>CFBundleExecutable</key>
		<string>BaiduPCS-Go</string>
		<key>CFBundleVersion</key>
		<string>1.0</string>
		<key>CFBundleIdentifier</key>
		<string>com.iikira.baidupcsgo</string>
		<key>LSRequiresIPhoneOS</key>
		<true/>
		<key>CFBundleDisplayName</key>
		<string>BaiduPCS-Go</string>
	</dict>
</plist>


================================================
FILE: LICENSE
================================================
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright iikira.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.




================================================
FILE: versioninfo.json
================================================
{
    "FixedFileInfo": {
        "FileVersion": {
            "Major": 3,
            "Minor": 6,
            "Patch": 2,
            "Build": 0
        },
        "ProductVersion": {
            "Major": 3,
            "Minor": 6,
            "Patch": 2,
            "Build": 0
        },
        "FileFlagsMask": "3f",
        "FileFlags ": "00",
        "FileOS": "040004",
        "FileType": "01",
        "FileSubType": "00"
    },
    "StringFileInfo": {
        "Comments": "",
        "CompanyName": "iikira",
        "FileDescription": "ç™¾åº¦ç½‘ç›˜å®¢æˆ·ç«¯",
        "FileVersion": "v3.6.2",
        "InternalName": "",
        "LegalCopyright": "Â© 2016-2020 iikira.",
        "LegalTrademarks": "",
        "OriginalFilename": "",
        "PrivateBuild": "",
        "ProductName": "BaiduPCS-Go",
        "ProductVersion": "v3.6.2",
        "SpecialBuild": ""
    },
    "VarFileInfo": {
        "Translation": {
            "LangID": "0409",
            "CharsetID": "04B0"
        }
    },
    "IconPath": "assets/BaiduPCS-Go.ico",
    "ManifestPath": "BaiduPCS-Go.exe.manifest"
}


================================================
FILE: baidupcs/baidupcs.go
================================================
// Package baidupcs BaiduPCS RESTful API å·¥å…·åŒ…
package baidupcs

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires/cachemap"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/internal/panhome"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"strconv"
)

const (
	// OperationGetUK è·å–UK
	OperationGetUK = "è·å–UK"
	// OperationQuotaInfo è·å–å½“å‰ç”¨æˆ·ç©ºé—´é…é¢ä¿¡æ¯
	OperationQuotaInfo = "è·å–å½“å‰ç”¨æˆ·ç©ºé—´é…é¢ä¿¡æ¯"
	// OperationFilesDirectoriesMeta è·å–æ–‡ä»¶/ç›®å½•çš„å…ƒä¿¡æ¯
	OperationFilesDirectoriesMeta = "è·å–æ–‡ä»¶/ç›®å½•çš„å…ƒä¿¡æ¯"
	// OperationFilesDirectoriesList è·å–ç›®å½•ä¸‹çš„æ–‡ä»¶åˆ—è¡¨
	OperationFilesDirectoriesList = "è·å–ç›®å½•ä¸‹çš„æ–‡ä»¶åˆ—è¡¨"
	// OperationSearch æœç´¢
	OperationSearch = "æœç´¢"
	// OperationRemove åˆ é™¤æ–‡ä»¶/ç›®å½•
	OperationRemove = "åˆ é™¤æ–‡ä»¶/ç›®å½•"
	// OperationMkdir åˆ›å»ºç›®å½•
	OperationMkdir = "åˆ›å»ºç›®å½•"
	// OperationRename é‡å‘½åæ–‡ä»¶/ç›®å½•
	OperationRename = "é‡å‘½åæ–‡ä»¶/ç›®å½•"
	// OperationCopy æ‹·è´æ–‡ä»¶/ç›®å½•
	OperationCopy = "æ‹·è´æ–‡ä»¶/ç›®å½•"
	// OperationMove ç§»åŠ¨æ–‡ä»¶/ç›®å½•
	OperationMove = "ç§»åŠ¨æ–‡ä»¶/ç›®å½•"
	// OperationRapidUpload ç§’ä¼ æ–‡ä»¶
	OperationRapidUpload = "ç§’ä¼ æ–‡ä»¶"
	// OperationUpload ä¸Šä¼ å•ä¸ªæ–‡ä»¶
	OperationUpload = "ä¸Šä¼ å•ä¸ªæ–‡ä»¶"
	// OperationUploadTmpFile åˆ†ç‰‡ä¸Šä¼ â€”æ–‡ä»¶åˆ†ç‰‡åŠä¸Šä¼ 
	OperationUploadTmpFile = "åˆ†ç‰‡ä¸Šä¼ â€”æ–‡ä»¶åˆ†ç‰‡åŠä¸Šä¼ "
	// OperationUploadCreateSuperFile åˆ†ç‰‡ä¸Šä¼ â€”åˆå¹¶åˆ†ç‰‡æ–‡ä»¶
	OperationUploadCreateSuperFile = "åˆ†ç‰‡ä¸Šä¼ â€”åˆå¹¶åˆ†ç‰‡æ–‡ä»¶"
	// OperationUploadPrecreate åˆ†ç‰‡ä¸Šä¼ â€”Precreate
	OperationUploadPrecreate = "åˆ†ç‰‡ä¸Šä¼ â€”Precreate"
	// OperationUploadSuperfile2 åˆ†ç‰‡ä¸Šä¼ â€”Superfile2
	OperationUploadSuperfile2 = "åˆ†ç‰‡ä¸Šä¼ â€”Superfile2"
	// OperationDownloadFile ä¸‹è½½å•ä¸ªæ–‡ä»¶
	OperationDownloadFile = "ä¸‹è½½å•ä¸ªæ–‡ä»¶"
	// OperationDownloadStreamFile ä¸‹è½½æµå¼æ–‡ä»¶
	OperationDownloadStreamFile = "ä¸‹è½½æµå¼æ–‡ä»¶"
	// OperationLocateDownload è·å–ä¸‹è½½é“¾æ¥
	OperationLocateDownload = "è·å–ä¸‹è½½é“¾æ¥"
	// OperationLocatePanAPIDownload ä»ç™¾åº¦ç½‘ç›˜é¦–é¡µè·å–ä¸‹è½½é“¾æ¥
	OperationLocatePanAPIDownload = "è·å–ä¸‹è½½é“¾æ¥2"
	// OperationCloudDlAddTask æ·»åŠ ç¦»çº¿ä¸‹è½½ä»»åŠ¡
	OperationCloudDlAddTask = "æ·»åŠ ç¦»çº¿ä¸‹è½½ä»»åŠ¡"
	// OperationCloudDlQueryTask ç²¾ç¡®æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡
	OperationCloudDlQueryTask = "ç²¾ç¡®æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡"
	// OperationCloudDlListTask æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡åˆ—è¡¨
	OperationCloudDlListTask = "æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡åˆ—è¡¨"
	// OperationCloudDlCancelTask å–æ¶ˆç¦»çº¿ä¸‹è½½ä»»åŠ¡
	OperationCloudDlCancelTask = "å–æ¶ˆç¦»çº¿ä¸‹è½½ä»»åŠ¡"
	// OperationCloudDlDeleteTask åˆ é™¤ç¦»çº¿ä¸‹è½½ä»»åŠ¡
	OperationCloudDlDeleteTask = "åˆ é™¤ç¦»çº¿ä¸‹è½½ä»»åŠ¡"
	// OperationCloudDlClearTask æ¸…ç©ºç¦»çº¿ä¸‹è½½ä»»åŠ¡è®°å½•
	OperationCloudDlClearTask = "æ¸…ç©ºç¦»çº¿ä¸‹è½½ä»»åŠ¡è®°å½•"
	// OperationShareSet åˆ›å»ºåˆ†äº«é“¾æ¥
	OperationShareSet = "åˆ›å»ºåˆ†äº«é“¾æ¥"
	// OperationShareCancel å–æ¶ˆåˆ†äº«
	OperationShareCancel = "å–æ¶ˆåˆ†äº«"
	// OperationShareList åˆ—å‡ºåˆ†äº«åˆ—è¡¨
	OperationShareList = "åˆ—å‡ºåˆ†äº«åˆ—è¡¨"
	// OperationShareSURLInfo è·å–åˆ†äº«è¯¦ç»†ä¿¡æ¯
	OperationShareSURLInfo = "è·å–åˆ†äº«è¯¦ç»†ä¿¡æ¯"
	// OperationRecycleList åˆ—å‡ºå›æ”¶ç«™æ–‡ä»¶åˆ—è¡¨
	OperationRecycleList = "åˆ—å‡ºå›æ”¶ç«™æ–‡ä»¶åˆ—è¡¨"
	// OperationRecycleRestore è¿˜åŸå›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•
	OperationRecycleRestore = "è¿˜åŸå›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•"
	// OperationRecycleDelete åˆ é™¤å›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•
	OperationRecycleDelete = "åˆ é™¤å›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•"
	// OperationRecycleClear æ¸…ç©ºå›æ”¶ç«™
	OperationRecycleClear = "æ¸…ç©ºå›æ”¶ç«™"

	// OperationExportFileInfo å¯¼å‡ºæ–‡ä»¶ä¿¡æ¯
	OperationExportFileInfo = "å¯¼å‡ºæ–‡ä»¶ä¿¡æ¯"
	// OperationGetRapidUploadInfo è·å–æ–‡ä»¶ç§’ä¼ ä¿¡æ¯
	OperationGetRapidUploadInfo = "è·å–æ–‡ä»¶ç§’ä¼ ä¿¡æ¯"
	// OperationFixMD5 ä¿®å¤æ–‡ä»¶md5
	OperationFixMD5 = "ä¿®å¤æ–‡ä»¶md5"
	// OperrationMatchPathByShellPattern é€šé…ç¬¦åŒ¹é…æ–‡ä»¶è·¯å¾„
	OperrationMatchPathByShellPattern = "é€šé…ç¬¦åŒ¹é…æ–‡ä»¶è·¯å¾„"

	// PCSBaiduCom pcs apiåœ°å€
	PCSBaiduCom = "pcs.baidu.com"
	// PanBaiduCom ç½‘ç›˜é¦–é¡µapiåœ°å€
	PanBaiduCom = "pan.baidu.com"
	// YunBaiduCom ç½‘ç›˜é¦–é¡µapiåœ°å€2
	YunBaiduCom = "yun.baidu.com"
	// PanAppID ç™¾åº¦ç½‘ç›˜appid
	PanAppID = "250528"
	// NetdiskUA ç½‘ç›˜å®¢æˆ·ç«¯ua
	NetdiskUA = "netdisk;2.2.51.6;netdisk;10.0.63;PC;android-android"
	// DotBaiduCom .baidu.com
	DotBaiduCom = ".baidu.com"
	// PathSeparator è·¯å¾„åˆ†éš”ç¬¦
	PathSeparator = "/"
)

var (
	baiduPCSVerbose = pcsverbose.New("BAIDUPCS")

	baiduComURL = &url.URL{
		Scheme: "http",
		Host:   "baidu.com",
	}

	baiduPcsComURL = &url.URL{
		Scheme: "http",
		Host:   "baidupcs.com",
	}
)

type (
	// BaiduPCS ç™¾åº¦ PCS API è¯¦æƒ…
	BaiduPCS struct {
		appID      int                   // app_id
		isHTTPS    bool                  // æ˜¯å¦å¯ç”¨https
		uid        uint64                // ç™¾åº¦uid
		client     *requester.HTTPClient // http å®¢æˆ·ç«¯
		pcsUA      string
		panUA      string
		isSetPanUA bool
		ph         *panhome.PanHome
		cacheOpMap cachemap.CacheOpMap
	}

	userInfoJSON struct {
		*pcserror.PanErrorInfo
		Records []struct {
			Uk int64 `json:"uk"`
		} `json:"records"`
	}
)

// NewPCS æä¾›app_id, ç™¾åº¦BDUSS, è¿”å› BaiduPCS å¯¹è±¡
func NewPCS(appID int, bduss string) *BaiduPCS {
	client := requester.NewHTTPClient()
	client.ResetCookiejar()
	client.Jar.SetCookies(baiduComURL, []*http.Cookie{
		&http.Cookie{
			Name:   "BDUSS",
			Value:  bduss,
			Domain: DotBaiduCom,
		},
	})

	return &BaiduPCS{
		appID:  appID,
		client: client,
	}
}

// NewPCSWithClient æä¾›app_id, è‡ªå®šä¹‰å®¢æˆ·ç«¯, è¿”å› BaiduPCS å¯¹è±¡
func NewPCSWithClient(appID int, client *requester.HTTPClient) *BaiduPCS {
	pcs := &BaiduPCS{
		appID:  appID,
		client: client,
	}
	return pcs
}

// NewPCSWithCookieStr æä¾›app_id, cookie å­—ç¬¦ä¸², è¿”å› BaiduPCS å¯¹è±¡
func NewPCSWithCookieStr(appID int, cookieStr string) *BaiduPCS {
	pcs := &BaiduPCS{
		appID:  appID,
		client: requester.NewHTTPClient(),
	}

	cookies := requester.ParseCookieStr(cookieStr)
	for _, cookie := range cookies {
		cookie.Domain = DotBaiduCom
	}

	jar, _ := cookiejar.New(nil)
	jar.SetCookies(baiduComURL, cookies)
	pcs.client.SetCookiejar(jar)

	return pcs
}

func (pcs *BaiduPCS) lazyInit() {
	if pcs.client == nil {
		pcs.client = requester.NewHTTPClient()
	}
	if pcs.ph == nil {
		pcs.ph = panhome.NewPanHome(pcs.client)
	}
	if !pcs.isSetPanUA {
		pcs.panUA = NetdiskUA
	}
}

// GetClient è·å–å½“å‰çš„http client
func (pcs *BaiduPCS) GetClient() *requester.HTTPClient {
	pcs.lazyInit()
	return pcs.client
}

// GetBDUSS è·å–BDUSS
func (pcs *BaiduPCS) GetBDUSS() (bduss string) {
	if pcs.client == nil || pcs.client.Jar == nil {
		return ""
	}
	cookies := pcs.client.Jar.Cookies(baiduComURL)
	for _, cookie := range cookies {
		if cookie.Name == "BDUSS" {
			return cookie.Value
		}
	}
	return ""
}

// SetAPPID è®¾ç½®app_id
func (pcs *BaiduPCS) SetAPPID(appID int) {
	pcs.appID = appID
}

// SetUID è®¾ç½®ç™¾åº¦UID
// åªæœ‰locatedownloadæ‰éœ€è¦è®¾ç½®æ­¤é¡¹
func (pcs *BaiduPCS) SetUID(uid uint64) {
	pcs.uid = uid
}

// SetStoken è®¾ç½®stoken
func (pcs *BaiduPCS) SetStoken(stoken string) {
	pcs.lazyInit()
	if pcs.client.Jar == nil {
		pcs.client.ResetCookiejar()
	}

	pcs.client.Jar.SetCookies(baiduComURL, []*http.Cookie{
		&http.Cookie{
			Name:   "STOKEN",
			Value:  stoken,
			Domain: DotBaiduCom,
		},
	})
}

// SetPCSUserAgent è®¾ç½® PCS User-Agent
func (pcs *BaiduPCS) SetPCSUserAgent(ua string) {
	pcs.pcsUA = ua
}

// SetPanUserAgent è®¾ç½® Pan User-Agent
func (pcs *BaiduPCS) SetPanUserAgent(ua string) {
	pcs.panUA = ua
	pcs.isSetPanUA = true
}

// SetHTTPS æ˜¯å¦å¯ç”¨httpsè¿æ¥
func (pcs *BaiduPCS) SetHTTPS(https bool) {
	pcs.isHTTPS = https
}

// URL è¿”å› url
func (pcs *BaiduPCS) URL() *url.URL {
	return &url.URL{
		Scheme: GetHTTPScheme(pcs.isHTTPS),
		Host:   PCSBaiduCom,
	}
}

func (pcs *BaiduPCS) getPanUAHeader() (header map[string]string) {
	return map[string]string{
		"User-Agent": pcs.panUA,
	}
}

func (pcs *BaiduPCS) generatePCSURL(subPath, method string, param ...map[string]string) *url.URL {
	pcsURL := pcs.URL()
	pcsURL.Path = "/rest/2.0/pcs/" + subPath

	uv := pcsURL.Query()
	uv.Set("app_id", strconv.Itoa(pcs.appID))
	uv.Set("method", method)
	for k := range param {
		for k2 := range param[k] {
			uv.Set(k2, param[k][k2])
		}
	}

	pcsURL.RawQuery = uv.Encode()
	return pcsURL
}

func (pcs *BaiduPCS) generatePCSURL2(subPath, method string, param ...map[string]string) *url.URL {
	pcsURL2 := &url.URL{
		Scheme: GetHTTPScheme(pcs.isHTTPS),
		Host:   PanBaiduCom,
		Path:   "/rest/2.0/" + subPath,
	}

	uv := pcsURL2.Query()
	uv.Set("app_id", PanAppID)
	uv.Set("method", method)
	for k := range param {
		for k2 := range param[k] {
			uv.Set(k2, param[k][k2])
		}
	}

	pcsURL2.RawQuery = uv.Encode()
	return pcsURL2
}

func (pcs *BaiduPCS) generatePanURL(subPath string, param map[string]string) *url.URL {
	panURL := url.URL{
		Scheme: GetHTTPScheme(pcs.isHTTPS),
		Host:   PanBaiduCom,
		Path:   "/api/" + subPath,
	}

	if param != nil {
		uv := url.Values{}
		for k := range param {
			uv.Set(k, param[k])
		}
		panURL.RawQuery = uv.Encode()
	}
	return &panURL
}

// UK è·å–ç”¨æˆ· UK
func (pcs *BaiduPCS) UK() (uk int64, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareUK()
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPanErrorInfo(OperationGetUK)
	jsonData := userInfoJSON{
		PanErrorInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationGetUK, dataReadCloser, &jsonData)
	if pcsError != nil {
		return
	}

	if len(jsonData.Records) != 1 {
		errInfo.ErrType = pcserror.ErrTypeOthers
		errInfo.Err = errors.New("Unknown remote data")
		return 0, errInfo
	}

	return jsonData.Records[0].Uk, nil
}



================================================
FILE: baidupcs/cache.go
================================================
package baidupcs

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"time"
)

// deleteCache åˆ é™¤å«æœ‰ dirs çš„ç¼“å­˜
func (pcs *BaiduPCS) deleteCache(dirs []string) {
	cache := pcs.cacheOpMap.LazyInitCachePoolOp(OperationFilesDirectoriesList)
	for _, v := range dirs {
		key := v + "_" + defaultOrderOptionsStr
		_, ok := cache.Load(key)
		if ok {
			cache.Delete(key)
		}
	}
}

// CacheFilesDirectoriesList ç¼“å­˜è·å–
func (pcs *BaiduPCS) CacheFilesDirectoriesList(path string, options *OrderOptions) (fdl FileDirectoryList, pcsError pcserror.Error) {
	data := pcs.cacheOpMap.CacheOperation(OperationFilesDirectoriesList, path+"_"+fmt.Sprint(options), func() expires.DataExpires {
		fdl, pcsError = pcs.FilesDirectoriesList(path, options)
		if pcsError != nil {
			return nil
		}
		return expires.NewDataExpires(fdl, 1*time.Minute)
	})
	if pcsError != nil {
		return
	}
	return data.Data().(FileDirectoryList), nil
}



================================================
FILE: baidupcs/cloud_dl.go
================================================
package baidupcs

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/pcstime"
	"io"
	"path"
	"strconv"
	"strings"
)

type (
	// CloudDlFileInfo ç¦»çº¿ä¸‹è½½çš„æ–‡ä»¶ä¿¡æ¯
	CloudDlFileInfo struct {
		FileName string `json:"file_name"`
		FileSize int64  `json:"file_size"`
	}

	// CloudDlTaskInfo ç¦»çº¿ä¸‹è½½çš„ä»»åŠ¡ä¿¡æ¯
	CloudDlTaskInfo struct {
		TaskID       int64
		Status       int // 0ä¸‹è½½æˆåŠŸ, 1ä¸‹è½½è¿›è¡Œä¸­, 2ç³»ç»Ÿé”™è¯¯, 3èµ„æºä¸å­˜åœ¨, 4ä¸‹è½½è¶…æ—¶, 5èµ„æºå­˜åœ¨ä½†ä¸‹è½½å¤±è´¥, 6å­˜å‚¨ç©ºé—´ä¸è¶³, 7ä»»åŠ¡å–æ¶ˆ
		StatusText   string
		FileSize     int64  // æ–‡ä»¶å¤§å°
		FinishedSize int64  // æ–‡ä»¶å¤§å°
		CreateTime   int64  // åˆ›å»ºæ—¶é—´
		StartTime    int64  // å¼€å§‹æ—¶é—´
		FinishTime   int64  // ç»“æŸæ—¶é—´
		SavePath     string // ä¿å­˜çš„è·¯å¾„
		SourceURL    string // èµ„æºåœ°å€
		TaskName     string // ä»»åŠ¡åç§°, ä¸€èˆ¬ä¸ºæ–‡ä»¶å
		OdType       int
		FileList     []*CloudDlFileInfo
		Result       int // 0æŸ¥è¯¢æˆåŠŸï¼Œç»“æœæœ‰æ•ˆï¼Œ1è¦æŸ¥è¯¢çš„task_idä¸å­˜åœ¨
	}

	// CloudDlTaskList ç¦»çº¿ä¸‹è½½çš„ä»»åŠ¡ä¿¡æ¯åˆ—è¡¨
	CloudDlTaskList []*CloudDlTaskInfo

	// cloudDlTaskInfo ç”¨äºè§£æè¿œç¨‹è¿”å›çš„JSON
	cloudDlTaskInfo struct {
		Status       string `json:"status"`
		FileSize     string `json:"file_size"`
		FinishedSize string `json:"finished_size"`
		CreateTime   string `json:"create_time"`
		StartTime    string `json:"start_time"`
		FinishTime   string `json:"finish_time"`
		SavePath     string `json:"save_path"`
		SourceURL    string `json:"source_url"`
		TaskName     string `json:"task_name"`
		OdType       string `json:"od_type"`
		FileList     []*struct {
			FileName string `json:"file_name"`
			FileSize string `json:"file_size"`
		} `json:"file_list"`
		Result int `json:"result"`
	}

	taskIDJSON struct {
		TaskID string `json:"task_id"`
	}

	taskIDInt64JSON struct {
		TaskID int64 `json:"task_id"`
	}

	cloudDlAddTaskJSON struct {
		*pcserror.PCSErrInfo
		taskIDInt64JSON
	}

	cloudDlQueryTaskJSON struct {
		TaskInfo map[string]*cloudDlTaskInfo `json:"task_info"`
		*pcserror.PCSErrInfo
	}

	cloudDlListTaskJSON struct {
		TaskInfo []*taskIDJSON `json:"task_info"`
		*pcserror.PCSErrInfo
	}

	cloudDlClearJSON struct {
		Total int `json:"total"`
		*pcserror.PCSErrInfo
	}
)

func (ci *cloudDlTaskInfo) convert() *CloudDlTaskInfo {
	ci2 := &CloudDlTaskInfo{
		Status:       converter.MustInt(ci.Status),
		FileSize:     converter.MustInt64(ci.FileSize),
		FinishedSize: converter.MustInt64(ci.FinishedSize),
		CreateTime:   converter.MustInt64(ci.CreateTime),
		StartTime:    converter.MustInt64(ci.StartTime),
		FinishTime:   converter.MustInt64(ci.FinishTime),
		SavePath:     ci.SavePath,
		SourceURL:    ci.SourceURL,
		TaskName:     ci.TaskName,
		OdType:       converter.MustInt(ci.OdType),
		Result:       ci.Result,
	}

	ci2.FileList = make([]*CloudDlFileInfo, 0, len(ci.FileList))
	for _, v := range ci.FileList {
		if v == nil {
			continue
		}

		ci2.FileList = append(ci2.FileList, &CloudDlFileInfo{
			FileName: v.FileName,
			FileSize: converter.MustInt64(v.FileSize),
		})
	}

	return ci2
}

// CloudDlAddTask æ·»åŠ ç¦»çº¿ä¸‹è½½ä»»åŠ¡
func (pcs *BaiduPCS) CloudDlAddTask(sourceURL, savePath string) (taskID int64, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareCloudDlAddTask(sourceURL, savePath)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPCSErrorInfo(OperationCloudDlAddTask)
	taskInfo := cloudDlAddTaskJSON{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationCloudDlAddTask, dataReadCloser, &taskInfo)
	if pcsError != nil {
		return
	}

	return taskInfo.TaskID, nil
}

func (pcs *BaiduPCS) cloudDlQueryTask(op string, taskIDs []int64) (cl CloudDlTaskList, pcsError pcserror.Error) {
	errInfo := pcserror.NewPCSErrorInfo(op)
	if len(taskIDs) == 0 {
		errInfo.ErrType = pcserror.ErrTypeOthers
		errInfo.Err = errors.New("no input any task_ids")
		return nil, errInfo
	}

	// TODO: æ”¯æŒ100æ¡ä»¥ä¸Šçš„task_idæŸ¥è¯¢
	if len(taskIDs) > 100 {
		taskIDs = taskIDs[:100]
	}

	taskStrIDs := make([]string, len(taskIDs))
	for k := range taskStrIDs {
		taskStrIDs[k] = strconv.FormatInt(taskIDs[k], 10)
	}

	dataReadCloser, pcsError := pcs.PrepareCloudDlQueryTask(strings.Join(taskStrIDs, ","))
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	taskInfo := cloudDlQueryTaskJSON{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationCloudDlQueryTask, dataReadCloser, &taskInfo)
	if pcsError != nil {
		return
	}

	var v2 *CloudDlTaskInfo
	cl = make(CloudDlTaskList, 0, len(taskStrIDs))
	for k := range taskStrIDs {
		var err error
		v := taskInfo.TaskInfo[taskStrIDs[k]]
		if v == nil {
			continue
		}

		v2 = v.convert()

		v2.TaskID, err = strconv.ParseInt(taskStrIDs[k], 10, 64)
		if err != nil {
			continue
		}

		v2.ParseText()
		cl = append(cl, v2)
	}

	return cl, nil
}

// CloudDlQueryTask ç²¾ç¡®æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡
func (pcs *BaiduPCS) CloudDlQueryTask(taskIDs []int64) (cl CloudDlTaskList, pcsError pcserror.Error) {
	return pcs.cloudDlQueryTask(OperationCloudDlQueryTask, taskIDs)
}

// CloudDlListTask æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡åˆ—è¡¨
func (pcs *BaiduPCS) CloudDlListTask() (cl CloudDlTaskList, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareCloudDlListTask()
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPCSErrorInfo(OperationCloudDlListTask)
	taskInfo := cloudDlListTaskJSON{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationCloudDlListTask, dataReadCloser, &taskInfo)
	if pcsError != nil {
		return
	}

	// æ²¡æœ‰ä»»åŠ¡
	if len(taskInfo.TaskInfo) <= 0 {
		return CloudDlTaskList{}, nil
	}

	var (
		taskID  int64
		taskIDs = make([]int64, 0, len(taskInfo.TaskInfo))
	)
	for _, v := range taskInfo.TaskInfo {
		if v == nil {
			continue
		}
		var err error
		if taskID, err = strconv.ParseInt(v.TaskID, 10, 64); err == nil {
			taskIDs = append(taskIDs, taskID)
		}
	}

	cl, pcsError = pcs.cloudDlQueryTask(OperationCloudDlListTask, taskIDs)
	if pcsError != nil {
		return nil, pcsError
	}

	return cl, nil
}

func (pcs *BaiduPCS) cloudDlManipTask(op string, taskID int64) (pcsError pcserror.Error) {
	var dataReadCloser io.ReadCloser

	switch op {
	case OperationCloudDlCancelTask:
		dataReadCloser, pcsError = pcs.PrepareCloudDlCancelTask(taskID)
	case OperationCloudDlDeleteTask:
		dataReadCloser, pcsError = pcs.PrepareCloudDlDeleteTask(taskID)
	default:
		panic("unknown op, " + op)
	}
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.DecodePCSJSONError(op, dataReadCloser)
	return errInfo
}

// CloudDlCancelTask å–æ¶ˆç¦»çº¿ä¸‹è½½ä»»åŠ¡
func (pcs *BaiduPCS) CloudDlCancelTask(taskID int64) (pcsError pcserror.Error) {
	return pcs.cloudDlManipTask(OperationCloudDlCancelTask, taskID)
}

// CloudDlDeleteTask åˆ é™¤ç¦»çº¿ä¸‹è½½ä»»åŠ¡
func (pcs *BaiduPCS) CloudDlDeleteTask(taskID int64) (pcsError pcserror.Error) {
	return pcs.cloudDlManipTask(OperationCloudDlDeleteTask, taskID)
}

// CloudDlClearTask æ¸…ç©ºç¦»çº¿ä¸‹è½½ä»»åŠ¡è®°å½•
func (pcs *BaiduPCS) CloudDlClearTask() (total int, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareCloudDlClearTask()
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPCSErrorInfo(OperationCloudDlClearTask)
	clearInfo := cloudDlClearJSON{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationCloudDlClearTask, dataReadCloser, &clearInfo)
	if pcsError != nil {
		return
	}

	return clearInfo.Total, nil
}

// ParseText è§£æçŠ¶æ€ç 
func (ci *CloudDlTaskInfo) ParseText() {
	switch ci.Status {
	case 0:
		ci.StatusText = "ä¸‹è½½æˆåŠŸ"
	case 1:
		ci.StatusText = "ä¸‹è½½è¿›è¡Œä¸­"
	case 2:
		ci.StatusText = "ç³»ç»Ÿé”™è¯¯"
	case 3:
		ci.StatusText = "èµ„æºä¸å­˜åœ¨"
	case 4:
		ci.StatusText = "ä¸‹è½½è¶…æ—¶"
	case 5:
		ci.StatusText = "èµ„æºå­˜åœ¨ä½†ä¸‹è½½å¤±è´¥"
	case 6:
		ci.StatusText = "å­˜å‚¨ç©ºé—´ä¸è¶³"
	case 7:
		ci.StatusText = "ä»»åŠ¡å–æ¶ˆ"
	default:
		ci.StatusText = "æœªçŸ¥çŠ¶æ€ç : " + strconv.Itoa(ci.Status)
	}
}

func (cl CloudDlTaskList) String() string {
	builder := &strings.Builder{}
	tb := pcstable.NewTable(builder)
	tb.SetHeader([]string{"#", "ä»»åŠ¡ID", "ä»»åŠ¡åç§°", "æ–‡ä»¶å¤§å°", "åˆ›å»ºæ—¥æœŸ", "ä¿å­˜è·¯å¾„", "èµ„æºåœ°å€", "çŠ¶æ€"})
	for k, v := range cl {
		tb.Append([]string{strconv.Itoa(k), strconv.FormatInt(v.TaskID, 10), v.TaskName, converter.ConvertFileSize(v.FileSize), pcstime.FormatTime(v.CreateTime), path.Clean(v.SavePath), v.SourceURL, v.StatusText})
	}
	tb.Render()
	return builder.String()
}



================================================
FILE: baidupcs/cp_mv_rename.go
================================================
package baidupcs

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"unsafe"
)

// Rename é‡å‘½åæ–‡ä»¶/ç›®å½•
func (pcs *BaiduPCS) Rename(from, to string) (pcsError pcserror.Error) {
	return pcs.cpmvOp(OperationRename, &CpMvJSON{
		From: from,
		To:   to,
	})
}

// Copy æ‰¹é‡æ‹·è´æ–‡ä»¶/ç›®å½•
func (pcs *BaiduPCS) Copy(cpmvJSON ...*CpMvJSON) (pcsError pcserror.Error) {
	return pcs.cpmvOp(OperationCopy, cpmvJSON...)
}

// Move æ‰¹é‡ç§»åŠ¨æ–‡ä»¶/ç›®å½•
func (pcs *BaiduPCS) Move(cpmvJSON ...*CpMvJSON) (pcsError pcserror.Error) {
	return pcs.cpmvOp(OperationMove, cpmvJSON...)
}

func (pcs *BaiduPCS) cpmvOp(op string, cpmvJSON ...*CpMvJSON) (pcsError pcserror.Error) {
	dataReadCloser, err := pcs.prepareCpMvOp(op, cpmvJSON...)
	if err != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.DecodePCSJSONError(op, dataReadCloser)
	if errInfo != nil {
		return errInfo
	}

	// æ›´æ–°ç¼“å­˜
	pcs.deleteCache((*CpMvJSONList)(unsafe.Pointer(&cpmvJSON)).AllRelatedDir())
	return nil
}



================================================
FILE: baidupcs/download.go
================================================
package baidupcs

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"net/http"
	"net/url"
)

var (
	// ErrLocateDownloadURLNotFound æœªæ‰¾åˆ°ä¸‹è½½é“¾æ¥
	ErrLocateDownloadURLNotFound = errors.New("locatedownload url not found")
	// MaxDownloadRangeSize æ–‡ä»¶ç‰‡æ®µæœ€å¤§å€¼
	MaxDownloadRangeSize = 55 * converter.MB
)

type (
	// DownloadFunc ä¸‹è½½æ–‡ä»¶å¤„ç†å‡½æ•°
	DownloadFunc func(downloadURL string, jar http.CookieJar) error

	// URLInfo ä¸‹è½½é“¾æ¥è¯¦æƒ…
	URLInfo struct {
		URLs []struct {
			URL string `json:"url"`
		} `json:"urls"`
	}

	// LocateDownloadInfoV1 locatedownload api v1
	LocateDownloadInfoV1 struct {
		Server []string `json:"server"`
		PathJSON
	}

	locateDownloadJSON struct {
		*pcserror.PCSErrInfo
		URLInfo
	}

	// APIDownloadDlinkInfo ä¸‹è½½ä¿¡æ¯
	APIDownloadDlinkInfo struct {
		Dlink string `json:"dlink"`
		FsID  string `json:"fs_id"`
	}

	// APIDownloadDlinkInfoList ä¸‹è½½ä¿¡æ¯åˆ—è¡¨
	APIDownloadDlinkInfoList []*APIDownloadDlinkInfo

	panAPIDownloadJSON struct {
		*pcserror.PanErrorInfo
		DlinkList APIDownloadDlinkInfoList `json:"dlink"`
	}
)

// URLStrings è¿”å›ä¸‹è½½é“¾æ¥æ•°ç»„
func (ui *URLInfo) URLStrings(https bool) (urls []*url.URL) {
	urls = make([]*url.URL, 0, len(ui.URLs))
	for k := range ui.URLs {
		thisURL, err := url.Parse(ui.URLs[k].URL)
		if err != nil {
			continue
		}
		thisURL.Scheme = GetHTTPScheme(https)
		urls = append(urls, thisURL)
	}
	return urls
}

// SingleURL è¿”å›å•æ¡ä¸‹è½½é“¾æ¥
func (ui *URLInfo) SingleURL(https bool) *url.URL {
	if len(ui.URLs) < 1 {
		return nil
	}

	u, err := url.Parse(ui.URLs[0].URL)
	if err != nil {
		return nil
	}
	u.Scheme = GetHTTPScheme(https)
	return u
}

// LastURL è¿”å›æœ€åä¸€æ¡ä¸‹è½½é“¾æ¥
func (ui *URLInfo) LastURL(https bool) *url.URL {
	if len(ui.URLs) < 1 {
		return nil
	}

	u, err := url.Parse(ui.URLs[len(ui.URLs)-1].URL)
	if err != nil {
		return nil
	}
	u.Scheme = GetHTTPScheme(https)
	return u
}

// DownloadFile ä¸‹è½½å•ä¸ªæ–‡ä»¶
func (pcs *BaiduPCS) DownloadFile(path string, downloadFunc DownloadFunc) (err error) {
	pcs.lazyInit()
	pcsURL := pcs.generatePCSURL("file", "download", map[string]string{
		"path": path,
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationDownloadFile, pcsURL)

	return downloadFunc(pcsURL.String(), pcs.client.Jar)
}

// DownloadStreamFile ä¸‹è½½æµå¼æ–‡ä»¶
func (pcs *BaiduPCS) DownloadStreamFile(path string, downloadFunc DownloadFunc) (err error) {
	pcs.lazyInit()
	pcsURL := pcs.generatePCSURL("stream", "download", map[string]string{
		"path": path,
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationDownloadStreamFile, pcsURL)

	return downloadFunc(pcsURL.String(), pcs.client.Jar)
}

// LocateDownloadWithUserAgent è·å–ä¸‹è½½é“¾æ¥
func (pcs *BaiduPCS) LocateDownload(pcspath string) (info *URLInfo, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareLocateDownload(pcspath)
	if dataReadCloser != nil {
		defer dataReadCloser.Close()
	}
	if pcsError != nil {
		return nil, pcsError
	}

	errInfo := pcserror.NewPCSErrorInfo(OperationLocateDownload)
	jsonData := locateDownloadJSON{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationLocateDownload, dataReadCloser, &jsonData)
	if pcsError != nil {
		return
	}

	return &jsonData.URLInfo, nil
}

// LocatePanAPIDownload ä»ç™¾åº¦ç½‘ç›˜é¦–é¡µè·å–ä¸‹è½½é“¾æ¥
func (pcs *BaiduPCS) LocatePanAPIDownload(fidList ...int64) (dlinkInfoList APIDownloadDlinkInfoList, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareLocatePanAPIDownload(fidList...)
	if dataReadCloser != nil {
		defer dataReadCloser.Close()
	}
	if pcsError != nil {
		return nil, pcsError
	}

	jsonData := panAPIDownloadJSON{
		PanErrorInfo: pcserror.NewPanErrorInfo(OperationLocatePanAPIDownload),
	}
	pcsError = pcserror.HandleJSONParse(OperationLocatePanAPIDownload, dataReadCloser, &jsonData)
	if pcsError != nil {
		if pcsError.GetErrType() == pcserror.ErrTypeRemoteError {
			switch pcsError.GetRemoteErrCode() {
			case 112: // é¡µé¢å·²è¿‡æœŸ
				fallthrough
			case 113: // ç­¾åé”™è¯¯
				pcs.ph.SetSignExpires() // é‡ç½®
			}
		}
		return
	}

	return jsonData.DlinkList, nil
}



================================================
FILE: baidupcs/extends.go
================================================
package baidupcs

import (
	"crypto/md5"
	"encoding/hex"
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/escaper"
	"github.com/felixonmars/BaiduPCS-Go/requester/downloader"
	"io"
	"mime"
	"net/http"
	"net/url"
	"path"
	"strconv"
	"strings"
)

const (
	// ShellPatternCharacters é€šé…ç¬¦å­—ç¬¦ä¸²
	ShellPatternCharacters = "*?[]"
)

var (
	// ErrFixMD5Isdir ç›®å½•ä¸éœ€è¦ä¿®å¤md5
	ErrFixMD5Isdir = errors.New("directory not support fix md5")
	// ErrFixMD5Failed ä¿®å¤MD5å¤±è´¥, å¯èƒ½æœåŠ¡å™¨æœªåˆ·æ–°
	ErrFixMD5Failed = errors.New("fix md5 failed")
	// ErrFixMD5FileInfoNil æ–‡ä»¶ä¿¡æ¯å¯¹è±¡ä¸ºç©º
	ErrFixMD5FileInfoNil = errors.New("file info is nil")
	// ErrMatchPathByShellPatternNotAbsPath ä¸æ˜¯ç»å¯¹è·¯å¾„
	ErrMatchPathByShellPatternNotAbsPath = errors.New("not absolute path")

	ErrContentRangeNotFound               = errors.New("Content-Range not found")
	ErrGetRapidUploadInfoLengthNotFound   = errors.New("Content-Length not found")
	ErrGetRapidUploadInfoMD5NotFound      = errors.New("Content-MD5 not found")
	ErrGetRapidUploadInfoCrc32NotFound    = errors.New("x-bs-meta-crc32 not found")
	ErrGetRapidUploadInfoFilenameNotEqual = errors.New("æ–‡ä»¶åä¸åŒ¹é…")
	ErrGetRapidUploadInfoLengthNotEqual   = errors.New("Content-Length ä¸åŒ¹é…")
	ErrGetRapidUploadInfoMD5NotEqual      = errors.New("Content-MD5 ä¸åŒ¹é…")
	ErrGetRapidUploadInfoCrc32NotEqual    = errors.New("x-bs-meta-crc32 ä¸åŒ¹é…")
	ErrGetRapidUploadInfoSliceMD5NotEqual = errors.New("slice-md5 ä¸åŒ¹é…")

	ErrFileTooLarge = errors.New("æ–‡ä»¶å¤§äº20GB, æ— æ³•ç§’ä¼ ")
)

func (pcs *BaiduPCS) getLocateDownloadLink(pcspath string) (link string, pcsError pcserror.Error) {
	info, pcsError := pcs.LocateDownload(pcspath)
	if pcsError != nil {
		return
	}

	u := info.SingleURL(pcs.isHTTPS)
	if u == nil {
		return "", &pcserror.PCSErrInfo{
			Operation: OperationLocateDownload,
			ErrType:   pcserror.ErrTypeOthers,
			Err:       ErrLocateDownloadURLNotFound,
		}
	}
	return u.String(), nil
}

// ExportByFileInfo é€šè¿‡æ–‡ä»¶ä¿¡æ¯å¯¹è±¡, å¯¼å‡ºæ–‡ä»¶ä¿¡æ¯
func (pcs *BaiduPCS) ExportByFileInfo(finfo *FileDirectory) (rinfo *RapidUploadInfo, pcsError pcserror.Error) {
	errInfo := pcserror.NewPCSErrorInfo(OperationExportFileInfo)
	errInfo.ErrType = pcserror.ErrTypeOthers
	if finfo.Size > MaxRapidUploadSize {
		errInfo.Err = ErrFileTooLarge
		return nil, errInfo
	}

	rinfo, pcsError = pcs.GetRapidUploadInfoByFileInfo(finfo)
	if pcsError != nil {
		return nil, pcsError
	}
	if rinfo.Filename != finfo.Filename {
		baiduPCSVerbose.Infof("%s filename not equal, local: %s, remote link: %s\n", OperationExportFileInfo, finfo.Filename, rinfo.Filename)
		rinfo.Filename = finfo.Filename
	}
	return rinfo, nil
}

// GetRapidUploadInfoByFileInfo é€šè¿‡æ–‡ä»¶ä¿¡æ¯å¯¹è±¡, è·å–ç§’ä¼ ä¿¡æ¯
func (pcs *BaiduPCS) GetRapidUploadInfoByFileInfo(finfo *FileDirectory) (rinfo *RapidUploadInfo, pcsError pcserror.Error) {
	if finfo.Size <= SliceMD5Size && len(finfo.BlockList) == 1 && finfo.BlockList[0] == finfo.MD5 {
		// å¯ç›´æ¥ç§’ä¼ 
		return &RapidUploadInfo{
			Filename:      finfo.Filename,
			ContentLength: finfo.Size,
			ContentMD5:    finfo.MD5,
			SliceMD5:      finfo.MD5,
			ContentCrc32:  "0",
		}, nil
	}

	link, pcsError := pcs.getLocateDownloadLink(finfo.Path)
	if pcsError != nil {
		return nil, pcsError
	}

	// åªæœ‰ContentLengthå¯ä»¥æ¯”è¾ƒ
	// finfoè®°å½•çš„ContentMD5ä¸ä¸€å®šæ˜¯æ­£ç¡®çš„
	// finfoè®°å½•çš„Filenameä¸ä¸€å®šä¸è·å–åˆ°çš„ä¸€è‡´
	return pcs.GetRapidUploadInfoByLink(link, &RapidUploadInfo{
		ContentLength: finfo.Size,
	})
}

// GetRapidUploadInfoByLink é€šè¿‡ä¸‹è½½é“¾æ¥, è·å–æ–‡ä»¶ç§’ä¼ ä¿¡æ¯
func (pcs *BaiduPCS) GetRapidUploadInfoByLink(link string, compareRInfo *RapidUploadInfo) (rinfo *RapidUploadInfo, pcsError pcserror.Error) {
	errInfo := pcserror.NewPCSErrorInfo(OperationGetRapidUploadInfo)
	errInfo.ErrType = pcserror.ErrTypeOthers

	var (
		header     = pcs.getPanUAHeader()
		isSetRange = compareRInfo != nil && compareRInfo.ContentLength > SliceMD5Size // æ˜¯å¦è®¾ç½®Range
	)
	if isSetRange {
		header["Range"] = "bytes=0-" + strconv.FormatInt(SliceMD5Size-1, 10)
	}

	resp, err := pcs.client.Req(http.MethodGet, link, nil, header)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		errInfo.SetNetError(err)
		return nil, errInfo
	}

	// æ£€æµ‹å“åº”çŠ¶æ€ç 
	if resp.StatusCode/100 != 2 {
		errInfo.SetNetError(errors.New(resp.Status))
		return nil, errInfo
	}

	// æ£€æµ‹æ˜¯å¦å­˜åœ¨MD5
	md5Str := resp.Header.Get("Content-MD5")
	if md5Str == "" { // æœªæ‰¾åˆ°md5å€¼, å¯èƒ½æ˜¯æœåŠ¡å™¨æœªåˆ·æ–°
		errInfo.Err = ErrGetRapidUploadInfoMD5NotFound
		return nil, errInfo
	}
	if compareRInfo != nil && compareRInfo.ContentMD5 != "" && compareRInfo.ContentMD5 != md5Str {
		errInfo.Err = ErrGetRapidUploadInfoMD5NotEqual
		return nil, errInfo
	}

	// è·å–æ–‡ä»¶å
	_, params, err := mime.ParseMediaType(resp.Header.Get("Content-Disposition"))
	if err != nil {
		errInfo.Err = err
		return nil, errInfo
	}
	filename, err := url.QueryUnescape(params["filename"])
	if err != nil {
		errInfo.Err = err
		return nil, errInfo
	}
	if compareRInfo != nil && compareRInfo.Filename != "" && compareRInfo.Filename != filename {
		errInfo.Err = ErrGetRapidUploadInfoFilenameNotEqual
		return nil, errInfo
	}

	var (
		contentLength int64
	)
	if isSetRange {
		// æ£€æµ‹Content-Range
		contentRange := resp.Header.Get("Content-Range")
		if contentRange == "" {
			errInfo.Err = ErrContentRangeNotFound
			return nil, errInfo
		}
		contentLength = downloader.ParseContentRange(contentRange)
	} else {
		contentLength = resp.ContentLength
	}

	// æ£€æµ‹Content-Length
	switch contentLength {
	case -1:
		errInfo.Err = ErrGetRapidUploadInfoLengthNotFound
		return nil, errInfo
	case 0:
		return &RapidUploadInfo{
			Filename:      filename,
			ContentLength: contentLength,
			ContentMD5:    EmptyContentMD5,
			SliceMD5:      EmptyContentMD5,
			ContentCrc32:  "0",
		}, nil
	default:
		if compareRInfo != nil && compareRInfo.ContentLength > 0 && compareRInfo.ContentLength != contentLength {
			errInfo.Err = ErrGetRapidUploadInfoLengthNotEqual
			return nil, errInfo
		}
	}

	// æ£€æµ‹æ˜¯å¦å­˜åœ¨crc32 å€¼, ä¸€èˆ¬éƒ½ä¼šå­˜åœ¨çš„
	crc32Str := resp.Header.Get("x-bs-meta-crc32")
	if crc32Str == "" || crc32Str == "0" {
		errInfo.Err = ErrGetRapidUploadInfoCrc32NotFound
		return nil, errInfo
	}
	if compareRInfo != nil && compareRInfo.ContentCrc32 != "" && compareRInfo.ContentCrc32 != crc32Str {
		errInfo.Err = ErrGetRapidUploadInfoCrc32NotEqual
		return nil, errInfo
	}

	// è·å–slice-md5
	// å¿½ç•¥æ¯”è¾ƒslice-md5
	if contentLength <= SliceMD5Size {
		return &RapidUploadInfo{
			Filename:      filename,
			ContentLength: contentLength,
			ContentMD5:    md5Str,
			SliceMD5:      md5Str,
			ContentCrc32:  crc32Str,
		}, nil
	}

	buf := cachepool.RawMallocByteSlice(int(SliceMD5Size))
	_, err = io.ReadFull(resp.Body, buf)
	if err != nil {
		errInfo.SetNetError(err)
		return nil, errInfo
	}

	// è®¡ç®—slice-md5
	m := md5.New()
	_, err = m.Write(buf)
	if err != nil {
		panic(err)
	}

	sliceMD5Str := hex.EncodeToString(m.Sum(nil))

	// æ£€æµ‹slice-md5, ä¸å¿…è¦çš„
	if compareRInfo != nil && compareRInfo.SliceMD5 != "" && compareRInfo.SliceMD5 != sliceMD5Str {
		errInfo.Err = ErrGetRapidUploadInfoSliceMD5NotEqual
		return nil, errInfo
	}

	return &RapidUploadInfo{
		Filename:      filename,
		ContentLength: contentLength,
		ContentMD5:    md5Str,
		SliceMD5:      sliceMD5Str,
		ContentCrc32:  crc32Str,
	}, nil
}

// FixMD5ByFileInfo å°è¯•ä¿®å¤æ–‡ä»¶çš„md5, é€šè¿‡æ–‡ä»¶ä¿¡æ¯å¯¹è±¡
func (pcs *BaiduPCS) FixMD5ByFileInfo(finfo *FileDirectory) (pcsError pcserror.Error) {
	errInfo := pcserror.NewPCSErrorInfo(OperationFixMD5)
	errInfo.ErrType = pcserror.ErrTypeOthers
	if finfo == nil {
		errInfo.Err = ErrFixMD5FileInfoNil
		return errInfo
	}

	if finfo.Size > MaxRapidUploadSize { // æ–‡ä»¶å¤§äº20GB
		errInfo.Err = ErrFileTooLarge
		return errInfo
	}

	// å¿½ç•¥ç›®å½•
	if finfo.Isdir {
		errInfo.Err = ErrFixMD5Isdir
		return errInfo
	}

	if len(finfo.BlockList) == 1 && finfo.BlockList[0] == finfo.MD5 {
		// ä¸éœ€è¦ä¿®å¤
		return nil
	}

	link, pcsError := pcs.getLocateDownloadLink(finfo.Path)
	if pcsError != nil {
		return pcsError
	}

	var (
		cmpInfo = &RapidUploadInfo{
			Filename:      finfo.Filename,
			ContentLength: finfo.Size,
		}
	)
	rinfo, pcsError := pcs.GetRapidUploadInfoByLink(link, cmpInfo)
	if pcsError != nil {
		switch pcsError.GetError() {
		case ErrGetRapidUploadInfoMD5NotFound, ErrGetRapidUploadInfoCrc32NotFound:
			errInfo.Err = ErrFixMD5Failed
		default:
			errInfo.Err = pcsError
		}
		return errInfo
	}

	// å¼€å§‹ä¿®å¤
	return pcs.RapidUploadNoCheckDir(finfo.Path, rinfo.ContentMD5, rinfo.SliceMD5, rinfo.ContentCrc32, rinfo.ContentLength)
}

// FixMD5 å°è¯•ä¿®å¤æ–‡ä»¶çš„md5
func (pcs *BaiduPCS) FixMD5(pcspath string) (pcsError pcserror.Error) {
	finfo, pcsError := pcs.FilesDirectoriesMeta(pcspath)
	if pcsError != nil {
		return
	}

	return pcs.FixMD5ByFileInfo(finfo)
}

func (pcs *BaiduPCS) recurseMatchPathByShellPattern(index int, patternSlice *[]string, ps *[]string, pcspaths *[]string) {
	if index == len(*patternSlice) {
		*pcspaths = append(*pcspaths, strings.Join(*ps, PathSeparator))
		return
	}

	if !strings.ContainsAny((*patternSlice)[index], ShellPatternCharacters) {
		(*ps)[index] = (*patternSlice)[index]
		pcs.recurseMatchPathByShellPattern(index+1, patternSlice, ps, pcspaths)
		return
	}

	fds, pcsError := pcs.FilesDirectoriesList(strings.Join((*ps)[:index], PathSeparator), DefaultOrderOptions)
	if pcsError != nil {
		panic(pcsError) // æŠ›å‡ºå¼‚å¸¸
	}

	for k := range fds {
		if matched, _ := path.Match((*patternSlice)[index], fds[k].Filename); matched {
			(*ps)[index] = fds[k].Filename
			pcs.recurseMatchPathByShellPattern(index+1, patternSlice, ps, pcspaths)
		}
	}
	return
}

// MatchPathByShellPattern é€šé…ç¬¦åŒ¹é…æ–‡ä»¶è·¯å¾„, pattern ä¸ºç»å¯¹è·¯å¾„
func (pcs *BaiduPCS) MatchPathByShellPattern(pattern string) (pcspaths []string, pcsError pcserror.Error) {
	errInfo := pcserror.NewPCSErrorInfo(OperrationMatchPathByShellPattern)
	errInfo.ErrType = pcserror.ErrTypeOthers

	patternSlice := strings.Split(escaper.Escape(path.Clean(pattern), []rune{'['}), PathSeparator) // è½¬ä¹‰ä¸­æ‹¬å·
	if patternSlice[0] != "" {
		errInfo.Err = ErrMatchPathByShellPatternNotAbsPath
		return nil, errInfo
	}

	ps := make([]string, len(patternSlice))
	defer func() { // æ•è·å¼‚å¸¸
		if err := recover(); err != nil {
			pcspaths = nil
			pcsError = err.(pcserror.Error)
		}
	}()
	pcs.recurseMatchPathByShellPattern(1, &patternSlice, &ps, &pcspaths)
	return pcspaths, nil
}



================================================
FILE: baidupcs/file_directory.go
================================================
package baidupcs

import (
	"errors"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/pcstime"
	"github.com/olekukonko/tablewriter"
	"strconv"
	"strings"
	"unsafe"
)

type (
	// OrderBy æ’åºå­—æ®µ
	OrderBy string
	// Order å‡åºé™åº
	Order string
)

const (
	// OrderByName æ ¹æ®æ–‡ä»¶åæ’åº
	OrderByName OrderBy = "name"
	// OrderByTime æ ¹æ®æ—¶é—´æ’åº
	OrderByTime OrderBy = "time"
	// OrderBySize æ ¹æ®å¤§å°æ’åº, æ³¨æ„ç›®å½•æ— å¤§å°
	OrderBySize OrderBy = "size"
	// OrderAsc å‡åº
	OrderAsc Order = "asc"
	// OrderDesc é™åº
	OrderDesc Order = "desc"
)

type (
	// HandleFileDirectoryFunc å¤„ç†æ–‡ä»¶æˆ–ç›®å½•çš„å…ƒä¿¡æ¯, è¿”å›å€¼æ§åˆ¶æ˜¯å¦é€€å‡ºé€’å½’
	HandleFileDirectoryFunc func(depth int, fdPath string, fd *FileDirectory, pcsError pcserror.Error) bool

	// FileDirectory æ–‡ä»¶æˆ–ç›®å½•çš„å…ƒä¿¡æ¯
	FileDirectory struct {
		FsID     int64  // fs_id
		AppID    int64  // app_id
		Path     string // è·¯å¾„
		Filename string // æ–‡ä»¶å æˆ– ç›®å½•å
		Ctime    int64  // åˆ›å»ºæ—¥æœŸ
		Mtime    int64  // ä¿®æ”¹æ—¥æœŸ
		MD5      string // md5 å€¼
		BlockListJSON
		Size        int64 // æ–‡ä»¶å¤§å° (ç›®å½•ä¸º0)
		Isdir       bool  // æ˜¯å¦ä¸ºç›®å½•
		Ifhassubdir bool  // æ˜¯å¦å«æœ‰å­ç›®å½• (åªå¯¹ç›®å½•æœ‰æ•ˆ)

		Parent   *FileDirectory    // çˆ¶ç›®å½•ä¿¡æ¯
		Children FileDirectoryList // å­ç›®å½•ä¿¡æ¯
	}

	// FileDirectoryList FileDirectory çš„ æŒ‡é’ˆæ•°ç»„
	FileDirectoryList []*FileDirectory

	// fdJSON ç”¨äºè§£æè¿œç¨‹JSONæ•°æ®
	fdJSON struct {
		FsID     int64  `json:"fs_id"` // fs_id
		AppID    int64  `json:"app_id"`
		Path     string `json:"path"`            // è·¯å¾„
		Filename string `json:"server_filename"` // æ–‡ä»¶å æˆ– ç›®å½•å
		Ctime    int64  `json:"ctime"`           // åˆ›å»ºæ—¥æœŸ
		Mtime    int64  `json:"mtime"`           // ä¿®æ”¹æ—¥æœŸ
		MD5      string `json:"md5"`             // md5 å€¼
		BlockListJSON
		Size           int64 `json:"size"` // æ–‡ä»¶å¤§å° (ç›®å½•ä¸º0)
		IsdirInt       int8  `json:"isdir"`
		IfhassubdirInt int8  `json:"ifhassubdir"`

		// å¯¹é½
		_ *fdJSON
		_ []*fdJSON
	}

	fdData struct {
		*pcserror.PCSErrInfo
		List FileDirectoryList
	}

	fdDataJSONExport struct {
		*pcserror.PCSErrInfo
		List []*fdJSON `json:"list"`
	}

	// OrderOptions åˆ—æ–‡ä»¶/ç›®å½•å¯é€‰é¡¹
	OrderOptions struct {
		By    OrderBy
		Order Order
	}
)

var (
	// DefaultOrderOptions é»˜è®¤çš„æ’åº
	DefaultOrderOptions = &OrderOptions{
		By:    OrderByName,
		Order: OrderAsc,
	}

	defaultOrderOptionsStr = fmt.Sprint(DefaultOrderOptions)
)

// FilesDirectoriesMeta è·å–å•ä¸ªæ–‡ä»¶/ç›®å½•çš„å…ƒä¿¡æ¯
func (pcs *BaiduPCS) FilesDirectoriesMeta(path string) (data *FileDirectory, pcsError pcserror.Error) {
	if path == "" {
		path = PathSeparator
	}

	fds, err := pcs.FilesDirectoriesBatchMeta(path)
	if err != nil {
		return nil, err
	}

	// è¿”å›äº†å¤šæ¡å…ƒä¿¡æ¯
	if len(fds) != 1 {
		return nil, &pcserror.PCSErrInfo{
			Operation: OperationFilesDirectoriesMeta,
			ErrType:   pcserror.ErrTypeOthers,
			Err:       errors.New("æœªçŸ¥è¿”å›æ•°æ®"),
		}
	}

	return fds[0], nil
}

// FilesDirectoriesBatchMeta è·å–å¤šä¸ªæ–‡ä»¶/ç›®å½•çš„å…ƒä¿¡æ¯
func (pcs *BaiduPCS) FilesDirectoriesBatchMeta(paths ...string) (data FileDirectoryList, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareFilesDirectoriesBatchMeta(paths...)
	if pcsError != nil {
		return nil, pcsError
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPCSErrorInfo(OperationFilesDirectoriesMeta)
	// æœåŠ¡å™¨è¿”å›æ•°æ®è¿›è¡Œå¤„ç†
	jsonData := fdData{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationFilesDirectoriesMeta, dataReadCloser, (*fdDataJSONExport)(unsafe.Pointer(&jsonData)))
	if pcsError != nil {
		return
	}

	// ä¿®å¤MD5
	jsonData.List.fixMD5()

	data = jsonData.List
	return
}

// FilesDirectoriesList è·å–ç›®å½•ä¸‹çš„æ–‡ä»¶å’Œç›®å½•åˆ—è¡¨
func (pcs *BaiduPCS) FilesDirectoriesList(path string, options *OrderOptions) (data FileDirectoryList, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareFilesDirectoriesList(path, options)
	if pcsError != nil {
		return nil, pcsError
	}

	defer dataReadCloser.Close()

	jsonData := fdData{
		PCSErrInfo: pcserror.NewPCSErrorInfo(OperationFilesDirectoriesList),
	}

	pcsError = pcserror.HandleJSONParse(OperationFilesDirectoriesList, dataReadCloser, (*fdDataJSONExport)(unsafe.Pointer(&jsonData)))
	if pcsError != nil {
		return nil, pcsError
	}

	// ä¿®å¤MD5
	jsonData.List.fixMD5()

	data = jsonData.List
	return
}

// Search æŒ‰æ–‡ä»¶åæœç´¢æ–‡ä»¶, ä¸æ”¯æŒæŸ¥æ‰¾ç›®å½•
func (pcs *BaiduPCS) Search(targetPath, keyword string, recursive bool) (fdl FileDirectoryList, pcsError pcserror.Error) {
	if targetPath == "" {
		targetPath = PathSeparator
	}

	dataReadCloser, pcsError := pcs.PrepareSearch(targetPath, keyword, recursive)
	if pcsError != nil {
		return nil, pcsError
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPCSErrorInfo(OperationSearch)
	jsonData := fdData{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationSearch, dataReadCloser, (*fdDataJSONExport)(unsafe.Pointer(&jsonData)))
	if pcsError != nil {
		return
	}

	// ä¿®å¤MD5
	jsonData.List.fixMD5()

	fdl = jsonData.List
	return
}

func (pcs *BaiduPCS) recurseList(path string, depth int, options *OrderOptions, handleFileDirectoryFunc HandleFileDirectoryFunc) (fdl FileDirectoryList, ok bool) {
	fdl, pcsError := pcs.FilesDirectoriesList(path, options)
	if pcsError != nil {
		ok := handleFileDirectoryFunc(depth, path, nil, pcsError) // ä¼ é€’é”™è¯¯
		return nil, ok
	}

	for k := range fdl {
		ok = handleFileDirectoryFunc(depth+1, fdl[k].Path, fdl[k], nil)
		if !ok {
			return
		}

		if !fdl[k].Isdir {
			continue
		}

		fdl[k].Children, ok = pcs.recurseList(fdl[k].Path, depth+1, options, handleFileDirectoryFunc)
		if !ok {
			return
		}
	}

	return fdl, true
}

// FilesDirectoriesRecurseList é€’å½’è·å–ç›®å½•ä¸‹çš„æ–‡ä»¶å’Œç›®å½•åˆ—è¡¨
func (pcs *BaiduPCS) FilesDirectoriesRecurseList(path string, options *OrderOptions, handleFileDirectoryFunc HandleFileDirectoryFunc) (data FileDirectoryList) {
	fd, pcsError := pcs.FilesDirectoriesMeta(path)
	if pcsError != nil {
		handleFileDirectoryFunc(0, path, nil, pcsError) // ä¼ é€’é”™è¯¯
		return nil
	}

	if !fd.Isdir { // ä¸æ˜¯ä¸€ä¸ªç›®å½•
		handleFileDirectoryFunc(0, path, fd, nil)
		return FileDirectoryList{fd}
	}

	data, _ = pcs.recurseList(path, 0, options, handleFileDirectoryFunc)
	return data
}

// fixMD5 å°è¯•ä¿®å¤MD5å­—æ®µ
// æœåŠ¡å™¨è¿”å›çš„MD5å­—æ®µä¸ä¸€å®šæ­£ç¡®äº†, å³æ˜¯BlockListåªæœ‰ä¸€ä¸ªmd5
// MD5å­—æ®µä½¿ç”¨BlockListä¸­çš„md5
func (f *FileDirectory) fixMD5() {
	if len(f.BlockList) != 1 {
		return
	}
	f.MD5 = f.BlockList[0]
}

func (f *FileDirectory) String() string {
	builder := &strings.Builder{}
	tb := pcstable.NewTable(builder)
	tb.SetColumnAlignment([]int{tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT})

	if f.Isdir {
		tb.AppendBulk([][]string{
			[]string{"ç±»å‹", "ç›®å½•"},
			[]string{"ç›®å½•è·¯å¾„", f.Path},
			[]string{"ç›®å½•åç§°", f.Filename},
		})
	} else {
		var md5info string
		if len(f.BlockList) > 1 {
			md5info = "md5 (å¯èƒ½ä¸æ­£ç¡®)"
		} else {
			md5info = "md5 (æˆªå›¾è¯·æ‰“ç )"
		}
		tb.AppendBulk([][]string{
			[]string{"ç±»å‹", "æ–‡ä»¶"},
			[]string{"æ–‡ä»¶è·¯å¾„", f.Path},
			[]string{"æ–‡ä»¶åç§°", f.Filename},
			[]string{"æ–‡ä»¶å¤§å°", strconv.FormatInt(f.Size, 10) + ", " + converter.ConvertFileSize(f.Size)},
			[]string{md5info, f.MD5},
		})
	}

	tb.Append([]string{"app_id", strconv.FormatInt(f.AppID, 10)})
	tb.Append([]string{"fs_id", strconv.FormatInt(f.FsID, 10)})
	tb.AppendBulk([][]string{
		[]string{"åˆ›å»ºæ—¥æœŸ", pcstime.FormatTime(f.Ctime)},
		[]string{"ä¿®æ”¹æ—¥æœŸ", pcstime.FormatTime(f.Mtime)},
	})

	if f.Ifhassubdir {
		tb.Append([]string{"æ˜¯å¦å«æœ‰å­ç›®å½•", "true"})
	}

	tb.Render()
	return builder.String()
}

func (fl FileDirectoryList) fixMD5() {
	for _, v := range fl {
		v.fixMD5()
	}
}

// TotalSize è·å–ç›®å½•ä¸‹æ–‡ä»¶çš„æ€»å¤§å°
func (fl FileDirectoryList) TotalSize() int64 {
	var size int64
	for k := range fl {
		if fl[k] == nil {
			continue
		}

		size += fl[k].Size

		// é€’å½’è·å–
		if fl[k].Children != nil {
			size += fl[k].Children.TotalSize()
		}
	}
	return size
}

// Count è·å–æ–‡ä»¶æ€»æ•°å’Œç›®å½•æ€»æ•°
func (fl FileDirectoryList) Count() (fileN, directoryN int64) {
	for k := range fl {
		if fl[k] == nil {
			continue
		}

		if fl[k].Isdir {
			directoryN++
		} else {
			fileN++
		}

		// é€’å½’è·å–
		if fl[k].Children != nil {
			fN, dN := fl[k].Children.Count()
			fileN += fN
			directoryN += dN
		}
	}
	return
}

// AllFilePaths è¿”å›æ‰€æœ‰çš„ç½‘ç›˜è·¯å¾„, åŒ…æ‹¬å­ç›®å½•
func (fl FileDirectoryList) AllFilePaths() (pcspaths []string) {
	fN, dN := fl.Count()
	pcspaths = make([]string, 0, fN+dN)
	for k := range fl {
		if fl[k] == nil {
			continue
		}

		pcspaths = append(pcspaths, fl[k].Path)

		if fl[k].Children != nil {
			pcspaths = append(pcspaths, fl[k].Children.AllFilePaths()...)
		}
	}
	return
}



================================================
FILE: baidupcs/jsontable.go
================================================
package baidupcs

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/json-iterator/go"
	"path"
	"strconv"
	"strings"
)

type (
	// PathJSON ç½‘ç›˜è·¯å¾„
	PathJSON struct {
		Path string `json:"path"`
	}

	// PathsListJSON ç½‘ç›˜è·¯å¾„åˆ—è¡¨
	PathsListJSON struct {
		List []*PathJSON `json:"list"`
	}

	// FsIDJSON æ–‡ä»¶æˆ–ç›®å½•ID
	FsIDJSON struct {
		FsID int64 `json:"fs_id"` // fs_id
	}

	// FsIDListJSON fs_id åˆ—è¡¨
	FsIDListJSON struct {
		List []*FsIDJSON `json:"list"`
	}

	// CpMvJSON æºæ–‡ä»¶ç›®å½•çš„åœ°å€å’Œç›®æ ‡æ–‡ä»¶ç›®å½•çš„åœ°å€
	CpMvJSON struct {
		From string `json:"from"` // æºæ–‡ä»¶æˆ–ç›®å½•
		To   string `json:"to"`   // ç›®æ ‡æ–‡ä»¶æˆ–ç›®å½•
	}

	// CpMvJSONList CpMvJSON åˆ—è¡¨
	CpMvJSONList []*CpMvJSON

	// CpMvListJSON []*CpMvJSON å¯¹è±¡æ•°ç»„
	CpMvListJSON struct {
		List CpMvJSONList `json:"list"`
	}

	// BlockListJSON æ–‡ä»¶åˆ†å—ä¿¡æ¯JSON
	BlockListJSON struct {
		BlockList []string `json:"block_list"`
	}
)

var (
	// ErrNilJSONValue è§£æå‡ºçš„jsonå€¼ä¸ºç©º
	ErrNilJSONValue = errors.New("json value is nil")
)

// JSON json æ•°æ®æ„é€ 
func (plj *PathsListJSON) JSON(paths ...string) (data []byte, err error) {
	plj.List = make([]*PathJSON, len(paths))

	for k := range paths {
		plj.List[k] = &PathJSON{
			Path: paths[k],
		}
	}

	data, err = jsoniter.Marshal(plj)
	return
}

// JSON json æ•°æ®æ„é€ 
func (cj *CpMvJSON) JSON() (data []byte, err error) {
	data, err = jsoniter.Marshal(cj)
	return
}

// JSON json æ•°æ®æ„é€ 
func (clj *CpMvListJSON) JSON() (data []byte, err error) {
	data, err = jsoniter.Marshal(clj)
	return
}

func (clj *CpMvListJSON) String() string {
	builder := &strings.Builder{}

	tb := pcstable.NewTable(builder)
	tb.SetHeader([]string{"#", "åŸè·¯å¾„", "ç›®æ ‡è·¯å¾„"})

	for k := range clj.List {
		if clj.List[k] == nil {
			continue
		}
		tb.Append([]string{strconv.Itoa(k), clj.List[k].From, clj.List[k].To})
	}

	tb.Render()
	return builder.String()
}

// AllRelatedDir è·å–æ‰€æœ‰ç›¸å…³çš„ç›®å½•
func (cjl *CpMvJSONList) AllRelatedDir() (dirs []string) {
	for _, cj := range *cjl {
		fromDir, toDir := path.Dir(cj.From), path.Dir(cj.To)
		if !pcsutil.ContainsString(dirs, fromDir) {
			dirs = append(dirs, fromDir)
		}
		if !pcsutil.ContainsString(dirs, toDir) {
			dirs = append(dirs, toDir)
		}
	}
	return
}



================================================
FILE: baidupcs/prepare.go
================================================
package baidupcs

import (
	"bytes"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/netdisksign"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/requester/multipartreader"
	"github.com/felixonmars/baidu-tools/tieba"
	"github.com/json-iterator/go"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"unsafe"
)

type (
	reqType int
)

const (
	reqTypePCS = iota
	reqTypePan
)

func handleRespClose(resp *http.Response) error {
	if resp != nil {
		return resp.Body.Close()
	}
	return nil
}

func handleRespStatusError(opreation string, resp *http.Response) pcserror.Error {
	errInfo := pcserror.NewPCSErrorInfo(opreation)
	// http å“åº”é”™è¯¯å¤„ç†
	switch resp.StatusCode / 100 {
	case 4, 5:
		resp.Body.Close()
		errInfo.SetNetError(fmt.Errorf("http å“åº”é”™è¯¯, %s", resp.Status))
		return errInfo
	}

	return nil
}

func (pcs *BaiduPCS) sendReqReturnResp(rt reqType, op, method, urlStr string, post interface{}, header map[string]string) (resp *http.Response, pcsError pcserror.Error) {
	if header == nil {
		header = map[string]string{}
	}

	var (
		_, uaok = header["User-Agent"]
	)

	if !uaok {
		switch rt {
		case reqTypePCS:
			header["User-Agent"] = pcs.pcsUA
		case reqTypePan:
			header["User-Agent"] = pcs.panUA
		}
	}

	resp, err := pcs.client.Req(method, urlStr, post, header)
	if err != nil {
		handleRespClose(resp)
		switch rt {
		case reqTypePCS:
			return nil, &pcserror.PCSErrInfo{
				Operation: op,
				ErrType:   pcserror.ErrTypeNetError,
				Err:       err,
			}
		case reqTypePan:
			return nil, &pcserror.PanErrorInfo{
				Operation: op,
				ErrType:   pcserror.ErrTypeNetError,
				Err:       err,
			}
		}
		panic("unreachable")
	}
	return resp, nil
}

func (pcs *BaiduPCS) sendReqReturnReadCloser(rt reqType, op, method, urlStr string, post interface{}, header map[string]string) (readCloser io.ReadCloser, pcsError pcserror.Error) {
	resp, pcsError := pcs.sendReqReturnResp(rt, op, method, urlStr, post, header)
	if pcsError != nil {
		return
	}
	return resp.Body, nil
}

// PrepareUK è·å–ç”¨æˆ· UK, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareUK() (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()

	query := url.Values{}
	query.Set("need_selfinfo", "1")

	panURL := &url.URL{
		Scheme:   "https",
		Host:     PanBaiduCom,
		Path:     "api/user/getinfo",
		RawQuery: query.Encode(),
	}

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationGetUK, http.MethodGet, panURL.String(), nil, nil)
	return
}

// PrepareQuotaInfo è·å–å½“å‰ç”¨æˆ·ç©ºé—´é…é¢ä¿¡æ¯, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareQuotaInfo() (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL := pcs.generatePCSURL("quota", "info")
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationQuotaInfo, pcsURL)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationQuotaInfo, http.MethodGet, pcsURL.String(), nil, nil)
	return
}

// PrepareFilesDirectoriesBatchMeta è·å–å¤šä¸ªæ–‡ä»¶/ç›®å½•çš„å…ƒä¿¡æ¯, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareFilesDirectoriesBatchMeta(paths ...string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	sendData, err := (&PathsListJSON{}).JSON(paths...)
	if err != nil {
		panic(OperationFilesDirectoriesMeta + ", json æ•°æ®æ„é€ å¤±è´¥, " + err.Error())
	}

	pcsURL := pcs.generatePCSURL("file", "meta")
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationFilesDirectoriesMeta, pcsURL)

	// è¡¨å•ä¸Šä¼ 
	mr := multipartreader.NewMultipartReader()
	mr.AddFormFeild("param", bytes.NewReader(sendData))
	mr.CloseMultipart()

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationFilesDirectoriesMeta, http.MethodPost, pcsURL.String(), mr, nil)
	return
}

// PrepareFilesDirectoriesList è·å–ç›®å½•ä¸‹çš„æ–‡ä»¶å’Œç›®å½•åˆ—è¡¨, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareFilesDirectoriesList(path string, options *OrderOptions) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	if options == nil {
		options = DefaultOrderOptions
	}
	if path == "" {
		path = PathSeparator
	}

	pcsURL := pcs.generatePCSURL("file", "list", map[string]string{
		"path":  path,
		"by":    *(*string)(unsafe.Pointer(&options.By)),
		"order": *(*string)(unsafe.Pointer(&options.Order)),
		"limit": "0-2147483647",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationFilesDirectoriesList, pcsURL)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationFilesDirectoriesList, http.MethodGet, pcsURL.String(), nil, nil)
	return
}

// PrepareSearch æŒ‰æ–‡ä»¶åæœç´¢æ–‡ä»¶, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareSearch(targetPath, keyword string, recursive bool) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	var re string
	if recursive {
		re = "1"
	} else {
		re = "0"
	}
	pcsURL := pcs.generatePCSURL("file", "search", map[string]string{
		"path": targetPath,
		"wd":   keyword,
		"re":   re,
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationSearch, pcsURL)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationSearch, http.MethodGet, pcsURL.String(), nil, nil)
	return
}

// PrepareRemove æ‰¹é‡åˆ é™¤æ–‡ä»¶/ç›®å½•, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareRemove(paths ...string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	sendData, err := (&PathsListJSON{}).JSON(paths...)
	if err != nil {
		panic(OperationMove + ", json æ•°æ®æ„é€ å¤±è´¥, " + err.Error())
	}

	pcsURL := pcs.generatePCSURL("file", "delete")
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationRemove, pcsURL)

	// è¡¨å•ä¸Šä¼ 
	mr := multipartreader.NewMultipartReader()
	mr.AddFormFeild("param", bytes.NewReader(sendData))
	mr.CloseMultipart()

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationRemove, http.MethodPost, pcsURL.String(), mr, nil)
	return
}

// PrepareMkdir åˆ›å»ºç›®å½•, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareMkdir(pcspath string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL := pcs.generatePCSURL("file", "mkdir", map[string]string{
		"path": pcspath,
	})
	baiduPCSVerbose.Infof("%s URL: %s", OperationMkdir, pcsURL)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationMkdir, http.MethodPost, pcsURL.String(), nil, nil)
	return
}

func (pcs *BaiduPCS) prepareCpMvOp(op string, cpmvJSON ...*CpMvJSON) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	var method string
	switch op {
	case OperationCopy:
		method = "copy"
	case OperationMove, OperationRename:
		method = "move"
	default:
		panic("Unknown opreation: " + op)
	}

	sendData, err := (&CpMvListJSON{
		List: cpmvJSON,
	}).JSON()
	if err != nil {
		//json æ•°æ®ç”Ÿæˆå¤±è´¥
		panic(err)
	}

	pcsURL := pcs.generatePCSURL("file", method)
	baiduPCSVerbose.Infof("%s URL: %s\n", op, pcsURL)

	// è¡¨å•ä¸Šä¼ 
	mr := multipartreader.NewMultipartReader()
	mr.AddFormFeild("param", bytes.NewReader(sendData))
	mr.CloseMultipart()

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, op, http.MethodPost, pcsURL.String(), mr, nil)
	return
}

// PrepareRename é‡å‘½åæ–‡ä»¶/ç›®å½•, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareRename(from, to string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	return pcs.prepareCpMvOp(OperationRename, &CpMvJSON{
		From: from,
		To:   to,
	})
}

// PrepareCopy æ‰¹é‡æ‹·è´æ–‡ä»¶/ç›®å½•, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareCopy(cpmvJSON ...*CpMvJSON) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	return pcs.prepareCpMvOp(OperationCopy, cpmvJSON...)
}

// PrepareMove æ‰¹é‡ç§»åŠ¨æ–‡ä»¶/ç›®å½•, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareMove(cpmvJSON ...*CpMvJSON) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	return pcs.prepareCpMvOp(OperationMove, cpmvJSON...)
}

// prepareRapidUpload ç§’ä¼ æ–‡ä»¶, ä¸è¿›è¡Œæ–‡ä»¶å¤¹æ£€æŸ¥
func (pcs *BaiduPCS) prepareRapidUpload(targetPath, contentMD5, sliceMD5, crc32 string, length int64) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL := pcs.generatePCSURL("file", "rapidupload", map[string]string{
		"path":           targetPath,                    // ä¸Šä¼ æ–‡ä»¶çš„å…¨è·¯å¾„å
		"content-length": strconv.FormatInt(length, 10), // å¾…ç§’ä¼ çš„æ–‡ä»¶é•¿åº¦
		"content-md5":    contentMD5,                    // å¾…ç§’ä¼ çš„æ–‡ä»¶çš„MD5
		"slice-md5":      sliceMD5,                      // å¾…ç§’ä¼ çš„æ–‡ä»¶å‰256kbçš„MD5
		"content-crc32":  crc32,                         // å¾…ç§’ä¼ æ–‡ä»¶CRC32
		"ondup":          "overwrite",                   // overwrite: è¡¨ç¤ºè¦†ç›–åŒåæ–‡ä»¶; newcopy: è¡¨ç¤ºç”Ÿæˆæ–‡ä»¶å‰¯æœ¬å¹¶è¿›è¡Œé‡å‘½åï¼Œå‘½åè§„åˆ™ä¸ºâ€œæ–‡ä»¶å_æ—¥æœŸ.åç¼€â€
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationRapidUpload, pcsURL)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationRapidUpload, http.MethodGet, pcsURL.String(), nil, nil)
	return
}

// PrepareRapidUpload ç§’ä¼ æ–‡ä»¶, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareRapidUpload(targetPath, contentMD5, sliceMD5, crc32 string, length int64) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsError = pcs.checkIsdir(OperationRapidUpload, targetPath)
	if pcsError != nil {
		return nil, pcsError
	}

	return pcs.prepareRapidUpload(targetPath, contentMD5, sliceMD5, crc32, length)
}

// PrepareLocateDownload è·å–ä¸‹è½½é“¾æ¥, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareLocateDownload(pcspath string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	bduss := pcs.GetBDUSS()
	// æ£€æµ‹uid
	if pcs.uid == 0 {
		t, err := tieba.NewUserInfoByBDUSS(bduss)
		if err != nil {
			return nil, &pcserror.PCSErrInfo{
				Operation: OperationLocateDownload,
				ErrType:   pcserror.ErrTypeNetError,
				Err:       err,
			}
		}
		pcs.uid = t.Baidu.UID
	}

	ns := netdisksign.NewLocateDownloadSign(pcs.uid, bduss)
	pcsURL := &url.URL{
		Scheme: GetHTTPScheme(pcs.isHTTPS),
		Host:   PCSBaiduCom,
		Path:   "/rest/2.0/pcs/file",
		RawQuery: (url.Values{
			"app_id": []string{PanAppID},
			"method": []string{"locatedownload"},
			"path":   []string{pcspath},
			"ver":    []string{"2"},
		}).Encode() + "&" + ns.URLParam(),
	}
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationLocateDownload, pcsURL)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationLocateDownload, http.MethodGet, pcsURL.String(), nil, pcs.getPanUAHeader())
	return
}

// PrepareLocatePanAPIDownload ä»ç™¾åº¦ç½‘ç›˜é¦–é¡µè·å–ä¸‹è½½é“¾æ¥, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareLocatePanAPIDownload(fidList ...int64) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()
	// åˆå§‹åŒ–
	var (
		sign, err = pcs.ph.CacheSignature()
	)
	if err != nil {
		return nil, &pcserror.PanErrorInfo{
			Operation: OperationLocatePanAPIDownload,
			ErrType:   pcserror.ErrTypeOthers,
			Err:       err,
		}
	}

	panURL := pcs.generatePanURL("download", nil)
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationLocatePanAPIDownload, panURL)

	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationLocatePanAPIDownload, http.MethodPost, panURL.String(), map[string]string{
		"sign":      sign.Sign(),
		"timestamp": sign.Timestamp(),
		"fidlist":   mergeInt64List(fidList...),
	}, map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
	})
	return
}

// PrepareUpload ä¸Šä¼ å•ä¸ªæ–‡ä»¶, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareUpload(targetPath string, uploadFunc UploadFunc) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsError = pcs.checkIsdir(OperationUpload, targetPath)
	if pcsError != nil {
		return nil, pcsError
	}

	pcsURL := pcs.generatePCSURL("file", "upload", map[string]string{
		"path":  targetPath,
		"ondup": "overwrite",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationUpload, pcsURL)

	resp, err := uploadFunc(pcsURL.String(), pcs.client.Jar)
	if err != nil {
		handleRespClose(resp)
		return nil, &pcserror.PCSErrInfo{
			Operation: OperationUpload,
			ErrType:   pcserror.ErrTypeNetError,
			Err:       err,
		}
	}

	pcsError = handleRespStatusError(OperationUpload, resp)
	if pcsError != nil {
		return
	}

	return resp.Body, nil
}

// PrepareUploadTmpFile åˆ†ç‰‡ä¸Šä¼ â€”æ–‡ä»¶åˆ†ç‰‡åŠä¸Šä¼ , åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareUploadTmpFile(uploadFunc UploadFunc) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL := pcs.generatePCSURL("file", "upload", map[string]string{
		"type": "tmpfile",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationUploadTmpFile, pcsURL)

	resp, err := uploadFunc(pcsURL.String(), pcs.client.Jar)
	if err != nil {
		handleRespClose(resp)
		return nil, &pcserror.PCSErrInfo{
			Operation: OperationUploadTmpFile,
			ErrType:   pcserror.ErrTypeNetError,
			Err:       err,
		}
	}

	pcsError = handleRespStatusError(OperationUploadTmpFile, resp)
	if pcsError != nil {
		return
	}

	return resp.Body, nil
}

// PrepareUploadCreateSuperFile åˆ†ç‰‡ä¸Šä¼ â€”åˆå¹¶åˆ†ç‰‡æ–‡ä»¶, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareUploadCreateSuperFile(checkDir bool, targetPath string, blockList ...string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()

	if checkDir {
		// æ£€æŸ¥æ˜¯å¦ä¸ºç›®å½•
		pcsError = pcs.checkIsdir(OperationUploadCreateSuperFile, targetPath)
		if pcsError != nil {
			return nil, pcsError
		}
	}

	bl := BlockListJSON{
		BlockList: blockList,
	}

	sendData, err := jsoniter.Marshal(&bl)
	if err != nil {
		panic(err)
	}

	pcsURL := pcs.generatePCSURL("file", "createsuperfile", map[string]string{
		"path":  targetPath,
		"ondup": "overwrite",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationUploadCreateSuperFile, pcsURL)

	// è¡¨å•ä¸Šä¼ 
	mr := multipartreader.NewMultipartReader()
	mr.AddFormFeild("param", bytes.NewReader(sendData))
	mr.CloseMultipart()

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationUploadCreateSuperFile, http.MethodPost, pcsURL.String(), mr, nil)
	return
}

// PrepareUploadPrecreate åˆ†ç‰‡ä¸Šä¼ â€”Precreate, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareUploadPrecreate(targetPath, contentMD5, sliceMD5, crc32 string, size int64, bolckList ...string) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()
	panURL := &url.URL{
		Scheme: "https",
		Host:   PanBaiduCom,
		Path:   "api/precreate",
	}
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationUploadPrecreate, panURL)

	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationUploadPrecreate, http.MethodPost, panURL.String(), map[string]string{
		"path":         targetPath,
		"size":         strconv.FormatInt(size, 10),
		"isdir":        "0",
		"block_list":   mergeStringList(bolckList...),
		"autoinit":     "1",
		"content-md5":  contentMD5,
		"slice-md5":    sliceMD5,
		"contentCrc32": crc32,
		"rtype":        "2",
	}, map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
	})
	return
}

// PrepareUploadSuperfile2 å¦ä¸€ä¸ªä¸Šä¼ æ¥å£
func (pcs *BaiduPCS) PrepareUploadSuperfile2(uploadid, targetPath string, partseq int, partOffset int64, uploadFunc UploadFunc) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL := pcs.generatePCSURL("superfile2", "upload", map[string]string{
		"type":       "tmpfile",
		"path":       targetPath,
		"partseq":    strconv.Itoa(partseq),
		"partoffset": strconv.FormatInt(partOffset, 10),
		"uploadid":   uploadid,
		"vip":        "1",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationUploadSuperfile2, pcsURL)

	resp, err := uploadFunc(pcsURL.String(), pcs.client.Jar)
	if err != nil {
		handleRespClose(resp)
		return nil, &pcserror.PCSErrInfo{
			Operation: OperationUploadSuperfile2,
			ErrType:   pcserror.ErrTypeNetError,
			Err:       err,
		}
	}

	pcsError = handleRespStatusError(OperationUpload, resp)
	if pcsError != nil {
		return
	}
	return resp.Body, nil
}

// PrepareCloudDlAddTask æ·»åŠ ç¦»çº¿ä¸‹è½½ä»»åŠ¡, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareCloudDlAddTask(sourceURL, savePath string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL2 := pcs.generatePCSURL2("services/cloud_dl", "add_task", map[string]string{
		"save_path":  savePath,
		"source_url": sourceURL,
		"timeout":    "2147483647",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationCloudDlAddTask, pcsURL2)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationCloudDlAddTask, http.MethodPost, pcsURL2.String(), nil, nil)
	return
}

// PrepareCloudDlQueryTask ç²¾ç¡®æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯,
// taskids ä¾‹å­: 12123,234234,2344, ç”¨é€—å·éš”å¼€å¤šä¸ª task_id
func (pcs *BaiduPCS) PrepareCloudDlQueryTask(taskIDs string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL2 := pcs.generatePCSURL2("services/cloud_dl", "query_task", map[string]string{
		"op_type": "1",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationCloudDlQueryTask, pcsURL2)

	// è¡¨å•ä¸Šä¼ 
	mr := multipartreader.NewMultipartReader()
	mr.AddFormFeild("task_ids", strings.NewReader(taskIDs))
	mr.CloseMultipart()

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationCloudDlQueryTask, http.MethodPost, pcsURL2.String(), mr, nil)
	return
}

// PrepareCloudDlListTask æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡åˆ—è¡¨, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareCloudDlListTask() (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL2 := pcs.generatePCSURL2("services/cloud_dl", "list_task", map[string]string{
		"need_task_info": "1",
		"status":         "255",
		"start":          "0",
		"limit":          "1000",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationCloudDlListTask, pcsURL2)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationCloudDlListTask, http.MethodPost, pcsURL2.String(), nil, nil)
	return
}

func (pcs *BaiduPCS) prepareCloudDlCDTask(opreation, method string, taskID int64) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL2 := pcs.generatePCSURL2("services/cloud_dl", method, map[string]string{
		"task_id": strconv.FormatInt(taskID, 10),
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", opreation, pcsURL2)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, opreation, http.MethodPost, pcsURL2.String(), nil, nil)
	return
}

// PrepareCloudDlCancelTask å–æ¶ˆç¦»çº¿ä¸‹è½½ä»»åŠ¡, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareCloudDlCancelTask(taskID int64) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	return pcs.prepareCloudDlCDTask(OperationCloudDlCancelTask, "cancel_task", taskID)
}

// PrepareCloudDlDeleteTask å–æ¶ˆç¦»çº¿ä¸‹è½½ä»»åŠ¡, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareCloudDlDeleteTask(taskID int64) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	return pcs.prepareCloudDlCDTask(OperationCloudDlDeleteTask, "delete_task", taskID)
}

// PrepareCloudDlClearTask æ¸…ç©ºç¦»çº¿ä¸‹è½½ä»»åŠ¡è®°å½•, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareCloudDlClearTask() (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL2 := pcs.generatePCSURL2("services/cloud_dl", "clear_task")
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationCloudDlClearTask, pcsURL2)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationCloudDlClearTask, http.MethodPost, pcsURL2.String(), nil, nil)
	return
}

// PrepareSharePSet ç§å¯†åˆ†äº«æ–‡ä»¶, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareSharePSet(paths []string, period int) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()
	panURL := &url.URL{
		Scheme: "https",
		Host:   PanBaiduCom,
		Path:   "share/pset",
	}
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationShareSet, panURL)

	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationShareSet, http.MethodPost, panURL.String(), map[string]string{
		"path_list":    mergeStringList(paths...),
		"schannel":     "0",
		"channel_list": "[]",
		"period":       strconv.Itoa(period),
	}, map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
	})
	return
}

// PrepareShareCancel å–æ¶ˆåˆ†äº«, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareShareCancel(shareIDs []int64) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()
	panURL := &url.URL{
		Scheme: "https",
		Host:   PanBaiduCom,
		Path:   "share/cancel",
	}

	baiduPCSVerbose.Infof("%s URL: %s\n", OperationShareCancel, panURL)

	ss := converter.SliceInt64ToString(shareIDs)
	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationShareCancel, http.MethodPost, panURL.String(), map[string]string{
		"shareid_list": "[" + strings.Join(ss, ",") + "]",
	}, map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
	})
	return
}

// PrepareShareList åˆ—å‡ºåˆ†äº«åˆ—è¡¨, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareShareList(page int) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()

	query := url.Values{}
	query.Set("page", strconv.Itoa(page))
	query.Set("desc", "1")
	query.Set("order", "time")

	panURL := &url.URL{
		Scheme:   "https",
		Host:     PanBaiduCom,
		Path:     "share/record",
		RawQuery: query.Encode(),
	}
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationShareList, panURL)

	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationShareList, http.MethodGet, panURL.String(), nil, nil)
	return
}

// PrepareShareSURLInfo è·å–åˆ†äº«çš„è¯¦ç»†ä¿¡æ¯, åŒ…å«å¯†ç , åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareShareSURLInfo(shareID int64) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()

	query := url.Values{}
	query.Set("shareid", strconv.FormatInt(shareID, 10))
	query.Set("sign", converter.ToString(netdisksign.ShareSURLInfoSign(shareID)))

	panURL := &url.URL{
		Scheme:   "https",
		Host:     PanBaiduCom,
		Path:     "share/surlinfoinrecord",
		RawQuery: query.Encode(),
	}
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationShareSURLInfo, panURL)

	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationShareSURLInfo, http.MethodGet, panURL.String(), nil, nil)
	return
}

// PrepareRecycleList åˆ—å‡ºå›æ”¶ç«™æ–‡ä»¶åˆ—è¡¨, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareRecycleList(page int) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()

	panURL := pcs.generatePanURL("recycle/list", map[string]string{
		"num":  "100",
		"page": strconv.Itoa(page),
	})

	baiduPCSVerbose.Infof("%s URL: %s\n", OperationRecycleList, panURL)

	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationRecycleList, http.MethodGet, panURL.String(), nil, nil)
	return
}

// PrepareRecycleRestore è¿˜åŸå›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareRecycleRestore(fidList ...int64) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()

	pcsURL := pcs.generatePCSURL("file", "restore")
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationRecycleRestore, pcsURL)

	fsIDList := make([]*FsIDJSON, 0, len(fidList))
	for k := range fidList {
		fsIDList = append(fsIDList, &FsIDJSON{
			FsID: fidList[k],
		})
	}
	fsIDListJSON := FsIDListJSON{
		List: fsIDList,
	}

	sendData, err := jsoniter.Marshal(&fsIDListJSON)
	if err != nil {
		panic(err)
	}

	// è¡¨å•ä¸Šä¼ 
	mr := multipartreader.NewMultipartReader()
	mr.AddFormFeild("param", bytes.NewReader(sendData))
	mr.CloseMultipart()

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationRecycleRestore, http.MethodPost, pcsURL.String(), mr, nil)
	return
}

// PrepareRecycleDelete åˆ é™¤å›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareRecycleDelete(fidList ...int64) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()

	panURL := pcs.generatePanURL("recycle/delete", nil)
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationRecycleDelete, panURL)

	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationRecycleDelete, http.MethodPost, panURL.String(), map[string]string{
		"fidlist": mergeInt64List(fidList...),
	}, map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
	})
	return
}

// PrepareRecycleClear æ¸…ç©ºå›æ”¶ç«™, åªè¿”å›æœåŠ¡å™¨å“åº”æ•°æ®å’Œé”™è¯¯ä¿¡æ¯
func (pcs *BaiduPCS) PrepareRecycleClear() (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()

	pcsURL := pcs.generatePCSURL("file", "delete", map[string]string{
		"type": "recycle",
	})

	baiduPCSVerbose.Infof("%s URL: %s\n", OperationRecycleClear, pcsURL)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationRecycleClear, http.MethodGet, pcsURL.String(), nil, nil)
	return
}



================================================
FILE: baidupcs/publicsuffix.go
================================================
package baidupcs

import (
	"net/http/cookiejar"
	"strings"
)

type list struct{}

// PublicSuffixList baidupcs PublicSuffixList
var PublicSuffixList cookiejar.PublicSuffixList = list{}

func (list) PublicSuffix(domain string) string {
	if strings.HasSuffix(domain, ".baidu.com") {
		return "com"
	}
	return domain
}

func (list) String() string {
	return "baidupcs"
}



================================================
FILE: baidupcs/quota.go
================================================
package baidupcs

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
)

type quotaInfo struct {
	*pcserror.PCSErrInfo
	Quota int64 `json:"quota"`
	Used  int64 `json:"used"`
}

// QuotaInfo è·å–å½“å‰ç”¨æˆ·ç©ºé—´é…é¢ä¿¡æ¯
func (pcs *BaiduPCS) QuotaInfo() (quota, used int64, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareQuotaInfo()
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	quotaInfo := &quotaInfo{
		PCSErrInfo: pcserror.NewPCSErrorInfo(OperationQuotaInfo),
	}

	pcsError = pcserror.HandleJSONParse(OperationQuotaInfo, dataReadCloser, quotaInfo)
	if pcsError != nil {
		return
	}

	return quotaInfo.Quota, quotaInfo.Used, nil
}



================================================
FILE: baidupcs/recycle.go
================================================
package baidupcs

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
)

type (
	// RecycleFDInfo å›æ”¶ç«™ä¸­æ–‡ä»¶/ç›®å½•ä¿¡æ¯
	RecycleFDInfo struct {
		FsID     int64  `json:"fs_id"` // fs_id
		Isdir    int    `json:"isdir"`
		LeftTime int    `json:"leftTime"`        // å‰©ä½™æ—¶é—´
		Path     string `json:"path"`            // è·¯å¾„
		Filename string `json:"server_filename"` // æ–‡ä»¶å æˆ– ç›®å½•å
		Ctime    int64  `json:"server_ctime"`    // åˆ›å»ºæ—¥æœŸ
		Mtime    int64  `json:"server_mtime"`    // ä¿®æ”¹æ—¥æœŸ
		MD5      string `json:"md5"`             // md5 å€¼
		Size     int64  `json:"size"`            // æ–‡ä»¶å¤§å° (ç›®å½•ä¸º0)
	}

	// RecycleFDInfoList å›æ”¶ç«™ä¸­æ–‡ä»¶/ç›®å½•åˆ—è¡¨
	RecycleFDInfoList []*RecycleFDInfo

	recycleListJSON struct {
		*pcserror.PanErrorInfo
		List RecycleFDInfoList `json:"list"`
	}

	recycleRestoreJSON struct {
		*pcserror.PCSErrInfo
		Extra FsIDListJSON `json:"extra"`
	}

	// RecycleClearInfo æ¸…ç©ºå›æ”¶ç«™çš„ä¿¡æ¯
	RecycleClearInfo struct {
		List    RecycleFDInfoList `json:"list"`
		SussNum int               `json:"succNum"`
	}

	recycleClearJSON struct {
		*pcserror.PCSErrInfo
		Extra RecycleClearInfo `json:"extra"`
	}
)

// RecycleList åˆ—å‡ºå›æ”¶ç«™æ–‡ä»¶åˆ—è¡¨
func (pcs *BaiduPCS) RecycleList(page int) (fdl RecycleFDInfoList, panError pcserror.Error) {
	dataReadCloser, panError := pcs.PrepareRecycleList(page)
	if panError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPanErrorInfo(OperationRecycleList)
	jsonData := recycleListJSON{
		PanErrorInfo: errInfo,
	}

	panError = pcserror.HandleJSONParse(OperationRecycleList, dataReadCloser, &jsonData)
	if panError != nil {
		return
	}

	return jsonData.List, nil
}

// RecycleRestore è¿˜åŸå›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•
func (pcs *BaiduPCS) RecycleRestore(fidList ...int64) (sussFsIDList []*FsIDJSON, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareRecycleRestore(fidList...)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPCSErrorInfo(OperationRecycleRestore)
	jsonData := recycleRestoreJSON{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationRecycleRestore, dataReadCloser, &jsonData)
	return jsonData.Extra.List, pcsError
}

// RecycleDelete åˆ é™¤å›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•
func (pcs *BaiduPCS) RecycleDelete(fidList ...int64) (panError pcserror.Error) {
	dataReadCloser, panError := pcs.PrepareRecycleDelete(fidList...)
	if panError != nil {
		return
	}

	defer dataReadCloser.Close()

	panError = pcserror.DecodePanJSONError(OperationRecycleDelete, dataReadCloser)
	return
}

// RecycleClear æ¸…ç©ºå›æ”¶ç«™
func (pcs *BaiduPCS) RecycleClear() (sussNum int, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareRecycleClear()
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPCSErrorInfo(OperationRecycleClear)
	jsonData := recycleClearJSON{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationRecycleClear, dataReadCloser, &jsonData)
	return jsonData.Extra.SussNum, pcsError
}



================================================
FILE: baidupcs/rm_mkdir.go
================================================
package baidupcs

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"path"
)

// Remove æ‰¹é‡åˆ é™¤æ–‡ä»¶/ç›®å½•
func (pcs *BaiduPCS) Remove(paths ...string) (pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareRemove(paths...)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.DecodePCSJSONError(OperationRemove, dataReadCloser)
	if errInfo != nil {
		return errInfo
	}

	// æ›´æ–°ç¼“å­˜
	pcs.deleteCache(allRelatedDir(paths))
	return nil
}

// Mkdir åˆ›å»ºç›®å½•
func (pcs *BaiduPCS) Mkdir(pcspath string) (pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareMkdir(pcspath)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.DecodePCSJSONError(OperationMkdir, dataReadCloser)
	if errInfo != nil {
		return errInfo
	}

	// æ›´æ–°ç¼“å­˜
	pcs.deleteCache([]string{path.Dir(pcspath)})
	return
}



================================================
FILE: baidupcs/share.go
================================================
package baidupcs

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"strings"
)

type (
	// ShareOption åˆ†äº«å¯é€‰é¡¹
	ShareOption struct {
		Password string // å¯†ç 
		Period   int    // æœ‰æ•ˆæœŸ
	}

	// Shared åˆ†äº«ä¿¡æ¯
	Shared struct {
		Link    string `json:"link"`
		ShareID int64  `json:"shareid"`
	}

	// ShareRecordInfo åˆ†äº«ä¿¡æ¯
	ShareRecordInfo struct {
		ShareID         int64   `json:"shareId"`
		FsIds           []int64 `json:"fsIds"`
		Passwd          string  `json:"-"` // è¿™ä¸ªå­—æ®µå·²ç»æ²¡æœ‰ç”¨äº†, éœ€è¦ä»ShareSURLInfoä¸­è·å–
		Shortlink       string  `json:"shortlink"`
		Status          int     `json:"status"`          // çŠ¶æ€
		Public          int     `json:"public"`          // æ˜¯å¦ä¸ºå…¬å¼€åˆ†äº«
		TypicalCategory int     `json:"typicalCategory"` // æ–‡ä»¶ç±»å‹
		TypicalPath     string  `json:"typicalPath"`
	}

	shareSURLInfo struct {
		*pcserror.PanErrorInfo
		*ShareSURLInfo
	}

	// ShareSURLInfo åˆ†äº«çš„å­ä¿¡æ¯
	ShareSURLInfo struct {
		Pwd      string `json:"pwd"` // æ–°å¯†ç 
		ShortURL string `json:"shorturl"`
	}

	// ShareRecordInfoList åˆ†äº«ä¿¡æ¯åˆ—è¡¨
	ShareRecordInfoList []*ShareRecordInfo

	sharePSetJSON struct {
		*Shared
		*pcserror.PanErrorInfo
	}

	shareListJSON struct {
		List ShareRecordInfoList `json:"list"`
		*pcserror.PanErrorInfo
	}
)

var (
	// ErrShareLinkNotFound æœªæ‰¾åˆ°åˆ†äº«é“¾æ¥
	ErrShareLinkNotFound = errors.New("æœªæ‰¾åˆ°åˆ†äº«é“¾æ¥")
)

// ShareSet åˆ†äº«æ–‡ä»¶
func (pcs *BaiduPCS) ShareSet(paths []string, option *ShareOption) (s *Shared, pcsError pcserror.Error) {
	if option == nil {
		option = &ShareOption{}
	}

	dataReadCloser, pcsError := pcs.PrepareSharePSet(paths, option.Period)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPanErrorInfo(OperationShareSet)
	jsonData := sharePSetJSON{
		Shared:       &Shared{},
		PanErrorInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationShareSet, dataReadCloser, &jsonData)
	if pcsError != nil {
		return
	}

	if jsonData.Link == "" {
		errInfo.ErrType = pcserror.ErrTypeOthers
		errInfo.Err = ErrShareLinkNotFound
		return nil, errInfo
	}

	return jsonData.Shared, nil
}

// ShareCancel å–æ¶ˆåˆ†äº«
func (pcs *BaiduPCS) ShareCancel(shareIDs []int64) (pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareShareCancel(shareIDs)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	pcsError = pcserror.DecodePanJSONError(OperationShareCancel, dataReadCloser)
	return
}

// ShareList åˆ—å‡ºåˆ†äº«åˆ—è¡¨
func (pcs *BaiduPCS) ShareList(page int) (records ShareRecordInfoList, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareShareList(page)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPanErrorInfo(OperationShareList)
	jsonData := shareListJSON{
		List:         records,
		PanErrorInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationShareList, dataReadCloser, &jsonData)
	if pcsError != nil {
		// jsonè§£æé”™è¯¯
		if pcsError.GetErrType() == pcserror.ErrTypeJSONParseError {
			// æœåŠ¡å™¨æ›´æ”¹, Listä¸ºç©ºæ—¶å˜æˆ{}, å¯¼è‡´è§£æé”™è¯¯
			if strings.Contains(pcsError.GetError().Error(), `"list":{}`) {
				// è¿”å›ç©ºåˆ—è¡¨
				return jsonData.List, nil
			}
		}
		return
	}

	if jsonData.List == nil {
		errInfo.ErrType = pcserror.ErrTypeOthers
		errInfo.Err = errors.New("shared list is nil")
		return nil, errInfo
	}

	return jsonData.List, nil
}

//ShareSURLInfo è·å–åˆ†äº«çš„è¯¦ç»†ä¿¡æ¯, åŒ…å«å¯†ç 
func (pcs *BaiduPCS) ShareSURLInfo(shareID int64) (info *ShareSURLInfo, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareShareSURLInfo(shareID)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPanErrorInfo(OperationShareSURLInfo)

	jsonData := shareSURLInfo{
		PanErrorInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationShareList, dataReadCloser, &jsonData)
	if pcsError != nil {
		// jsonè§£æé”™è¯¯
		return
	}

	// å»æ‰0
	if jsonData.Pwd == "0" {
		jsonData.Pwd = ""
	}

	return jsonData.ShareSURLInfo, nil
}



================================================
FILE: baidupcs/upload.go
================================================
package baidupcs

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"net/http"
	"path"
)

const (
	// MaxUploadBlockSize æœ€å¤§ä¸Šä¼ çš„æ–‡ä»¶åˆ†ç‰‡å¤§å°
	MaxUploadBlockSize = 2 * converter.GB
	// MinUploadBlockSize æœ€å°çš„ä¸Šä¼ çš„æ–‡ä»¶åˆ†ç‰‡å¤§å°
	MinUploadBlockSize = 4 * converter.MB
	// MaxRapidUploadSize ç§’ä¼ æ–‡ä»¶æ”¯æŒçš„æœ€å¤§æ–‡ä»¶å¤§å°
	MaxRapidUploadSize = 20 * converter.GB
	// RecommendUploadBlockSize æ¨èçš„ä¸Šä¼ çš„æ–‡ä»¶åˆ†ç‰‡å¤§å°
	RecommendUploadBlockSize = 1 * converter.GB
	// SliceMD5Size è®¡ç®— slice-md5 æ‰€éœ€çš„é•¿åº¦
	SliceMD5Size = 256 * converter.KB
	// EmptyContentMD5 ç©ºä¸²çš„md5
	EmptyContentMD5 = "d41d8cd98f00b204e9800998ecf8427e"
)

var (
	// ErrUploadMD5NotFound æœªæ‰¾åˆ°md5
	ErrUploadMD5NotFound = errors.New("unknown response data, md5 not found")
	// ErrUploadSavePathFound æœªæ‰¾åˆ°ä¿å­˜è·¯å¾„
	ErrUploadSavePathFound = errors.New("unknown response data, file saved path not found")
	// ErrUploadSeqNotMatch æœåŠ¡å™¨è¿”å›çš„ä¸Šä¼ é˜Ÿåˆ—ä¸åŒ¹é…
	ErrUploadSeqNotMatch = errors.New("æœåŠ¡å™¨è¿”å›çš„ä¸Šä¼ é˜Ÿåˆ—ä¸åŒ¹é…")
)

type (
	// UploadFunc ä¸Šä¼ æ–‡ä»¶å¤„ç†å‡½æ•°
	UploadFunc func(uploadURL string, jar http.CookieJar) (resp *http.Response, err error)

	// RapidUploadInfo æ–‡ä»¶ç§’ä¼ ä¿¡æ¯
	RapidUploadInfo struct {
		Filename      string
		ContentLength int64
		ContentMD5    string
		SliceMD5      string
		ContentCrc32  string
	}

	uploadJSON struct {
		*PathJSON
		*pcserror.PCSErrInfo
	}

	uploadTmpFileJSON struct {
		MD5 string `json:"md5"`
		*pcserror.PCSErrInfo
	}

	uploadPrecreateJSON struct {
		ReturnType int    `json:"return_type"` // 1ä¸Šä¼ , 2ç§’ä¼ 
		UploadID   string `json:"uploadid"`
		BlockList  []int  `json:"block_list"`
		*pcserror.PanErrorInfo
		fdJSON `json:"info"`
	}

	// UploadSeq åˆ†ç‰‡ä¸Šä¼ é¡ºåº
	UploadSeq struct {
		Seq   int
		Block string
	}

	// PrecreateInfo é¢„æäº¤æ–‡ä»¶æ¶ˆæ¯è¿”å›æ•°æ®
	PrecreateInfo struct {
		IsRapidUpload bool
		UploadID      string
		UploadSeqList []*UploadSeq
	}

	uploadSuperfile2JSON struct {
		MD5 string `json:"md5"`
		*pcserror.PCSErrInfo
	}
)

// RapidUpload ç§’ä¼ æ–‡ä»¶
func (pcs *BaiduPCS) RapidUpload(targetPath, contentMD5, sliceMD5, crc32 string, length int64) (pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareRapidUpload(targetPath, contentMD5, sliceMD5, crc32, length)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	pcsError = pcserror.DecodePCSJSONError(OperationRapidUpload, dataReadCloser)
	if pcsError != nil {
		return
	}

	// æ›´æ–°ç¼“å­˜
	pcs.deleteCache([]string{path.Dir(targetPath)})
	return nil
}

// RapidUploadNoCheckDir ç§’ä¼ æ–‡ä»¶, ä¸è¿›è¡Œç›®å½•æ£€æŸ¥, ä¼šè¦†ç›–æ‰åŒåçš„ç›®å½•!
func (pcs *BaiduPCS) RapidUploadNoCheckDir(targetPath, contentMD5, sliceMD5, crc32 string, length int64) (pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.prepareRapidUpload(targetPath, contentMD5, sliceMD5, crc32, length)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	pcsError = pcserror.DecodePCSJSONError(OperationRapidUpload, dataReadCloser)
	if pcsError != nil {
		return
	}

	return nil
}

// Upload ä¸Šä¼ å•ä¸ªæ–‡ä»¶
func (pcs *BaiduPCS) Upload(targetPath string, uploadFunc UploadFunc) (pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareUpload(targetPath, uploadFunc)
	if pcsError != nil {
		return pcsError
	}

	defer dataReadCloser.Close()

	// æ•°æ®å¤„ç†
	jsonData := uploadJSON{
		PCSErrInfo: pcserror.NewPCSErrorInfo(OperationUpload),
	}

	pcsError = pcserror.HandleJSONParse(OperationUpload, dataReadCloser, &jsonData)
	if pcsError != nil {
		return
	}

	if jsonData.Path == "" {
		jsonData.PCSErrInfo.ErrType = pcserror.ErrTypeInternalError
		jsonData.PCSErrInfo.Err = ErrUploadSavePathFound
		return jsonData.PCSErrInfo
	}

	// æ›´æ–°ç¼“å­˜
	pcs.deleteCache([]string{path.Dir(targetPath)})
	return nil
}

// UploadTmpFile åˆ†ç‰‡ä¸Šä¼ â€”æ–‡ä»¶åˆ†ç‰‡åŠä¸Šä¼ 
func (pcs *BaiduPCS) UploadTmpFile(uploadFunc UploadFunc) (md5 string, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareUploadTmpFile(uploadFunc)
	if pcsError != nil {
		return "", pcsError
	}

	defer dataReadCloser.Close()

	// æ•°æ®å¤„ç†
	jsonData := uploadTmpFileJSON{
		PCSErrInfo: pcserror.NewPCSErrorInfo(OperationUploadTmpFile),
	}

	pcsError = pcserror.HandleJSONParse(OperationUploadTmpFile, dataReadCloser, &jsonData)
	if pcsError != nil {
		return
	}

	// æœªæ‰¾åˆ°md5
	if jsonData.MD5 == "" {
		jsonData.PCSErrInfo.ErrType = pcserror.ErrTypeInternalError
		jsonData.PCSErrInfo.Err = ErrUploadMD5NotFound
		return "", jsonData.PCSErrInfo
	}

	return jsonData.MD5, nil
}

// UploadCreateSuperFile åˆ†ç‰‡ä¸Šä¼ â€”åˆå¹¶åˆ†ç‰‡æ–‡ä»¶
func (pcs *BaiduPCS) UploadCreateSuperFile(checkDir bool, targetPath string, blockList ...string) (pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareUploadCreateSuperFile(checkDir, targetPath, blockList...)
	if pcsError != nil {
		return pcsError
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.DecodePCSJSONError(OperationUploadCreateSuperFile, dataReadCloser)
	if errInfo != nil {
		return errInfo
	}

	// æ›´æ–°ç¼“å­˜
	pcs.deleteCache([]string{path.Dir(targetPath)})
	return nil
}

// UploadPrecreate åˆ†ç‰‡ä¸Šä¼ â€”Precreate,
// æ”¯æŒæ£€éªŒç§’ä¼ 
func (pcs *BaiduPCS) UploadPrecreate(targetPath, contentMD5, sliceMD5, crc32 string, size int64, bolckList ...string) (precreateInfo *PrecreateInfo, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareUploadPrecreate(targetPath, contentMD5, sliceMD5, crc32, size, bolckList...)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPanErrorInfo(OperationUploadPrecreate)
	jsonData := uploadPrecreateJSON{
		PanErrorInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationUploadPrecreate, dataReadCloser, &jsonData)
	if pcsError != nil {
		return
	}

	switch jsonData.ReturnType {
	case 1: // ä¸Šä¼ 
		seqLen := len(jsonData.BlockList)
		if seqLen != len(bolckList) {
			errInfo.ErrType = pcserror.ErrTypeRemoteError
			errInfo.Err = ErrUploadSeqNotMatch
			return nil, errInfo
		}

		seqList := make([]*UploadSeq, 0, seqLen)
		for k, seq := range jsonData.BlockList {
			seqList = append(seqList, &UploadSeq{
				Seq:   seq,
				Block: bolckList[k],
			})
		}
		return &PrecreateInfo{
			UploadID:      jsonData.UploadID,
			UploadSeqList: seqList,
		}, nil

	case 2: // ç§’ä¼ 
		return &PrecreateInfo{
			IsRapidUpload: true,
		}, nil

	default:
		panic("unknown returntype")
	}
}

// UploadSuperfile2 åˆ†ç‰‡ä¸Šä¼ â€”Superfile2
func (pcs *BaiduPCS) UploadSuperfile2(uploadid, targetPath string, partseq int, partOffset int64, uploadFunc UploadFunc) (md5sum string, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareUploadSuperfile2(uploadid, targetPath, partseq, partOffset, uploadFunc)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	jsonData := uploadSuperfile2JSON{
		PCSErrInfo: pcserror.NewPCSErrorInfo(OperationUploadSuperfile2),
	}

	pcsError = pcserror.HandleJSONParse(OperationUploadSuperfile2, dataReadCloser, &jsonData)
	if pcsError != nil {
		return
	}

	return jsonData.MD5, nil
}



================================================
FILE: baidupcs/util.go
================================================
package baidupcs

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"path"
	"strings"
)

// Isdir æ£€æŸ¥è·¯å¾„åœ¨ç½‘ç›˜ä¸­æ˜¯å¦ä¸ºç›®å½•
func (pcs *BaiduPCS) Isdir(pcspath string) (isdir bool, pcsError pcserror.Error) {
	if path.Clean(pcspath) == PathSeparator {
		return true, nil
	}

	f, pcsError := pcs.FilesDirectoriesMeta(pcspath)
	if pcsError != nil {
		return false, pcsError
	}

	return f.Isdir, nil
}

func (pcs *BaiduPCS) checkIsdir(op string, targetPath string) pcserror.Error {
	// æ£€æµ‹æ–‡ä»¶æ˜¯å¦å­˜åœ¨äºç½‘ç›˜è·¯å¾„
	// å¾ˆé‡è¦, å¦‚æœæ–‡ä»¶å­˜åœ¨ä¼šç›´æ¥è¦†ç›–!!! å³ä½¿æ˜¯æ ¹ç›®å½•!
	isdir, pcsError := pcs.Isdir(targetPath)
	if pcsError != nil {
		// å¿½ç•¥è¿œç¨‹æœåŠ¡ç«¯è¿”å›çš„é”™è¯¯
		if pcsError.GetErrType() != pcserror.ErrTypeRemoteError {
			return pcsError
		}
	}

	errInfo := pcserror.NewPCSErrorInfo(op)
	if isdir {
		errInfo.ErrType = pcserror.ErrTypeOthers
		errInfo.Err = errors.New("ä¿å­˜è·¯å¾„ä¸å¯ä»¥è¦†ç›–ç›®å½•")
		return errInfo
	}
	return nil
}

func mergeStringList(a ...string) string {
	s := strings.Join(a, `","`)
	return `["` + s + `"]`
}

func mergeInt64List(si ...int64) string {
	i := converter.SliceInt64ToString(si)
	s := strings.Join(i, ",")
	return "[" + s + "]"
}

func allRelatedDir(pcspaths []string) (dirs []string) {
	for _, pcspath := range pcspaths {
		pathDir := path.Dir(pcspath)
		if !pcsutil.ContainsString(dirs, pathDir) {
			dirs = append(dirs, pathDir)
		}
	}
	return
}

// GetHTTPScheme è·å– http åè®®, https æˆ– http
func GetHTTPScheme(https bool) (scheme string) {
	if https {
		return "https"
	}
	return "http"
}



================================================
FILE: baidupcs/expires/dataexpires.go
================================================
package expires

import (
	"time"
)

type (
	DataExpires interface {
		Data() interface{}
		Expires
	}

	dataExpires struct {
		data interface{}
		Expires
	}
)

func NewDataExpires(data interface{}, dur time.Duration) DataExpires {
	return &dataExpires{
		data:    data,
		Expires: NewExpires(dur),
	}
}

func (de *dataExpires) Data() interface{} {
	return de.data
}



================================================
FILE: baidupcs/expires/expires.go
================================================
package expires

import (
	"fmt"
	"time"
	_ "unsafe" // for go:linkname
)

type (
	Expires interface {
		IsExpires() bool
		GetExpires() time.Time
		SetExpires(e bool)
		fmt.Stringer
	}

	expires struct {
		expiresAt time.Time
		abort     bool
	}
)

//go:linkname stripMono time.(*Time).stripMono
func stripMono(t *time.Time)

// StripMono strip monotonic clocks
func StripMono(t *time.Time) {
	stripMono(t)
}

func NewExpires(dur time.Duration) Expires {
	t := time.Now().Add(dur)
	StripMono(&t)
	return &expires{
		expiresAt: t,
	}
}

func NewExpiresAt(at time.Time) Expires {
	StripMono(&at)
	return &expires{
		expiresAt: at,
	}
}

func (ep *expires) GetExpires() time.Time {
	return ep.expiresAt
}

func (ep *expires) SetExpires(e bool) {
	ep.abort = e
}

func (ep *expires) IsExpires() bool {
	return ep.abort || time.Now().After(ep.expiresAt)
}

func (ep *expires) String() string {
	return fmt.Sprintf("expires at: %s, abort: %t", ep.expiresAt, ep.abort)
}



================================================
FILE: baidupcs/expires/expires.s
================================================
[Empty file]


================================================
FILE: baidupcs/expires/cachemap/cachemap.go
================================================
package cachemap

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"sync"
)

var (
	GlobalCacheOpMap = CacheOpMap{}
)

type (
	CacheOpMap struct {
		cachePool sync.Map
	}
)

func (cm *CacheOpMap) LazyInitCachePoolOp(op string) CacheUnit {
	cacheItf, _ := cm.cachePool.LoadOrStore(op, &cacheUnit{})
	return cacheItf.(CacheUnit)
}

func (cm *CacheOpMap) RemoveCachePoolOp(op string) {
	cm.cachePool.Delete(op)
}

// ClearInvalidate æ¸…é™¤å·²è¿‡æœŸçš„æ•°æ®(ä¸€èˆ¬ç”¨ä¸åˆ°)
func (cm *CacheOpMap) ClearInvalidate() {
	cm.cachePool.Range(func(_, cacheItf interface{}) bool {
		cache := cacheItf.(CacheUnit)
		cache.Range(func(key interface{}, exp expires.DataExpires) bool {
			if exp.IsExpires() {
				cache.Delete(key)
			}
			return true
		})
		return true
	})
}

// PrintAll è¾“å‡ºæ‰€æœ‰ç¼“å†²é¡¹ç›®
func (cm *CacheOpMap) PrintAll() {
}



================================================
FILE: baidupcs/expires/cachemap/cachemap_test.go
================================================
package cachemap_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires/cachemap"
	"sync"
	"sync/atomic"
	"testing"
	"time"
)

func TestCacheMapDataExpires(t *testing.T) {
	cm := cachemap.CacheOpMap{}
	cache := cm.LazyInitCachePoolOp("op")
	cache.Store("key_1", expires.NewDataExpires("value_1", 1*time.Second))

	time.Sleep(2 * time.Second)
	data, ok := cache.Load("key_1")
	if ok {
		fmt.Printf("data: %s\n", data.Data())
		// è¶…æ—¶ä»èƒ½è¯»å–åˆ°æ•°æ®, å¤±è´¥
		t.FailNow()
	}
}

func TestCacheOperation(t *testing.T) {
	cm := cachemap.CacheOpMap{}
	data := cm.CacheOperation("op", "key_1", func() expires.DataExpires {
		return expires.NewDataExpires("value_1", 1*time.Second)
	})
	fmt.Printf("data: %s\n", data.Data())

	newData := cm.CacheOperation("op", "key_1", func() expires.DataExpires {
		return expires.NewDataExpires("value_3", 1*time.Second)
	})
	if data != newData {
		t.FailNow()
	}
	fmt.Printf("data: %s\n", data.Data())
}

func TestCacheOperation_LockKey(t *testing.T) {
	cm := cachemap.CacheOpMap{}
	wg := sync.WaitGroup{}
	wg.Add(5000)

	var (
		execTimes1 int32 = 0 // æ‰§è¡Œæ¬¡æ•°1
		execTimes2 int32 = 0 // æ‰§è¡Œæ¬¡æ•°2
	)

	for i := 0; i < 5000; i++ {
		go func(i int) {
			defer wg.Done()
			cm.CacheOperation("op", "key_1", func() expires.DataExpires {
				time.Sleep(50 * time.Microsecond) // ä¸€äº›è€—æ—¶çš„æ“ä½œ
				atomic.AddInt32(&execTimes1, 1)
				return expires.NewDataExpires(fmt.Sprintf("value_1: %d", i), 10*time.Second)
			})

			cm.CacheOperation("op", "key_2", func() expires.DataExpires {
				time.Sleep(50 * time.Microsecond) // ä¸€äº›è€—æ—¶çš„æ“ä½œ
				atomic.AddInt32(&execTimes2, 1)
				return expires.NewDataExpires(fmt.Sprintf("value_2: %d", i), 10*time.Second)
			})
		}(i)
	}
	wg.Wait()

	// æ‰§è¡Œæ¬¡æ•°åº”ä¸º1
	if execTimes1 != 1 {
		fmt.Printf("execTimes1: %d\n", execTimes1)
		t.FailNow()
	}
	if execTimes2 != 1 {
		fmt.Printf("execTimes2: %d\n", execTimes2)
		t.FailNow()
	}
}



================================================
FILE: baidupcs/expires/cachemap/cacheunit.go
================================================
package cachemap

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"sync"
)

type (
	CacheUnit interface {
		Delete(key interface{})
		Load(key interface{}) (value expires.DataExpires, ok bool)
		LoadOrStore(key interface{}, value expires.DataExpires) (actual expires.DataExpires, loaded bool)
		Range(f func(key interface{}, value expires.DataExpires) bool)
		Store(key interface{}, value expires.DataExpires)
		LockKey(key interface{})
		UnlockKey(key interface{})
	}

	cacheUnit struct {
		unit   sync.Map
		keyMap sync.Map
	}
)

func (cu *cacheUnit) Delete(key interface{}) {
	cu.unit.Delete(key)
	cu.keyMap.Delete(key)
}

func (cu *cacheUnit) Load(key interface{}) (value expires.DataExpires, ok bool) {
	val, ok := cu.unit.Load(key)
	if !ok {
		return nil, ok
	}
	exp := val.(expires.DataExpires)
	if exp.IsExpires() {
		cu.unit.Delete(key)
		return nil, false
	}
	return exp, ok
}

func (cu *cacheUnit) Range(f func(key interface{}, value expires.DataExpires) bool) {
	cu.unit.Range(func(k, val interface{}) bool {
		exp := val.(expires.DataExpires)
		if exp.IsExpires() {
			cu.unit.Delete(k)
			return true
		}
		return f(k, val.(expires.DataExpires))
	})
}

func (cu *cacheUnit) LoadOrStore(key interface{}, value expires.DataExpires) (actual expires.DataExpires, loaded bool) {
	ac, loaded := cu.unit.LoadOrStore(key, value)
	exp := ac.(expires.DataExpires)
	if exp.IsExpires() {
		cu.unit.Delete(key)
		return nil, false
	}
	return exp, loaded
}

func (cu *cacheUnit) Store(key interface{}, value expires.DataExpires) {
	if value.IsExpires() {
		return
	}
	cu.unit.Store(key, value)
}

func (cu *cacheUnit) LockKey(key interface{}) {
	muItf, _ := cu.keyMap.LoadOrStore(key, &sync.Mutex{})
	mu := muItf.(*sync.Mutex)
	mu.Lock()
}

func (cu *cacheUnit) UnlockKey(key interface{}) {
	muItf, _ := cu.keyMap.LoadOrStore(key, &sync.Mutex{})
	mu := muItf.(*sync.Mutex)
	mu.Unlock()
}



================================================
FILE: baidupcs/expires/cachemap/utils.go
================================================
package cachemap

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
)

type (
	OpFunc          func() expires.DataExpires
	OpFuncWithError func() (expires.DataExpires, error)
)

func (cm *CacheOpMap) CacheOperation(op string, key interface{}, opFunc OpFunc) (data expires.DataExpires) {
	var (
		cache = cm.LazyInitCachePoolOp(op)
		ok    bool
	)

	cache.LockKey(key)
	defer cache.UnlockKey(key)
	data, ok = cache.Load(key)
	if !ok {
		data = opFunc()
		if data != nil {
			cache.Store(key, data)
		}
		return
	}

	return
}

func (cm *CacheOpMap) CacheOperationWithError(op string, key interface{}, opFunc OpFuncWithError) (data expires.DataExpires, err error) {
	var (
		cache = cm.LazyInitCachePoolOp(op)
		ok    bool
	)

	cache.LockKey(key)
	defer cache.UnlockKey(key)
	data, ok = cache.Load(key)
	if !ok {
		data, err = opFunc()
		if err != nil {
			return
		}
		if data == nil {
			// æ•°æ®ä¸ºç©ºæ—¶ä¹Ÿä¸å­˜
			return
		}
		cache.Store(key, data)
	}

	return
}



================================================
FILE: baidupcs/internal/panhome/cache.go
================================================
package panhome

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"time"
)

// SetSignExpires è®¾ç½®signè¿‡æœŸ
func (ph *PanHome) SetSignExpires() {
	if ph.signExpires != nil {
		ph.signExpires.SetExpires(true)
	}
}

// CacheSignature åœ¨æœ‰æ•ˆæœŸå†…è¿”å›ç¼“å­˜ç»“æœ
func (ph *PanHome) CacheSignature() (sign SignRes, err error) {
	if ph.signExpires == nil || ph.signExpires.IsExpires() {
		// å…ˆç­¾åå†è®¾ç½®æœ‰æ•ˆæœŸ
		ph.signRes, err = ph.Signature()
		if err != nil { // ç©ºæŒ‡é’ˆä¸ç©ºæ¥å£ä¸ç­‰ä»·
			return nil, err
		}

		ph.signExpires = expires.NewExpires(1 * time.Hour) // è®¾ç½®ä¸€å°æ—¶æœ‰æ•ˆæœŸ
		return ph.signRes, nil
	}

	return ph.signRes, nil
}



================================================
FILE: baidupcs/internal/panhome/panhome.go
================================================
package panhome

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"net/url"
)

const (
	// OperationSignature signature
	OperationSignature = "signature"
)

var (
	panBaiduComURL = &url.URL{
		Scheme: "https",
		Host:   "pan.baidu.com",
	}
	// PanHomeUserAgent PanHome User-Agent
	PanHomeUserAgent = "Mozilla/5.0"
)

type (
	PanHome struct {
		client *requester.HTTPClient
		ua     string
		bduss  string

		sign1, sign3 []rune
		timestamp    string

		signRes     SignRes
		signExpires expires.Expires
	}
)

func NewPanHome(client *requester.HTTPClient) *PanHome {
	ph := PanHome{}
	if client != nil {
		newC := *client
		ph.client = &newC
	}
	return &ph
}

func (ph *PanHome) lazyInit() {
	if ph.client == nil {
		ph.client = requester.NewHTTPClient()
	}
}



================================================
FILE: baidupcs/internal/panhome/parse.go
================================================
package panhome

import (
	"errors"
	"io/ioutil"
	"net/http"
	"net/url"
	"regexp"
	"unsafe"
)

var (
	signInfoRE         = regexp.MustCompile(`"sign1":"(.*?)"[\s\S]*"sign3":"(.*?)","timestamp":(\d*?),`)
	ErrCookieInvalid   = errors.New("cookie is invalid")
	ErrUnknownLocation = errors.New("unknown location")
	ErrMatchPanHome    = errors.New("ç½‘ç›˜é¦–é¡µæ•°æ®åŒ¹é…å‡ºé”™")
)

func (ph *PanHome) getSignInfo() error {
	ph.client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		return http.ErrUseLastResponse
	}
	u := *panBaiduComURL
	u.Path = "/disk/home"
	resp, err := ph.client.Req(http.MethodGet, u.String(), nil, map[string]string{
		"User-Agent": PanHomeUserAgent,
	})
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		return err
	}

	loc := resp.Header.Get("Location")
	switch loc {
	case "/":
		return ErrCookieInvalid
	case "":
		//pass
	default:
		locU, err := url.Parse(loc)
		if err != nil {
			return ErrUnknownLocation
		}
		if locU.Host == "passport.baidu.com" {
			return ErrCookieInvalid
		}
		return ErrUnknownLocation
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	matchRes := signInfoRE.FindSubmatch(body)
	if len(matchRes) <= 3 {
		return ErrMatchPanHome
	}

	ph.sign1 = []rune(*(*string)(unsafe.Pointer(&matchRes[1])))
	ph.sign3 = []rune(*(*string)(unsafe.Pointer(&matchRes[2])))
	ph.timestamp = *(*string)(unsafe.Pointer(&matchRes[3]))
	return nil
}



================================================
FILE: baidupcs/internal/panhome/sign.go
================================================
package panhome

import (
	"github.com/felixonmars/Baidu-Login/bdcrypto"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/netdisksign"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
)

type (
	// SignRes ç­¾åç»“æœ
	SignRes interface {
		Sign() string
		Timestamp() string
	}

	signRes struct {
		sign      string
		timestamp string
	}
)

func (sr *signRes) Sign() string {
	return sr.sign
}
func (sr *signRes) Timestamp() string {
	return sr.timestamp
}

func (ph *PanHome) Signature() (sign SignRes, err error) {
	err = ph.getSignInfo()
	if err != nil {
		return nil, err
	}

	o := netdisksign.Sign2(ph.sign3, ph.sign1)
	signed := bdcrypto.Base64Encode(o)
	return &signRes{
		sign:      converter.ToString(signed),
		timestamp: ph.timestamp,
	}, nil
}



================================================
FILE: baidupcs/netdisksign/devuid.go
================================================
package netdisksign

import (
	"bytes"
	"crypto/md5"
	"encoding/hex"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
)

func DevUID(feature string) string {
	m := md5.New()
	m.Write(converter.ToBytes(feature))
	res := m.Sum(nil)
	resHex := cachepool.RawMallocByteSlice(34)
	hex.Encode(resHex[2:], res)
	resHex[0] = 'O'
	resHex[1] = '|'
	return converter.ToString(bytes.ToUpper(resHex))
}



================================================
FILE: baidupcs/netdisksign/locatedownloadsign.go
================================================
package netdisksign

import (
	"crypto/sha1"
	"encoding/hex"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"strconv"
	"time"
)

type (
	LocateDownloadSign struct {
		Time   int64
		Rand   string
		DevUID string
	}
)

func NewLocateDownloadSign(uid uint64, bduss string) *LocateDownloadSign {
	return NewLocateDownloadSignWithTimeAndDevUID(time.Now().Unix(), DevUID(bduss), uid, bduss)
}

func NewLocateDownloadSignWithTimeAndDevUID(timeunix int64, devuid string, uid uint64, bduss string) *LocateDownloadSign {
	l := &LocateDownloadSign{
		Time:   timeunix,
		DevUID: devuid,
	}
	l.Sign(uid, bduss)
	return l
}

func (s *LocateDownloadSign) Sign(uid uint64, bduss string) {
	randSha1 := sha1.New()
	bdussSha1 := sha1.New()
	bdussSha1.Write(converter.ToBytes(bduss))
	sha1ResHex := cachepool.RawMallocByteSlice(40)
	hex.Encode(sha1ResHex, bdussSha1.Sum(nil))
	randSha1.Write(sha1ResHex)
	uidStr := strconv.FormatUint(uid, 10)
	randSha1.Write(converter.ToBytes(uidStr))
	randSha1.Write([]byte{'\x65', '\x62', '\x72', '\x63', '\x55', '\x59', '\x69', '\x75', '\x78', '\x61', '\x5a', '\x76', '\x32', '\x58', '\x47', '\x75', '\x37', '\x4b', '\x49', '\x59', '\x4b', '\x78', '\x55', '\x72', '\x71', '\x66', '\x6e', '\x4f', '\x66', '\x70', '\x44', '\x46'})
	timeStr := strconv.FormatInt(s.Time, 10)
	randSha1.Write(converter.ToBytes(timeStr))
	randSha1.Write(converter.ToBytes(s.DevUID))
	hex.Encode(sha1ResHex, randSha1.Sum(nil))
	s.Rand = converter.ToString(sha1ResHex)
}

func (s *LocateDownloadSign) URLParam() string {
	return "time=" + strconv.FormatInt(s.Time, 10) + "&rand=" + s.Rand + "&devuid=" + s.DevUID
}



================================================
FILE: baidupcs/netdisksign/locatedownloadsign_test.go
================================================
package netdisksign_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/netdisksign"
	"testing"
)

func TestLocateDownloadSign(t *testing.T) {
	sign := netdisksign.NewLocateDownloadSignWithTimeAndDevUID(1571140066, "O|1E67351CCE80B2CF48DB511CD77ACD9F", 10086, "test_bduss")
	fmt.Printf("%#v\n", sign.Rand == "b6bb7a6f46899e181baea58798d4fdb889775c2c")
}



================================================
FILE: baidupcs/netdisksign/share_sign.go
================================================
package netdisksign

import (
	"crypto/md5"
	"encoding/hex"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"strconv"
)

func ShareSURLInfoSign(shareID int64) []byte {
	s := strconv.FormatInt(shareID, 10)
	m := md5.New()
	m.Write(converter.ToBytes(s))
	m.Write([]byte("_sharesurlinfo!@#"))
	res := m.Sum(nil)
	resHex := cachepool.RawMallocByteSlice(32)
	hex.Encode(resHex, res)
	return resHex
}



================================================
FILE: baidupcs/netdisksign/sign2.go
================================================
package netdisksign

func Sign2(j, r []rune) []byte {
	var (
		a  = make([]rune, 256)
		p  = make([]rune, 256)
		o  = make([]byte, len(r))
		v  = len(j)
		q  int
		u  rune
		i  int
		k  rune
		dr int
	)
	if v == 0 {
		return o
	}
	for ; q < 256; q++ {
		dr = q % v
		a[q] = j[dr : 1+dr][0]
		p[q] = rune(q)
	}
	for q = 0; q < 256; q++ {
		u = (u + p[q] + a[q]) % 256
		p[q], p[u] = p[u], p[q]
	}
	u = 0
	for q = 0; q < len(r); q++ {
		i = (i + 1) % 256
		u = (u + p[i]) % 256
		p[i], p[u] = p[u], p[i]
		k = p[(p[i]+p[u])%256]
		o[q] = byte(r[q] ^ k)
	}
	return o
}


================================================
FILE: baidupcs/netdisksign/sign2.js
================================================
function s(j, r) {
    var a = [];
    var p = [];
    var o = "";
    var v = j.length;
    for (var q = 0; q < 256; q++) {
        a[q] = j.substr((q % v), 1).charCodeAt(0);
        // console.log(q, q%v);
        p[q] = q;
        // console.log(q, a[q], p[q]);
    }
    for (var u = q = 0; q < 256; q++) {
        u = (u + p[q] + a[q]) % 256;
        var t = p[q];
        p[q] = p[u];
        p[u] = t;
    }
    // console.log(p)
    for (var i = u = q = 0; q < r.length; q++) {
        i = (i + 1) % 256;
        u = (u + p[i]) % 256;
        var t = p[i];
        p[i] = p[u];
        p[u] = t;
        k = p[((p[i] + p[u]) % 256)];
        o += String.fromCharCode(r.charCodeAt(q) ^ k);
    }
    return o;
};

function base64encode(t) {
    var r, e, a, o, n, i, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (a = t.length,
    e = 0,
    r = ""; a > e; ) {
        if (o = 255 & t.charCodeAt(e++),
        e == a) {
            r += s.charAt(o >> 2),
            r += s.charAt((3 & o) << 4),
            r += "==";
            break
        }
        if (n = t.charCodeAt(e++),
        e == a) {
            r += s.charAt(o >> 2),
            r += s.charAt((3 & o) << 4 | (240 & n) >> 4),
            r += s.charAt((15 & n) << 2),
            r += "=";
            break
        }
        i = t.charCodeAt(e++),
        r += s.charAt(o >> 2),
        r += s.charAt((3 & o) << 4 | (240 & n) >> 4),
        r += s.charAt((15 & n) << 2 | (192 & i) >> 6),
        r += s.charAt(63 & i)
    }
    return r
}

var s1 = s("e8c7d729eea7b54551aa594f942decbe", "37dbe07ade9359c1aa70807e847f768c13360ad2");
console.log(s1);
console.log(base64encode(s1));


================================================
FILE: baidupcs/netdisksign/sign2_test.go
================================================
package netdisksign_test

import (
	"fmt"
	"github.com/felixonmars/Baidu-Login/bdcrypto"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/netdisksign"
	"testing"
)

func TestSign2(t *testing.T) {
	standard := bdcrypto.Base64Decode([]byte("8RxCbsVeSzn2UjxJAAiV9QQs/WetOj2FJUGwjsMG6SgxFMWlLS/U1Q=="))
	fmt.Println("standard,", standard)
	fmt.Printf("standard s %s\n", standard)

	res := netdisksign.Sign2([]rune("e8c7d729eea7b54551aa594f942decbe"), []rune("37dbe07ade9359c1aa70807e847f768c13360ad2"))
	fmt.Println(res)
	fmt.Printf("%s\n", string(res))
	fmt.Println([]byte(string(res)))
	fmt.Println(bdcrypto.Base64Encode([]byte(string(res))))
}



================================================
FILE: baidupcs/pcserror/dlinkerrinfo.go
================================================
[Binary file]


================================================
FILE: baidupcs/pcserror/panerrorinfo.go
================================================
package pcserror

import (
	"fmt"
)

type (
	// PanErrorInfo ç½‘ç›˜ç½‘é¡µçš„apié”™è¯¯
	PanErrorInfo struct {
		Operation string
		ErrType   ErrType
		Err       error
		ErrNo     int `json:"errno"`
		// ErrMsg    string `json:"err_msg"`
	}
)

// NewPanErrorInfo æä¾›operationæ“ä½œåç§°, è¿”å› *PanErrorInfo
func NewPanErrorInfo(operation string) *PanErrorInfo {
	return &PanErrorInfo{
		Operation: operation,
		ErrType:   ErrorTypeNoError,
	}
}

// SetJSONError è®¾ç½®JSONé”™è¯¯
func (pane *PanErrorInfo) SetJSONError(err error) {
	pane.ErrType = ErrTypeJSONParseError
	pane.Err = err
}

// SetNetError è®¾ç½®ç½‘ç»œé”™è¯¯
func (pane *PanErrorInfo) SetNetError(err error) {
	pane.ErrType = ErrTypeNetError
	pane.Err = err
}

// SetRemoteError è®¾ç½®è¿œç«¯æœåŠ¡å™¨é”™è¯¯
func (pane *PanErrorInfo) SetRemoteError() {
	pane.ErrType = ErrTypeRemoteError
}

// GetOperation è·å–æ“ä½œ
func (pane *PanErrorInfo) GetOperation() string {
	return pane.Operation
}

// GetErrType è·å–é”™è¯¯ç±»å‹
func (pane *PanErrorInfo) GetErrType() ErrType {
	return pane.ErrType
}

// GetRemoteErrCode è·å–è¿œç«¯æœåŠ¡å™¨é”™è¯¯ä»£ç 
func (pane *PanErrorInfo) GetRemoteErrCode() int {
	return pane.ErrNo
}

// GetRemoteErrMsg è·å–è¿œç«¯æœåŠ¡å™¨é”™è¯¯æ¶ˆæ¯
func (pane *PanErrorInfo) GetRemoteErrMsg() string {
	return FindPanErr(pane.ErrNo)
}

// GetError è·å–åŸå§‹é”™è¯¯
func (pane *PanErrorInfo) GetError() error {
	return pane.Err
}

func (pane *PanErrorInfo) Error() string {
	if pane.Operation == "" {
		if pane.Err != nil {
			return pane.Err.Error()
		}
		return StrSuccess
	}

	switch pane.ErrType {
	case ErrTypeInternalError:
		return fmt.Sprintf("%s: %s, %s", pane.Operation, StrInternalError, pane.Err)
	case ErrTypeJSONParseError:
		return fmt.Sprintf("%s: %s, %s", pane.Operation, StrJSONParseError, pane.Err)
	case ErrTypeNetError:
		return fmt.Sprintf("%s: %s, %s", pane.Operation, StrNetError, pane.Err)
	case ErrTypeRemoteError:
		if pane.ErrNo == 0 {
			return fmt.Sprintf("%s: %s", pane.Operation, StrSuccess)
		}

		errmsg := FindPanErr(pane.ErrNo)
		return fmt.Sprintf("%s: é‡åˆ°é”™è¯¯, %s, ä»£ç : %d, æ¶ˆæ¯: %s", pane.Operation, StrRemoteError, pane.ErrNo, errmsg)
	case ErrTypeOthers:
		if pane.Err == nil {
			return fmt.Sprintf("%s: %s", pane.Operation, StrSuccess)
		}

		return fmt.Sprintf("%s, é‡åˆ°é”™è¯¯, %s", pane.Operation, pane.Err)
	default:
		panic("panerrorinfo: unknown ErrType")
	}
}

// FindPanErr æ ¹æ® ErrNo, è§£æç½‘ç›˜é”™è¯¯ä¿¡æ¯
func FindPanErr(errno int) (errmsg string) {
	switch errno {
	case 0:
		return StrSuccess
	case -1:
		return "ç”±äºæ‚¨åˆ†äº«äº†è¿åç›¸å…³æ³•å¾‹æ³•è§„çš„æ–‡ä»¶ï¼Œåˆ†äº«åŠŸèƒ½å·²è¢«ç¦ç”¨ï¼Œä¹‹å‰åˆ†äº«å‡ºå»çš„æ–‡ä»¶ä¸å—å½±å“ã€‚"
	case -2:
		return "ç”¨æˆ·ä¸å­˜åœ¨,è¯·åˆ·æ–°é¡µé¢åé‡è¯•"
	case -3:
		return "æ–‡ä»¶ä¸å­˜åœ¨,è¯·åˆ·æ–°é¡µé¢åé‡è¯•"
	case -4:
		return "ç™»å½•ä¿¡æ¯æœ‰è¯¯ï¼Œè¯·é‡æ–°ç™»å½•è¯•è¯•"
	case -5:
		return "host_keyå’Œuser_keyæ— æ•ˆ"
	case -6:
		return "è¯·é‡æ–°ç™»å½•"
	case -7:
		return "è¯¥åˆ†äº«å·²åˆ é™¤æˆ–å·²å–æ¶ˆ"
	case -8:
		return "è¯¥åˆ†äº«å·²ç»è¿‡æœŸ"
	case -9:
		return "æ–‡ä»¶ä¸å­˜åœ¨"
	case -10:
		return "åˆ†äº«å¤–é“¾å·²ç»è¾¾åˆ°æœ€å¤§ä¸Šé™100000æ¡ï¼Œä¸èƒ½å†æ¬¡åˆ†äº«"
	case -11:
		return "éªŒè¯cookieæ— æ•ˆ"
	case -12:
		return "è®¿é—®å¯†ç é”™è¯¯"
	case -14:
		return "å¯¹ä¸èµ·ï¼ŒçŸ­ä¿¡åˆ†äº«æ¯å¤©é™åˆ¶20æ¡ï¼Œä½ ä»Šå¤©å·²ç»åˆ†äº«å®Œï¼Œè¯·æ˜å¤©å†æ¥åˆ†äº«å§ï¼"
	case -15:
		return "å¯¹ä¸èµ·ï¼Œé‚®ä»¶åˆ†äº«æ¯å¤©é™åˆ¶20å°ï¼Œä½ ä»Šå¤©å·²ç»åˆ†äº«å®Œï¼Œè¯·æ˜å¤©å†æ¥åˆ†äº«å§ï¼"
	case -16:
		return "å¯¹ä¸èµ·ï¼Œè¯¥æ–‡ä»¶å·²ç»é™åˆ¶åˆ†äº«ï¼"
	case -17:
		return "æ–‡ä»¶åˆ†äº«è¶…è¿‡é™åˆ¶"
	case -19:
		return "éœ€è¦è¾“å…¥éªŒè¯ç "
	case -21:
		return "åˆ†äº«å·²å–æ¶ˆæˆ–åˆ†äº«ä¿¡æ¯æ— æ•ˆ"
	case -30:
		return "æ–‡ä»¶å·²å­˜åœ¨"
	case -31:
		return "æ–‡ä»¶ä¿å­˜å¤±è´¥"
	case -33:
		return "ä¸€æ¬¡æ”¯æŒæ“ä½œ999ä¸ªï¼Œå‡ç‚¹è¯•è¯•å§"
	case -62:
		return "å¯èƒ½éœ€è¦è¾“å…¥éªŒè¯ç "
	case -70:
		return "ä½ åˆ†äº«çš„æ–‡ä»¶ä¸­åŒ…å«ç—…æ¯’æˆ–ç–‘ä¼¼ç—…æ¯’ï¼Œä¸ºäº†ä½ å’Œä»–äººçš„æ•°æ®å®‰å…¨ï¼Œæ¢ä¸ªæ–‡ä»¶åˆ†äº«å§"
	case 2:
		return "å‚æ•°é”™è¯¯"
	case 3:
		return "æœªç™»å½•æˆ–å¸å·æ— æ•ˆ"
	case 4:
		return "å­˜å‚¨å¥½åƒå‡ºé—®é¢˜äº†ï¼Œè¯·ç¨å€™å†è¯•"
	case 105:
		return "å•Šå“¦ï¼Œé“¾æ¥é”™è¯¯æ²¡æ‰¾åˆ°æ–‡ä»¶ï¼Œè¯·æ‰“å¼€æ­£ç¡®çš„åˆ†äº«é“¾æ¥"
	case 108:
		return "æ–‡ä»¶åæœ‰æ•æ„Ÿè¯ï¼Œä¼˜åŒ–ä¸€ä¸‹å§"
	case 110:
		return "åˆ†äº«æ¬¡æ•°è¶…å‡ºé™åˆ¶ï¼Œå¯ä»¥åˆ°â€œæˆ‘çš„åˆ†äº«â€ä¸­æŸ¥çœ‹å·²åˆ†äº«çš„æ–‡ä»¶é“¾æ¥"
	case 112:
		return "é¡µé¢å·²è¿‡æœŸï¼Œè¯·åˆ·æ–°åé‡è¯•"
	case 113:
		return "ç­¾åé”™è¯¯"
	case 114:
		return "å½“å‰ä»»åŠ¡ä¸å­˜åœ¨ï¼Œä¿å­˜å¤±è´¥"
	case 115:
		return "è¯¥æ–‡ä»¶ç¦æ­¢åˆ†äº«"
	case 132:
		return "æ‚¨çš„å¸å·å¯èƒ½å­˜åœ¨å®‰å…¨é£é™©ï¼Œä¸ºäº†ç¡®ä¿ä¸ºæ‚¨æœ¬äººæ“ä½œï¼Œè¯·å…ˆè¿›è¡Œå®‰å…¨éªŒè¯ã€‚"
	default:
		return "æœªçŸ¥é”™è¯¯"
	}
}



================================================
FILE: baidupcs/pcserror/pcserror.go
================================================
// Package pcserror PCSé”™è¯¯åŒ…
package pcserror

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/jsonhelper"
	"io"
)

type (
	// ErrType é”™è¯¯ç±»å‹
	ErrType int

	// Error é”™è¯¯ä¿¡æ¯æ¥å£
	Error interface {
		error
		SetJSONError(err error)
		SetNetError(err error)
		SetRemoteError()
		GetOperation() string
		GetErrType() ErrType
		GetRemoteErrCode() int
		GetRemoteErrMsg() string
		GetError() error
	}
)

const (
	// ErrorTypeNoError æ— é”™è¯¯
	ErrorTypeNoError ErrType = iota
	// ErrTypeInternalError å†…éƒ¨é”™è¯¯
	ErrTypeInternalError
	// ErrTypeRemoteError è¿œç«¯æœåŠ¡å™¨è¿”å›é”™è¯¯
	ErrTypeRemoteError
	// ErrTypeNetError ç½‘ç»œé”™è¯¯
	ErrTypeNetError
	// ErrTypeJSONParseError json æ•°æ®è§£æå¤±è´¥
	ErrTypeJSONParseError
	// ErrTypeOthers å…¶ä»–é”™è¯¯
	ErrTypeOthers
)

const (
	// StrSuccess æ“ä½œæˆåŠŸ
	StrSuccess = "æ“ä½œæˆåŠŸ"
	// StrInternalError å†…éƒ¨é”™è¯¯
	StrInternalError = "å†…éƒ¨é”™è¯¯"
	// StrRemoteError è¿œç«¯æœåŠ¡å™¨è¿”å›é”™è¯¯
	StrRemoteError = "è¿œç«¯æœåŠ¡å™¨è¿”å›é”™è¯¯"
	// StrNetError ç½‘ç»œé”™è¯¯
	StrNetError = "ç½‘ç»œé”™è¯¯"
	// StrJSONParseError json æ•°æ®è§£æå¤±è´¥
	StrJSONParseError = "json æ•°æ®è§£æå¤±è´¥"
)

// DecodePCSJSONError è§£æPCS JSONçš„é”™è¯¯
func DecodePCSJSONError(opreation string, data io.Reader) Error {
	errInfo := NewPCSErrorInfo(opreation)
	return HandleJSONParse(opreation, data, errInfo)
}

// DecodePanJSONError è§£æPan JSONçš„é”™è¯¯
func DecodePanJSONError(opreation string, data io.Reader) Error {
	errInfo := NewPanErrorInfo(opreation)
	return HandleJSONParse(opreation, data, errInfo)
}

// HandleJSONParse å¤„ç†è§£æjson
func HandleJSONParse(op string, data io.Reader, info interface{}) (pcsError Error) {
	var (
		err     = jsonhelper.UnmarshalData(data, info)
		errInfo = info.(Error)
	)

	if errInfo == nil {
		errInfo = NewPCSErrorInfo(op)
	}

	if err != nil {
		errInfo.SetJSONError(err)
		return errInfo
	}

	// è®¾ç½®å‡ºé”™ç±»å‹ä¸ºè¿œç¨‹é”™è¯¯
	if errInfo.GetRemoteErrCode() != 0 {
		errInfo.SetRemoteError()
		return errInfo
	}

	return nil
}



================================================
FILE: baidupcs/pcserror/pcserrorinfo.go
================================================
[Binary file]


================================================
FILE: cmd/AndroidNDKBuild/main.go
================================================
// AndroidNDKBuild
// go build -ldflags "-X main.APILevel=15 -X main.Arch=x86_64"
// env ANDROID_API_LEVEL NDK ANDROID_NDK_ROOT GOARCH

package main

import (
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"syscall"
)

var (
	// NDKPath path to Android NDK
	NDKPath string
	// APILevel Android api level
	APILevel string
	// Arch arch
	Arch string
)

func getNDKPath() string {
	ndkPath, ok := os.LookupEnv("NDK")
	if ok {
		return ndkPath
	}
	ndkPath, ok = os.LookupEnv("ANDROID_NDK_ROOT")
	if ok {
		return ndkPath
	}
	ndkPath, ok = os.LookupEnv("ANDROID_NDK_DIR")
	if ok {
		return ndkPath
	}
	return ""
}

func getAPILevel() string {
	apiLevelStr, ok := os.LookupEnv("ANDROID_API_LEVEL")
	if ok {
		return apiLevelStr
	}
	return "21"
}

func getGoarch() string {
	arch, ok := os.LookupEnv("GOARCH")
	if ok {
		return arch
	}

	return runtime.GOARCH
}

func getArch() string {
	if Arch != "" {
		return Arch
	}
	goarch := getGoarch()
	switch goarch {
	case "386":
		return "x86"
	case "amd64":
		return "x86_64"
	case "arm64":
		return "aarch64"
	}
	return goarch
}

func getPlatformsArch() string {
	arch := getArch()
	switch arch {
	case "aarch64":
		return "arm64"
	}
	return arch
}

func main() {
	if NDKPath == "" {
		NDKPath = getNDKPath()
	}
	if APILevel == "" {
		APILevel = getAPILevel()
	}
	if Arch == "" {
		Arch = getArch()
	}

	lastPattern := "*-gcc"
	if runtime.GOOS == "windows" {
		lastPattern += ".exe"
	}

	gccPaths, err := filepath.Glob(filepath.Join(NDKPath, "toolchains", getArch()+"-*", "prebuilt", runtime.GOOS+"-*", "bin", lastPattern))
	checkErr(err)
	if len(gccPaths) == 0 {
		panic("no match gcc")
	}

	args := make([]string, len(os.Args))
	copy(args[1:], os.Args[1:])
	args[0] = "--sysroot=" + filepath.Join(NDKPath, "platforms", "android-"+APILevel, "arch-"+getPlatformsArch())

	gccExec := exec.Command(gccPaths[0], args...)
	gccExec.Stdout = os.Stdout
	gccExec.Stderr = os.Stderr

	err = gccExec.Run()
	exitError, ok := err.(*exec.ExitError)
	if ok {
		status := exitError.ProcessState.Sys().(syscall.WaitStatus)
		os.Exit(status.ExitStatus())
	}

	if err != nil {
		println(err.Error())
	}

	return
}

func checkErr(err error) {
	if err != nil {
		panic(err)
	}
}



================================================
FILE: debian/copyright
================================================
Format-Specification: http://svn.debian.org/wsvn/dep/web/deps/dep5.mdwn?op=file&rev=135
Name: BaiduPCS-Go
Maintainer: iikira <i@mail.iikira.com>
Source: https://github.com/iikira/BaiduPCS-Go

Copyright: 2016-2019 iikira <i@mail.iikira.com>
License: Apache-2.0+
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright iikira.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.




================================================
FILE: debian/Packages.sh
================================================
dpkg-scanpackages . | gzip > Packages.gz


================================================
FILE: debian/iphoneos-arm/control
================================================
Package: BaiduPCS-Go
Version: 3.6
Homepage: https://github.com/iikira/BaiduPCS-Go
Section: å®ç”¨å·¥å…·
Priority: optional
Architecture: iphoneos-arm
Installed-Size: 4096
Maintainer: iikira <i@mail.iikira.com>
Description: BaiduPCS-Go ä½¿ç”¨Goè¯­è¨€ç¼–å†™çš„ç™¾åº¦ç½‘ç›˜å‘½ä»¤è¡Œå®¢æˆ·ç«¯, ä¸ºæ“ä½œç™¾åº¦ç½‘ç›˜, æä¾›å®ç”¨åŠŸèƒ½.


================================================
FILE: debian/linux-amd64/control
================================================
Package: BaiduPCS-Go
Version: 3.6
Homepage: https://github.com/iikira/BaiduPCS-Go
Section: utils
Priority: optional
Architecture: amd64
Installed-Size: 4096
Maintainer: iikira <i@mail.iikira.com>
Description: BaiduPCS-Go ä½¿ç”¨Goè¯­è¨€ç¼–å†™çš„ç™¾åº¦ç½‘ç›˜å‘½ä»¤è¡Œå®¢æˆ·ç«¯, ä¸ºæ“ä½œç™¾åº¦ç½‘ç›˜, æä¾›å®ç”¨åŠŸèƒ½.


================================================
FILE: docs/README.md
================================================
# æ–‡æ¡£ç›®å½•

## ç™¾åº¦PCSæ–‡æ¡£

### æ–‡ä»¶API

[ç»¼è¿°](https://github.com/iikira/BaiduPCS-Go/blob/master/docs/overview.md)

[æ–‡ä»¶APIåˆ—è¡¨](https://github.com/iikira/BaiduPCS-Go/blob/master/docs/file_data_apis_list.md)

[æ–‡ä»¶APIé”™è¯¯ç åˆ—è¡¨](https://github.com/iikira/BaiduPCS-Go/blob/master/docs/file_data_apis_error.md)

### ç»“æ„åŒ–æ•°æ®API

[ç»¼è¿°](https://github.com/iikira/BaiduPCS-Go/blob/master/docs/structured_data_apis_overview.md)

[ç»“æ„åŒ–æ•°æ®APIåˆ—è¡¨](https://github.com/iikira/BaiduPCS-Go/blob/master/docs/structured_data_api_list.md)

[ç»“æ„åŒ–æ•°æ®APIé”™è¯¯ç ](https://github.com/iikira/BaiduPCS-Go/blob/master/docs/structured_data_apis_error.md)



================================================
FILE: docs/file_data_apis_error.md
================================================
[Binary file]


================================================
FILE: docs/overview.md
================================================
# æ¦‚è¿°

ç™¾åº¦å¼€æ”¾äº‘å¹³å°ä¸ºå¹¿å¤§å¼€å‘è€…æä¾›äº†è®¿é—®PCSèµ„æºçš„ç³»åˆ—æ¥å£ï¼Œç›®å‰å¼€æ”¾çš„æ¥å£ä¸»è¦åˆ†ä¸¤ä¸ªéƒ¨åˆ†ï¼š

* æ–‡ä»¶API:

    ä¸»è¦æä¾›æ–‡ä»¶ä¸Šä¼ ã€ä¸‹è½½ã€æ‹·è´ã€åˆ é™¤ã€æœç´¢ã€æ–­ç‚¹ç»­ä¼ åŠç¼©ç•¥å›¾ç­‰åŠŸèƒ½ã€‚

* ç»“æ„åŒ–æ•°æ®API:

    ä¸»è¦æä¾›ç»“æ„æ•°æ®å­˜å‚¨ã€æŸ¥è¯¢ã€åˆ é™¤åŠåŒæ­¥ç­‰åŠŸèƒ½ã€‚

é€šè¿‡å¯¹è¿™äº›APIçš„ç»„åˆè°ƒç”¨ï¼Œå¼€å‘è€…å¯ä»¥å®ç°åŸºæœ¬çš„ç”¨æˆ·æ–‡ä»¶æ“ä½œä»¥åŠç»“æ„æ•°æ®å­˜å‚¨å’Œç®¡ç†åŠŸèƒ½ï¼Œä¹Ÿèƒ½å¤Ÿæ”¯æŒç”¨æˆ·æ•°æ®åœ¨å¤šç§ä¸åŒç»ˆç«¯ä¸Šçš„åŒæ­¥ï¼Œä»¥æä¾›æ›´ä¼˜è´¨çš„ç”¨æˆ·ä½“éªŒã€‚

é™¤äº†åŸç”Ÿçš„RESTï¼ˆRepresentational State Transferï¼Œå³â€œè¡¨è¿°æ€§çŠ¶æ€è½¬ç§»â€ï¼‰ APIä¹‹å¤–ï¼Œç™¾åº¦å¼€æ”¾äº‘å¹³å°è¿˜æä¾›äº†å¤šç§å¹³å°çš„SDKæ¥å¸®åŠ©å¼€å‘è€…ç¼©çŸ­å¼€å‘å‘¨æœŸï¼Œå…·ä½“è¯·å‚è€ƒâ€œSDKâ€éƒ¨åˆ†ç›¸å…³å†…å®¹ã€‚

## PCS REST APIä½¿ç”¨è¯´æ˜

### å¼€é€šPCS APIæƒé™

PCSæ‰€æœ‰REST APIéƒ½å¿…é¡»ç»è¿‡å¼€é€šæƒé™æ‰èƒ½æ­£å¸¸ä½¿ç”¨ã€‚ç”³è¯·çš„æ–¹æ³•è¯·å‚è€ƒâ€œå¼€é€šPCS APIæƒé™â€éƒ¨åˆ†ç›¸å…³å†…å®¹ã€‚

æ³¨æ„ï¼šPCSæœªæä¾›åˆ†äº«æ¥å£ï¼Œdownloadç­‰æ¥å£ä»…ä¾›ä¸ªäººè·å–æ•°æ®ä½¿ç”¨ã€‚ access_tokenä¸èƒ½æ³„éœ²ï¼Œå¦åˆ™ä¼šç›´æ¥å°ç¦åº”ç”¨ã€‚

### APIè¯·æ±‚æ–¹å¼è¯´æ˜

ç›®å‰æ‰€æœ‰çš„æäº¤ç±»æ¥å£ä»…æ”¯æŒPOSTæ–¹å¼ï¼ŒæŸ¥è¯¢ç±»æ¥å£åŒæ—¶æ”¯æŒPOSTæ–¹å¼å’ŒGETæ–¹å¼ã€‚

PCS REST APIçš„æ‰€æœ‰å‚æ•°åœ¨ä¼ å…¥æ—¶åº”å½“ä½¿ç”¨ï¼šUTF-8ç¼–ç ã€‚

#### HTTP è¯·æ±‚æ–¹å¼

    GET | POST

#### URL

    https://pcs.baidu.com/rest/2.0/pcs/{object_name}?{query_string}

#### å‚æ•°è¯´æ˜

| å‚æ•°åç§° | æè¿° |
| :- | :- |
| object_name | PCS REST APIæ“ä½œå®ä½“åç§°ï¼Œå¦‚ï¼šquotaã€fileã€thumbnailã€‚ |
| query_string | æ”¾åœ¨HTTPå¤´éƒ¨ä¼ å…¥çš„å‚æ•°ï¼Œå¿…é¡»ç»è¿‡UrlEncodeç¼–ç ã€‚ |

#### HTTP GETå’ŒPOSTæ–¹å¼ä½¿ç”¨è¯´æ˜

<table width="600" border="1" cellpadding="1" cellspacing="1">
    <tbody>
        <tr>
            <th scope="row" width="80">è¯·æ±‚æ–¹å¼
            </th>
            <th scope="col">GET
            </th>
            <th scope="col">POST
            </th>
        </tr>
        <tr>
            <th scope="row">URL
            </th>
            <td colspan="2">https://pcs.baidu.com/rest/2.0/pcs/{object_name}?{query_string}
            </td>
        </tr>
        <tr>
            <th scope="row">è¯·æ±‚å‚æ•°
            </th>
            <td> å…¨éƒ¨æºå¸¦åœ¨ HTTPS è¯·æ±‚å¤´éƒ¨çš„ query_string ä¸­ã€‚
            </td>
            <td> æ—¢å¯æºå¸¦åœ¨ query_string ä¸­ï¼Œä¹Ÿå¯æºå¸¦åœ¨ HTTP Body ä¸­ã€‚
                <dl>
                    <dd>
                        <ul>
                            <li> method åŠ access token ç­‰å‚æ•°å¿…é¡»æºå¸¦åœ¨ query_string ä¸­è¿›è¡Œä¼ è¾“ï¼Œè¯·å‚è€ƒå„ä¸ªAPIçš„å…·ä½“è¯´æ˜ï¼›
                            </li>
                            <li> æºå¸¦åœ¨ query_string ä¸­çš„å‚æ•°çš„å€¼ï¼Œå¿…é¡»è¿›è¡Œ UrlEncode ç¼–ç ï¼›
                            </li>
                            <li> æºå¸¦åœ¨ HTTP Body ä¸­çš„å‚æ•°ï¼Œåˆ™ä¸éœ€è¦è¿›è¡Œ UrlEncode ç¼–ç ã€‚
                            </li>
                        </ul>
                    </dd>
                </dl>
                <div style="border:solid 1px #d7d7d7;padding:10px 16px 2px 16px; background-color:#fbfafb;">
                    <div>æ³¨</div>
                    HTTP URL é•¿åº¦æœ‰é™ï¼Œè‹¥å‚æ•°å€¼é•¿åº¦è¿‡é•¿ï¼Œå»ºè®®å°†å‚æ•°æ”¾åœ¨ HTTP Body ä¸­è¿›è¡Œä¼ è¾“ã€‚</div>
            </td>
        </tr>
        <tr>
            <th scope="row"> HTTP BODY
            </th>
            <td> ä¸æºå¸¦HTTP Body
            </td>
            <td> multipart/form-data
            </td>
        </tr>
        <tr>
            <th scope="row">æ³¨æ„
            </th>
            <td colspan="2">å¦‚æœ HTTP Body å’Œ query_string å­˜åœ¨ç›¸åŒçš„å‚æ•°ï¼Œåˆ™ä»¥ query_string ä¸­çš„å‚æ•°ä¸ºå‡†ã€‚
            </td>
        </tr>
    </tbody>
</table>

#### ä½¿ç”¨ç¤ºä¾‹

1. GETè¯·æ±‚ï¼š

    ç”¨HTTP GETè¯·æ±‚æ–¹å¼å‘é€ä¸¤ä¸ªå‚æ•°ï¼škey1=value1å’Œkey2=value2ã€‚

    https://pcs.baidu.com/rest/2.0/pcs/quota?key1=UrlEncode(value1)&key2=UrlEncode(value2)

2. POSTè¯·æ±‚ï¼š

    åˆ†åˆ«ç”¨ä¸¤ç§æ–¹å¼ä½¿ç”¨POSTæ–¹å¼å‘é€ä¸‰ä¸ªå‚æ•°ï¼škey1=value1ã€key2=value2å’Œkey3=value3ï¼›æ–¹å¼ä¸€ä¸æ–¹å¼äºŒæ•ˆæœç­‰åŒã€‚

##### æ–¹å¼ä¸€ï¼š

    POST /rest/2.0/pcs/quota?key2=value2&key3=value3 HTTP/1.1

    User-Agent: curl/7.12.1 (x86_64-redhat-linux-gnu) libcurl/7.12.1 OpenSSL/0.9.7a zlib/1.2.1.2 libidn/0.5.6
    Pragma: no-cache
    Accept: */*
    Host:pcs.baidu.com
    Content-Length:123
    Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryS0JIa4uHF7yHd8xJ
    ------WebKitFormBoundaryS0JIa4uHF7yHd8xJ
    Content-Disposition: form-data; name="key1"
    value1
    ------WebKitFormBoundaryS0JIa4uHF7yHd8xJâ€”

##### æ–¹å¼äºŒï¼š

    POST /rest/2.0/pcs/quota HTTP/1.1
    User-Agent: curl/7.12.1 (x86_64-redhat-linux-gnu) libcurl/7.12.1 OpenSSL/0.9.7a zlib/1.2.1.2 libidn/0.5.6
    Pragma: no-cache
    Accept: */*
    Host:pcs.baidu.com
    Content-Length:123
    Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryS0JIa4uHF7yHd8xJ
    ------WebKitFormBoundaryS0JIa4uHF7yHd8xJ
    Content-Disposition: form-data; name="key1"

    value1
    ------WebKitFormBoundaryS0JIa4uHF7yHd8xJ
    Content-Disposition: form-data; name="key2"

    value2
    ------WebKitFormBoundaryS0JIa4uHF7yHd8xJ
    Content-Disposition: form-data; name="key3"

    value3
    ------WebKitFormBoundaryS0JIa4uHF7yHd8xJ--

### APIå“åº”æ ¼å¼è¯´æ˜

<table>
    <tbody>
        <tr>
            <th scope="col">
            </th>
            <th scope="col">æ­£å¸¸è¯·æ±‚
            </th>
            <th scope="col">å¼‚å¸¸è¯·æ±‚
            </th>
        </tr>
        <tr>
            <th scope="row">HTTPçŠ¶æ€ç 
            </th>
            <td> 200 OK
            </td>
            <td> 4**&nbsp;: ç”¨æˆ·è¯·æ±‚é”™è¯¯ã€‚<br>5** ï¼šserveræœåŠ¡å¤±è´¥ã€‚
            </td>
        </tr>
        <tr>
            <th scope="row">HTTP BODY
            </th>
            <td> APIå“åº”å†…å®¹
            </td>
            <td> å¼‚å¸¸è¯·æ±‚çš„è¿”å›å€¼ä¸ºJSONå­—ç¬¦ä¸²ã€‚<br>ä¾‹å¦‚ï¼š<br>{<br>"error_code":110,<br>"error_msg":"Access token invalid or no longer valid",<br>"request_id":729562373<br>}<br>è¯´æ˜ï¼š<br>
                <dl>
                    <dd>- error_codeï¼šé”™è¯¯ç ï¼›<br>
                    </dd>
                    <dd>- error_msg: é”™è¯¯æè¿°ä¿¡æ¯ï¼›<br>
                    </dd>
                    <dd>- request_id: è¯·æ±‚IDã€‚ç”±serverç”Ÿæˆï¼Œç”¨äºè¿½æŸ¥å’Œå®šä½è¯·æ±‚æ—¥å¿—ã€‚<br>
                    </dd>
                </dl>
            </td>
        </tr>
    </tbody>
</table>



================================================
FILE: docs/structured_data_apis_error.md
================================================
[Binary file]


================================================
FILE: docs/structured_data_apis_overview.md
================================================
[Binary file]


================================================
FILE: internal/pcscommand/cd.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
)

// RunChangeDirectory æ‰§è¡Œæ›´æ”¹å·¥ä½œç›®å½•
func RunChangeDirectory(targetPath string, isList bool) {
	pcs := GetBaiduPCS()
	err := matchPathByShellPatternOnce(&targetPath)
	if err != nil {
		fmt.Println(err)
		return
	}

	data, err := pcs.FilesDirectoriesMeta(targetPath)
	if err != nil {
		fmt.Println(err)
		return
	}

	if !data.Isdir {
		fmt.Printf("é”™è¯¯: %s ä¸æ˜¯ä¸€ä¸ªç›®å½• (æ–‡ä»¶å¤¹)\n", targetPath)
		return
	}

	GetActiveUser().Workdir = targetPath
	pcsconfig.Config.Save()

	fmt.Printf("æ”¹å˜å·¥ä½œç›®å½•: %s\n", targetPath)

	if isList {
		RunLs(".", nil, baidupcs.DefaultOrderOptions)
	}
}



================================================
FILE: internal/pcscommand/cloud_dl.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
)

// RunCloudDlAddTask æ‰§è¡Œæ·»åŠ ç¦»çº¿ä¸‹è½½ä»»åŠ¡
func RunCloudDlAddTask(sourceURLs []string, savePath string) {
	var (
		err error
		pcs = GetBaiduPCS()
	)
	err = matchPathByShellPatternOnce(&savePath)
	if err != nil {
		fmt.Println(err)
		return
	}

	var taskid int64
	for k := range sourceURLs {
		taskid, err = pcs.CloudDlAddTask(sourceURLs[k], savePath+baidupcs.PathSeparator)
		if err != nil {
			fmt.Printf("[%d] %s, åœ°å€: %s\n", k+1, err, sourceURLs[k])
			continue
		}

		fmt.Printf("[%d] æ·»åŠ ç¦»çº¿ä»»åŠ¡æˆåŠŸ, ä»»åŠ¡ID(task_id): %d, æºåœ°å€: %s, ä¿å­˜è·¯å¾„: %s\n", k+1, taskid, sourceURLs[k], savePath)
	}
}

// RunCloudDlQueryTask ç²¾ç¡®æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡
func RunCloudDlQueryTask(taskIDs []int64) {
	cl, err := GetBaiduPCS().CloudDlQueryTask(taskIDs)
	if err != nil {
		fmt.Printf("%s\n", err)
		return
	}

	fmt.Println(cl)
}

// RunCloudDlListTask æŸ¥è¯¢ç¦»çº¿ä¸‹è½½ä»»åŠ¡åˆ—è¡¨
func RunCloudDlListTask() {
	cl, err := GetBaiduPCS().CloudDlListTask()
	if err != nil {
		fmt.Printf("%s\n", err)
		return
	}

	fmt.Println(cl)
}

// RunCloudDlCancelTask å–æ¶ˆç¦»çº¿ä¸‹è½½ä»»åŠ¡
func RunCloudDlCancelTask(taskIDs []int64) {
	for _, id := range taskIDs {
		err := GetBaiduPCS().CloudDlCancelTask(id)
		if err != nil {
			fmt.Printf("[%d] %s\n", id, err)
			continue
		}

		fmt.Printf("[%d] å–æ¶ˆæˆåŠŸ\n", id)
	}
}

// RunCloudDlDeleteTask åˆ é™¤ç¦»çº¿ä¸‹è½½ä»»åŠ¡
func RunCloudDlDeleteTask(taskIDs []int64) {
	for _, id := range taskIDs {
		err := GetBaiduPCS().CloudDlDeleteTask(id)
		if err != nil {
			fmt.Printf("[%d] %s\n", id, err)
			continue
		}

		fmt.Printf("[%d] åˆ é™¤æˆåŠŸ\n", id)
	}
}

// RunCloudDlClearTask æ¸…ç©ºç¦»çº¿ä¸‹è½½ä»»åŠ¡è®°å½•
func RunCloudDlClearTask() {
	total, err := GetBaiduPCS().CloudDlClearTask()
	if err != nil {
		fmt.Printf("%s\n", err)
		return
	}

	fmt.Printf("%sæˆåŠŸ, å…±æ¸…é™¤ %d æ¡è®°å½•\n", baidupcs.OperationCloudDlClearTask, total)
	return
}



================================================
FILE: internal/pcscommand/cp_mv.go
================================================
[Binary file]


================================================
FILE: internal/pcscommand/download.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsfunctions/pcsdownload"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/taskframework"
	"github.com/felixonmars/BaiduPCS-Go/requester/downloader"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"os"
	"path/filepath"
	"runtime"
)

type (
	//DownloadOptions ä¸‹è½½å¯é€‰å‚æ•°
	DownloadOptions struct {
		IsTest               bool
		IsPrintStatus        bool
		IsExecutedPermission bool
		IsOverwrite          bool
		DownloadMode         pcsdownload.DownloadMode
		SaveTo               string
		Parallel             int
		Load                 int
		MaxRetry             int
		NoCheck              bool
	}

	// LocateDownloadOption è·å–ä¸‹è½½é“¾æ¥å¯é€‰å‚æ•°
	LocateDownloadOption struct {
		FromPan bool
	}
)

func downloadPrintFormat(load int) string {
	if load <= 1 {
		return pcsdownload.DefaultPrintFormat
	}
	return "[%d] â†“ %s/%s %s/s in %s, left %s ...\n"
}

// RunDownload æ‰§è¡Œä¸‹è½½ç½‘ç›˜å†…æ–‡ä»¶
func RunDownload(paths []string, options *DownloadOptions) {
	if options == nil {
		options = &DownloadOptions{}
	}

	if options.Load <= 0 {
		options.Load = pcsconfig.Config.MaxDownloadLoad
	}

	if options.MaxRetry < 0 {
		options.MaxRetry = pcsdownload.DefaultDownloadMaxRetry
	}

	if runtime.GOOS == "windows" {
		// windowsä¸‹ä¸åŠ æ‰§è¡Œæƒé™
		options.IsExecutedPermission = false
	}

	// è®¾ç½®ä¸‹è½½é…ç½®
	cfg := &downloader.Config{
		Mode:                       transfer.RangeGenMode_BlockSize,
		CacheSize:                  pcsconfig.Config.CacheSize,
		BlockSize:                  baidupcs.MaxDownloadRangeSize,
		MaxRate:                    pcsconfig.Config.MaxDownloadRate,
		InstanceStateStorageFormat: downloader.InstanceStateStorageFormatProto3,
		IsTest:                     options.IsTest,
		TryHTTP:                    !pcsconfig.Config.EnableHTTPS,
	}

	// è®¾ç½®ä¸‹è½½æœ€å¤§å¹¶å‘é‡
	if options.Parallel < 1 {
		options.Parallel = pcsconfig.Config.MaxParallel
	}

	paths, err := matchPathByShellPattern(paths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Print("\n")
	fmt.Printf("[0] æç¤º: å½“å‰ä¸‹è½½æœ€å¤§å¹¶å‘é‡ä¸º: %d, ä¸‹è½½ç¼“å­˜ä¸º: %d\n", options.Parallel, cfg.CacheSize)

	var (
		pcs       = GetBaiduPCS()
		loadCount = 0
	)

	// é¢„æµ‹è¦ä¸‹è½½çš„æ–‡ä»¶æ•°é‡
	// TODO: pcscache
	for k := range paths {
		pcs.FilesDirectoriesRecurseList(paths[k], baidupcs.DefaultOrderOptions, func(depth int, _ string, fd *baidupcs.FileDirectory, pcsError pcserror.Error) bool {
			if pcsError != nil {
				pcsCommandVerbose.Warnf("%s\n", pcsError)
				return true
			}

			// å¿½ç•¥ç»Ÿè®¡æ–‡ä»¶å¤¹æ•°é‡
			if !fd.Isdir {
				loadCount++
				if loadCount >= options.Load {
					return false
				}
			}
			return true
		})

		if loadCount >= options.Load {
			break
		}
	}

	// ä¿®æ”¹Load, è®¾ç½®MaxParallel
	if loadCount > 0 {
		options.Load = loadCount
		// å–å¹³å‡å€¼
		cfg.MaxParallel = pcsconfig.AverageParallel(options.Parallel, loadCount)
	} else {
		cfg.MaxParallel = options.Parallel
	}

	var (
		executor = taskframework.TaskExecutor{
			IsFailedDeque: true, // ç»Ÿè®¡å¤±è´¥çš„åˆ—è¡¨
		}
		statistic = &pcsdownload.DownloadStatistic{}
	)
	// å¤„ç†é˜Ÿåˆ—
	for k := range paths {
		newCfg := *cfg
		unit := pcsdownload.DownloadTaskUnit{
			Cfg:                  &newCfg, // å¤åˆ¶ä¸€ä»½æ–°çš„cfg
			PCS:                  pcs,
			VerbosePrinter:       pcsCommandVerbose,
			PrintFormat:          downloadPrintFormat(options.Load),
			ParentTaskExecutor:   &executor,
			DownloadStatistic:    statistic,
			IsPrintStatus:        options.IsPrintStatus,
			IsExecutedPermission: options.IsExecutedPermission,
			IsOverwrite:          options.IsOverwrite,
			NoCheck:              options.NoCheck,
			DownloadMode:         options.DownloadMode,
			PcsPath:              paths[k],
		}

		// è®¾ç½®å‚¨å­˜çš„è·¯å¾„
		if options.SaveTo != "" {
			unit.SavePath = filepath.Join(options.SaveTo, filepath.Base(paths[k]))
		} else {
			// ä½¿ç”¨é»˜è®¤çš„ä¿å­˜è·¯å¾„
			unit.SavePath = GetActiveUser().GetSavePath(paths[k])
		}
		info := executor.Append(&unit, options.MaxRetry)
		fmt.Printf("[%s] åŠ å…¥ä¸‹è½½é˜Ÿåˆ—: %s\n", info.Id(), paths[k])
	}

	// å¼€å§‹è®¡æ—¶
	statistic.StartTimer()

	// å¼€å§‹æ‰§è¡Œ
	executor.Execute()

	fmt.Printf("\nä¸‹è½½ç»“æŸ, æ—¶é—´: %s, æ•°æ®æ€»é‡: %s\n", statistic.Elapsed()/1e6*1e6, converter.ConvertFileSize(statistic.TotalSize()))

	// è¾“å‡ºå¤±è´¥çš„æ–‡ä»¶åˆ—è¡¨
	failedList := executor.FailedDeque()
	if failedList.Size() != 0 {
		fmt.Printf("ä»¥ä¸‹æ–‡ä»¶ä¸‹è½½å¤±è´¥: \n")
		tb := pcstable.NewTable(os.Stdout)
		for e := failedList.Shift(); e != nil; e = failedList.Shift() {
			item := e.(*taskframework.TaskInfoItem)
			tb.Append([]string{item.Info.Id(), item.Unit.(*pcsdownload.DownloadTaskUnit).PcsPath})
		}
		tb.Render()
	}
}



================================================
FILE: internal/pcscommand/export.go
================================================
package pcscommand

import (
	"container/list"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/pcstime"
	"os"
	"path"
	"strings"
	"time"
)

type (
	etask struct {
		*ListTask
		path     string
		rootPath string
		fd       *baidupcs.FileDirectory
		err      pcserror.Error
	}

	// ExportOptions å¯¼å‡ºå¯é€‰é¡¹
	ExportOptions struct {
		RootPath  string // æ ¹è·¯å¾„
		SavePath  string // è¾“å‡ºè·¯å¾„
		MaxRetry  int
		Recursive bool
	}
)

func (task *etask) handleExportTaskError(l *list.List, failedList *list.List) {
	if task.err == nil {
		return
	}

	// ä¸é‡è¯•
	switch task.err.GetError() {
	case baidupcs.ErrGetRapidUploadInfoMD5NotFound, baidupcs.ErrGetRapidUploadInfoCrc32NotFound:
		fmt.Printf("[%d] - [%s] å¯¼å‡ºå¤±è´¥, å¯èƒ½æ˜¯æœåŠ¡å™¨æœªåˆ·æ–°æ–‡ä»¶çš„md5, è¯·è¿‡ä¸€æ®µæ—¶é—´å†è¯•ä¸€è¯•\n", task.ID, task.path)
		failedList.PushBack(task)
		return
	case baidupcs.ErrFileTooLarge:
		fmt.Printf("[%d] - [%s] å¯¼å‡ºå¤±è´¥, æ–‡ä»¶å¤§äº20GB, æ— æ³•å¯¼å‡º\n", task.ID, task.path)
		failedList.PushBack(task)
		return
	}

	// æœªè¾¾åˆ°å¤±è´¥é‡è¯•æœ€å¤§æ¬¡æ•°, å°†ä»»åŠ¡æ¨é€åˆ°é˜Ÿåˆ—æœ«å°¾
	if task.retry < task.MaxRetry {
		task.retry++
		fmt.Printf("[%d] - [%s] å¯¼å‡ºé”™è¯¯, %s, é‡è¯• %d/%d\n", task.ID, task.path, task.err, task.retry, task.MaxRetry)
		l.PushBack(task)
		time.Sleep(3 * time.Duration(task.retry) * time.Second)
	} else {
		fmt.Printf("[%d] - [%s] å¯¼å‡ºé”™è¯¯, %s\n", task.ID, task.path, task.err)
		failedList.PushBack(task)
	}
}

func changeRootPath(dstRootPath, dstPath, srcRootPath string) string {
	if srcRootPath == "" {
		return dstPath
	}
	return path.Join(srcRootPath, strings.TrimPrefix(dstPath, dstRootPath))
}

// GetExportFilename è·å–å¯¼å‡ºè·¯å¾„
func GetExportFilename() string {
	return "BaiduPCS-Go_export_" + pcstime.BeijingTimeOption("") + ".txt"
}

// RunExport æ‰§è¡Œå¯¼å‡ºæ–‡ä»¶å’Œç›®å½•
func RunExport(pcspaths []string, opt *ExportOptions) {
	if opt == nil {
		opt = &ExportOptions{}
	}

	if opt.SavePath == "" {
		opt.SavePath = GetExportFilename()
	}

	pcspaths, err := matchPathByShellPattern(pcspaths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	saveFile, err := os.OpenFile(opt.SavePath, os.O_CREATE|os.O_RDWR|os.O_APPEND, 0644)
	if err != nil { // ä¸å¯å†™
		fmt.Printf("%s\n", err)
		return
	}
	defer saveFile.Close()
	fmt.Printf("å¯¼å‡ºçš„ä¿¡æ¯å°†ä¿å­˜åœ¨: %s\n", opt.SavePath)

	var (
		au         = GetActiveUser()
		pcs        = GetBaiduPCS()
		l          = list.New()
		failedList = list.New()
		writeErr   error
		id         int
	)

	for id = range pcspaths {
		var rootPath string
		if pcspaths[id] == au.Workdir {
			rootPath = pcspaths[id]
		} else {
			rootPath = path.Dir(pcspaths[id])
		}
		// åŠ å…¥é˜Ÿåˆ—
		l.PushBack(&etask{
			ListTask: &ListTask{
				ID:       id,
				MaxRetry: opt.MaxRetry,
			},
			path:     pcspaths[id],
			rootPath: rootPath,
		})
	}

	for {
		e := l.Front()
		if e == nil { // ç»“æŸ
			break
		}

		l.Remove(e) // è½½å…¥ä»»åŠ¡å, ç§»é™¤é˜Ÿåˆ—

		task := e.Value.(*etask)
		root := task.fd == nil

		// è·å–æ–‡ä»¶ä¿¡æ¯
		if task.fd == nil { // ç¬¬ä¸€æ¬¡åˆå§‹åŒ–
			fd, pcsError := pcs.FilesDirectoriesMeta(task.path)
			if pcsError != nil {
				task.err = pcsError
				task.handleExportTaskError(l, failedList)
				continue
			}
			task.fd = fd
		}

		if task.fd.Isdir { // å¯¼å‡ºç›®å½•
			if !root && !opt.Recursive { // éé€’å½’
				continue
			}

			fds, pcsError := pcs.FilesDirectoriesList(task.path, baidupcs.DefaultOrderOptions)
			if pcsError != nil {
				task.err = pcsError
				task.handleExportTaskError(l, failedList)
				continue
			}

			if len(fds) == 0 {
				_, writeErr = saveFile.Write(converter.ToBytes(fmt.Sprintf("BaiduPCS-Go mkdir \"%s\"\n", changeRootPath(task.rootPath, task.path, opt.RootPath))))
				if writeErr != nil {
					fmt.Printf("å†™å…¥æ–‡ä»¶å¤±è´¥: %s\n", writeErr)
					return // ç›´æ¥è¿”å›
				}
				fmt.Printf("[%d] - [%s] å¯¼å‡ºæˆåŠŸ\n", task.ID, task.path)
				continue
			}

			// åŠ å…¥é˜Ÿåˆ—
			for _, fd := range fds {
				// åŠ å…¥é˜Ÿåˆ—
				id++
				l.PushBack(&etask{
					ListTask: &ListTask{
						ID:       id,
						MaxRetry: opt.MaxRetry,
					},
					path:     fd.Path,
					fd:       fd,
					rootPath: task.rootPath,
				})
			}
			continue
		}

		rinfo, pcsError := pcs.ExportByFileInfo(task.fd)
		if pcsError != nil {
			task.err = pcsError
			task.handleExportTaskError(l, failedList)
			continue
		}

		_, writeErr = saveFile.Write(converter.ToBytes(fmt.Sprintf("BaiduPCS-Go rapidupload -length=%d -md5=%s -slicemd5=%s -crc32=%s \"%s\"\n", rinfo.ContentLength, rinfo.ContentMD5, rinfo.SliceMD5, rinfo.ContentCrc32, changeRootPath(task.rootPath, task.path, opt.RootPath))))
		if writeErr != nil {
			fmt.Printf("å†™å…¥æ–‡ä»¶å¤±è´¥: %s\n", writeErr)
			return // ç›´æ¥è¿”å›
		}

		fmt.Printf("[%d] - [%s] å¯¼å‡ºæˆåŠŸ\n", task.ID, task.path)
	}

	if failedList.Len() > 0 {
		fmt.Printf("\nä»¥ä¸‹ç›®å½•å¯¼å‡ºå¤±è´¥: \n")
		fmt.Printf("%s\n", strings.Repeat("-", 100))
		for e := failedList.Front(); e != nil; e = e.Next() {
			et := e.Value.(*etask)
			fmt.Printf("[%d] %s\n", et.ID, et.path)
		}
	}
}



================================================
FILE: internal/pcscommand/fixmd5.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
)

// RunFixMD5 æ‰§è¡Œä¿®å¤md5
func RunFixMD5(pcspaths ...string) {
	absPaths, err := matchPathByShellPattern(pcspaths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	pcs := GetBaiduPCS()
	finfoList, err := pcs.FilesDirectoriesBatchMeta(absPaths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	for k, finfo := range finfoList {
		err := pcs.FixMD5ByFileInfo(finfo)
		if err == nil {
			fmt.Printf("[%d] - [%s] ä¿®å¤md5æˆåŠŸ\n", k, finfo.Path)
			continue
		}

		if err.GetError() == baidupcs.ErrFixMD5Failed {
			fmt.Printf("[%d] - [%s] ä¿®å¤md5å¤±è´¥, å¯èƒ½æ˜¯æœåŠ¡å™¨æœªåˆ·æ–°\n", k, finfo.Path)
			continue
		}
		fmt.Printf("[%d] - [%s] ä¿®å¤md5å¤±è´¥, é”™è¯¯ä¿¡æ¯: %s\n", k, finfo.Path, err)
	}
}



================================================
FILE: internal/pcscommand/locatedonwload.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"os"
	"strconv"
)

// RunLocateDownload æ‰§è¡Œè·å–ç›´é“¾
func RunLocateDownload(pcspaths []string, opt *LocateDownloadOption) {
	if opt == nil {
		opt = &LocateDownloadOption{}
	}

	absPaths, err := matchPathByShellPattern(pcspaths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	pcs := GetBaiduPCS()

	if opt.FromPan {
		fds, err := pcs.FilesDirectoriesBatchMeta(absPaths...)
		if err != nil {
			fmt.Printf("%s\n", err)
			return
		}

		fidList := make([]int64, 0, len(fds))
		for i := range fds {
			fidList = append(fidList, fds[i].FsID)
		}

		list, err := pcs.LocatePanAPIDownload(fidList...)
		if err != nil {
			fmt.Printf("%s\n", err)
			return
		}

		tb := pcstable.NewTable(os.Stdout)
		tb.SetHeader([]string{"#", "fs_id", "è·¯å¾„", "é“¾æ¥"})

		var (
			i          int
			fidStrList = converter.SliceInt64ToString(fidList)
		)
		for k := range fidStrList {
			for i = range list {
				if fidStrList[k] == list[i].FsID {
					tb.Append([]string{strconv.Itoa(k), list[i].FsID, fds[k].Path, list[i].Dlink})
					list = append(list[:i], list[i+1:]...)
					break
				}
			}
		}
		tb.Render()
		fmt.Printf("\næ³¨æ„: ä»¥ä¸Šé“¾æ¥ä¸èƒ½ç›´æ¥è®¿é—®, éœ€è¦ç™»å½•ç™¾åº¦å¸å·æ‰å¯ä»¥ä¸‹è½½\n")
		return
	}

	for i, pcspath := range absPaths {
		info, err := pcs.LocateDownload(pcspath)
		if err != nil {
			fmt.Printf("[%d] %s, è·¯å¾„: %s\n", i, err, pcspath)
			continue
		}

		fmt.Printf("[%d] %s: \n", i, pcspath)
		tb := pcstable.NewTable(os.Stdout)
		tb.SetHeader([]string{"#", "é“¾æ¥"})
		for k, u := range info.URLStrings(pcsconfig.Config.EnableHTTPS) {
			tb.Append([]string{strconv.Itoa(k), u.String()})
		}
		tb.Render()
		fmt.Println()
	}
	fmt.Printf("æç¤º: è®¿é—®ä¸‹è½½é“¾æ¥, éœ€å°†ä¸‹è½½å™¨çš„ User-Agent è®¾ç½®ä¸º: %s\n", pcsconfig.Config.PanUA)
}



================================================
FILE: internal/pcscommand/login.go
================================================
package pcscommand

import (
	"bytes"
	"fmt"
	"github.com/felixonmars/Baidu-Login"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsfunctions/pcscaptcha"
	"github.com/felixonmars/BaiduPCS-Go/pcsliner"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"image/png"
	"io/ioutil"
)

// handleVerifyImg å¤„ç†éªŒè¯ç , ä¸‹è½½åˆ°æœ¬åœ°
func handleVerifyImg(imgURL string) (savePath string, err error) {
	imgContents, err := requester.Fetch("GET", imgURL, nil, nil)
	if err != nil {
		return "", fmt.Errorf("è·å–éªŒè¯ç å¤±è´¥, é”™è¯¯: %s", err)
	}

	_, err = png.Decode(bytes.NewReader(imgContents))
	if err != nil {
		return "", fmt.Errorf("éªŒè¯ç è§£æé”™è¯¯: %s", err)
	}

	savePath = pcscaptcha.CaptchaPath()

	return savePath, ioutil.WriteFile(savePath, imgContents, 0777)
}

// RunLogin ç™»å½•ç™¾åº¦å¸å·
func RunLogin(username, password string) (bduss, ptoken, stoken string, err error) {
	line := pcsliner.NewLiner()
	defer line.Close()

	bc := baidulogin.NewBaiduClinet()

	if username == "" {
		username, err = line.State.Prompt("è¯·è¾“å…¥ç™¾åº¦ç”¨æˆ·å(æ‰‹æœºå·/é‚®ç®±/ç”¨æˆ·å), å›è½¦é”®æäº¤ > ")
		if err != nil {
			return
		}
	}

	if password == "" {
		// liner çš„ PasswordPrompt ä¸å®‰å…¨, æ‹†è¡Œä¹‹åå¯†ç å°±ä¼šæ˜¾ç¤ºå‡ºæ¥äº†
		fmt.Printf("è¯·è¾“å…¥å¯†ç (è¾“å…¥çš„å¯†ç æ— å›æ˜¾, ç¡®è®¤è¾“å…¥å®Œæˆ, å›è½¦æäº¤å³å¯) > ")
		password, err = line.State.PasswordPrompt("")
		if err != nil {
			return
		}
	}

	var vcode, vcodestr string
	// ç§»é™¤éªŒè¯ç æ–‡ä»¶
	defer func() {
		pcscaptcha.RemoveCaptchaPath()
		pcscaptcha.RemoveOldCaptchaPath()
	}()

for_1:
	for i := 0; i < 10; i++ {
		lj := bc.BaiduLogin(username, password, vcode, vcodestr)

		switch lj.ErrInfo.No {
		case "0": // ç™»å½•æˆåŠŸ, é€€å‡ºå¾ªç¯
			return lj.Data.BDUSS, lj.Data.PToken, lj.Data.SToken, nil
		case "400023", "400101": // éœ€è¦éªŒè¯æ‰‹æœºæˆ–é‚®ç®±
			fmt.Printf("\néœ€è¦éªŒè¯æ‰‹æœºæˆ–é‚®ç®±æ‰èƒ½ç™»å½•\né€‰æ‹©ä¸€ç§éªŒè¯æ–¹å¼\n")
			fmt.Printf("1: æ‰‹æœº: %s\n", lj.Data.Phone)
			fmt.Printf("2: é‚®ç®±: %s\n", lj.Data.Email)
			fmt.Printf("\n")

			var verifyType string
			for et := 0; et < 3; et++ {
				verifyType, err = line.State.Prompt("è¯·è¾“å…¥éªŒè¯æ–¹å¼ (1 æˆ– 2) > ")
				if err != nil {
					return
				}

				switch verifyType {
				case "1":
					verifyType = "mobile"
				case "2":
					verifyType = "email"
				default:
					fmt.Printf("[%d/3] éªŒè¯æ–¹å¼ä¸åˆæ³•\n", et+1)
					continue
				}
				break
			}
			if verifyType != "mobile" && verifyType != "email" {
				err = fmt.Errorf("éªŒè¯æ–¹å¼ä¸åˆæ³•")
				return
			}

			msg := bc.SendCodeToUser(verifyType, lj.Data.Token) // å‘é€éªŒè¯ç 
			fmt.Printf("æ¶ˆæ¯: %s\n\n", msg)

			for et := 0; et < 5; et++ {
				vcode, err = line.State.Prompt("è¯·è¾“å…¥æ¥æ”¶åˆ°çš„éªŒè¯ç  > ")
				if err != nil {
					return
				}

				nlj := bc.VerifyCode(verifyType, lj.Data.Token, vcode, lj.Data.U)
				if nlj.ErrInfo.No != "0" {
					fmt.Printf("[%d/5] é”™è¯¯æ¶ˆæ¯: %s\n\n", et+1, nlj.ErrInfo.Msg)
					continue
				}
				// ç™»å½•æˆåŠŸ
				return nlj.Data.BDUSS, nlj.Data.PToken, nlj.Data.SToken, nil
			}
			break for_1
		case "500001", "500002": // éªŒè¯ç 
			fmt.Printf("\n%s\n", lj.ErrInfo.Msg)
			vcodestr = lj.Data.CodeString
			if vcodestr == "" {
				err = fmt.Errorf("æœªæ‰¾åˆ°codeString")
				return
			}

			// å›¾ç‰‡éªŒè¯ç 
			var (
				verifyImgURL = "https://wappass.baidu.com/cgi-bin/genimage?" + vcodestr
				savePath     string
			)

			savePath, err = handleVerifyImg(verifyImgURL)
			if err != nil {
				fmt.Println(err)
			} else {
				fmt.Printf("æ‰“å¼€ä»¥ä¸‹è·¯å¾„, ä»¥æŸ¥çœ‹éªŒè¯ç \n%s\n\n", savePath)
			}

			fmt.Printf("æˆ–è€…æ‰“å¼€ä»¥ä¸‹çš„ç½‘å€, ä»¥æŸ¥çœ‹éªŒè¯ç \n")
			fmt.Printf("%s\n\n", verifyImgURL)

			vcode, err = line.State.Prompt("è¯·è¾“å…¥éªŒè¯ç  > ")
			if err != nil {
				return
			}
			continue
		default:
			err = fmt.Errorf("é”™è¯¯ä»£ç : %s, æ¶ˆæ¯: %s", lj.ErrInfo.No, lj.ErrInfo.Msg)
			return
		}
	}
	return
}



================================================
FILE: internal/pcscommand/ls_search.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/pcstime"
	"github.com/olekukonko/tablewriter"
	"os"
	"strconv"
)

type (
	// LsOptions åˆ—ç›®å½•å¯é€‰é¡¹
	LsOptions struct {
		Total bool
	}

	// SearchOptions æœç´¢å¯é€‰é¡¹
	SearchOptions struct {
		Total   bool
		Recurse bool
	}
)

const (
	opLs int = iota
	opSearch
)

// RunLs æ‰§è¡Œåˆ—ç›®å½•
func RunLs(pcspath string, lsOptions *LsOptions, orderOptions *baidupcs.OrderOptions) {
	err := matchPathByShellPatternOnce(&pcspath)
	if err != nil {
		fmt.Println(err)
		return
	}

	files, err := GetBaiduPCS().FilesDirectoriesList(pcspath, orderOptions)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Printf("\nå½“å‰ç›®å½•: %s\n----\n", pcspath)

	if lsOptions == nil {
		lsOptions = &LsOptions{}
	}

	renderTable(opLs, lsOptions.Total, pcspath, files)
	return
}

// RunSearch æ‰§è¡Œæœç´¢
func RunSearch(targetPath, keyword string, opt *SearchOptions) {
	err := matchPathByShellPatternOnce(&targetPath)
	if err != nil {
		fmt.Println(err)
		return
	}

	if opt == nil {
		opt = &SearchOptions{}
	}

	files, err := GetBaiduPCS().Search(targetPath, keyword, opt.Recurse)
	if err != nil {
		fmt.Println(err)
		return
	}

	renderTable(opSearch, opt.Total, targetPath, files)
	return
}

func renderTable(op int, isTotal bool, path string, files baidupcs.FileDirectoryList) {
	tb := pcstable.NewTable(os.Stdout)
	var (
		fN, dN   int64
		showPath string
	)

	switch op {
	case opLs:
		showPath = "æ–‡ä»¶(ç›®å½•)"
	case opSearch:
		showPath = "è·¯å¾„"
	}

	if isTotal {
		tb.SetHeader([]string{"#", "fs_id", "app_id", "æ–‡ä»¶å¤§å°", "åˆ›å»ºæ—¥æœŸ", "ä¿®æ”¹æ—¥æœŸ", "md5(æˆªå›¾è¯·æ‰“ç )", showPath})
		tb.SetColumnAlignment([]int{tablewriter.ALIGN_DEFAULT, tablewriter.ALIGN_RIGHT, tablewriter.ALIGN_RIGHT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT})
		for k, file := range files {
			if file.Isdir {
				tb.Append([]string{strconv.Itoa(k), strconv.FormatInt(file.FsID, 10), strconv.FormatInt(file.AppID, 10), "-", pcstime.FormatTime(file.Ctime), pcstime.FormatTime(file.Mtime), file.MD5, file.Filename + baidupcs.PathSeparator})
				continue
			}

			var md5 string
			if len(file.BlockList) > 1 {
				md5 = "(å¯èƒ½ä¸æ­£ç¡®)" + file.MD5
			} else {
				md5 = file.MD5
			}

			switch op {
			case opLs:
				tb.Append([]string{strconv.Itoa(k), strconv.FormatInt(file.FsID, 10), strconv.FormatInt(file.AppID, 10), converter.ConvertFileSize(file.Size, 2), pcstime.FormatTime(file.Ctime), pcstime.FormatTime(file.Mtime), md5, file.Filename})
			case opSearch:
				tb.Append([]string{strconv.Itoa(k), strconv.FormatInt(file.FsID, 10), strconv.FormatInt(file.AppID, 10), converter.ConvertFileSize(file.Size, 2), pcstime.FormatTime(file.Ctime), pcstime.FormatTime(file.Mtime), md5, file.Path})
			}
		}
		fN, dN = files.Count()
		tb.Append([]string{"", "", "æ€»: " + converter.ConvertFileSize(files.TotalSize(), 2), "", "", "", fmt.Sprintf("æ–‡ä»¶æ€»æ•°: %d, ç›®å½•æ€»æ•°: %d", fN, dN)})
	} else {
		tb.SetHeader([]string{"#", "æ–‡ä»¶å¤§å°", "ä¿®æ”¹æ—¥æœŸ", showPath})
		tb.SetColumnAlignment([]int{tablewriter.ALIGN_DEFAULT, tablewriter.ALIGN_RIGHT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT})
		for k, file := range files {
			if file.Isdir {
				tb.Append([]string{strconv.Itoa(k), "-", pcstime.FormatTime(file.Mtime), file.Filename + baidupcs.PathSeparator})
				continue
			}

			switch op {
			case opLs:
				tb.Append([]string{strconv.Itoa(k), converter.ConvertFileSize(file.Size, 2), pcstime.FormatTime(file.Mtime), file.Filename})
			case opSearch:
				tb.Append([]string{strconv.Itoa(k), converter.ConvertFileSize(file.Size, 2), pcstime.FormatTime(file.Mtime), file.Path})
			}
		}
		fN, dN = files.Count()
		tb.Append([]string{"", "æ€»: " + converter.ConvertFileSize(files.TotalSize(), 2), "", fmt.Sprintf("æ–‡ä»¶æ€»æ•°: %d, ç›®å½•æ€»æ•°: %d", fN, dN)})
	}

	tb.Render()

	if fN+dN >= 50 {
		fmt.Printf("\nå½“å‰ç›®å½•: %s\n", path)
	}

	fmt.Printf("----\n")
}



================================================
FILE: internal/pcscommand/meta.go
================================================
package pcscommand

import (
	"fmt"
)

// RunGetMeta æ‰§è¡Œ è·å–æ–‡ä»¶/ç›®å½•çš„å…ƒä¿¡æ¯
func RunGetMeta(targetPaths ...string) {
	targetPaths, err := matchPathByShellPattern(targetPaths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	for k, targetPath := range targetPaths {
		fmt.Printf("[%d] - [%s] --------------\n", k, targetPath)
		data, err := GetBaiduPCS().FilesDirectoriesMeta(targetPath)
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Println()
		fmt.Println(data)
	}
}



================================================
FILE: internal/pcscommand/pcscommand.go
================================================
// Package pcscommand å‘½ä»¤åŒ…
package pcscommand

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
)

var (
	pcsCommandVerbose = pcsverbose.New("PCSCOMMAND")
)

// GetActiveUser è·å–å½“å‰ç™»å½•çš„ç™¾åº¦å¸å·
func GetActiveUser() *pcsconfig.Baidu {
	return pcsconfig.Config.ActiveUser()
}

// GetBaiduPCS ä»é…ç½®è¯»å–BaiduPCS
func GetBaiduPCS() *baidupcs.BaiduPCS {
	return pcsconfig.Config.ActiveUserBaiduPCS()
}



================================================
FILE: internal/pcscommand/quota.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
)

// RunGetQuota æ‰§è¡Œ è·å–å½“å‰ç”¨æˆ·ç©ºé—´é…é¢ä¿¡æ¯, å¹¶è¾“å‡º
func RunGetQuota() {
	quota, used, err := GetBaiduPCS().QuotaInfo()
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("ç”¨æˆ·å: %s, æ€»ç©ºé—´: %s, å·²ç”¨ç©ºé—´: %s, æ¯”ç‡: %f%%\n",
		GetActiveUser().Name,
		converter.ConvertFileSize(quota),
		converter.ConvertFileSize(used),
		100*float64(used)/float64(quota),
	)
}



================================================
FILE: internal/pcscommand/recycle.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/pcstime"
	"github.com/olekukonko/tablewriter"
	"os"
	"strconv"
)

// RunRecycleList æ‰§è¡Œåˆ—å‡ºå›æ”¶ç«™æ–‡ä»¶åˆ—è¡¨
func RunRecycleList(page int) {
	if page < 1 {
		page = 1
	}

	pcs := GetBaiduPCS()
	fdl, err := pcs.RecycleList(page)
	if err != nil {
		fmt.Println(err)
		return
	}

	tb := pcstable.NewTable(os.Stdout)
	tb.SetHeader([]string{"#", "fs_id", "æ–‡ä»¶å¤§å°", "åˆ›å»ºæ—¥æœŸ", "ä¿®æ”¹æ—¥æœŸ", "md5(æˆªå›¾è¯·æ‰“ç )", "å‰©ä½™æ—¶é—´", "è·¯å¾„"})
	tb.SetColumnAlignment([]int{tablewriter.ALIGN_DEFAULT, tablewriter.ALIGN_RIGHT, tablewriter.ALIGN_RIGHT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_DEFAULT, tablewriter.ALIGN_LEFT})
	for k, file := range fdl {
		if file.Isdir == 1 {
			tb.Append([]string{strconv.Itoa(k), strconv.FormatInt(file.FsID, 10), "-", pcstime.FormatTime(file.Ctime), pcstime.FormatTime(file.Mtime), file.MD5, strconv.Itoa(file.LeftTime), file.Path + baidupcs.PathSeparator})
			continue
		}
		tb.Append([]string{strconv.Itoa(k), strconv.FormatInt(file.FsID, 10), converter.ConvertFileSize(file.Size, 2), pcstime.FormatTime(file.Ctime), pcstime.FormatTime(file.Mtime), file.MD5, strconv.Itoa(file.LeftTime), file.Path})
	}

	tb.Render()
}

// RunRecycleRestore æ‰§è¡Œè¿˜åŸå›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•
func RunRecycleRestore(fidStrList ...string) {
	var (
		fidList = converter.SliceStringToInt64(fidStrList)
		pcs     = GetBaiduPCS()
		ex, err = pcs.RecycleRestore(fidList...)
	)
	if err != nil {
		fmt.Println(err)
		if len(ex) > 0 {
			fmt.Printf("\nä»¥ä¸‹çš„ fs_id è¿˜åŸæˆåŠŸ, æ•°é‡: %d\n", len(ex))
			for k := range ex {
				fmt.Println(ex[k].FsID)
			}
		}
		return
	}

	fmt.Printf("è¿˜åŸæˆåŠŸ, æ•°é‡: %d\n", len(ex))
}

// RunRecycleDelete æ‰§è¡Œåˆ é™¤å›æ”¶ç«™æ–‡ä»¶æˆ–ç›®å½•
func RunRecycleDelete(fidStrList ...string) {
	var (
		fidList = converter.SliceStringToInt64(fidStrList)
		pcs     = GetBaiduPCS()
		err     = pcs.RecycleDelete(fidList...)
	)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Printf("åˆ é™¤æˆåŠŸ\n")
}

// RunRecycleClear æ¸…ç©ºå›æ”¶ç«™
func RunRecycleClear() {
	pcs := GetBaiduPCS()
	sussNum, err := pcs.RecycleClear()
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("æ¸…ç©ºå›æ”¶ç«™æˆåŠŸ, æ•°é‡: %d\n", sussNum)
}



================================================
FILE: internal/pcscommand/rm_mkdir.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"os"
	"strconv"
)

// RunRemove æ‰§è¡Œ æ‰¹é‡åˆ é™¤æ–‡ä»¶/ç›®å½•
func RunRemove(paths ...string) {
	paths, err := matchPathByShellPattern(paths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	pnt := func() {
		tb := pcstable.NewTable(os.Stdout)
		tb.SetHeader([]string{"#", "æ–‡ä»¶/ç›®å½•"})
		for k := range paths {
			tb.Append([]string{strconv.Itoa(k), paths[k]})
		}
		tb.Render()
	}

	err = GetBaiduPCS().Remove(paths...)
	if err != nil {
		fmt.Println(err)
		fmt.Println("æ“ä½œå¤±è´¥, ä»¥ä¸‹æ–‡ä»¶/ç›®å½•åˆ é™¤å¤±è´¥: ")
		pnt()
		return
	}

	fmt.Println("æ“ä½œæˆåŠŸ, ä»¥ä¸‹æ–‡ä»¶/ç›®å½•å·²åˆ é™¤, å¯åœ¨ç½‘ç›˜æ–‡ä»¶å›æ”¶ç«™æ‰¾å›: ")
	pnt()
}

// RunMkdir æ‰§è¡Œ åˆ›å»ºç›®å½•
func RunMkdir(path string) {
	activeUser := GetActiveUser()
	err := GetBaiduPCS().Mkdir(activeUser.PathJoin(path))
	if err != nil {
		fmt.Printf("åˆ›å»ºç›®å½• %s å¤±è´¥, %s\n", path, err)
		return
	}

	fmt.Println("åˆ›å»ºç›®å½•æˆåŠŸ:", path)
}



================================================
FILE: internal/pcscommand/runner.go
================================================
package pcscommand

import (
	"io"
	"os"
)

var (
	// DefaultRunner é»˜è®¤ Runner
	DefaultRunner = Runner{
		Output: os.Stdout,
	}
)

type (
	// Runner æ‰§è¡Œå™¨
	Runner struct {
		Output       io.Writer
		IsBackground bool
	}
)



================================================
FILE: internal/pcscommand/share.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"os"
	"path"
	"strconv"
)

// RunShareSet æ‰§è¡Œåˆ†äº«
func RunShareSet(paths []string, option *baidupcs.ShareOption) {
	pcspaths, err := matchPathByShellPattern(paths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	shared, err := GetBaiduPCS().ShareSet(pcspaths, option)
	if err != nil {
		fmt.Printf("%så¤±è´¥: %s\n", baidupcs.OperationShareSet, err)
		return
	}

	fmt.Printf("shareID: %d, é“¾æ¥: %s\n", shared.ShareID, shared.Link)
}

// RunShareCancel æ‰§è¡Œå–æ¶ˆåˆ†äº«
func RunShareCancel(shareIDs []int64) {
	if len(shareIDs) == 0 {
		fmt.Printf("%så¤±è´¥, æ²¡æœ‰ä»»ä½• shareid\n", baidupcs.OperationShareCancel)
		return
	}

	err := GetBaiduPCS().ShareCancel(shareIDs)
	if err != nil {
		fmt.Printf("%så¤±è´¥: %s\n", baidupcs.OperationShareCancel, err)
		return
	}

	fmt.Printf("%sæˆåŠŸ\n", baidupcs.OperationShareCancel)
}

// RunShareList æ‰§è¡Œåˆ—å‡ºåˆ†äº«åˆ—è¡¨
func RunShareList(page int) {
	if page < 1 {
		page = 1
	}

	pcs := GetBaiduPCS()
	records, err := pcs.ShareList(page)
	if err != nil {
		fmt.Printf("%så¤±è´¥: %s\n", baidupcs.OperationShareList, err)
		return
	}

	tb := pcstable.NewTable(os.Stdout)
	tb.SetHeader([]string{"#", "ShareID", "åˆ†äº«é“¾æ¥", "æå–å¯†ç ", "ç‰¹å¾ç›®å½•", "ç‰¹å¾è·¯å¾„"})
	for k, record := range records {
		// è·å–Passwd
		if record.Public == 0 {
			// ç§å¯†åˆ†äº«
			info, pcsError := pcs.ShareSURLInfo(record.ShareID)
			if pcsError != nil {
				// è·å–é”™è¯¯
				fmt.Printf("[%d] è·å–åˆ†äº«å¯†ç é”™è¯¯: %s\n", k, pcsError)
			} else {
				record.Passwd = info.Pwd
			}
		}

		tb.Append([]string{strconv.Itoa(k), strconv.FormatInt(record.ShareID, 10), record.Shortlink, record.Passwd, path.Clean(path.Dir(record.TypicalPath)), record.TypicalPath})
	}
	tb.Render()
}



================================================
FILE: internal/pcscommand/tree.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"strings"
)

const (
	indentPrefix   = "â”‚   "
	pathPrefix     = "â”œâ”€â”€"
	lastFilePrefix = "â””â”€â”€"
)

func getTree(pcspath string, depth int) {
	var (
		err   error
		files baidupcs.FileDirectoryList
	)
	if depth == 0 {
		err := matchPathByShellPatternOnce(&pcspath)
		if err != nil {
			fmt.Println(err)
			return
		}
	}

	files, err = GetBaiduPCS().FilesDirectoriesList(pcspath, baidupcs.DefaultOrderOptions)
	if err != nil {
		fmt.Println(err)
		return
	}

	var (
		prefix          = pathPrefix
		fN              = len(files)
		indentPrefixStr = strings.Repeat(indentPrefix, depth)
	)
	for i, file := range files {
		if file.Isdir {
			fmt.Printf("%v%v %v/\n", indentPrefixStr, pathPrefix, file.Filename)
			getTree(file.Path, depth+1)
			continue
		}

		if i+1 == fN {
			prefix = lastFilePrefix
		}

		fmt.Printf("%v%v %v\n", indentPrefixStr, prefix, file.Filename)
	}

	return
}

// RunTree åˆ—å‡ºæ ‘å½¢å›¾
func RunTree(path string) {
	getTree(path, 0)
}



================================================
FILE: internal/pcscommand/upload.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsfunctions/pcsupload"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/checksum"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/taskframework"
	"os"
	"path"
	"path/filepath"
	"strings"
)

const (
	// DefaultUploadMaxRetry é»˜è®¤ä¸Šä¼ å¤±è´¥æœ€å¤§é‡è¯•æ¬¡æ•°
	DefaultUploadMaxRetry = 3
)

type (
	// UploadOptions ä¸Šä¼ å¯é€‰é¡¹
	UploadOptions struct {
		Parallel      int
		MaxRetry      int
		NoRapidUpload bool
		NoSplitFile   bool // ç¦ç”¨åˆ†ç‰‡ä¸Šä¼ 
	}
)

// RunRapidUpload æ‰§è¡Œç§’ä¼ æ–‡ä»¶, å‰ææ˜¯çŸ¥é“æ–‡ä»¶çš„å¤§å°, md5, å‰256KBåˆ‡ç‰‡çš„ md5, crc32
func RunRapidUpload(targetPath, contentMD5, sliceMD5, crc32 string, length int64) {
	err := matchPathByShellPatternOnce(&targetPath)
	if err != nil {
		fmt.Printf("è­¦å‘Š: %s, è·å–ç½‘ç›˜è·¯å¾„ %s é”™è¯¯, %s\n", baidupcs.OperationRapidUpload, targetPath, err)
	}

	err = GetBaiduPCS().RapidUpload(targetPath, contentMD5, sliceMD5, crc32, length)
	if err != nil {
		fmt.Printf("%så¤±è´¥, æ¶ˆæ¯: %s\n", baidupcs.OperationRapidUpload, err)
		return
	}

	fmt.Printf("%sæˆåŠŸ, ä¿å­˜åˆ°ç½‘ç›˜è·¯å¾„: %s\n", baidupcs.OperationRapidUpload, targetPath)
	return
}

// RunCreateSuperFile æ‰§è¡Œåˆ†ç‰‡ä¸Šä¼ â€”åˆå¹¶åˆ†ç‰‡æ–‡ä»¶
func RunCreateSuperFile(targetPath string, blockList ...string) {
	err := matchPathByShellPatternOnce(&targetPath)
	if err != nil {
		fmt.Printf("è­¦å‘Š: %s, è·å–ç½‘ç›˜è·¯å¾„ %s é”™è¯¯, %s\n", baidupcs.OperationUploadCreateSuperFile, targetPath, err)
	}

	err = GetBaiduPCS().UploadCreateSuperFile(true, targetPath, blockList...)
	if err != nil {
		fmt.Printf("%så¤±è´¥, æ¶ˆæ¯: %s\n", baidupcs.OperationUploadCreateSuperFile, err)
		return
	}

	fmt.Printf("%sæˆåŠŸ, ä¿å­˜åˆ°ç½‘ç›˜è·¯å¾„: %s\n", baidupcs.OperationUploadCreateSuperFile, targetPath)
	return
}

// RunUpload æ‰§è¡Œæ–‡ä»¶ä¸Šä¼ 
func RunUpload(localPaths []string, savePath string, opt *UploadOptions) {
	if opt == nil {
		opt = &UploadOptions{}
	}

	// æ£€æµ‹opt
	if opt.Parallel <= 0 {
		opt.Parallel = pcsconfig.Config.MaxUploadParallel
	}

	if opt.MaxRetry < 0 {
		opt.MaxRetry = DefaultUploadMaxRetry
	}

	err := matchPathByShellPatternOnce(&savePath)
	if err != nil {
		fmt.Printf("è­¦å‘Š: ä¸Šä¼ æ–‡ä»¶, è·å–ç½‘ç›˜è·¯å¾„ %s é”™è¯¯, %s\n", savePath, err)
	}

	switch len(localPaths) {
	case 0:
		fmt.Printf("æœ¬åœ°è·¯å¾„ä¸ºç©º\n")
		return
	}

	// æ‰“å¼€ä¸Šä¼ çŠ¶æ€
	uploadDatabase, err := pcsupload.NewUploadingDatabase()
	if err != nil {
		fmt.Printf("æ‰“å¼€ä¸Šä¼ æœªå®Œæˆæ•°æ®åº“é”™è¯¯: %s\n", err)
		return
	}
	defer uploadDatabase.Close()

	var (
		pcs = GetBaiduPCS()
		// ä½¿ç”¨ task framework
		executor = &taskframework.TaskExecutor{
			IsFailedDeque: true, // å¤±è´¥ç»Ÿè®¡
		}
		subSavePath string
		// ç»Ÿè®¡
		statistic = &pcsupload.UploadStatistic{}
	)

	statistic.StartTimer() // å¼€å§‹è®¡æ—¶

	for k := range localPaths {
		walkedFiles, err := pcsutil.WalkDir(localPaths[k], "")
		if err != nil {
			fmt.Printf("è­¦å‘Š: éå†é”™è¯¯: %s\n", err)
			continue
		}

		for k3 := range walkedFiles {
			var localPathDir string
			// é’ˆå¯¹ windows çš„ç›®å½•å¤„ç†
			if os.PathSeparator == '\\' {
				walkedFiles[k3] = pcsutil.ConvertToUnixPathSeparator(walkedFiles[k3])
				localPathDir = pcsutil.ConvertToUnixPathSeparator(filepath.Dir(localPaths[k]))
			} else {
				localPathDir = filepath.Dir(localPaths[k])
			}

			// é¿å…å»é™¤æ–‡ä»¶åå¼€å¤´çš„"."
			if localPathDir == "." {
				localPathDir = ""
			}

			subSavePath = strings.TrimPrefix(walkedFiles[k3], localPathDir)

			info := executor.Append(&pcsupload.UploadTaskUnit{
				LocalFileChecksum: checksum.NewLocalFileChecksum(walkedFiles[k3], int(baidupcs.SliceMD5Size)),
				SavePath:          path.Clean(savePath + baidupcs.PathSeparator + subSavePath),
				PCS:               pcs,
				UploadingDatabase: uploadDatabase,
				Parallel:          opt.Parallel,
				NoRapidUpload:     opt.NoRapidUpload,
				NoSplitFile:       opt.NoSplitFile,
				UploadStatistic:   statistic,
			}, opt.MaxRetry)
			fmt.Printf("[%s] åŠ å…¥ä¸Šä¼ é˜Ÿåˆ—: %s\n", info.Id(), walkedFiles[k3])
		}
	}

	// æ²¡æœ‰æ·»åŠ ä»»ä½•ä»»åŠ¡
	if executor.Count() == 0 {
		fmt.Printf("æœªæ£€æµ‹åˆ°ä¸Šä¼ çš„æ–‡ä»¶.\n")
		return
	}

	// æ‰§è¡Œä¸Šä¼ ä»»åŠ¡
	executor.Execute()

	fmt.Printf("\n")
	fmt.Printf("ä¸Šä¼ ç»“æŸ, æ—¶é—´: %s, æ€»å¤§å°: %s\n", statistic.Elapsed()/1e6*1e6, converter.ConvertFileSize(statistic.TotalSize()))

	// è¾“å‡ºä¸Šä¼ å¤±è´¥çš„æ–‡ä»¶åˆ—è¡¨
	failedList := executor.FailedDeque()
	if failedList.Size() != 0 {
		fmt.Printf("ä»¥ä¸‹æ–‡ä»¶ä¸Šä¼ å¤±è´¥: \n")
		tb := pcstable.NewTable(os.Stdout)
		for e := failedList.Shift(); e != nil; e = failedList.Shift() {
			item := e.(*taskframework.TaskInfoItem)
			tb.Append([]string{item.Info.Id(), item.Unit.(*pcsupload.UploadTaskUnit).LocalFileChecksum.Path})
		}
		tb.Render()
	}
}



================================================
FILE: internal/pcscommand/util.go
================================================
package pcscommand

import (
	"errors"
	"fmt"
)

var (
	// ErrShellPatternMultiRes å¤šæ¡é€šé…ç¬¦åŒ¹é…ç»“æœ
	ErrShellPatternMultiRes = errors.New("å¤šæ¡é€šé…ç¬¦åŒ¹é…ç»“æœ")
	// ErrShellPatternNoHit æœªåŒ¹é…åˆ°è·¯å¾„
	ErrShellPatternNoHit = errors.New("æœªåŒ¹é…åˆ°è·¯å¾„, è¯·æ£€æµ‹é€šé…ç¬¦")
)

// ListTask é˜Ÿåˆ—çŠ¶æ€ (åŸºç±»)
type ListTask struct {
	ID       int // ä»»åŠ¡id
	MaxRetry int // æœ€å¤§é‡è¯•æ¬¡æ•°
	retry    int // ä»»åŠ¡å¤±è´¥çš„é‡è¯•æ¬¡æ•°
}

// RunTestShellPattern æ‰§è¡Œæµ‹è¯•é€šé…ç¬¦
func RunTestShellPattern(pattern string) {
	pcs := GetBaiduPCS()
	paths, err := pcs.MatchPathByShellPattern(GetActiveUser().PathJoin(pattern))
	if err != nil {
		fmt.Println(err)
		return
	}
	for k := range paths {
		fmt.Printf("%s\n", paths[k])
	}
	return
}

func matchPathByShellPatternOnce(pattern *string) error {
	paths, err := GetBaiduPCS().MatchPathByShellPattern(GetActiveUser().PathJoin(*pattern))
	if err != nil {
		return err
	}
	switch len(paths) {
	case 0:
		return ErrShellPatternNoHit
	case 1:
		*pattern = paths[0]
	default:
		return ErrShellPatternMultiRes
	}

	return nil
}

func matchPathByShellPattern(patterns ...string) (pcspaths []string, err error) {
	acUser, pcs := GetActiveUser(), GetBaiduPCS()
	for k := range patterns {
		ps, err := pcs.MatchPathByShellPattern(acUser.PathJoin(patterns[k]))
		if err != nil {
			return nil, err
		}

		pcspaths = append(pcspaths, ps...)
	}
	return pcspaths, nil
}



================================================
FILE: internal/pcsconfig/baidu.go
================================================
package pcsconfig

import (
	"errors"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/baidu-tools/tieba"
	"github.com/olekukonko/tablewriter"
	"path"
	"path/filepath"
	"strconv"
	"strings"
)

var (
	//ErrNoSuchBaiduUser æœªç™»å½•ä»»ä½•ç™¾åº¦å¸å·
	ErrNoSuchBaiduUser = errors.New("no such baidu user")
	//ErrBaiduUserNotFound æœªæ‰¾åˆ°ç™¾åº¦å¸å·
	ErrBaiduUserNotFound = errors.New("baidu user not found")
)

//BaiduBase BaiduåŸº
type BaiduBase struct {
	UID  uint64 `json:"uid"`  // ç™¾åº¦IDå¯¹åº”çš„uid
	Name string `json:"name"` // çœŸå®ID
}

// Baidu ç™¾åº¦å¸å·å¯¹è±¡
type Baidu struct {
	BaiduBase
	Sex string  `json:"sex"` // æ€§åˆ«
	Age float64 `json:"age"` // å¸å·å¹´é¾„

	BDUSS  string `json:"bduss"`
	PTOKEN string `json:"ptoken"`
	STOKEN string `json:"stoken"`

	Workdir string `json:"workdir"` // å·¥ä½œç›®å½•
}

// BaiduPCS åˆå§‹åŒ–*baidupcs.BaiduPCS
func (baidu *Baidu) BaiduPCS() *baidupcs.BaiduPCS {
	pcs := baidupcs.NewPCS(Config.AppID, baidu.BDUSS)
	pcs.SetStoken(baidu.STOKEN)
	pcs.SetHTTPS(Config.EnableHTTPS)
	pcs.SetPCSUserAgent(Config.PCSUA)
	pcs.SetPanUserAgent(Config.PanUA)
	pcs.SetUID(baidu.UID)
	return pcs
}

// GetSavePath æ ¹æ®æä¾›çš„ç½‘ç›˜æ–‡ä»¶è·¯å¾„ pcspath, è¿”å›æœ¬åœ°å‚¨å­˜è·¯å¾„,
// è¿”å›ç»å¯¹è·¯å¾„, è·å–ç»å¯¹è·¯å¾„å‡ºé”™æ—¶æ‰è¿”å›ç›¸å¯¹è·¯å¾„...
func (baidu *Baidu) GetSavePath(pcspath string) string {
	dirStr := filepath.Join(Config.SaveDir, fmt.Sprintf("%d_%s", baidu.UID, converter.TrimPathInvalidChars(baidu.Name)), pcspath)
	dir, err := filepath.Abs(dirStr)
	if err != nil {
		dir = filepath.Clean(dirStr)
	}
	return dir
}

// PathJoin åˆå¹¶å·¥ä½œç›®å½•å’Œç›¸å¯¹è·¯å¾„p, è‹¥pä¸ºç»å¯¹è·¯å¾„åˆ™å¿½ç•¥
func (baidu *Baidu) PathJoin(p string) string {
	if path.IsAbs(p) {
		return p
	}
	return path.Join(baidu.Workdir, p)
}

// BaiduUserList ç™¾åº¦å¸å·åˆ—è¡¨
type BaiduUserList []*Baidu

// NewUserInfoByBDUSS æ£€æµ‹BDUSSæœ‰æ•ˆæ€§, åŒæ—¶è·å–ç™¾åº¦è¯¦ç»†ä¿¡æ¯ (æ— æ³•è·å– ptoken å’Œ stoken)
func NewUserInfoByBDUSS(bduss string) (b *Baidu, err error) {
	t, err := tieba.NewUserInfoByBDUSS(bduss)
	if err != nil {
		return nil, err
	}

	b = &Baidu{
		BaiduBase: BaiduBase{
			UID:  t.Baidu.UID,
			Name: t.Baidu.Name,
		},
		Sex:     t.Baidu.Sex,
		Age:     t.Baidu.Age,
		BDUSS:   bduss,
		Workdir: "/",
	}
	return b, nil
}

// String æ ¼å¼è¾“å‡ºç™¾åº¦å¸å·åˆ—è¡¨
func (bl *BaiduUserList) String() string {
	builder := &strings.Builder{}

	tb := pcstable.NewTable(builder)
	tb.SetColumnAlignment([]int{tablewriter.ALIGN_DEFAULT, tablewriter.ALIGN_RIGHT, tablewriter.ALIGN_CENTER, tablewriter.ALIGN_CENTER, tablewriter.ALIGN_CENTER})
	tb.SetHeader([]string{"#", "uid", "ç”¨æˆ·å", "æ€§åˆ«", "age"})

	for k, baiduInfo := range *bl {
		tb.Append([]string{strconv.Itoa(k), strconv.FormatUint(baiduInfo.UID, 10), baiduInfo.Name, baiduInfo.Sex, fmt.Sprint(baiduInfo.Age)})
	}

	tb.Render()

	return builder.String()
}



================================================
FILE: internal/pcsconfig/errors.go
================================================
package pcsconfig

import (
	"errors"
)

var (
	//ErrNotLogin æœªç™»å½•å¸å·é”™è¯¯
	ErrNotLogin = errors.New("baidu user not login")
	//ErrConfigFilePathNotSet æœªè®¾ç½®é…ç½®æ–‡ä»¶
	ErrConfigFilePathNotSet = errors.New("config file not set")
	//ErrConfigFileNotExist æœªè®¾ç½®Config, æœªåˆå§‹åŒ–
	ErrConfigFileNotExist = errors.New("config file not exist")
	//ErrConfigFileNoPermission Configæ–‡ä»¶æ— æƒé™è®¿é—®
	ErrConfigFileNoPermission = errors.New("config file permission denied")
	//ErrConfigContentsParseError è§£æConfigæ•°æ®é”™è¯¯
	ErrConfigContentsParseError = errors.New("config contents parse error")
)



================================================
FILE: internal/pcsconfig/export.go
================================================
package pcsconfig

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/olekukonko/tablewriter"
	"os"
	"strconv"
)

// ActiveUser è·å–å½“å‰ç™»å½•çš„ç”¨æˆ·
func (c *PCSConfig) ActiveUser() *Baidu {
	if c.activeUser == nil {
		return &Baidu{}
	}
	return c.activeUser
}

// ActiveUserBaiduPCS è·å–å½“å‰ç™»å½•çš„ç”¨æˆ·çš„baidupcs.BaiduPCS
func (c *PCSConfig) ActiveUserBaiduPCS() *baidupcs.BaiduPCS {
	if c.pcs == nil {
		c.pcs = c.ActiveUser().BaiduPCS()
	}
	return c.pcs
}

func (c *PCSConfig) httpClientWithUA(ua string) *requester.HTTPClient {
	client := requester.NewHTTPClient()
	client.SetHTTPSecure(c.EnableHTTPS)
	client.SetUserAgent(ua)
	return client
}

// HTTPClient è¿”å›è®¾ç½®å¥½çš„ HTTPClient
func (c *PCSConfig) HTTPClient() *requester.HTTPClient {
	return c.httpClientWithUA(c.UserAgent)
}

// PCSHTTPClient è¿”å›è®¾ç½®å¥½çš„ PCS HTTPClient
func (c *PCSConfig) PCSHTTPClient() *requester.HTTPClient {
	return c.httpClientWithUA(c.PCSUA)
}

// PanHTTPClient è¿”å›è®¾ç½®å¥½çš„ Pan HTTPClient
func (c *PCSConfig) PanHTTPClient() *requester.HTTPClient {
	return c.httpClientWithUA(c.PanUA)
}

// NumLogins è·å–ç™»å½•çš„ç”¨æˆ·æ•°é‡
func (c *PCSConfig) NumLogins() int {
	return len(c.BaiduUserList)
}

// AverageParallel è¿”å›å¹³å‡çš„ä¸‹è½½æœ€å¤§å¹¶å‘é‡
func (c *PCSConfig) AverageParallel() int {
	return AverageParallel(c.MaxParallel, c.MaxDownloadLoad)
}

// PrintTable è¾“å‡ºè¡¨æ ¼
func (c *PCSConfig) PrintTable() {
	tb := pcstable.NewTable(os.Stdout)
	tb.SetHeader([]string{"åç§°", "å€¼", "å»ºè®®å€¼", "æè¿°"})
	tb.SetHeaderAlignment(tablewriter.ALIGN_LEFT)
	tb.SetColumnAlignment([]int{tablewriter.ALIGN_DEFAULT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT})
	tb.AppendBulk([][]string{
		[]string{"appid", fmt.Sprint(c.AppID), "", "ç™¾åº¦ PCS åº”ç”¨ID"},
		[]string{"cache_size", converter.ConvertFileSize(int64(c.CacheSize), 2), "1KB ~ 256KB", "ä¸‹è½½ç¼“å­˜, å¦‚æœç¡¬ç›˜å ç”¨é«˜æˆ–ä¸‹è½½é€Ÿåº¦æ…¢, è¯·å°è¯•è°ƒå¤§æ­¤å€¼"},
		[]string{"max_parallel", strconv.Itoa(c.MaxParallel), "1 ~ 64", "ä¸‹è½½æœ€å¤§å¹¶å‘é‡"},
		[]string{"max_upload_parallel", strconv.Itoa(c.MaxUploadParallel), "1 ~ 100", "ä¸Šä¼ æœ€å¤§å¹¶å‘é‡"},
		[]string{"max_download_load", strconv.Itoa(c.MaxDownloadLoad), "1 ~ 5", "åŒæ—¶è¿›è¡Œä¸‹è½½æ–‡ä»¶çš„æœ€å¤§æ•°é‡"},
		[]string{"max_download_rate", showMaxRate(c.MaxDownloadRate), "", "é™åˆ¶æœ€å¤§ä¸‹è½½é€Ÿåº¦, 0ä»£è¡¨ä¸é™åˆ¶"},
		[]string{"max_upload_rate", showMaxRate(c.MaxUploadRate), "", "é™åˆ¶æœ€å¤§ä¸Šä¼ é€Ÿåº¦, 0ä»£è¡¨ä¸é™åˆ¶"},
		[]string{"savedir", c.SaveDir, "", "ä¸‹è½½æ–‡ä»¶çš„å‚¨å­˜ç›®å½•"},
		[]string{"enable_https", fmt.Sprint(c.EnableHTTPS), "true", "å¯ç”¨ https"},
		[]string{"user_agent", c.UserAgent, requester.DefaultUserAgent, "æµè§ˆå™¨æ ‡è¯†"},
		[]string{"pcs_ua", c.PCSUA, "", "PCS æµè§ˆå™¨æ ‡è¯†"},
		[]string{"pan_ua", c.PanUA, baidupcs.NetdiskUA, "Pan æµè§ˆå™¨æ ‡è¯†"},
		[]string{"proxy", c.Proxy, "", "è®¾ç½®ä»£ç†, æ”¯æŒ http/socks5 ä»£ç†"},
		[]string{"local_addrs", c.LocalAddrs, "", "è®¾ç½®æœ¬åœ°ç½‘å¡åœ°å€, å¤šä¸ªåœ°å€ç”¨é€—å·éš”å¼€"},
	})
	tb.Render()
}



================================================
FILE: internal/pcsconfig/maniper.go
================================================
package pcsconfig

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"strings"
)

const (
	opDelete = "delete"
	opSwitch = "switch"
	opGet    = "get"
)

func (c *PCSConfig) manipUser(op string, baiduBase *BaiduBase) (*Baidu, error) {
	// empty baiduBase
	if baiduBase == nil || (baiduBase.UID == 0 && baiduBase.Name == "") {
		switch op {
		case opGet:
			return &Baidu{}, nil
		default:
			return nil, ErrBaiduUserNotFound
		}
	}
	if len(c.BaiduUserList) == 0 {
		return nil, ErrNoSuchBaiduUser
	}

	for k, user := range c.BaiduUserList {
		if user == nil {
			continue
		}

		switch {
		case baiduBase.UID != 0 && baiduBase.Name != "":
			// ä¸åŒºåˆ†å¤§å°å†™
			if user.UID == baiduBase.UID && strings.EqualFold(user.Name, baiduBase.Name) {
				goto handle
			}
			continue
		case baiduBase.UID == 0 && baiduBase.Name != "":
			// ä¸åŒºåˆ†å¤§å°å†™
			if strings.EqualFold(user.Name, baiduBase.Name) {
				goto handle
			}
			continue
		case baiduBase.UID != 0 && baiduBase.Name == "":
			if user.UID == baiduBase.UID {
				goto handle
			}
			continue
		default:
			continue
		}
		// unreachable zone

	handle:
		switch op {
		case opSwitch:
			c.setupNewUser(user)
		case opDelete:
			c.BaiduUserList = append(c.BaiduUserList[:k], c.BaiduUserList[k+1:]...)

			// ä¿®æ”¹ æ­£åœ¨ä½¿ç”¨çš„ ç™¾åº¦å¸å·
			// å¦‚æœè¦åˆ é™¤çš„å¸å·ä¸ºå½“å‰ç™»å½•çš„å¸å·, åˆ™è®¾ç½®å½“å‰ç™»å½•å¸å·ä¸ºåˆ—è¡¨ä¸­ç¬¬ä¸€ä¸ªå¸å·
			if c.BaiduActiveUID == user.UID {
				if len(c.BaiduUserList) != 0 {
					c.setupNewUser(c.BaiduUserList[0])
				} else {
					c.BaiduActiveUID = 0
				}
			}
		case opGet:
			// do nothing
		default:
			// do nothing
		}
		return user, nil
	}

	return nil, ErrBaiduUserNotFound
}

//setupNewUser ä»å·²æœ‰ç”¨æˆ·ä¸­, è®¾ç½®æ–°çš„å½“å‰ç™»å½•ç”¨æˆ·
func (c *PCSConfig) setupNewUser(user *Baidu) {
	if user == nil {
		return
	}
	c.BaiduActiveUID = user.UID
	c.activeUser = user
	c.pcs = user.BaiduPCS()
}

// SwitchUser åˆ‡æ¢ç”¨æˆ·, è¿”å›åˆ‡æ¢æˆåŠŸçš„ç”¨æˆ·
func (c *PCSConfig) SwitchUser(baiduBase *BaiduBase) (*Baidu, error) {
	return c.manipUser(opSwitch, baiduBase)
}

// DeleteUser åˆ é™¤ç”¨æˆ·, è¿”å›åˆ é™¤æˆåŠŸçš„ç”¨æˆ·
func (c *PCSConfig) DeleteUser(baiduBase *BaiduBase) (*Baidu, error) {
	return c.manipUser(opDelete, baiduBase)
}

// GetBaiduUser è·å–ç™¾åº¦ç”¨æˆ·ä¿¡æ¯
func (c *PCSConfig) GetBaiduUser(baidubase *BaiduBase) (*Baidu, error) {
	return c.manipUser(opGet, baidubase)
}

// CheckBaiduUserExist æ£€æŸ¥ç™¾åº¦ç”¨æˆ·æ˜¯å¦å­˜åœ¨äºå·²ç™»å½•åˆ—è¡¨
func (c *PCSConfig) CheckBaiduUserExist(baidubase *BaiduBase) bool {
	_, err := c.manipUser("", baidubase)
	return err == nil
}

// SetupUserByBDUSS è®¾ç½®ç™¾åº¦ bduss, ptoken, stoken å¹¶ä¿å­˜
func (c *PCSConfig) SetupUserByBDUSS(bduss, ptoken, stoken string) (baidu *Baidu, err error) {
	b, err := NewUserInfoByBDUSS(bduss)
	if err != nil {
		return nil, err
	}

	c.DeleteUser(&BaiduBase{
		UID: b.UID,
	}) // åˆ é™¤æ—§çš„ä¿¡æ¯

	b.PTOKEN = ptoken
	b.STOKEN = stoken

	c.BaiduUserList = append(c.BaiduUserList, b)

	// è‡ªåŠ¨åˆ‡æ¢ç”¨æˆ·
	c.setupNewUser(b)
	return b, nil
}

// SetAppID è®¾ç½®app_id
func (c *PCSConfig) SetAppID(appID int) {
	c.AppID = appID
	if c.pcs != nil {
		c.pcs.SetAPPID(appID)
	}
}

// SetCacheSizeByStr è®¾ç½®cache_size
func (c *PCSConfig) SetCacheSizeByStr(sizeStr string) error {
	size, err := converter.ParseFileSizeStr(sizeStr)
	if err != nil {
		return err
	}
	c.CacheSize = int(size)
	return nil
}

// SetMaxDownloadRateByStr è®¾ç½® max_download_rate
func (c *PCSConfig) SetMaxDownloadRateByStr(sizeStr string) error {
	size, err := converter.ParseFileSizeStr(stripPerSecond(sizeStr))
	if err != nil {
		return err
	}
	c.MaxDownloadRate = size
	return nil
}

// SetMaxUploadRateByStr è®¾ç½® max_upload_rate
func (c *PCSConfig) SetMaxUploadRateByStr(sizeStr string) error {
	size, err := converter.ParseFileSizeStr(stripPerSecond(sizeStr))
	if err != nil {
		return err
	}
	c.MaxUploadRate = size
	return nil
}

// SetUserAgent è®¾ç½®User-Agent
func (c *PCSConfig) SetUserAgent(userAgent string) {
	c.UserAgent = userAgent
	requester.UserAgent = userAgent
}

// SetPCSUA è®¾ç½® PCS User-Agent
func (c *PCSConfig) SetPCSUA(pcsUA string) {
	c.PCSUA = pcsUA
	if c.pcs != nil {
		c.pcs.SetPCSUserAgent(pcsUA)
	}
}

// SetPanUA è®¾ç½® Pan User-Agent
func (c *PCSConfig) SetPanUA(panUA string) {
	c.PanUA = panUA
	if c.pcs != nil {
		c.pcs.SetPanUserAgent(panUA)
	}
}

// SetEnableHTTPS è®¾ç½®æ˜¯å¦å¯ç”¨https
func (c *PCSConfig) SetEnableHTTPS(https bool) {
	c.EnableHTTPS = https
	if c.pcs != nil {
		c.pcs.SetHTTPS(https)
	}
}

// SetProxy è®¾ç½®ä»£ç†
func (c *PCSConfig) SetProxy(proxy string) {
	c.Proxy = proxy
	requester.SetGlobalProxy(proxy)
}

// SetLocalAddrs è®¾ç½®localAddrs
func (c *PCSConfig) SetLocalAddrs(localAddrs string) {
	c.LocalAddrs = localAddrs
	requester.SetLocalTCPAddrList(strings.Split(localAddrs, ",")...)
}



================================================
FILE: internal/pcsconfig/pcsconfig.go
================================================
// Package pcsconfig é…ç½®åŒ…
package pcsconfig

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/jsonhelper"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/json-iterator/go"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
)

const (
	// EnvConfigDir é…ç½®è·¯å¾„ç¯å¢ƒå˜é‡
	EnvConfigDir = "BAIDUPCS_GO_CONFIG_DIR"
	// ConfigName é…ç½®æ–‡ä»¶å
	ConfigName = "pcs_config.json"
)

var (
	pcsConfigVerbose = pcsverbose.New("PCSCONFIG")
	configFilePath   = filepath.Join(GetConfigDir(), ConfigName)

	// Config é…ç½®ä¿¡æ¯, ç”±å¤–éƒ¨è°ƒç”¨
	Config = NewConfig(configFilePath)
)

// PCSConfig é…ç½®è¯¦æƒ…
type PCSConfig struct {
	BaiduActiveUID uint64        `json:"baidu_active_uid"`
	BaiduUserList  BaiduUserList `json:"baidu_user_list"`

	AppID int `json:"appid"` // appid

	CacheSize         int `json:"cache_size"`          // ä¸‹è½½ç¼“å­˜
	MaxParallel       int `json:"max_parallel"`        // æœ€å¤§ä¸‹è½½å¹¶å‘é‡
	MaxUploadParallel int `json:"max_upload_parallel"` // æœ€å¤§ä¸Šä¼ å¹¶å‘é‡
	MaxDownloadLoad   int `json:"max_download_load"`   // åŒæ—¶è¿›è¡Œä¸‹è½½æ–‡ä»¶çš„æœ€å¤§æ•°é‡

	MaxDownloadRate int64 `json:"max_download_rate"` // é™åˆ¶æœ€å¤§ä¸‹è½½é€Ÿåº¦
	MaxUploadRate   int64 `json:"max_upload_rate"`   // é™åˆ¶æœ€å¤§ä¸Šä¼ é€Ÿåº¦

	UserAgent   string `json:"user_agent"`   // æµè§ˆå™¨æ ‡è¯†
	PCSUA       string `json:"pcs_ua"`       // PCSæµè§ˆå™¨æ ‡è¯†
	PanUA       string `json:"pan_ua"`       // PANæµè§ˆå™¨æ ‡è¯†
	SaveDir     string `json:"savedir"`      // ä¸‹è½½å‚¨å­˜è·¯å¾„
	EnableHTTPS bool   `json:"enable_https"` // å¯ç”¨https
	Proxy       string `json:"proxy"`        // ä»£ç†
	LocalAddrs  string `json:"local_addrs"`  // æœ¬åœ°ç½‘å¡åœ°å€

	configFilePath string
	configFile     *os.File
	fileMu         sync.Mutex
	activeUser     *Baidu
	pcs            *baidupcs.BaiduPCS
}

// NewConfig è¿”å› PCSConfig æŒ‡é’ˆå¯¹è±¡
func NewConfig(configFilePath string) *PCSConfig {
	c := &PCSConfig{
		configFilePath: configFilePath,
	}
	return c
}

// Init åˆå§‹åŒ–é…ç½®
func (c *PCSConfig) Init() error {
	return c.init()
}

// Reload ä»æ–‡ä»¶é‡è½½é…ç½®
func (c *PCSConfig) Reload() error {
	return c.init()
}

// Close å…³é—­é…ç½®æ–‡ä»¶
func (c *PCSConfig) Close() error {
	if c.configFile != nil {
		err := c.configFile.Close()
		c.configFile = nil
		return err
	}
	return nil
}

// Save ä¿å­˜é…ç½®ä¿¡æ¯åˆ°é…ç½®æ–‡ä»¶
func (c *PCSConfig) Save() error {
	// æ£€æµ‹é…ç½®é¡¹æ˜¯å¦åˆæ³•, ä¸åˆæ³•åˆ™è‡ªåŠ¨ä¿®å¤
	c.fix()

	err := c.lazyOpenConfigFile()
	if err != nil {
		return err
	}

	c.fileMu.Lock()
	defer c.fileMu.Unlock()

	data, err := jsoniter.MarshalIndent(c, "", " ")
	if err != nil {
		// jsonæ•°æ®ç”Ÿæˆå¤±è´¥
		panic(err)
	}

	// å‡æ‰å¤šä½™çš„éƒ¨åˆ†
	err = c.configFile.Truncate(int64(len(data)))
	if err != nil {
		return err
	}

	_, err = c.configFile.Seek(0, os.SEEK_SET)
	if err != nil {
		return err
	}

	_, err = c.configFile.Write(data)
	if err != nil {
		return err
	}

	return nil
}

func (c *PCSConfig) init() error {
	if c.configFilePath == "" {
		return ErrConfigFileNotExist
	}

	c.initDefaultConfig()
	err := c.loadConfigFromFile()
	if err != nil {
		return err
	}

	// è½½å…¥é…ç½®
	// å¦‚æœ activeUser å·²åˆå§‹åŒ–, åˆ™è·³è¿‡
	if c.activeUser != nil && c.activeUser.UID == c.BaiduActiveUID {
		return nil
	}

	c.activeUser, err = c.GetBaiduUser(&BaiduBase{
		UID: c.BaiduActiveUID,
	})
	if err != nil {
		return err
	}
	c.pcs = c.activeUser.BaiduPCS()

	// è®¾ç½®å…¨å±€User-Agent
	requester.UserAgent = c.UserAgent
	// è®¾ç½®å…¨å±€ä»£ç†
	requester.SetGlobalProxy(c.Proxy)
	// è®¾ç½®æœ¬åœ°ç½‘å¡åœ°å€
	requester.SetLocalTCPAddrList(strings.Split(c.LocalAddrs, ",")...)

	return nil
}

// lazyOpenConfigFile æ‰“å¼€é…ç½®æ–‡ä»¶
func (c *PCSConfig) lazyOpenConfigFile() (err error) {
	if c.configFile != nil {
		return nil
	}

	c.fileMu.Lock()
	os.MkdirAll(filepath.Dir(c.configFilePath), 0700)
	c.configFile, err = os.OpenFile(c.configFilePath, os.O_CREATE|os.O_RDWR, 0600)
	c.fileMu.Unlock()

	if err != nil {
		if os.IsPermission(err) {
			return ErrConfigFileNoPermission
		}
		if os.IsExist(err) {
			return ErrConfigFileNotExist
		}
		return err
	}
	return nil
}

// loadConfigFromFile è½½å…¥é…ç½®
func (c *PCSConfig) loadConfigFromFile() (err error) {
	err = c.lazyOpenConfigFile()
	if err != nil {
		return err
	}

	// æœªåˆå§‹åŒ–
	info, err := c.configFile.Stat()
	if err != nil {
		return err
	}

	if info.Size() == 0 {
		err = c.Save()
		return err
	}

	c.fileMu.Lock()
	defer c.fileMu.Unlock()

	_, err = c.configFile.Seek(0, os.SEEK_SET)
	if err != nil {
		return err
	}

	err = jsonhelper.UnmarshalData(c.configFile, c)
	if err != nil {
		return ErrConfigContentsParseError
	}
	return nil
}

func (c *PCSConfig) initDefaultConfig() {
	c.AppID = 266719
	c.CacheSize = 65536
	c.MaxParallel = 1
	c.MaxUploadParallel = 8
	c.MaxDownloadLoad = 1
	c.UserAgent = requester.UserAgent
	c.PCSUA = ""
	c.PanUA = baidupcs.NetdiskUA
	c.EnableHTTPS = true

	// è®¾ç½®é»˜è®¤çš„ä¸‹è½½è·¯å¾„
	switch runtime.GOOS {
	case "windows":
		c.SaveDir = pcsutil.ExecutablePathJoin("Downloads")
	case "android":
		// TODO: è·å–å®Œæ•´çš„çš„ä¸‹è½½è·¯å¾„
		c.SaveDir = "/sdcard/Download"
	default:
		dataPath, ok := os.LookupEnv("HOME")
		if !ok {
			pcsConfigVerbose.Warn("Environment HOME not set")
			c.SaveDir = pcsutil.ExecutablePathJoin("Downloads")
		} else {
			c.SaveDir = filepath.Join(dataPath, "Downloads")
		}
	}
}

// GetConfigDir è·å–é…ç½®è·¯å¾„
func GetConfigDir() string {
	// ä»ç¯å¢ƒå˜é‡è¯»å–
	configDir, ok := os.LookupEnv(EnvConfigDir)
	if ok {
		if filepath.IsAbs(configDir) {
			return configDir
		}
		// å¦‚æœä¸æ˜¯ç»å¯¹è·¯å¾„, ä»ç¨‹åºç›®å½•å¯»æ‰¾
		return pcsutil.ExecutablePathJoin(configDir)
	}

	// ä½¿ç”¨æ—§ç‰ˆ
	// å¦‚æœæ—§ç‰ˆçš„é…ç½®æ–‡ä»¶å­˜åœ¨, åˆ™ä½¿ç”¨æ—§ç‰ˆ
	oldConfigDir := pcsutil.ExecutablePath()
	_, err := os.Stat(filepath.Join(oldConfigDir, ConfigName))
	if err == nil {
		return oldConfigDir
	}

	switch runtime.GOOS {
	case "windows":
		dataPath, ok := os.LookupEnv("APPDATA")
		if !ok {
			pcsConfigVerbose.Warn("Environment APPDATA not set")
			return oldConfigDir
		}
		return filepath.Join(dataPath, "BaiduPCS-Go")
	default:
		dataPath, ok := os.LookupEnv("HOME")
		if !ok {
			pcsConfigVerbose.Warn("Environment HOME not set")
			return oldConfigDir
		}
		configDir = filepath.Join(dataPath, ".config", "BaiduPCS-Go")

		// æ£€æµ‹æ˜¯å¦å¯å†™
		err = os.MkdirAll(configDir, 0700)
		if err != nil {
			pcsConfigVerbose.Warnf("check config dir error: %s\n", err)
			return oldConfigDir
		}
		return configDir
	}
}

func (c *PCSConfig) fix() {
	if c.CacheSize < 1024 {
		c.CacheSize = 1024
	}
	if c.MaxParallel < 1 {
		c.MaxParallel = 1
	}
	if c.MaxUploadParallel < 1 {
		c.MaxUploadParallel = 1
	}
	if c.MaxDownloadLoad < 1 {
		c.MaxDownloadLoad = 1
	}
}



================================================
FILE: internal/pcsconfig/util.go
================================================
package pcsconfig

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"strings"
)

// AverageParallel è¿”å›å¹³å‡çš„ä¸‹è½½æœ€å¤§å¹¶å‘é‡
func AverageParallel(parallel, downloadLoad int) int {
	if downloadLoad < 1 {
		return 1
	}

	p := parallel / downloadLoad
	if p < 1 {
		return 1
	}
	return p
}

func stripPerSecond(sizeStr string) string {
	i := strings.LastIndex(sizeStr, "/")
	if i < 0 {
		return sizeStr
	}
	return sizeStr[:i]
}

func showMaxRate(size int64) string {
	if size <= 0 {
		return "ä¸é™åˆ¶"
	}
	return converter.ConvertFileSize(size, 2) + "/s"
}



================================================
FILE: internal/pcsfunctions/common.go
================================================
package pcsfunctions

import "time"

// RetryWait å¤±è´¥é‡è¯•ç­‰å¾…äº‹ä»¶
func RetryWait(retry int) time.Duration {
	if retry < 3 {
		return 2 * time.Duration(retry) * time.Second
	}
	return 6 * time.Second
}



================================================
FILE: internal/pcsfunctions/statistic.go
================================================
package pcsfunctions

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"sync/atomic"
	"time"
)

type (
	Statistic struct {
		totalSize int64
		startTime time.Time
	}
)

func (s *Statistic) AddTotalSize(size int64) int64 {
	return atomic.AddInt64(&s.totalSize, size)
}

func (s *Statistic) TotalSize() int64 {
	return s.totalSize
}

func (s *Statistic) StartTimer() {
	s.startTime = time.Now()
	expires.StripMono(&s.startTime)
}

func (s *Statistic) Elapsed() time.Duration {
	return time.Now().Sub(s.startTime)
}


================================================
FILE: internal/pcsfunctions/pcscaptcha/captchapath.go
================================================
package pcscaptcha

import (
	"os"
	"path/filepath"
)

// CaptchaPath è¿”å›éªŒè¯ç å­˜æ”¾è·¯å¾„
func CaptchaPath() string {
	return filepath.Join(os.TempDir(), CaptchaName)
}



================================================
FILE: internal/pcsfunctions/pcscaptcha/pcscaptcha.go
================================================
// Package pcscaptcha éªŒè¯ç å¤„ç†åŒ…
// TODO: ç›´æ¥æ‰“å¼€éªŒè¯ç 
package pcscaptcha

import (
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"os"
	"path/filepath"
)

const (
	// CaptchaName éªŒè¯ç æ–‡ä»¶åç§°
	CaptchaName = "captcha.png"
)

// RemoveOldCaptchaPath ç§»é™¤æ—§çš„éªŒè¯ç è·¯å¾„
func RemoveOldCaptchaPath() error {
	return os.Remove(filepath.Join(pcsconfig.GetConfigDir(), CaptchaName))
}

// RemoveCaptchaPath ç§»é™¤éªŒè¯ç è·¯å¾„
func RemoveCaptchaPath() error {
	return os.Remove(CaptchaPath())
}



================================================
FILE: internal/pcsfunctions/pcsdownload/download_link.go
================================================
package pcsdownload

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"net/url"
)

func GetLocateDownloadLinks(pcs *baidupcs.BaiduPCS, pcspath string) (dlinks []*url.URL, err error) {
	dInfo, pcsError := pcs.LocateDownload(pcspath)
	if pcsError != nil {
		return nil, pcsError
	}

	us := dInfo.URLStrings(pcsconfig.Config.EnableHTTPS)
	if len(us) == 0 {
		return nil, ErrDlinkNotFound
	}

	return us, nil
}



================================================
FILE: internal/pcsfunctions/pcsdownload/download_statistic.go
================================================
package pcsdownload

import (
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsfunctions"
)

type (
	DownloadStatistic struct {
		pcsfunctions.Statistic
	}
)



================================================
FILE: internal/pcsfunctions/pcsdownload/download_task_unit.go
================================================
package pcsdownload

import (
	"errors"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsfunctions"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/taskframework"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/felixonmars/BaiduPCS-Go/requester/downloader"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

type (
	// DownloadMode ä¸‹è½½æ¨¡å¼
	DownloadMode int

	// DownloadTaskUnit ä¸‹è½½çš„ä»»åŠ¡å•å…ƒ
	DownloadTaskUnit struct {
		taskInfo *taskframework.TaskInfo // ä»»åŠ¡ä¿¡æ¯

		Cfg                *downloader.Config
		PCS                *baidupcs.BaiduPCS
		ParentTaskExecutor *taskframework.TaskExecutor

		DownloadStatistic *DownloadStatistic // ä¸‹è½½ç»Ÿè®¡

		// å¯é€‰é¡¹
		VerbosePrinter       *pcsverbose.PCSVerbose
		PrintFormat          string
		IsPrintStatus        bool // æ˜¯å¦è¾“å‡ºå„ä¸ªä¸‹è½½çº¿ç¨‹çš„è¯¦ç»†ä¿¡æ¯
		IsExecutedPermission bool // ä¸‹è½½æˆåŠŸåæ˜¯å¦åŠ ä¸Šæ‰§è¡Œæƒé™
		IsOverwrite          bool // æ˜¯å¦è¦†ç›–å·²å­˜åœ¨çš„æ–‡ä»¶
		NoCheck              bool // ä¸æ ¡éªŒæ–‡ä»¶

		DownloadMode DownloadMode // ä¸‹è½½æ¨¡å¼

		PcsPath  string // è¦ä¸‹è½½çš„ç½‘ç›˜æ–‡ä»¶è·¯å¾„
		SavePath string // ä¿å­˜çš„è·¯å¾„

		fileInfo *baidupcs.FileDirectory // æ–‡ä»¶æˆ–ç›®å½•è¯¦æƒ…
	}
)

const (
	// DefaultPrintFormat é»˜è®¤çš„ä¸‹è½½è¿›åº¦è¾“å‡ºæ ¼å¼
	DefaultPrintFormat = "\r[%s] â†“ %s/%s %s/s in %s, left %s ............"
	//DownloadSuffix æ–‡ä»¶ä¸‹è½½åç¼€
	DownloadSuffix = ".BaiduPCS-Go-downloading"
	//StrDownloadInitError åˆå§‹åŒ–ä¸‹è½½å‘ç”Ÿé”™è¯¯
	StrDownloadInitError = "åˆå§‹åŒ–ä¸‹è½½å‘ç”Ÿé”™è¯¯"
	// StrDownloadFailed ä¸‹è½½æ–‡ä»¶å¤±è´¥
	StrDownloadFailed = "ä¸‹è½½æ–‡ä»¶å¤±è´¥"
	// StrDownloadGetDlinkFailed è·å–ä¸‹è½½é“¾æ¥å¤±è´¥
	StrDownloadGetDlinkFailed = "è·å–ä¸‹è½½é“¾æ¥å¤±è´¥"
	// StrDownloadChecksumFailed æ£€æµ‹æ–‡ä»¶æœ‰æ•ˆæ€§å¤±è´¥
	StrDownloadChecksumFailed = "æ£€æµ‹æ–‡ä»¶æœ‰æ•ˆæ€§å¤±è´¥"
	// DefaultDownloadMaxRetry é»˜è®¤ä¸‹è½½å¤±è´¥æœ€å¤§é‡è¯•æ¬¡æ•°
	DefaultDownloadMaxRetry = 3
)

const (
	DownloadModeLocate DownloadMode = iota
	DownloadModePCS
	DownloadModeStreaming
)

func (dtu *DownloadTaskUnit) SetTaskInfo(info *taskframework.TaskInfo) {
	dtu.taskInfo = info
}

func (dtu *DownloadTaskUnit) verboseInfof(format string, a ...interface{}) {
	if dtu.VerbosePrinter != nil {
		dtu.VerbosePrinter.Infof(format, a...)
	}
}

// download æ‰§è¡Œä¸‹è½½
func (dtu *DownloadTaskUnit) download(downloadURL string, client *requester.HTTPClient) (err error) {
	var (
		writer downloader.Writer
		file   *os.File
	)

	if !dtu.Cfg.IsTest {
		// éæµ‹è¯•ä¸‹è½½
		dtu.Cfg.InstanceStatePath = dtu.SavePath + DownloadSuffix

		// åˆ›å»ºä¸‹è½½çš„ç›®å½•
		// è·å–SavePathæ‰€åœ¨çš„ç›®å½•
		dir := filepath.Dir(dtu.SavePath)
		fileInfo, err := os.Stat(dir)
		if err != nil {
			// ç›®å½•ä¸å­˜åœ¨, åˆ›å»º
			err = os.MkdirAll(dir, 0777)
			if err != nil {
				return err
			}
		} else if !fileInfo.IsDir() {
			// SavePathæ‰€åœ¨çš„ç›®å½•ä¸æ˜¯ç›®å½•
			return fmt.Errorf("%s, path %s: not a directory", StrDownloadInitError, dir)
		}

		// æ‰“å¼€æ–‡ä»¶
		writer, file, err = downloader.NewDownloaderWriterByFilename(dtu.SavePath, os.O_CREATE|os.O_WRONLY, 0666)
		if err != nil {
			return fmt.Errorf("%s, %s", StrDownloadInitError, err)
		}
		defer file.Close()
	}

	der := downloader.NewDownloader(downloadURL, writer, dtu.Cfg)
	der.SetClient(client)
	der.SetDURLCheckFunc(BaiduPCSURLCheckFunc)
	der.SetStatusCodeBodyCheckFunc(func(respBody io.Reader) error {
		// è¿”å›çš„é”™è¯¯å¯èƒ½æ˜¯pcsçš„json
		// è§£æé”™è¯¯
		return pcserror.DecodePCSJSONError(baidupcs.OperationDownloadFile, respBody)
	})

	// æ£€æŸ¥è¾“å‡ºæ ¼å¼
	if dtu.PrintFormat == "" {
		dtu.PrintFormat = DefaultPrintFormat
	}

	// è¿™é‡Œç”¨å…±äº«å˜é‡çš„æ–¹å¼
	isComplete := false
	der.OnDownloadStatusEvent(func(status transfer.DownloadStatuser, workersCallback func(downloader.RangeWorkerFunc)) {
		// è¿™é‡Œå¯èƒ½ä¼šä¸‹è½½ç»“æŸäº†, è¿˜ä¼šè¾“å‡ºå†…å®¹
		builder := &strings.Builder{}
		if dtu.IsPrintStatus {
			// è¾“å‡ºæ‰€æœ‰çš„workerçŠ¶æ€
			var (
				tb      = pcstable.NewTable(builder)
			)
			tb.SetHeader([]string{"#", "status", "range", "left", "speeds", "error"})
			workersCallback(func(key int, worker *downloader.Worker) bool {
				wrange := worker.GetRange()
				tb.Append([]string{fmt.Sprint(worker.ID()), worker.GetStatus().StatusText(), wrange.ShowDetails(), strconv.FormatInt(wrange.Len(), 10), strconv.FormatInt(worker.GetSpeedsPerSecond(), 10), fmt.Sprint(worker.Err())})
				return true
			})

			// å…ˆç©ºä¸¤è¡Œ
			builder.WriteString("\n\n")
			tb.Render()
		}

		// å¦‚æœä¸‹è½½é€Ÿåº¦ä¸º0, å‰©ä½™ä¸‹è½½æ—¶é—´æœªçŸ¥, åˆ™ç”¨ - ä»£æ›¿
		var leftStr string
		left := status.TimeLeft()
		if left < 0 {
			leftStr = "-"
		} else {
			leftStr = left.String()
		}

		fmt.Fprintf(builder,dtu.PrintFormat, dtu.taskInfo.Id(),
			converter.ConvertFileSize(status.Downloaded(), 2),
			converter.ConvertFileSize(status.TotalSize(), 2),
			converter.ConvertFileSize(status.SpeedsPerSecond(), 2),
			status.TimeElapsed()/1e7*1e7, leftStr,
		)

		if !isComplete {
			// å¦‚æœæœªå®Œæˆä¸‹è½½, å°±è¾“å‡º
			fmt.Print(builder.String())
		}
	})

	der.OnExecute(func() {
		if dtu.Cfg.IsTest {
			fmt.Printf("[%s] æµ‹è¯•ä¸‹è½½å¼€å§‹\n\n", dtu.taskInfo.Id())
		}
	})

	err = der.Execute()
	isComplete = true
	fmt.Print("\n")

	if err != nil {
		// ä¸‹è½½å‘ç”Ÿé”™è¯¯
		if !dtu.Cfg.IsTest {
			// ä¸‹è½½å¤±è´¥, åˆ å»ç©ºæ–‡ä»¶
			if info, infoErr := file.Stat(); infoErr == nil {
				if info.Size() == 0 {
					// ç©ºæ–‡ä»¶, åº”è¯¥åˆ é™¤
					dtu.verboseInfof("[%s] remove empty file: %s\n", dtu.taskInfo.Id(), dtu.SavePath)
					removeErr := os.Remove(dtu.SavePath)
					if removeErr != nil {
						dtu.verboseInfof("[%s] remove file error: %s\n", dtu.taskInfo.Id(), removeErr)
					}
				}
			}
		}
		return err
	}

	// ä¸‹è½½æˆåŠŸ
	if !dtu.Cfg.IsTest {
		if dtu.IsExecutedPermission {
			err = file.Chmod(0766)
			if err != nil {
				fmt.Printf("[%s] è­¦å‘Š, åŠ æ‰§è¡Œæƒé™é”™è¯¯: %s\n", dtu.taskInfo.Id(), err)
			}
		}

		fmt.Printf("[%s] ä¸‹è½½å®Œæˆ, ä¿å­˜ä½ç½®: %s\n", dtu.taskInfo.Id(), dtu.SavePath)
	} else {
		fmt.Printf("[%s] æµ‹è¯•ä¸‹è½½ç»“æŸ\n", dtu.taskInfo.Id())
	}

	return nil
}

//panHTTPClient è·å–åŒ…å«ç‰¹å®šUser-Agentçš„HTTPClient
func (dtu *DownloadTaskUnit) panHTTPClient() (client *requester.HTTPClient) {
	client = pcsconfig.Config.PanHTTPClient()
	client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		// å»æ‰ Referer
		if !pcsconfig.Config.EnableHTTPS {
			req.Header.Del("Referer")
		}
		if len(via) >= 10 {
			return errors.New("stopped after 10 redirects")
		}
		return nil
	}
	client.SetTimeout(20 * time.Minute)
	client.SetKeepAlive(true)
	return client
}

func (dtu *DownloadTaskUnit) handleError(result *taskframework.TaskUnitRunResult) {
	switch value := result.Err.(type) {
	case pcserror.Error: // pcserror æ¥å£
		switch value.GetErrType() {
		case pcserror.ErrTypeRemoteError:
		// è¿œç¨‹æœåŠ¡å™¨é”™è¯¯
		case 31045: // user not exists
			fallthrough
		case 31066: // file does not exist
			result.NeedRetry = false
		case 31626: // user is not authorized
			//å¯èƒ½æ˜¯User-Agentä¸å¯¹
			//é‡è¯•
			fallthrough
		default:
			result.NeedRetry = true
		}
	case *os.PathError:
		// ç³»ç»Ÿçº§åˆ«çš„é”™è¯¯, å¯èƒ½æ˜¯æƒé™é—®é¢˜
		result.NeedRetry = false
	default:
		// å…¶ä»–é”™è¯¯, éœ€è¦é‡è¯•
		result.NeedRetry = true
	}
}

func (dtu *DownloadTaskUnit) execPanDownload(dlink string, result *taskframework.TaskUnitRunResult, okPtr *bool) {
	dtu.verboseInfof("[%s] è·å–åˆ°ä¸‹è½½é“¾æ¥: %s\n", dtu.taskInfo.Id(), dlink)

	client := dtu.panHTTPClient()
	err := dtu.download(dlink, client)
	if err != nil {
		result.ResultMessage = StrDownloadFailed
		result.Err = err
		dtu.handleError(result)
		return
	}
	*okPtr = true
}

func (dtu *DownloadTaskUnit) locateDownload(result *taskframework.TaskUnitRunResult) (ok bool) {
	rawDlinks, err := GetLocateDownloadLinks(dtu.PCS, dtu.PcsPath)
	if err != nil {
		result.ResultMessage = StrDownloadGetDlinkFailed
		result.Err = err
		dtu.handleError(result)
		return
	}

	// æ›´æ–°é“¾æ¥çš„åè®®
	FixHTTPLinkURL(rawDlinks[0])
	dlink := rawDlinks[0].String()

	dtu.execPanDownload(dlink, result, &ok)
	return
}

func (dtu *DownloadTaskUnit) pcsOrStreamingDownload(mode DownloadMode, result *taskframework.TaskUnitRunResult) (ok bool) {
	dfunc := func(downloadURL string, jar http.CookieJar) error {
		client := pcsconfig.Config.PCSHTTPClient()
		client.SetCookiejar(jar)
		client.SetKeepAlive(true)
		client.SetTimeout(10 * time.Minute)

		return dtu.download(downloadURL, client)
	}

	var err error
	switch mode {
	case DownloadModePCS:
		err = dtu.PCS.DownloadFile(dtu.PcsPath, dfunc)
	case DownloadModeStreaming:
		err = dtu.PCS.DownloadStreamFile(dtu.PcsPath, dfunc)
	default:
		panic("unreachable")
	}

	if err != nil {
		result.ResultMessage = StrDownloadFailed
		result.Err = err
		dtu.handleError(result)
		return
	}
	return true // ä¸‹è½½æˆåŠŸ
}

//checkFileValid æ£€æµ‹æ–‡ä»¶æœ‰æ•ˆæ€§
func (dtu *DownloadTaskUnit) checkFileValid(result *taskframework.TaskUnitRunResult) (ok bool) {
	if dtu.Cfg.IsTest || dtu.NoCheck {
		// ä¸æ£€æµ‹æ–‡ä»¶æœ‰æ•ˆæ€§
		return
	}

	if dtu.fileInfo.Size >= 128*converter.MB {
		// å¤§æ–‡ä»¶, è¾“å‡ºä¸€å¥æç¤ºæ¶ˆæ¯
		fmt.Printf("[%s] å¼€å§‹æ£€éªŒæ–‡ä»¶æœ‰æ•ˆæ€§, è¯·ç¨å€™...\n", dtu.taskInfo.Id())
	}

	// å°±åœ¨è¿™é‡Œå¤„ç†æ ¡éªŒå‡ºé”™
	err := CheckFileValid(dtu.SavePath, dtu.fileInfo)
	if err != nil {
		result.ResultMessage = StrDownloadChecksumFailed
		result.Err = err
		switch err {
		case ErrDownloadNotSupportChecksum:
			// æ–‡ä»¶ä¸æ”¯æŒæ ¡éªŒ
			result.ResultMessage = "æ£€éªŒæ–‡ä»¶æœ‰æ•ˆæ€§"
			result.Err = err
			fmt.Printf("[%s] æ£€éªŒæ–‡ä»¶æœ‰æ•ˆæ€§: %s\n", dtu.taskInfo.Id(), err)
			return true
		case ErrDownloadFileBanned:
			// è¿è§„æ–‡ä»¶
			result.NeedRetry = false
			return
		case ErrDownloadChecksumFailed:
			// æ ¡éªŒå¤±è´¥, éœ€è¦é‡æ–°ä¸‹è½½
			result.NeedRetry = true
			// è®¾ç½®å…è®¸è¦†ç›–
			dtu.IsOverwrite = true
			return
		default:
			result.NeedRetry = false
			return
		}
	}

	fmt.Printf("[%s] æ£€éªŒæ–‡ä»¶æœ‰æ•ˆæ€§æˆåŠŸ: %s\n", dtu.taskInfo.Id(), dtu.SavePath)
	return true
}

func (dtu *DownloadTaskUnit) OnRetry(lastRunResult *taskframework.TaskUnitRunResult) {
	// è¾“å‡ºé”™è¯¯ä¿¡æ¯
	if lastRunResult.Err == nil {
		// resultä¸­ä¸åŒ…å«Err, å¿½ç•¥è¾“å‡º
		fmt.Printf("[%s] %s, é‡è¯• %d/%d\n", dtu.taskInfo.Id(), lastRunResult.ResultMessage, dtu.taskInfo.Retry(), dtu.taskInfo.MaxRetry())
		return
	}
	fmt.Printf("[%s] %s, %s, é‡è¯• %d/%d\n", dtu.taskInfo.Id(), lastRunResult.ResultMessage, lastRunResult.Err, dtu.taskInfo.Retry(), dtu.taskInfo.MaxRetry())
}

func (dtu *DownloadTaskUnit) OnSuccess(lastRunResult *taskframework.TaskUnitRunResult) {
}

func (dtu *DownloadTaskUnit) OnFailed(lastRunResult *taskframework.TaskUnitRunResult) {
	// å¤±è´¥
	if lastRunResult.Err == nil {
		// resultä¸­ä¸åŒ…å«Err, å¿½ç•¥è¾“å‡º
		fmt.Printf("[%s] %s\n", dtu.taskInfo.Id(), lastRunResult.ResultMessage)
		return
	}
	fmt.Printf("[%s] %s, %s\n", dtu.taskInfo.Id(), lastRunResult.ResultMessage, lastRunResult.Err)
}

func (dtu *DownloadTaskUnit) OnComplete(lastRunResult *taskframework.TaskUnitRunResult) {
}

func (dtu *DownloadTaskUnit) RetryWait() time.Duration {
	return pcsfunctions.RetryWait(dtu.taskInfo.Retry())
}

func (dtu *DownloadTaskUnit) Run() (result *taskframework.TaskUnitRunResult) {
	result = &taskframework.TaskUnitRunResult{}
	// è·å–æ–‡ä»¶ä¿¡æ¯
	var err error
	if dtu.fileInfo == nil || dtu.taskInfo.Retry() > 0 {
		// æ²¡æœ‰è·å–æ–‡ä»¶ä¿¡æ¯
		// å¦‚æœæ˜¯åŠ¨æ€æ·»åŠ çš„ä¸‹è½½ä»»åŠ¡, æ˜¯ä¼šå†™å…¥æ–‡ä»¶ä¿¡æ¯çš„
		// å¦‚æœè¯¥ä»»åŠ¡é‡è¯•è¿‡, åˆ™åº”è¯¥å†è·å–ä¸€æ¬¡æ–‡ä»¶ä¿¡æ¯
		dtu.fileInfo, err = dtu.PCS.FilesDirectoriesMeta(dtu.PcsPath)
		if err != nil {
			// å¦‚æœä¸æ˜¯æœªç™»å½•æˆ–æ–‡ä»¶ä¸å­˜åœ¨, åˆ™ä¸é‡è¯•
			result.ResultMessage = "è·å–ä¸‹è½½è·¯å¾„ä¿¡æ¯é”™è¯¯"
			result.Err = err
			dtu.handleError(result)
			return
		}
	}

	// è¾“å‡ºæ–‡ä»¶ä¿¡æ¯
	fmt.Print("\n")
	fmt.Printf("[%s] ----\n%s\n", dtu.taskInfo.Id(), dtu.fileInfo.String())

	// å¦‚æœæ˜¯ä¸€ä¸ªç›®å½•, å°†å­æ–‡ä»¶å’Œå­ç›®å½•åŠ å…¥é˜Ÿåˆ—
	if dtu.fileInfo.Isdir {
		if !dtu.Cfg.IsTest { // æµ‹è¯•ä¸‹è½½, ä¸å»ºç«‹ç©ºç›®å½•
			os.MkdirAll(dtu.SavePath, 0777) // é¦–å…ˆåœ¨æœ¬åœ°åˆ›å»ºç›®å½•, ä¿è¯ç©ºç›®å½•ä¹Ÿèƒ½è¢«ä¿å­˜
		}

		// è·å–è¯¥ç›®å½•ä¸‹çš„æ–‡ä»¶åˆ—è¡¨
		fileList, err := dtu.PCS.FilesDirectoriesList(dtu.PcsPath, baidupcs.DefaultOrderOptions)
		if err != nil {
			result.ResultMessage = "è·å–ç›®å½•ä¿¡æ¯é”™è¯¯"
			result.Err = err
			result.NeedRetry = true
			return
		}

		for k := range fileList {
			// æ·»åŠ å­ä»»åŠ¡
			subUnit := *dtu
			newCfg := *dtu.Cfg
			subUnit.Cfg = &newCfg
			subUnit.fileInfo = fileList[k] // ä¿å­˜æ–‡ä»¶ä¿¡æ¯
			subUnit.PcsPath = fileList[k].Path
			subUnit.SavePath = filepath.Join(dtu.SavePath, fileList[k].Filename) // ä¿å­˜ä½ç½®

			// åŠ å…¥çˆ¶é˜Ÿåˆ—
			info := dtu.ParentTaskExecutor.Append(&subUnit, dtu.taskInfo.MaxRetry())
			fmt.Printf("[%s] åŠ å…¥ä¸‹è½½é˜Ÿåˆ—: %s\n", info.Id(), fileList[k].Path)
		}

		result.Succeed = true // æ‰§è¡ŒæˆåŠŸ
		return
	}

	fmt.Printf("[%s] å‡†å¤‡ä¸‹è½½: %s\n", dtu.taskInfo.Id(), dtu.PcsPath)

	if !dtu.Cfg.IsTest && !dtu.IsOverwrite && FileExist(dtu.SavePath) {
		fmt.Printf("[%s] æ–‡ä»¶å·²ç»å­˜åœ¨: %s, è·³è¿‡...\n", dtu.taskInfo.Id(), dtu.SavePath)
		result.Succeed = true // æ‰§è¡ŒæˆåŠŸ
		return
	}

	if !dtu.Cfg.IsTest {
		// ä¸æ˜¯æµ‹è¯•ä¸‹è½½, è¾“å‡ºä¸‹è½½è·¯å¾„
		fmt.Printf("[%s] å°†ä¼šä¸‹è½½åˆ°è·¯å¾„: %s\n\n", dtu.taskInfo.Id(), dtu.SavePath)
	}

	var ok bool
	// è·å–ä¸‹è½½é“¾æ¥
	switch dtu.DownloadMode {
	case DownloadModeLocate:
		ok = dtu.locateDownload(result)
	case DownloadModePCS, DownloadModeStreaming:
		ok = dtu.pcsOrStreamingDownload(dtu.DownloadMode, result)
	}

	if !ok {
		// ä»¥ä¸Šæ‰§è¡Œä¸æˆåŠŸ, è¿”å›
		return result
	}

	// æ£€æµ‹æ–‡ä»¶æœ‰æ•ˆæ€§
	ok = dtu.checkFileValid(result)
	if !ok {
		// æ ¡éªŒä¸æˆåŠŸ, è¿”å›ç»“æœ
		return result
	}

	// ç»Ÿè®¡ä¸‹è½½
	dtu.DownloadStatistic.AddTotalSize(dtu.fileInfo.Size)
	// ä¸‹è½½æˆåŠŸ
	result.Succeed = true
	return
}



================================================
FILE: internal/pcsfunctions/pcsdownload/errors.go
================================================
package pcsdownload

import "errors"

var (
	// ErrDownloadNotSupportChecksum æ–‡ä»¶ä¸æ”¯æŒæ ¡éªŒ
	ErrDownloadNotSupportChecksum = errors.New("è¯¥æ–‡ä»¶ä¸æ”¯æŒæ ¡éªŒ")
	// ErrDownloadChecksumFailed æ–‡ä»¶æ ¡éªŒå¤±è´¥
	ErrDownloadChecksumFailed = errors.New("è¯¥æ–‡ä»¶æ ¡éªŒå¤±è´¥, æ–‡ä»¶md5å€¼ä¸æœåŠ¡å™¨è®°å½•çš„ä¸åŒ¹é…")
	// ErrDownloadFileBanned è¿è§„æ–‡ä»¶
	ErrDownloadFileBanned = errors.New("è¯¥æ–‡ä»¶å¯èƒ½æ˜¯è¿è§„æ–‡ä»¶, ä¸æ”¯æŒæ ¡éªŒ")
	// ErrDlinkNotFound æœªå–å¾—ä¸‹è½½é“¾æ¥
	ErrDlinkNotFound = errors.New("æœªå–å¾—ä¸‹è½½é“¾æ¥")
	// ErrShareInfoNotFound æœªåœ¨å·²åˆ†äº«åˆ—è¡¨ä¸­æ‰¾åˆ°åˆ†äº«ä¿¡æ¯
	ErrShareInfoNotFound = errors.New("æœªåœ¨å·²åˆ†äº«åˆ—è¡¨ä¸­æ‰¾åˆ°åˆ†äº«ä¿¡æ¯")
)



================================================
FILE: internal/pcsfunctions/pcsdownload/pcsdownload.go
================================================
package pcsdownload

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"net/http"
	"strconv"
)

// IsSkipMd5Checksum æ˜¯å¦å¿½ç•¥æŸäº›æ ¡éªŒ
func IsSkipMd5Checksum(size int64, md5Str string) bool {
	switch {
	case size == 1749504 && md5Str == "48bb9b0361dc9c672f3dc7b3ffcfde97": //8ç§’æ¸©é¦¨æç¤º
		fallthrough
	case size == 120 && md5Str == "6c1b84914588d09a6e5ec43605557457": //æ¸©é¦¨æç¤ºæ–‡å­—ç‰ˆ
		return true
	}
	return false
}

// BaiduPCSURLCheckFunc downloader é¦–æ¬¡æ£€æŸ¥ä¸‹è½½åœ°å€è¦æ‰§è¡Œçš„å‡½æ•°
func BaiduPCSURLCheckFunc(client *requester.HTTPClient, durl string) (contentLength int64, resp *http.Response, err error) {
	resp, err = client.Req(http.MethodGet, durl, nil, map[string]string{
		"Range": "bytes=0-" + strconv.FormatInt(baidupcs.MaxDownloadRangeSize-1, 10),
	})
	if err != nil {
		if resp != nil {
			resp.Body.Close()
		}
		return 0, nil, err
	}

	contentLengthStr := resp.Header.Get("x-bs-file-size")
	contentLength, _ = strconv.ParseInt(contentLengthStr, 10, 64)
	return contentLength, resp, nil
}



================================================
FILE: internal/pcsfunctions/pcsdownload/utils.go
================================================
package pcsdownload

import (
	"encoding/hex"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/checksum"
	"net/url"
	"os"
)

// CheckFileValid æ£€æµ‹æ–‡ä»¶æœ‰æ•ˆæ€§
func CheckFileValid(filePath string, fileInfo *baidupcs.FileDirectory) error {
	if len(fileInfo.BlockList) != 1 {
		return ErrDownloadNotSupportChecksum
	}

	f := checksum.NewLocalFileChecksum(filePath, int(baidupcs.SliceMD5Size))
	err := f.OpenPath()
	if err != nil {
		return err
	}
	defer f.Close()

	err = f.Sum(checksum.CHECKSUM_MD5)
	if err != nil {
		return err
	}
	md5Str := hex.EncodeToString(f.MD5)

	if md5Str != fileInfo.MD5 { // md5ä¸ä¸€è‡´
		// æ£€æµ‹æ˜¯å¦ä¸ºè¿è§„æ–‡ä»¶
		if IsSkipMd5Checksum(f.Length, md5Str) {
			return ErrDownloadFileBanned
		}
		return ErrDownloadChecksumFailed
	}
	return nil
}

// FileExist æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨,
// åªæœ‰å½“æ–‡ä»¶å­˜åœ¨, æ–‡ä»¶å¤§å°ä¸ä¸º0æˆ–æ–­ç‚¹ç»­ä¼ æ–‡ä»¶ä¸å­˜åœ¨æ—¶, æ‰åˆ¤æ–­ä¸ºå­˜åœ¨
func FileExist(path string) bool {
	if info, err := os.Stat(path); err == nil {
		if info.Size() == 0 {
			return false
		}
		if _, err = os.Stat(path + DownloadSuffix); err != nil {
			return true
		}
	}

	return false
}

//FixHTTPLinkURL é€šè¿‡é…ç½®, ç¡®å®šé“¾æ¥ä½¿ç”¨çš„åè®®(http,https)
func FixHTTPLinkURL(linkURL *url.URL) {
	if pcsconfig.Config.EnableHTTPS {
		if linkURL.Scheme == "http" {
			linkURL.Scheme = "https"
		}
	}
}



================================================
FILE: internal/pcsfunctions/pcsupload/pcsupload.go
================================================
// Package pcsupload ä¸Šä¼ åŒ…
package pcsupload

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
)

const (
	UploadingFileName = "pcs_uploading.json"
)

var (
	pcsUploadVerbose = pcsverbose.New("PCSUPLOAD")
)



================================================
FILE: internal/pcsfunctions/pcsupload/upload.go
================================================
package pcsupload

import (
	"context"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/felixonmars/BaiduPCS-Go/requester/multipartreader"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"github.com/felixonmars/BaiduPCS-Go/requester/uploader"
	"io"
	"net/http"
)

type (
	PCSUpload struct {
		pcs        *baidupcs.BaiduPCS
		targetPath string
	}

	EmptyReaderLen64 struct {
	}
)

func (e EmptyReaderLen64) Read(p []byte) (n int, err error) {
	return 0, io.EOF
}

func (e EmptyReaderLen64) Len() int64 {
	return 0
}

func NewPCSUpload(pcs *baidupcs.BaiduPCS, targetPath string) uploader.MultiUpload {
	return &PCSUpload{
		pcs:        pcs,
		targetPath: targetPath,
	}
}

func (pu *PCSUpload) lazyInit() {
	if pu.pcs == nil {
		pu.pcs = &baidupcs.BaiduPCS{}
	}
}

// Precreate do nothing
func (pu *PCSUpload) Precreate() (err error) {
	return nil
}

func (pu *PCSUpload) TmpFile(ctx context.Context, partseq int, partOffset int64, r rio.ReaderLen64) (checksum string, uperr error) {
	pu.lazyInit()

	var respErr *uploader.MultiError
	checksum, pcsError := pu.pcs.UploadTmpFile(func(uploadURL string, jar http.CookieJar) (resp *http.Response, err error) {
		client := pcsconfig.Config.PCSHTTPClient()
		client.SetCookiejar(jar)
		client.SetTimeout(0)

		mr := multipartreader.NewMultipartReader()
		mr.AddFormFile("uploadedfile", "", r)
		mr.CloseMultipart()

		doneChan := make(chan struct{}, 1)
		go func() {
			resp, err = client.Req(http.MethodPost, uploadURL, mr, nil)
			doneChan <- struct{}{}

			if resp != nil {
				// ä¸å¯æ¢å¤çš„é”™è¯¯
				switch resp.StatusCode {
				case 400, 401, 403, 413:
					respErr = &uploader.MultiError{
						Terminated: true,
					}
				}
			}
		}()
		select {
		case <-ctx.Done(): // å–æ¶ˆ
			// è¿”å›, è®©é‚£è¾¹å…³é—­è¿æ¥
			return resp, ctx.Err()
		case <-doneChan:
			// return
		}
		return
	})

	if respErr != nil {
		respErr.Err = pcsError
		return checksum, respErr
	}

	return checksum, pcsError
}

func (pu *PCSUpload) CreateSuperFile(checksumList ...string) (err error) {
	pu.lazyInit()

	// å…ˆåœ¨ç½‘ç›˜ç›®æ ‡ä½ç½®, ä¸Šä¼ ä¸€ä¸ªç©ºæ–‡ä»¶
	// é˜²æ­¢å‡ºç°file does not exist
	pcsError := pu.pcs.Upload(pu.targetPath, func(uploadURL string, jar http.CookieJar) (resp *http.Response, err error) {
		mr := multipartreader.NewMultipartReader()
		mr.AddFormFile("file", "file", &EmptyReaderLen64{})
		mr.CloseMultipart()

		c := requester.NewHTTPClient()
		c.SetCookiejar(jar)
		return c.Req(http.MethodPost, uploadURL, mr, nil)
	})
	if pcsError != nil {
		// ä¿®æ”¹æ“ä½œ
		pcsError.(*pcserror.PCSErrInfo).Operation = baidupcs.OperationUploadCreateSuperFile
		return pcsError
	}

	return pu.pcs.UploadCreateSuperFile(false, pu.targetPath, checksumList...)
}



================================================
FILE: internal/pcsfunctions/pcsupload/upload2.go
================================================
package pcsupload

/*
import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
)

type (
	// PCSUpload2 æ–°çš„ä¸Šä¼ æ–¹å¼
	// TODO
	PCSUpload2 struct {
		pcs        *baidupcs.BaiduPCS
		targetPath string
		uploadid   string
	}
)

func NewPCSUpload2(pcs *baidupcs.BaiduPCS, targetPath string) uploader.MultiUpload {
	return &PCSUpload{
		pcs:        pcs,
		targetPath: targetPath,
	}
}

func (pu2 *PCSUpload2) lazyInit() {
	if pu2.pcs == nil {
		pu2.pcs = &baidupcs.BaiduPCS{}
	}
}

// Precreate
func (pu2 *PCSUpload2) Precreate() (err error) {
	return nil
}

func (pu2 *PCSUpload2) TmpFile(ctx context.Context, partseq int, partOffset int64, r rio.ReaderLen64) (checksum string, uperr error) {
	pu2.lazyInit()
	return pu.pcs.UploadTmpFile(func(uploadURL string, jar http.CookieJar) (resp *http.Response, err error) {
		client := pcsconfig.Config.HTTPClient()
		client.SetCookiejar(jar)
		client.SetTimeout(0)

		mr := multipartreader.NewMultipartReader()
		mr.AddFormFile("uploadedfile", "", r)
		mr.CloseMultipart()

		doneChan := make(chan struct{}, 1)
		go func() {
			resp, err = client.Req("POST", uploadURL, mr, nil)
			doneChan <- struct{}{}
		}()
		select {
		case <-ctx.Done():
			return resp, ctx.Err()
		case <-doneChan:
			// return
		}
		return
	})
}

func (pu2 *PCSUpload2) CreateSuperFile(checksumList ...string) (err error) {
	return nil
}
*/



================================================
FILE: internal/pcsfunctions/pcsupload/upload_database.go
================================================
package pcsupload

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/checksum"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/jsonhelper"
	"github.com/felixonmars/BaiduPCS-Go/requester/uploader"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type (
	// Uploading æœªå®Œæˆä¸Šä¼ çš„ä¿¡æ¯
	Uploading struct {
		*checksum.LocalFileMeta
		State *uploader.InstanceState `json:"state"`
	}

	// UploadingDatabase æœªå®Œæˆä¸Šä¼ çš„æ•°æ®åº“
	UploadingDatabase struct {
		UploadingList []*Uploading `json:"upload_state"`
		Timestamp     int64        `json:"timestamp"`

		dataFile *os.File
	}
)

// NewUploadingDatabase åˆå§‹åŒ–æœªå®Œæˆä¸Šä¼ çš„æ•°æ®åº“, ä»åº“ä¸­è¯»å–å†…å®¹
func NewUploadingDatabase() (ud *UploadingDatabase, err error) {
	file, err := os.OpenFile(filepath.Join(pcsconfig.GetConfigDir(), UploadingFileName), os.O_CREATE|os.O_RDWR, 0777)
	if err != nil {
		return nil, err
	}

	ud = &UploadingDatabase{
		dataFile: file,
	}
	info, err := file.Stat()
	if err != nil {
		return nil, err
	}

	if info.Size() <= 0 {
		return ud, nil
	}

	err = jsonhelper.UnmarshalData(file, ud)
	if err != nil {
		return nil, err
	}

	return ud, nil
}

// Save ä¿å­˜å†…å®¹
func (ud *UploadingDatabase) Save() error {
	if ud.dataFile == nil {
		return errors.New("dataFile is nil")
	}

	ud.Timestamp = time.Now().Unix()

	var (
		builder = &strings.Builder{}
		err     = jsonhelper.MarshalData(builder, ud)
	)
	if err != nil {
		panic(err)
	}

	err = ud.dataFile.Truncate(int64(builder.Len()))
	if err != nil {
		return err
	}

	str := builder.String()
	_, err = ud.dataFile.WriteAt(converter.ToBytes(str), 0)
	if err != nil {
		return err
	}

	return nil
}

// UpdateUploading æ›´æ–°æ­£åœ¨ä¸Šä¼ 
func (ud *UploadingDatabase) UpdateUploading(meta *checksum.LocalFileMeta, state *uploader.InstanceState) {
	if meta == nil {
		return
	}

	meta.CompleteAbsPath()
	for k, uploading := range ud.UploadingList {
		if uploading.LocalFileMeta == nil {
			continue
		}
		if uploading.LocalFileMeta.EqualLengthMD5(meta) || uploading.LocalFileMeta.Path == meta.Path {
			ud.UploadingList[k].State = state
			return
		}
	}

	ud.UploadingList = append(ud.UploadingList, &Uploading{
		LocalFileMeta: meta,
		State:         state,
	})
}

func (ud *UploadingDatabase) deleteIndex(k int) {
	ud.UploadingList = append(ud.UploadingList[:k], ud.UploadingList[k+1:]...)
}

// Delete åˆ é™¤
func (ud *UploadingDatabase) Delete(meta *checksum.LocalFileMeta) bool {
	if meta == nil {
		return false
	}

	meta.CompleteAbsPath()
	for k, uploading := range ud.UploadingList {
		if uploading.LocalFileMeta == nil {
			continue
		}
		if uploading.LocalFileMeta.EqualLengthMD5(meta) || uploading.LocalFileMeta.Path == meta.Path {
			ud.deleteIndex(k)
			return true
		}
	}
	return false
}

// Search æœç´¢
func (ud *UploadingDatabase) Search(meta *checksum.LocalFileMeta) *uploader.InstanceState {
	if meta == nil {
		return nil
	}

	meta.CompleteAbsPath()
	ud.clearModTimeChange()
	for _, uploading := range ud.UploadingList {
		if uploading.LocalFileMeta == nil {
			continue
		}
		if uploading.LocalFileMeta.EqualLengthMD5(meta) {
			return uploading.State
		}
		if uploading.LocalFileMeta.Path == meta.Path {
			// ç§»é™¤æ—§çš„ä¿¡æ¯
			// ç›®å‰åªæ˜¯æ¯”è¾ƒäº†æ–‡ä»¶å¤§å°
			if meta.Length != uploading.LocalFileMeta.Length {
				ud.Delete(meta)
				return nil
			}

			// è¦†ç›–æ•°æ®
			meta.MD5 = uploading.LocalFileMeta.MD5
			meta.SliceMD5 = uploading.LocalFileMeta.SliceMD5
			return uploading.State
		}
	}
	return nil
}

func (ud *UploadingDatabase) clearModTimeChange() {
	for i := 0; i < len(ud.UploadingList); i++ {
		uploading := ud.UploadingList[i]
		if uploading.LocalFileMeta == nil {
			continue
		}

		if uploading.ModTime == -1 { // å¿½ç•¥
			continue
		}

		info, err := os.Stat(uploading.LocalFileMeta.Path)
		if err != nil {
			ud.deleteIndex(i)
			i--
			pcsUploadVerbose.Warnf("clear invalid file path: %s, err: %s\n", uploading.LocalFileMeta.Path, err)
			continue
		}

		if uploading.LocalFileMeta.ModTime != info.ModTime().Unix() {
			ud.deleteIndex(i)
			i--
			pcsUploadVerbose.Infof("clear modified file path: %s\n", uploading.LocalFileMeta.Path)
			continue
		}
	}
}

// Close å…³é—­æ•°æ®åº“
func (ud *UploadingDatabase) Close() error {
	return ud.dataFile.Close()
}



================================================
FILE: internal/pcsfunctions/pcsupload/upload_statistic.go
================================================
package pcsupload

import (
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsfunctions"
)

type (
	UploadStatistic struct {
		pcsfunctions.Statistic
	}
)



================================================
FILE: internal/pcsfunctions/pcsupload/upload_task_unit.go
================================================
package pcsupload

import (
	"bytes"
	"encoding/hex"
	"errors"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsfunctions"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/checksum"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/taskframework"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"github.com/felixonmars/BaiduPCS-Go/requester/uploader"
	"path"
	"strings"
	"time"
)

type (
	// StepUpload ä¸Šä¼ æ­¥éª¤
	StepUpload int

	// UploadTaskUnit ä¸Šä¼ çš„ä»»åŠ¡å•å…ƒ
	UploadTaskUnit struct {
		LocalFileChecksum *checksum.LocalFileChecksum // è¦ä¸Šä¼ çš„æœ¬åœ°æ–‡ä»¶è¯¦æƒ…
		Step              StepUpload
		SavePath          string // ä¿å­˜è·¯å¾„

		PCS               *baidupcs.BaiduPCS
		UploadingDatabase *UploadingDatabase // æ•°æ®åº“
		Parallel          int
		NoRapidUpload     bool // ç¦ç”¨ç§’ä¼ 
		NoSplitFile       bool // ç¦ç”¨åˆ†ç‰‡ä¸Šä¼ 

		UploadStatistic *UploadStatistic

		taskInfo *taskframework.TaskInfo
		panDir   string
		panFile  string
		state    *uploader.InstanceState
	}
)

const (
	// StepUploadInit åˆå§‹åŒ–æ­¥éª¤
	StepUploadInit StepUpload = iota
	// StepUploadRapidUpload ç§’ä¼ æ­¥éª¤
	StepUploadRapidUpload
	// StepUploadUpload æ­£å¸¸ä¸Šä¼ æ­¥éª¤
	StepUploadUpload
)

const (
	StrUploadFailed = "ä¸Šä¼ æ–‡ä»¶å¤±è´¥"
)

func (utu *UploadTaskUnit) SetTaskInfo(taskInfo *taskframework.TaskInfo) {
	utu.taskInfo = taskInfo
}

// prepareFile è§£ææ–‡ä»¶é˜¶æ®µ
func (utu *UploadTaskUnit) prepareFile() {
	// è§£ææ–‡ä»¶ä¿å­˜è·¯å¾„
	var (
		panDir, panFile = path.Split(utu.SavePath)
	)
	utu.panDir = path.Clean(panDir)
	utu.panFile = panFile

	// æ£€æµ‹æ–­ç‚¹ç»­ä¼ 
	utu.state = utu.UploadingDatabase.Search(&utu.LocalFileChecksum.LocalFileMeta)
	if utu.state != nil || utu.LocalFileChecksum.LocalFileMeta.MD5 != nil { // è¯»å–åˆ°äº†md5
		utu.Step = StepUploadUpload
		return
	}

	if utu.NoRapidUpload {
		utu.Step = StepUploadUpload
		return
	}

	if utu.LocalFileChecksum.Length > baidupcs.MaxRapidUploadSize {
		fmt.Printf("[%s] æ–‡ä»¶è¶…è¿‡20GB, æ— æ³•ä½¿ç”¨ç§’ä¼ åŠŸèƒ½, è·³è¿‡ç§’ä¼ ...\n", utu.taskInfo.Id())
		utu.Step = StepUploadUpload
		return
	}
	// ä¸‹ä¸€æ­¥: ç§’ä¼ 
	utu.Step = StepUploadRapidUpload
}

// rapidUpload æ‰§è¡Œç§’ä¼ 
func (utu *UploadTaskUnit) rapidUpload() (isContinue bool, result *taskframework.TaskUnitRunResult) {
	utu.Step = StepUploadRapidUpload

	// TODO: å»ºç«‹ä¸€ä¸ªé€šè¿‡ç™¾åº¦é”™è¯¯ç åˆ¤æ–­é‡è¯•çš„å‡½æ•°
	result = &taskframework.TaskUnitRunResult{}

	fdl, pcsError := utu.PCS.CacheFilesDirectoriesList(utu.panDir, baidupcs.DefaultOrderOptions)
	if pcsError != nil {
		switch pcsError.GetErrType() {
		case pcserror.ErrTypeRemoteError:
			switch pcsError.GetRemoteErrCode() {
			case 31066:
			// file does not exist
			// ä¸ç¼“å­˜æ–‡ä»¶å¤¹
			default:
				// å…¶ä»–ç™¾åº¦æœåŠ¡å™¨é”™è¯¯, ä¸é‡è¯•
				result.ResultMessage = "è·å–æ–‡ä»¶åˆ—è¡¨é”™è¯¯"
				result.Err = pcsError
				return
			}
		default:
			// æœªçŸ¥é”™è¯¯, é‡è¯•
			result.ResultMessage = "è·å–æ–‡ä»¶åˆ—è¡¨é”™è¯¯"
			result.NeedRetry = true
			result.Err = pcsError
			return
		}
	}

	// æ–‡ä»¶å¤§äº128MB, è¾“å‡ºæç¤ºä¿¡æ¯
	if utu.LocalFileChecksum.Length >= 128*converter.MB {
		fmt.Printf("[%s] æ£€æµ‹ç§’ä¼ ä¸­, è¯·ç¨å€™...\n", utu.taskInfo.Id())
	}

	// ç»æµ‹è¯•, æ–‡ä»¶çš„ crc32 å€¼å¹¶éç§’ä¼ æ–‡ä»¶æ‰€å¿…éœ€
	err := utu.LocalFileChecksum.Sum(checksum.CHECKSUM_MD5 | checksum.CHECKSUM_SLICE_MD5)
	if err != nil {
		// ä¸é‡è¯•
		result.ResultMessage = "è®¡ç®—æ–‡ä»¶ç§’ä¼ ä¿¡æ¯é”™è¯¯"
		result.Err = err
		return
	}

	// æ£€æµ‹ç¼“å­˜, é€šè¿‡æ–‡ä»¶çš„md5å€¼åˆ¤æ–­æœ¬åœ°æ–‡ä»¶å’Œç½‘ç›˜æ–‡ä»¶æ˜¯å¦ä¸€æ ·
	if fdl != nil {
		for _, fd := range fdl {
			if fd.Filename == utu.panFile {
				// TODO: fd.MD5 æœ‰å¯èƒ½æ˜¯é”™è¯¯çš„
				decodedMD5, _ := hex.DecodeString(fd.MD5)
				if bytes.Compare(decodedMD5, utu.LocalFileChecksum.MD5) == 0 {
					fmt.Printf("[%s] ç›®æ ‡æ–‡ä»¶, %s, å·²å­˜åœ¨, è·³è¿‡...\n", utu.taskInfo.Id(), utu.SavePath)
					result.Succeed = true // æˆåŠŸ
					return
				}
			}
		}
	}

	pcsError = utu.PCS.RapidUpload(utu.SavePath, hex.EncodeToString(utu.LocalFileChecksum.MD5), hex.EncodeToString(utu.LocalFileChecksum.SliceMD5), fmt.Sprint(utu.LocalFileChecksum.CRC32), utu.LocalFileChecksum.Length)
	if pcsError == nil {
		fmt.Printf("[%s] ç§’ä¼ æˆåŠŸ, ä¿å­˜åˆ°ç½‘ç›˜è·¯å¾„: %s\n\n", utu.taskInfo.Id(), utu.SavePath)
		// ç»Ÿè®¡
		utu.UploadStatistic.AddTotalSize(utu.LocalFileChecksum.Length)
		result.Succeed = true // æˆåŠŸ
		return
	}

	// åˆ¤æ–­é…é¢æ˜¯å¦å·²æ»¡
	switch pcsError.GetErrType() {
	// è¿œç¨‹æœåŠ¡å™¨é”™è¯¯
	case pcserror.ErrTypeRemoteError:
		switch pcsError.GetRemoteErrCode() {
		case 31112: //exceed quota
			result.ResultMessage = "ç§’ä¼ å¤±è´¥, è¶…å‡ºé…é¢, ç½‘ç›˜å®¹é‡å·²æ»¡"
			return
		}
	}

	fmt.Printf("[%s] ç§’ä¼ å¤±è´¥, å¼€å§‹ä¸Šä¼ æ–‡ä»¶...\n\n", utu.taskInfo.Id())

	// ä¿å­˜ç§’ä¼ ä¿¡æ¯
	utu.UploadingDatabase.UpdateUploading(&utu.LocalFileChecksum.LocalFileMeta, nil)
	utu.UploadingDatabase.Save()
	isContinue = true
	return
}

// upload ä¸Šä¼ æ–‡ä»¶
func (utu *UploadTaskUnit) upload() (result *taskframework.TaskUnitRunResult) {
	utu.Step = StepUploadUpload

	var blockSize int64
	if utu.NoSplitFile {
		// ä¸åˆ†ç‰‡ä¸Šä¼ 
		blockSize = utu.LocalFileChecksum.Length
	} else {
		blockSize = getBlockSize(utu.LocalFileChecksum.Length)
	}

	muer := uploader.NewMultiUploader(NewPCSUpload(utu.PCS, utu.SavePath), rio.NewFileReaderAtLen64(utu.LocalFileChecksum.GetFile()), &uploader.MultiUploaderConfig{
		Parallel:  utu.Parallel,
		BlockSize: blockSize,
		MaxRate:   pcsconfig.Config.MaxUploadRate,
	})

	// è®¾ç½®æ–­ç‚¹ç»­ä¼ 
	if utu.state != nil {
		muer.SetInstanceState(utu.state)
	}

	muer.OnUploadStatusEvent(func(status uploader.Status, updateChan <-chan struct{}) {
		select {
		case <-updateChan:
			utu.UploadingDatabase.UpdateUploading(&utu.LocalFileChecksum.LocalFileMeta, muer.InstanceState())
			utu.UploadingDatabase.Save()
		default:
		}

		fmt.Printf("\r[%s] â†‘ %s/%s %s/s in %s ............", utu.taskInfo.Id(),
			converter.ConvertFileSize(status.Uploaded(), 2),
			converter.ConvertFileSize(status.TotalSize(), 2),
			converter.ConvertFileSize(status.SpeedsPerSecond(), 2),
			status.TimeElapsed(),
		)
	})

	// result
	result = &taskframework.TaskUnitRunResult{}
	muer.OnSuccess(func() {
		fmt.Printf("\n")
		fmt.Printf("[%s] ä¸Šä¼ æ–‡ä»¶æˆåŠŸ, ä¿å­˜åˆ°ç½‘ç›˜è·¯å¾„: %s\n", utu.taskInfo.Id(), utu.SavePath)
		// ç»Ÿè®¡
		utu.UploadStatistic.AddTotalSize(utu.LocalFileChecksum.Length)
		utu.UploadingDatabase.Delete(&utu.LocalFileChecksum.LocalFileMeta) // åˆ é™¤
		utu.UploadingDatabase.Save()
		result.Succeed = true
	})
	muer.OnError(func(err error) {
		pcsError, ok := err.(pcserror.Error)
		if !ok {
			// æœªçŸ¥é”™è¯¯ç±»å‹ (éé¢„æœŸçš„)
			// ä¸é‡è¯•
			result.ResultMessage = "ä¸Šä¼ æ–‡ä»¶é”™è¯¯"
			result.Err = err
			return
		}

		// é»˜è®¤éœ€è¦é‡è¯•
		result.NeedRetry = true

		switch pcsError.GetErrType() {
		case pcserror.ErrTypeRemoteError:
			// è¿œç¨‹ç™¾åº¦æœåŠ¡å™¨çš„é”™è¯¯
			switch pcsError.GetRemoteErrCode() {
			case 31363:
				// block miss in superfile2, ä¸Šä¼ çŠ¶æ€è¿‡æœŸ
				// éœ€è¦é‡è¯•çš„
				utu.UploadingDatabase.Delete(&utu.LocalFileChecksum.LocalFileMeta)
				utu.UploadingDatabase.Save()

				result.ResultMessage = StrUploadFailed
				result.Err = errors.New("ä¸Šä¼ çŠ¶æ€è¿‡æœŸ, é‡æ–°ä¸Šä¼ ")
			case 31200:
				//æœåŠ¡å™¨é”™è¯¯
				//[Method:Insert][Error:Insert Request Forbid]
				// do nothing
			default:
				result.ResultMessage = StrUploadFailed
				result.Err = pcsError
			}
		case pcserror.ErrTypeNetError:
			// ç½‘ç»œé”™è¯¯
			result.ResultMessage = StrUploadFailed
			result.Err = pcsError
			if strings.Contains(pcsError.GetError().Error(), "413 Request Entity Too Large") {
				// è¯·æ±‚å®ä½“è¿‡å¤§
				// ä¸é‡è¯•
				result.NeedRetry = false
				return
			}
		default:
			result.ResultMessage = StrUploadFailed
			result.NeedRetry = false
			result.Err = pcsError
		}
		return
	})
	muer.Execute()

	return
}

func (utu *UploadTaskUnit) OnRetry(lastRunResult *taskframework.TaskUnitRunResult) {
	// è¾“å‡ºé”™è¯¯ä¿¡æ¯
	if lastRunResult.Err == nil {
		// resultä¸­ä¸åŒ…å«Err, å¿½ç•¥è¾“å‡º
		fmt.Printf("[%s] %s, é‡è¯• %d/%d\n", utu.taskInfo.Id(), lastRunResult.ResultMessage, utu.taskInfo.Retry(), utu.taskInfo.MaxRetry())
		return
	}
	fmt.Printf("[%s] %s, %s, é‡è¯• %d/%d\n", utu.taskInfo.Id(), lastRunResult.ResultMessage, lastRunResult.Err, utu.taskInfo.Retry(), utu.taskInfo.MaxRetry())
}

func (utu *UploadTaskUnit) OnSuccess(lastRunResult *taskframework.TaskUnitRunResult) {
}

func (utu *UploadTaskUnit) OnFailed(lastRunResult *taskframework.TaskUnitRunResult) {
	// å¤±è´¥
	if lastRunResult.Err == nil {
		// resultä¸­ä¸åŒ…å«Err, å¿½ç•¥è¾“å‡º
		fmt.Printf("[%s] %s\n", utu.taskInfo.Id(), lastRunResult.ResultMessage)
		return
	}
	fmt.Printf("[%s] %s, %s\n", utu.taskInfo.Id(), lastRunResult.ResultMessage, lastRunResult.Err)
}

func (utu *UploadTaskUnit) OnComplete(lastRunResult *taskframework.TaskUnitRunResult) {
}

func (utu *UploadTaskUnit) RetryWait() time.Duration {
	return pcsfunctions.RetryWait(utu.taskInfo.Retry())
}

func (utu *UploadTaskUnit) Run() (result *taskframework.TaskUnitRunResult) {
	fmt.Printf("[%s] å‡†å¤‡ä¸Šä¼ : %s\n", utu.taskInfo.Id(), utu.LocalFileChecksum.Path)

	err := utu.LocalFileChecksum.OpenPath()
	if err != nil {
		fmt.Printf("[%s] æ–‡ä»¶ä¸å¯è¯», é”™è¯¯ä¿¡æ¯: %s, è·³è¿‡...\n", utu.taskInfo.Id(), err)
		return
	}
	defer utu.LocalFileChecksum.Close() // å…³é—­æ–‡ä»¶

	// å‡†å¤‡æ–‡ä»¶
	utu.prepareFile()

	switch utu.Step {
	case StepUploadRapidUpload:
		goto stepUploadRapidUpload
	case StepUploadUpload:
		goto stepUploadUpload
	}

stepUploadRapidUpload:
	// ç§’ä¼ 
	{
		isContinue, rapidUploadResult := utu.rapidUpload()
		if !isContinue {
			// ä¸ç»§ç»­, è¿”å›ç§’ä¼ çš„ç»“æœ
			return rapidUploadResult
		}
	}

stepUploadUpload:
	// æ­£å¸¸ä¸Šä¼ æµç¨‹
	uploadResult := utu.upload()

	return uploadResult
}



================================================
FILE: internal/pcsfunctions/pcsupload/utils.go
================================================
package pcsupload

import "github.com/felixonmars/BaiduPCS-Go/baidupcs"

func getBlockSize(fileSize int64) int64 {
	blockNum := fileSize / baidupcs.MinUploadBlockSize
	if blockNum > 999 {
		return fileSize/999 + 1
	}
	return baidupcs.MinUploadBlockSize
}



================================================
FILE: internal/pcsinit/pcsinit.go
================================================
// Package pcsinit åˆå§‹åŒ–é…ç½®åŒ…
package pcsinit

import (
	"fmt"
	"github.com/urfave/cli"
	_ "unsafe" // for go:linkname
)

//go:linkname helpCommand1 github.com/felixonmars/BaiduPCS-Go/vendor/github.com/urfave/cli.helpCommand
//go:linkname helpCommand2 github.com/urfave/cli.helpCommand
var (
	helpCommand1 cli.Command
	helpCommand2 cli.Command
)

func init() {
	cli.AppHelpTemplate = `----
	{{.Name}}{{if .Usage}} - {{.Usage}}{{end}}

USAGE:
	{{if .UsageText}}{{.UsageText}}{{else}}{{.HelpName}} {{if .VisibleFlags}}[global options]{{end}}{{if .Commands}} command [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}}{{end}}{{if .Version}}{{if not .HideVersion}}

VERSION:
	{{.Version}}{{end}}{{end}}{{if .Description}}

DESCRIPTION:
	{{.Description}}{{end}}{{if len .Authors}}

AUTHOR{{with $length := len .Authors}}{{if ne 1 $length}}S{{end}}{{end}}:
	{{range $index, $author := .Authors}}{{if $index}}
	{{end}}{{$author}}{{end}}{{end}}{{if .VisibleCommands}}

COMMANDS:{{range .VisibleCategories}}{{if .Name}}
	{{.Name}}:{{end}}{{range .VisibleCommands}}
		{{join .Names ", "}}{{"\t"}}{{.Usage}}{{end}}{{end}}{{end}}{{if .VisibleFlags}}

GLOBAL OPTIONS:
	{{range $index, $option := .VisibleFlags}}{{if $index}}
	{{end}}{{$option}}{{end}}{{end}}{{if .Copyright}}

COPYRIGHT:
	{{.Copyright}}{{end}}
`

	cli.CommandHelpTemplate = `----
	{{.HelpName}} - {{.Usage}}

USAGE:
	{{if .UsageText}}{{.UsageText}}{{else}}{{.HelpName}}{{if .VisibleFlags}} [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}}{{end}}{{if .Category}}

CATEGORY:
	{{.Category}}{{end}}{{if .Description}}

DESCRIPTION:
	{{.Description}}{{end}}{{if .VisibleFlags}}

OPTIONS:
	{{range .VisibleFlags}}{{.}}
	{{end}}{{end}}
`

	cli.SubcommandHelpTemplate = `----
	{{.HelpName}} - {{.Usage}}

USAGE:
	{{if .UsageText}}{{.UsageText}}{{else}}{{.HelpName}} command{{if .VisibleFlags}} [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}}{{end}}{{if .Description}}

DESCRIPTION:
	{{.Description}}{{end}}

COMMANDS:{{range .VisibleCategories}}{{if .Name}}
	{{.Name}}:{{end}}{{range .VisibleCommands}}
		{{join .Names ", "}}{{"\t"}}{{.Usage}}{{end}}
{{end}}{{if .VisibleFlags}}
OPTIONS:
	{{range .VisibleFlags}}{{.}}
	{{end}}{{end}}
`

	helpCommand1.Aliases = append(helpCommand1.Aliases, "?", "ï¼Ÿ")
	helpCommand1.Action = func(c *cli.Context) error {
		args := c.Args()
		if args.Present() {
			err := cli.ShowCommandHelp(c, args.First())
			if err != nil {
				fmt.Printf("%s\n", err)
			}
			return nil
		}

		cli.ShowAppHelp(c)
		return nil
	}

	helpCommand2.Aliases = helpCommand1.Aliases
	helpCommand2.Action = helpCommand1.Action
}



================================================
FILE: internal/pcsinit/pcsinit.s
================================================
[Empty file]


================================================
FILE: internal/pcsupdate/github.go
================================================
package pcsupdate

type (
	// AssetInfo asset ä¿¡æ¯
	AssetInfo struct {
		Name               string `json:"name"`
		ContentType        string `json:"content_type"`
		State              string `json:"state"`
		Size               int64  `json:"size"`
		BrowserDownloadURL string `json:"browser_download_url"`
	}

	// ReleaseInfo å‘å¸ƒä¿¡æ¯
	ReleaseInfo struct {
		TagName string       `json:"tag_name"`
		Assets  []*AssetInfo `json:"assets"`
	}
)



================================================
FILE: internal/pcsupdate/pcsupdate.go
================================================
// Package pcsupdate æ›´æ–°åŒ…
package pcsupdate

import (
	"archive/zip"
	"bytes"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/pcsliner"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/checkaccess"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/jsonhelper"
	"github.com/felixonmars/BaiduPCS-Go/requester/downloader"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"net/http"
	"path/filepath"
	"regexp"
	"runtime"
	"strconv"
	"strings"
)

const (
	// ReleaseName åˆ†äº«æ ¹ç›®å½•åç§°
	ReleaseName = "BaiduPCS-Go-releases"
)

type info struct {
	filename    string
	size        int64
	downloadURL string
}

// CheckUpdate æ£€æµ‹æ›´æ–°
func CheckUpdate(version string, yes bool) {
	if !checkaccess.AccessRDWR(pcsutil.ExecutablePath()) {
		fmt.Printf("ç¨‹åºç›®å½•ä¸å¯å†™, æ— æ³•æ›´æ–°.\n")
		return
	}
	fmt.Println("æ£€æµ‹æ›´æ–°ä¸­, ç¨å€™...")
	c := pcsconfig.Config.HTTPClient()
	resp, err := c.Req(http.MethodGet, "https://api.github.com/repos/iikira/BaiduPCS-Go/releases/latest", nil, nil)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		fmt.Printf("è·å–æ•°æ®é”™è¯¯: %s\n", err)
		return
	}

	releaseInfo := ReleaseInfo{}
	err = jsonhelper.UnmarshalData(resp.Body, &releaseInfo)
	if err != nil {
		fmt.Printf("jsonæ•°æ®è§£æå¤±è´¥: %s\n", err)
		return
	}

	// æ²¡æœ‰æ›´æ–°, æˆ–å¿½ç•¥ Beta ç‰ˆæœ¬, å’Œç‰ˆæœ¬å‰ç¼€ä¸ç¬¦çš„
	if strings.Contains(releaseInfo.TagName, "Beta") || !strings.HasPrefix(releaseInfo.TagName, "v") || version >= releaseInfo.TagName {
		fmt.Printf("æœªæ£€æµ‹åˆ°æ›´æ–°!\n")
		return
	}

	fmt.Printf("æ£€æµ‹åˆ°æ–°ç‰ˆæœ¬: %s\n", releaseInfo.TagName)

	line := pcsliner.NewLiner()
	defer line.Close()

	if !yes {
		y, err := line.State.Prompt("æ˜¯å¦è¿›è¡Œæ›´æ–° (y/n): ")
		if err != nil {
			fmt.Printf("è¾“å…¥é”™è¯¯: %s\n", err)
			return
		}

		if y != "y" && y != "Y" {
			fmt.Printf("æ›´æ–°å–æ¶ˆ.\n")
			return
		}
	}

	builder := &strings.Builder{}
	builder.WriteString("BaiduPCS-Go-" + releaseInfo.TagName + "-" + runtime.GOOS + "-.*?")
	if runtime.GOOS == "darwin" && (runtime.GOARCH == "arm" || runtime.GOARCH == "arm64") {
		builder.WriteString("arm")
	} else {
		switch runtime.GOARCH {
		case "amd64":
			builder.WriteString("(amd64|x86_64|x64)")
		case "386":
			builder.WriteString("(386|x86)")
		case "arm":
			builder.WriteString("(armv5|armv7|arm)")
		case "arm64":
			builder.WriteString("arm64")
		case "mips":
			builder.WriteString("mips")
		case "mips64":
			builder.WriteString("mips64")
		case "mipsle":
			builder.WriteString("(mipsle|mipsel)")
		case "mips64le":
			builder.WriteString("(mips64le|mips64el)")
		default:
			builder.WriteString(runtime.GOARCH)
		}
	}
	builder.WriteString("\\.zip")

	exp := regexp.MustCompile(builder.String())

	var targetList []*info
	for _, asset := range releaseInfo.Assets {
		if asset == nil || asset.State != "uploaded" {
			continue
		}

		if exp.MatchString(asset.Name) {
			targetList = append(targetList, &info{
				filename:    asset.Name,
				size:        asset.Size,
				downloadURL: asset.BrowserDownloadURL,
			})
		}
	}

	var target info
	switch len(targetList) {
	case 0:
		fmt.Printf("æœªåŒ¹é…åˆ°å½“å‰ç³»ç»Ÿçš„ç¨‹åºæ›´æ–°æ–‡ä»¶, GOOS: %s, GOARCH: %s\n", runtime.GOOS, runtime.GOARCH)
		return
	case 1:
		target = *targetList[0]
	default:
		fmt.Println()
		for k := range targetList {
			fmt.Printf("%d: %s\n", k, targetList[k].filename)
		}

		fmt.Println()
		t, err := line.State.Prompt("è¾“å…¥åºå·ä»¥ä¸‹è½½æ›´æ–°: ")
		if err != nil {
			fmt.Printf("%s\n", err)
			return
		}

		i, err := strconv.Atoi(t)
		if err != nil {
			fmt.Printf("è¾“å…¥é”™è¯¯: %s\n", err)
			return
		}

		if i < 0 || i >= len(targetList) {
			fmt.Printf("è¾“å…¥é”™è¯¯: åºå·ä¸åœ¨èŒƒå›´å†…\n")
			return
		}

		target = *targetList[i]
	}

	if target.size > 0x7fffffff {
		fmt.Printf("file size too large: %d\n", target.size)
		return
	}

	fmt.Printf("å‡†å¤‡ä¸‹è½½æ›´æ–°: %s\n", target.filename)

	// å¼€å§‹ä¸‹è½½
	buf := rio.NewBuffer(cachepool.RawMallocByteSlice(int(target.size)))
	der := downloader.NewDownloader(target.downloadURL, buf, &downloader.Config{
		MaxParallel: 20,
		CacheSize:   10000,
	})
	der.SetClient(c)

	der.OnDownloadStatusEvent(func(status transfer.DownloadStatuser, workersCallback func(downloader.RangeWorkerFunc)) {
		var leftStr string
		left := status.TimeLeft()
		if left < 0 {
			leftStr = "-"
		} else {
			leftStr = left.String()
		}

		fmt.Printf("\r â†“ %s/%s %s/s in %s, left %s ............",
			converter.ConvertFileSize(status.Downloaded(), 2),
			converter.ConvertFileSize(status.TotalSize(), 2),
			converter.ConvertFileSize(status.SpeedsPerSecond(), 2),
			status.TimeElapsed()/1e7*1e7, leftStr,
		)
	})
	der.OnFinish(func() {
		fmt.Println()
	})
	der.OnSuccess(func() {
		fmt.Printf("ä¸‹è½½å®Œæ¯•\n")
	})

	err = der.Execute()
	if err != nil {
		fmt.Printf("ä¸‹è½½å‘ç”Ÿé”™è¯¯: %s\n", err)
		return
	}

	// è¯»å–æ–‡ä»¶
	reader, err := zip.NewReader(bytes.NewReader(buf.Bytes()), target.size)
	if err != nil {
		fmt.Printf("è¯»å–æ›´æ–°æ–‡ä»¶å‘ç”Ÿé”™è¯¯: %s\n", err)
		return
	}

	execPath := pcsutil.ExecutablePath()

	var fileNum, errTimes int
	for _, zipFile := range reader.File {
		if zipFile == nil {
			continue
		}

		info := zipFile.FileInfo()

		if info.IsDir() {
			continue
		}

		rc, err := zipFile.Open()
		if err != nil {
			fmt.Printf("è§£æ zip æ–‡ä»¶é”™è¯¯: %s\n", err)
			continue
		}

		fileNum++

		name := zipFile.Name[strings.Index(zipFile.Name, "/")+1:]
		if name == "BaiduPCS-Go" {
			err = update(pcsutil.Executable(), rc)
		} else {
			err = update(filepath.Join(execPath, name), rc)
		}

		if err != nil {
			errTimes++
			fmt.Printf("å‘ç”Ÿé”™è¯¯, zip è·¯å¾„: %s, é”™è¯¯: %s\n", zipFile.Name, err)
			continue
		}
	}

	if errTimes == fileNum {
		fmt.Printf("æ›´æ–°å¤±è´¥\n")
		return
	}

	fmt.Printf("æ›´æ–°å®Œæ¯•, è¯·é‡å¯ç¨‹åº\n")
}



================================================
FILE: internal/pcsupdate/updatefile.go
================================================
package pcsupdate

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
)

func update(targetPath string, src io.Reader) error {
	info, err := os.Stat(targetPath)
	if err != nil {
		fmt.Printf("Warning: %s\n", err)
		return nil
	}

	privMode := info.Mode()

	oldPath := filepath.Join(filepath.Dir(targetPath), "old"+filepath.Base(targetPath))

	err = os.Rename(targetPath, oldPath)
	if err != nil {
		return err
	}

	newFile, err := os.OpenFile(targetPath, os.O_CREATE|os.O_WRONLY, privMode)
	if err != nil {
		return err
	}

	_, err = io.Copy(newFile, src)
	if err != nil {
		return err
	}

	err = newFile.Close()
	if err != nil {
		fmt.Printf("Warning: å…³é—­æ–‡ä»¶å‘ç”Ÿé”™è¯¯: %s\n", err)
	}

	err = os.Remove(oldPath)
	if err != nil {
		fmt.Printf("Warning: ç§»é™¤æ—§æ–‡ä»¶å‘ç”Ÿé”™è¯¯: %s\n", err)
	}
	return nil
}



================================================
FILE: pcsliner/clear.go
================================================
// +build !windows

package pcsliner

import (
	"fmt"
)

// ClearScreen æ¸…ç©ºå±å¹•
func (pl *PCSLiner) ClearScreen() {
	ClearScreen()
}

// ClearScreen æ¸…ç©ºå±å¹•
func ClearScreen() {
	fmt.Print("\x1b[H\x1b[2J")
}



================================================
FILE: pcsliner/clear.s
================================================
[Empty file]


================================================
FILE: pcsliner/clear_windows.go
================================================
package pcsliner

import (
	"syscall"
	"unsafe"
)

const (
	std_output_handle = uint32(-11 & 0xFFFFFFFF)
)

var (
	kernel32 = syscall.NewLazyDLL("kernel32.dll")

	procGetStdHandle               = kernel32.NewProc("GetStdHandle")
	procSetConsoleCursorPosition   = kernel32.NewProc("SetConsoleCursorPosition")
	procGetConsoleScreenBufferInfo = kernel32.NewProc("GetConsoleScreenBufferInfo")
	procFillConsoleOutputCharacter = kernel32.NewProc("FillConsoleOutputCharacterW")
)

type (
	coord struct {
		x, y int16
	}
	smallRect struct {
		left, top, right, bottom int16
	}
	consoleScreenBufferInfo struct {
		dwSize              coord
		dwCursorPosition    coord
		wAttributes         int16
		srWindow            smallRect
		dwMaximumWindowSize coord
	}
)

// ClearScreen æ¸…ç©ºå±å¹•
func (pl *PCSLiner) ClearScreen() {
	ClearScreen()
}

// ClearScreen æ¸…ç©ºå±å¹•
func ClearScreen() {
	out, _, _ := procGetStdHandle.Call(uintptr(std_output_handle))
	hOut := syscall.Handle(out)

	var sbi consoleScreenBufferInfo
	procGetConsoleScreenBufferInfo.Call(uintptr(hOut), uintptr(unsafe.Pointer(&sbi)))

	var numWritten uint32
	procFillConsoleOutputCharacter.Call(uintptr(hOut), uintptr(' '),
		uintptr(sbi.dwSize.x)*uintptr(sbi.dwSize.y),
		0,
		uintptr(unsafe.Pointer(&numWritten)))
	procSetConsoleCursorPosition.Call(uintptr(hOut), 0)
}



================================================
FILE: pcsliner/linehistory.go
================================================
package pcsliner

import (
	"fmt"
	"os"
)

// LineHistory å‘½ä»¤è¡Œå†å²
type LineHistory struct {
	historyFilePath string
	historyFile     *os.File
}

// NewLineHistory è®¾ç½®å†å²
func NewLineHistory(filePath string) (lh *LineHistory, err error) {
	lh = &LineHistory{
		historyFilePath: filePath,
	}

	lh.historyFile, err = os.OpenFile(filePath, os.O_RDWR|os.O_CREATE, 0644)
	if err != nil {
		return nil, err
	}

	return lh, nil
}

// DoWriteHistory æ‰§è¡Œå†™å…¥å†å²
func (pl *PCSLiner) DoWriteHistory() (err error) {
	if pl.History == nil {
		return fmt.Errorf("history not set")
	}

	pl.History.historyFile, err = os.Create(pl.History.historyFilePath)
	if err != nil {
		return fmt.Errorf("å†™å…¥å†å²é”™è¯¯, %s", err)
	}

	_, err = pl.State.WriteHistory(pl.History.historyFile)
	if err != nil {
		return fmt.Errorf("å†™å…¥å†å²é”™è¯¯: %s", err)
	}

	return nil
}

// ReadHistory è¯»å–å†å²
func (pl *PCSLiner) ReadHistory() (err error) {
	if pl.History == nil {
		return fmt.Errorf("history not set")
	}

	_, err = pl.State.ReadHistory(pl.History.historyFile)
	return err
}



================================================
FILE: pcsliner/pcsliner.go
================================================
// Package pcsliner å‘½ä»¤è¡Œ readline å·¥å…·åŒ…
package pcsliner

import (
	"github.com/peterh/liner"
)

// PCSLiner å°è£… *liner.State, æä¾›æ›´ç®€ä¾¿çš„æ“ä½œ
type PCSLiner struct {
	State   *liner.State
	History *LineHistory

	tmode liner.ModeApplier
	lmode liner.ModeApplier

	paused bool
}

// NewLiner è¿”å› *PCSLiner, é»˜è®¤è®¾ç½®å…è®¸ Ctrl+C ç»“æŸ
func NewLiner() *PCSLiner {
	pl := &PCSLiner{}
	pl.tmode, _ = liner.TerminalMode()

	line := liner.NewLiner()
	pl.lmode, _ = liner.TerminalMode()

	line.SetMultiLineMode(true)
	line.SetCtrlCAborts(true)

	pl.State = line

	return pl
}

// Pause æš‚åœæœåŠ¡
func (pl *PCSLiner) Pause() error {
	if pl.paused {
		panic("PCSLiner already paused")
	}

	pl.paused = true
	pl.DoWriteHistory()

	return pl.tmode.ApplyMode()
}

// Resume æ¢å¤æœåŠ¡
func (pl *PCSLiner) Resume() error {
	if !pl.paused {
		panic("PCSLiner is not paused")
	}

	pl.paused = false

	return pl.lmode.ApplyMode()
}

// Close å…³é—­æœåŠ¡
func (pl *PCSLiner) Close() (err error) {
	err = pl.State.Close()
	if err != nil {
		return err
	}

	if pl.History != nil && pl.History.historyFile != nil {
		return pl.History.historyFile.Close()
	}

	return nil
}



================================================
FILE: pcsliner/args/args.go
================================================
package args

import (
	"strings"
	"unicode"
)

const (
	CharEscape      = '\\'
	CharSingleQuote = '\''
	CharDoubleQuote = '"'
	CharBackQuote   = '`'
)

// IsQuote æ˜¯å¦ä¸ºå¼•å·
func IsQuote(r rune) bool {
	return r == CharSingleQuote || r == CharDoubleQuote || r == CharBackQuote
}

// Parse è§£æline, å¿½ç•¥æ‹¬å·
func Parse(line string) (lineArgs []string) {
	var (
		rl        = []rune(line + " ")
		buf       = strings.Builder{}
		quoteChar rune
		nextChar  rune
		escaped   bool
		in        bool
	)

	var (
		isSpace bool
	)

	for k, r := range rl {
		isSpace = unicode.IsSpace(r)
		if !isSpace && !in {
			in = true
		}

		switch {
		case escaped: // å·²è½¬ä¹‰, è·³è¿‡
			escaped = false
			//pass
		case r == CharEscape: // è½¬ä¹‰æ¨¡å¼
			if k+1+1 < len(rl) { // ä¸æ˜¯æœ€åä¸€ä¸ªå­—ç¬¦, å¤š+1æ˜¯å› ä¸ºæœ€åä¸€ä¸ªç©ºæ ¼
				nextChar = rl[k+1]
				// ä»…æ”¯æŒè½¬ä¹‰è¿™äº›å­—ç¬¦, å¦åˆ™åŸæ ·è¾“å‡ºåæ–œæ 
				if unicode.IsSpace(nextChar) || IsQuote(nextChar) || nextChar == CharEscape {
					escaped = true
					continue
				}
			}
			// pass
		case IsQuote(r):
			if quoteChar == 0 { //æœªå¼•
				quoteChar = r
				continue
			}

			if quoteChar == r { //å–æ¶ˆå¼•
				quoteChar = 0
				continue
			}
		case isSpace:
			if !in { // å¿½ç•¥å¤šä½™çš„ç©ºæ ¼
				continue
			}
			if quoteChar == 0 { // æœªåœ¨å¼•å·å†…
				lineArgs = append(lineArgs, buf.String())
				buf.Reset()
				in = false
				continue
			}
		}

		buf.WriteRune(r)
	}

	return
}



================================================
FILE: pcsliner/args/args_test.go
================================================
package args_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsliner/args"
	"testing"
)

func TestParseArgs(t *testing.T) {
	as := args.Parse(`  one two three "double quotes" 'single quotes'  ""   arg\ with\ spaces "\"quotes\" in 'quotes'" '"quotes" in \'quotes'"  "   `)
	for k := range as {
		fmt.Printf("%d: %s|\n", k, as[k])
	}

	as = args.Parse(` cd  è‹±è¯­_800ä¸ªæœ‰è¶£å¥å­å¸®ä½ è®°å¿†7000ä¸ªå•è¯_42é¡µ.doc`)
	for k := range as {
		fmt.Printf("%d: %s|\n", k, as[k])
	}
}



================================================
FILE: pcstable/pcstable.go
================================================
// Package pcstable æ ¼å¼åŒ–è¡¨æ ¼åŒ…
package pcstable

import (
	"github.com/olekukonko/tablewriter"
	"io"
)

// PCSTable å°è£… tablewriter.Table
type PCSTable struct {
	*tablewriter.Table
}

// NewTable é¢„è®¾äº†ä¸€äº›é…ç½®
func NewTable(wt io.Writer) PCSTable {
	tb := tablewriter.NewWriter(wt)
	tb.SetAutoWrapText(false)
	tb.SetBorder(false)
	tb.SetHeaderLine(false)
	tb.SetColumnSeparator("")
	return PCSTable{tb}
}



================================================
FILE: pcsutil/addr.go
================================================
package pcsutil

import (
	"net"
)

// ListAddresses åˆ—å‡ºæœ¬åœ°å¯ç”¨çš„ IP åœ°å€
func ListAddresses() (addresses []string) {
	iFaces, _ := net.Interfaces()
	addresses = make([]string, 0, len(iFaces))
	for k := range iFaces {
		iFaceAddrs, _ := iFaces[k].Addrs()
		for l := range iFaceAddrs {
			switch v := iFaceAddrs[l].(type) {
			case *net.IPNet:
				addresses = append(addresses, v.IP.String())
			case *net.IPAddr:
				addresses = append(addresses, v.IP.String())
			}
		}
	}
	return
}

// ParseHost è§£æåœ°å€ä¸­çš„host
func ParseHost(address string) string {
	h, _, err := net.SplitHostPort(address)
	if err != nil {
		return address
	}
	return h
}



================================================
FILE: pcsutil/crypto.go
================================================
package pcsutil

import (
	"fmt"
	"github.com/felixonmars/Baidu-Login/bdcrypto"
	"io"
	"os"
	"strings"
)

// CryptoMethodSupport æ£€æµ‹æ˜¯å¦æ”¯æŒåŠ å¯†è§£å¯†æ–¹æ³•
func CryptoMethodSupport(method string) bool {
	switch method {
	case "aes-128-ctr", "aes-192-ctr", "aes-256-ctr", "aes-128-cfb", "aes-192-cfb", "aes-256-cfb", "aes-128-ofb", "aes-192-ofb", "aes-256-ofb":
		return true
	}

	return false
}

// EncryptFile åŠ å¯†æœ¬åœ°æ–‡ä»¶
func EncryptFile(method string, key []byte, filePath string, isGzip bool) (encryptedFilePath string, err error) {
	if !CryptoMethodSupport(method) {
		return "", fmt.Errorf("unknown encrypt method: %s", method)
	}

	if isGzip {
		err = bdcrypto.GZIPCompressFile(filePath)
		if err != nil {
			return
		}
	}

	plainFile, err := os.OpenFile(filePath, os.O_RDONLY, 0)
	if err != nil {
		return
	}

	defer plainFile.Close()

	var cipherReader io.Reader
	switch method {
	case "aes-128-ctr":
		cipherReader, err = bdcrypto.Aes128CTREncrypt(bdcrypto.Convert16bytes(key), plainFile)
	case "aes-192-ctr":
		cipherReader, err = bdcrypto.Aes192CTREncrypt(bdcrypto.Convert24bytes(key), plainFile)
	case "aes-256-ctr":
		cipherReader, err = bdcrypto.Aes256CTREncrypt(bdcrypto.Convert32bytes(key), plainFile)
	case "aes-128-cfb":
		cipherReader, err = bdcrypto.Aes128CFBEncrypt(bdcrypto.Convert16bytes(key), plainFile)
	case "aes-192-cfb":
		cipherReader, err = bdcrypto.Aes192CFBEncrypt(bdcrypto.Convert24bytes(key), plainFile)
	case "aes-256-cfb":
		cipherReader, err = bdcrypto.Aes256CFBEncrypt(bdcrypto.Convert32bytes(key), plainFile)
	case "aes-128-ofb":
		cipherReader, err = bdcrypto.Aes128OFBEncrypt(bdcrypto.Convert16bytes(key), plainFile)
	case "aes-192-ofb":
		cipherReader, err = bdcrypto.Aes192OFBEncrypt(bdcrypto.Convert24bytes(key), plainFile)
	case "aes-256-ofb":
		cipherReader, err = bdcrypto.Aes256OFBEncrypt(bdcrypto.Convert32bytes(key), plainFile)
	default:
		return "", fmt.Errorf("unknown encrypt method: %s", method)
	}

	if err != nil {
		return
	}

	plainFileInfo, err := plainFile.Stat()
	if err != nil {
		return
	}

	encryptedFilePath = filePath + ".encrypt"
	encryptedFile, err := os.OpenFile(encryptedFilePath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, plainFileInfo.Mode())
	if err != nil {
		return
	}

	defer encryptedFile.Close()

	_, err = io.Copy(encryptedFile, cipherReader)
	if err != nil {
		return
	}

	os.Remove(filePath)

	return encryptedFilePath, nil
}

// DecryptFile åŠ å¯†æœ¬åœ°æ–‡ä»¶
func DecryptFile(method string, key []byte, filePath string, isGzip bool) (decryptedFilePath string, err error) {
	if !CryptoMethodSupport(method) {
		return "", fmt.Errorf("unknown decrypt method: %s", method)
	}

	cipherFile, err := os.OpenFile(filePath, os.O_RDONLY, 0644)
	if err != nil {
		return
	}

	defer cipherFile.Close()

	var plainReader io.Reader
	switch method {
	case "aes-128-ctr":
		plainReader, err = bdcrypto.Aes128CTRDecrypt(bdcrypto.Convert16bytes(key), cipherFile)
	case "aes-192-ctr":
		plainReader, err = bdcrypto.Aes192CTRDecrypt(bdcrypto.Convert24bytes(key), cipherFile)
	case "aes-256-ctr":
		plainReader, err = bdcrypto.Aes256CTRDecrypt(bdcrypto.Convert32bytes(key), cipherFile)
	case "aes-128-cfb":
		plainReader, err = bdcrypto.Aes128CFBDecrypt(bdcrypto.Convert16bytes(key), cipherFile)
	case "aes-192-cfb":
		plainReader, err = bdcrypto.Aes192CFBDecrypt(bdcrypto.Convert24bytes(key), cipherFile)
	case "aes-256-cfb":
		plainReader, err = bdcrypto.Aes256CFBDecrypt(bdcrypto.Convert32bytes(key), cipherFile)
	case "aes-128-ofb":
		plainReader, err = bdcrypto.Aes128OFBDecrypt(bdcrypto.Convert16bytes(key), cipherFile)
	case "aes-192-ofb":
		plainReader, err = bdcrypto.Aes192OFBDecrypt(bdcrypto.Convert24bytes(key), cipherFile)
	case "aes-256-ofb":
		plainReader, err = bdcrypto.Aes256OFBDecrypt(bdcrypto.Convert32bytes(key), cipherFile)
	default:
		return "", fmt.Errorf("unknown decrypt method: %s", method)
	}

	if err != nil {
		return
	}

	cipherFileInfo, err := cipherFile.Stat()
	if err != nil {
		return
	}

	decryptedFilePath = strings.TrimSuffix(filePath, ".encrypt")
	decryptedTmpFilePath := decryptedFilePath + ".decrypted"
	decryptedTmpFile, err := os.OpenFile(decryptedTmpFilePath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, cipherFileInfo.Mode())
	if err != nil {
		return
	}

	_, err = io.Copy(decryptedTmpFile, plainReader)
	if err != nil {
		return
	}

	defer decryptedTmpFile.Close()

	if isGzip {
		err = bdcrypto.GZIPUnompressFile(decryptedTmpFilePath)
		if err != nil {
			os.Remove(decryptedTmpFilePath)
			return
		}

		// åˆ é™¤å·²åŠ å¯†çš„æ–‡ä»¶
		os.Remove(filePath)
	}

	if filePath != decryptedFilePath {
		os.Rename(decryptedTmpFilePath, decryptedFilePath)
	} else {
		decryptedFilePath = decryptedTmpFilePath
	}

	return decryptedFilePath, nil
}



================================================
FILE: pcsutil/error.go
================================================
package pcsutil

import (
	"log"
	"os"
)

// PrintErrIfExist ç®€æ˜“é”™è¯¯å¤„ç†, å¦‚æœ err å­˜åœ¨, å°±åªå‘å±å¹•è¾“å‡º err ã€‚
func PrintErrIfExist(err error) {
	if err != nil {
		log.Println(err)
	}
}

// PrintErrAndExit ç®€æ˜“é”™è¯¯å¤„ç†, å¦‚æœ err å­˜åœ¨, å‘å±å¹•è¾“å‡º err å¹¶é€€å‡º, annotate æ˜¯åŠ åœ¨ err ä¹‹å‰çš„æ³¨é‡Šä¿¡æ¯ã€‚
func PrintErrAndExit(annotate string, err error) {
	if err != nil {
		log.Println(annotate, err)
		os.Exit(1)
	}
}



================================================
FILE: pcsutil/file.go
================================================
package pcsutil

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/kardianos/osext"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"strings"
)

func IsPipeInput() bool {
	fileInfo, err := os.Stdin.Stat()
	if err != nil {
		return false
	}
	return (fileInfo.Mode() & os.ModeNamedPipe) == os.ModeNamedPipe
}

// IsIPhoneOS æ˜¯å¦ä¸ºè‹¹æœç§»åŠ¨è®¾å¤‡
func IsIPhoneOS() bool {
	if runtime.GOOS == "darwin" && (runtime.GOARCH == "arm" || runtime.GOARCH == "arm64") {
		_, err := os.Stat("Info.plist")
		return err == nil
	}
	return false
}

// ChWorkDir åˆ‡æ¢å›å·¥ä½œç›®å½•
func ChWorkDir() {
	if !IsIPhoneOS() {
		return
	}

	dir, err := filepath.Abs("")
	if err != nil {
		return
	}

	subPath := filepath.Dir(os.Args[0])
	os.Chdir(strings.TrimSuffix(dir, subPath))
}

// Executable è·å–ç¨‹åºæ‰€åœ¨çš„çœŸå®ç›®å½•æˆ–çœŸå®ç›¸å¯¹è·¯å¾„
func Executable() string {
	executablePath, err := osext.Executable()
	if err != nil {
		pcsverbose.Verbosef("DEBUG: osext.Executable: %s\n", err)
		executablePath, err = filepath.Abs(filepath.Dir(os.Args[0]))
		if err != nil {
			pcsverbose.Verbosef("DEBUG: filepath.Abs: %s\n", err)
			executablePath = filepath.Dir(os.Args[0])
		}
	}

	if IsIPhoneOS() {
		executablePath = filepath.Join(strings.TrimSuffix(executablePath, os.Args[0]), filepath.Base(os.Args[0]))
	}

	// è¯»å–é“¾æ¥
	linkedExecutablePath, err := filepath.EvalSymlinks(executablePath)
	if err != nil {
		pcsverbose.Verbosef("DEBUG: filepath.EvalSymlinks: %s\n", err)
		return executablePath
	}
	return linkedExecutablePath
}

// ExecutablePath è·å–ç¨‹åºæ‰€åœ¨ç›®å½•
func ExecutablePath() string {
	return filepath.Dir(Executable())
}

// ExecutablePathJoin è¿”å›ç¨‹åºæ‰€åœ¨ç›®å½•çš„å­ç›®å½•
func ExecutablePathJoin(subPath string) string {
	return filepath.Join(ExecutablePath(), subPath)
}

// WalkDir è·å–æŒ‡å®šç›®å½•åŠæ‰€æœ‰å­ç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶ï¼Œå¯ä»¥åŒ¹é…åç¼€è¿‡æ»¤ã€‚
// æ”¯æŒ Linux/macOS è½¯é“¾æ¥
func WalkDir(dirPth, suffix string) (files []string, err error) {
	files = make([]string, 0, 32)
	suffix = strings.ToUpper(suffix) //å¿½ç•¥åç¼€åŒ¹é…çš„å¤§å°å†™

	var walkFunc filepath.WalkFunc
	walkFunc = func(filename string, fi os.FileInfo, err error) error { //éå†ç›®å½•
		if err != nil {
			return err
		}
		if fi.IsDir() { // å¿½ç•¥ç›®å½•
			return nil
		}
		if fi.Mode()&os.ModeSymlink != 0 { // è¯»å– symbol link
			err = filepath.Walk(filename+string(os.PathSeparator), walkFunc)
			return err
		}

		if strings.HasSuffix(strings.ToUpper(fi.Name()), suffix) {
			files = append(files, path.Clean(filename))
		}
		return nil
	}

	err = filepath.Walk(dirPth, walkFunc)
	return files, err
}

// ConvertToUnixPathSeparator å°† windows ç›®å½•åˆ†éš”ç¬¦è½¬æ¢ä¸º Unix çš„
func ConvertToUnixPathSeparator(p string) string {
	return strings.Replace(p, "\\", "/", -1)
}



================================================
FILE: pcsutil/file_test.go
================================================
package pcsutil_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"testing"
)

func TestWalkDir(t *testing.T) {
	files, err := pcsutil.WalkDir("/Users/syy/tmp", "")
	if err != nil {
		t.Fatal(err)
	}
	for _, file := range files {
		fmt.Println(file)
	}
}



================================================
FILE: pcsutil/log_colorable_prefix.go
================================================
package pcsutil

import (
	"fmt"
	"github.com/fatih/color"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/pcstime"
	"log"
)

var (
	// ErrorColor è®¾ç½®è¾“å‡ºé”™è¯¯çš„é¢œè‰²
	ErrorColor = color.New(color.FgRed).SprintFunc()
)

// è‡ªå®šä¹‰log writer
type logWriter struct{}

func (logWriter) Write(bytes []byte) (int, error) {
	return fmt.Fprint(color.Output, "["+pcstime.BeijingTimeOption("Refer")+"] "+string(bytes))
}

// SetLogPrefix è®¾ç½®æ—¥å¿—è¾“å‡ºçš„æ—¶é—´å‰ç¼€
func SetLogPrefix() {
	log.SetFlags(0)
	log.SetOutput(new(logWriter))
}



================================================
FILE: pcsutil/pcsutil.go
================================================
// Package pcsutil å·¥å…·åŒ…
package pcsutil

import (
	"compress/gzip"
	"flag"
	"io"
	"io/ioutil"
	"net/http/cookiejar"
	"net/url"
	"strings"
)

// TrimPathPrefix å»é™¤ç›®å½•çš„å‰ç¼€
func TrimPathPrefix(path, prefixPath string) string {
	if prefixPath == "/" {
		return path
	}
	return strings.TrimPrefix(path, prefixPath)
}

// ContainsString æ£€æµ‹å­—ç¬¦ä¸²æ˜¯å¦åœ¨å­—ç¬¦ä¸²æ•°ç»„é‡Œ
func ContainsString(ss []string, s string) bool {
	for k := range ss {
		if ss[k] == s {
			return true
		}
	}
	return false
}

// GetURLCookieString è¿”å›cookieå­—ä¸²
func GetURLCookieString(urlString string, jar *cookiejar.Jar) string {
	u, _ := url.Parse(urlString)
	cookies := jar.Cookies(u)
	cookieString := ""
	for _, v := range cookies {
		cookieString += v.String() + "; "
	}
	cookieString = strings.TrimRight(cookieString, "; ")
	return cookieString
}

// DecompressGZIP å¯¹ io.Reader æ•°æ®, è¿›è¡Œ gzip è§£å‹
func DecompressGZIP(r io.Reader) ([]byte, error) {
	gzipReader, err := gzip.NewReader(r)
	if err != nil {
		return nil, err
	}
	gzipReader.Close()
	return ioutil.ReadAll(gzipReader)
}

// FlagProvided æ£€æµ‹å‘½ä»¤è¡Œæ˜¯å¦æä¾›åä¸º name çš„ flag, æ”¯æŒå¤šä¸ªname(names)
func FlagProvided(names ...string) bool {
	if len(names) == 0 {
		return false
	}
	var targetFlag *flag.Flag
	for _, name := range names {
		targetFlag = flag.Lookup(name)
		if targetFlag == nil {
			return false
		}
		if targetFlag.DefValue == targetFlag.Value.String() {
			return false
		}
	}
	return true
}

// Trigger ç”¨äºè§¦å‘äº‹ä»¶
func Trigger(f func()) {
	if f == nil {
		return
	}
	go f()
}

// TriggerOnSync ç”¨äºè§¦å‘äº‹ä»¶, åŒæ­¥è§¦å‘
func TriggerOnSync(f func()) {
	if f == nil {
		return
	}
	f()
}



================================================
FILE: pcsutil/regexp_pre.go
================================================
package pcsutil

import (
	"regexp"
)

var (
	// HTTPSRE https regexp
	HTTPSRE = regexp.MustCompile("^https")
	// ChinaPhoneRE https regexp
	ChinaPhoneRE = regexp.MustCompile(`^(\+86)?1[3-9][0-9]\d{8}$`)
)



================================================
FILE: pcsutil/cachepool/cachepool.go
================================================
package cachepool

import (
	"sync"
)

var (
	//CachePool []byte ç¼“å­˜æ±  2
	CachePool = cachePool2{}
)

//Cache cache
type Cache interface {
	Bytes() []byte
	Free()
}

type cache struct {
	isUsed bool
	b      []byte
}

func (c *cache) Bytes() []byte {
	if !c.isUsed {
		return nil
	}
	return c.b
}

func (c *cache) Free() {
	c.isUsed = false
}

type cachePool2 struct {
	pool []*cache
	mu   sync.Mutex
}

func (cp2 *cachePool2) Require(size int) Cache {
	cp2.mu.Lock()
	defer cp2.mu.Unlock()
	for k := range cp2.pool {
		if cp2.pool[k] == nil || cp2.pool[k].isUsed || len(cp2.pool[k].b) < size {
			continue
		}

		cp2.pool[k].isUsed = true
		return cp2.pool[k]
	}
	newCache := &cache{
		isUsed: true,
		b:      RawMallocByteSlice(size),
	}
	cp2.addCache(newCache)
	return newCache
}

func (cp2 *cachePool2) addCache(newCache *cache) {
	for k := range cp2.pool {
		if cp2.pool[k] == nil {
			cp2.pool[k] = newCache
			return
		}
	}
	cp2.pool = append(cp2.pool, newCache)
}

func (cp2 *cachePool2) DeleteNotUsed() {
	cp2.mu.Lock()
	defer cp2.mu.Unlock()
	for k := range cp2.pool {
		if cp2.pool[k] == nil {
			continue
		}

		if !cp2.pool[k].isUsed {
			cp2.pool[k] = nil
		}
	}
}

func (cp2 *cachePool2) DeleteAll() {
	cp2.mu.Lock()
	defer cp2.mu.Unlock()
	for k := range cp2.pool {
		cp2.pool[k] = nil
	}
}

//Require ç”³è¯·Cache
func Require(size int) Cache {
	return CachePool.Require(size)
}



================================================
FILE: pcsutil/cachepool/idcachepool.go
================================================
// Package cachepool []byteç¼“å­˜æ± 
package cachepool

import (
	"sync"
	"sync/atomic"
)

var (
	// IDCachePool []byte ç¼“å­˜æ± 
	IDCachePool = cachePool{
		cachepool: sync.Map{},
	}
)

type cachePool struct {
	lastID    int32
	cachepool sync.Map
}

func (cp *cachePool) Apply(size int) (id int32) {
	for {
		_, ok := cp.cachepool.Load(cp.lastID)
		atomic.AddInt32(&cp.lastID, 1)
		if ok {
			continue
		}
		break
	}

	cp.Set(cp.lastID, size)
	return cp.lastID
}

func (cp *cachePool) Existed(id int32) (existed bool) {
	_, existed = cp.cachepool.Load(id)
	return
}

func (cp *cachePool) Get(id int32) []byte {
	cache, ok := cp.cachepool.Load(id)
	if !ok {
		return nil
	}
	return cache.([]byte)
}

func (cp *cachePool) Set(id int32, size int) []byte {
	cache := RawMallocByteSlice(size)
	cp.cachepool.Store(id, cache)
	return cp.Get(id)
}

func (cp *cachePool) SetIfNotExist(id int32, size int) []byte {
	ok := cp.Existed(id)
	cache := cp.Get(id)
	if !ok || len(cache) < size {
		cache = nil
		cp.Delete(id)
		cp.Set(id, size)
	}
	return cp.Get(id)
}

func (cp *cachePool) Delete(id int32) {
	cp.cachepool.Store(id, nil)
	cp.cachepool.Delete(id)
}

func (cp *cachePool) DeleteAll() {
	cp.cachepool.Range(func(k interface{}, _ interface{}) bool {
		cp.Delete(k.(int32))
		return true
	})
}

// Apply ç”³è¯·ç¼“å­˜, è¿”å›ç¼“å­˜id
func Apply(size int) (id int32) {
	return IDCachePool.Apply(size)
}

// Existed é€šè¿‡ç¼“å­˜idæ£€æµ‹æ˜¯å¦å­˜åœ¨ç¼“å­˜
func Existed(id int32) bool {
	return IDCachePool.Existed(id)
}

// Get é€šè¿‡ç¼“å­˜idè·å–ç¼“å­˜[]byte
func Get(id int32) []byte {
	return IDCachePool.Get(id)
}

// Set è®¾ç½®ç¼“å­˜, é€šè¿‡ç»™å®šçš„ç¼“å­˜id
func Set(id int32, size int) []byte {
	return IDCachePool.Set(id, size)
}

// SetIfNotExist å¦‚æœç¼“å­˜ä¸å­˜åœ¨, åˆ™è®¾ç½®ç¼“å­˜æ± 
func SetIfNotExist(id int32, size int) []byte {
	return IDCachePool.SetIfNotExist(id, size)
}

// Delete é€šè¿‡ç¼“å­˜idåˆ é™¤ç¼“å­˜
func Delete(id int32) {
	IDCachePool.Delete(id)
}

// DeleteAll æ¸…ç©ºç¼“å­˜æ± 
func DeleteAll() {
	IDCachePool.DeleteAll()
}



================================================
FILE: pcsutil/cachepool/malloc.go
================================================
package cachepool

import (
	"reflect"
	"unsafe"
)

//go:linkname mallocgc runtime.mallocgc
func mallocgc(size uintptr, typ uintptr, needzero bool) unsafe.Pointer

//go:linkname rawbyteslice runtime.rawbyteslice
func rawbyteslice(size int) (b []byte)

// RawByteSlice point to runtime.rawbyteslice
func RawByteSlice(size int) (b []byte) {
	return rawbyteslice(size)
}

// RawMalloc allocates a new slice. The slice is not zeroed.
func RawMalloc(size int) unsafe.Pointer {
	return mallocgc(uintptr(size), 0, false)
}

// RawMallocByteSlice allocates a new byte slice. The slice is not zeroed.
func RawMallocByteSlice(size int) []byte {
	p := mallocgc(uintptr(size), 0, false)
	b := *(*[]byte)(unsafe.Pointer(&reflect.SliceHeader{
		Data: uintptr(p),
		Len:  size,
		Cap:  size,
	}))
	return b
}



================================================
FILE: pcsutil/cachepool/malloc.s
================================================
[Empty file]


================================================
FILE: pcsutil/cachepool/malloc_test.go
================================================
package cachepool_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"reflect"
	"runtime"
	"testing"
	"unsafe"
)

func TestMalloc(t *testing.T) {
	b := cachepool.RawMallocByteSlice(128)
	for k := range b {
		b[k] = byte(k)
	}
	fmt.Println(b)
	runtime.GC()

	b = cachepool.RawMallocByteSlice(128)
	fmt.Printf("---%s---\n", b)
	runtime.GC()

	b = cachepool.RawByteSlice(128)
	fmt.Println(b)
	runtime.GC()

	b = cachepool.RawByteSlice(127)
	bH := (*reflect.SliceHeader)(unsafe.Pointer(&b))
	fmt.Printf("%#v\n", bH)
}



================================================
FILE: pcsutil/cachepool/syncpool.go
================================================
package cachepool

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"runtime"
	"sync"
)

var (
	syncPoolSize     = int(64 * converter.KB)
	syncPoolFirstNew = false
	SyncPool         = sync.Pool{
		New: func() interface{} {
			syncPoolFirstNew = true
			return RawMallocByteSlice(syncPoolSize)
		},
	}
)

func SetSyncPoolSize(size int) {
	if syncPoolFirstNew && size != syncPoolSize {
		runtime.GC()
	}
	syncPoolSize = size
}



================================================
FILE: pcsutil/checkaccess/check_others.go
================================================
//+build aix plan9

package checkaccess

func AccessRDWR(path string) bool {
	return true
}



================================================
FILE: pcsutil/checkaccess/check_unix.go
================================================
// +build !windows,!plan9,!aix

package checkaccess

import (
	"syscall"
)

func AccessRDWR(path string) bool {
	return syscall.Access(path, syscall.O_RDWR) == nil
}



================================================
FILE: pcsutil/checkaccess/check_windows.go
================================================
package checkaccess

// TODO: check writable

func AccessRDWR(path string) bool {
	return true
}



================================================
FILE: pcsutil/checkaccess/checkaccess.go
================================================
package checkaccess



================================================
FILE: pcsutil/checksum/checksum.go
================================================
// Package checksum æ ¡éªŒæœ¬åœ°æ–‡ä»¶åŒ…
package checksum

import (
	"crypto/md5"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"hash/crc32"
	"io"
	"os"
)

const (
	// DefaultBufSize é»˜è®¤çš„bufSize
	DefaultBufSize = int(256 * converter.KB)
)

const (
	// CHECKSUM_MD5 è·å–æ–‡ä»¶çš„ md5 å€¼
	CHECKSUM_MD5 int = 1 << iota
	// CHECKSUM_SLICE_MD5 è·å–æ–‡ä»¶å‰ sliceSize åˆ‡ç‰‡çš„ md5 å€¼
	CHECKSUM_SLICE_MD5
	// CHECKSUM_CRC32 è·å–æ–‡ä»¶çš„ crc32 å€¼
	CHECKSUM_CRC32
)

type (
	// LocalFileMeta æœ¬åœ°æ–‡ä»¶å…ƒä¿¡æ¯
	LocalFileMeta struct {
		Path     string `json:"path"`     // æœ¬åœ°è·¯å¾„
		Length   int64  `json:"length"`   // æ–‡ä»¶å¤§å°
		SliceMD5 []byte `json:"slicemd5"` // æ–‡ä»¶å‰ requiredSliceLen (256KB) åˆ‡ç‰‡çš„ md5 å€¼
		MD5      []byte `json:"md5"`      // æ–‡ä»¶çš„ md5
		CRC32    uint32 `json:"crc32"`    // æ–‡ä»¶çš„ crc32
		ModTime  int64  `json:"modtime"`  // ä¿®æ”¹æ—¥æœŸ
	}

	// LocalFileChecksum æ ¡éªŒæœ¬åœ°æ–‡ä»¶
	LocalFileChecksum struct {
		LocalFileMeta
		bufSize   int
		sliceSize int
		buf       []byte
		file      *os.File // æ–‡ä»¶
	}
)

func NewLocalFileChecksum(localPath string, sliceSize int) *LocalFileChecksum {
	return NewLocalFileChecksumWithBufSize(localPath, DefaultBufSize, sliceSize)
}

func NewLocalFileChecksumWithBufSize(localPath string, bufSize, sliceSize int) *LocalFileChecksum {
	return &LocalFileChecksum{
		LocalFileMeta: LocalFileMeta{
			Path: localPath,
		},
		bufSize:   bufSize,
		sliceSize: sliceSize,
	}
}

// OpenPath æ£€æŸ¥æ–‡ä»¶çŠ¶æ€å¹¶è·å–æ–‡ä»¶çš„å¤§å° (Length)
func (lfc *LocalFileChecksum) OpenPath() error {
	if lfc.file != nil {
		lfc.file.Close()
	}

	var err error
	lfc.file, err = os.Open(lfc.Path)
	if err != nil {
		return err
	}

	info, err := lfc.file.Stat()
	if err != nil {
		return err
	}

	lfc.Length = info.Size()
	lfc.ModTime = info.ModTime().Unix()
	return nil
}

// GetFile è·å–æ–‡ä»¶
func (lfc *LocalFileChecksum) GetFile() *os.File {
	return lfc.file
}

// Close å…³é—­æ–‡ä»¶
func (lfc *LocalFileChecksum) Close() error {
	if lfc.file == nil {
		return ErrFileIsNil
	}

	return lfc.file.Close()
}

func (lfc *LocalFileChecksum) initBuf() {
	if lfc.buf == nil {
		lfc.buf = cachepool.RawMallocByteSlice(lfc.bufSize)
	}
}

func (lfc *LocalFileChecksum) writeChecksum(data []byte, wus ...*ChecksumWriteUnit) (err error) {
	doneCount := 0
	for _, wu := range wus {
		_, err := wu.Write(data)
		switch err {
		case ErrChecksumWriteStop:
			doneCount++
			continue
		case nil:
		default:
			return err
		}
	}
	if doneCount == len(wus) {
		return ErrChecksumWriteAllStop
	}
	return nil
}

func (lfc *LocalFileChecksum) repeatRead(wus ...*ChecksumWriteUnit) (err error) {
	if lfc.file == nil {
		return ErrFileIsNil
	}

	lfc.initBuf()

	defer func() {
		_, err = lfc.file.Seek(0, os.SEEK_SET) // æ¢å¤æ–‡ä»¶æŒ‡é’ˆ
		if err != nil {
			return
		}
	}()

	// è¯»æ–‡ä»¶
	var (
		n int
	)
read:
	for {
		n, err = lfc.file.Read(lfc.buf)
		switch err {
		case io.EOF:
			err = lfc.writeChecksum(lfc.buf[:n], wus...)
			break read
		case nil:
			err = lfc.writeChecksum(lfc.buf[:n], wus...)
		default:
			return
		}
	}
	switch err {
	case ErrChecksumWriteAllStop: // å…¨éƒ¨ç»“æŸ
		err = nil
	}
	return
}

func (lfc *LocalFileChecksum) createChecksumWriteUnit(cw ChecksumWriter, isAll, isSlice bool, getSumFunc func(sliceSum interface{}, sum interface{})) (wu *ChecksumWriteUnit, deferFunc func(err error)) {
	wu = &ChecksumWriteUnit{
		ChecksumWriter: cw,
		End:            lfc.LocalFileMeta.Length,
		OnlySliceSum:   !isAll,
	}

	if isSlice {
		wu.SliceEnd = int64(lfc.sliceSize)
	}

	return wu, func(err error) {
		if err != nil {
			return
		}
		getSumFunc(wu.SliceSum, wu.Sum)
	}
}

// Sum è®¡ç®—æ–‡ä»¶æ‘˜è¦å€¼
func (lfc *LocalFileChecksum) Sum(checkSumFlag int) (err error) {
	lfc.fix()
	wus := make([]*ChecksumWriteUnit, 0, 2)
	if (checkSumFlag & (CHECKSUM_MD5 | CHECKSUM_SLICE_MD5)) != 0 {
		md5w := md5.New()
		wu, d := lfc.createChecksumWriteUnit(
			NewHashChecksumWriter(md5w),
			(checkSumFlag&CHECKSUM_MD5) != 0,
			(checkSumFlag&CHECKSUM_SLICE_MD5) != 0,
			func(sliceSum interface{}, sum interface{}) {
				if sliceSum != nil {
					lfc.SliceMD5 = sliceSum.([]byte)
				}
				if sum != nil {
					lfc.MD5 = sum.([]byte)
				}
			},
		)

		wus = append(wus, wu)
		defer d(err)
	}
	if (checkSumFlag & CHECKSUM_CRC32) != 0 {
		crc32w := crc32.NewIEEE()
		wu, d := lfc.createChecksumWriteUnit(
			NewHash32ChecksumWriter(crc32w),
			true,
			false,
			func(sliceSum interface{}, sum interface{}) {
				if sum != nil {
					lfc.CRC32 = sum.(uint32)
				}
			},
		)

		wus = append(wus, wu)
		defer d(err)
	}

	err = lfc.repeatRead(wus...)
	return
}

func (lfc *LocalFileChecksum) fix() {
	if lfc.sliceSize <= 0 {
		lfc.sliceSize = DefaultBufSize
	}
	if lfc.bufSize < DefaultBufSize {
		lfc.bufSize = DefaultBufSize
	}
}



================================================
FILE: pcsutil/checksum/checksum_test.go
================================================
package checksum_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/checksum"
	"testing"
)

var (
	flagList = []int{
		checksum.CHECKSUM_MD5 | 000000000000000000000000000 | 00000000000000000000000,
		000000000000000000000 | checksum.CHECKSUM_SLICE_MD5 | 00000000000000000000000,
		000000000000000000000 | 000000000000000000000000000 | checksum.CHECKSUM_CRC32,
		checksum.CHECKSUM_MD5 | checksum.CHECKSUM_SLICE_MD5 | 00000000000000000000000,
		000000000000000000000 | checksum.CHECKSUM_SLICE_MD5 | checksum.CHECKSUM_CRC32,
		checksum.CHECKSUM_MD5 | 000000000000000000000000000 | checksum.CHECKSUM_CRC32,
		checksum.CHECKSUM_MD5 | checksum.CHECKSUM_SLICE_MD5 | checksum.CHECKSUM_CRC32,
	}
)

func printFileMeta(meta *checksum.LocalFileMeta) {
	fmt.Printf("slicemd5: %x, md5: %x, crc32: %x %d\n", meta.SliceMD5, meta.MD5, meta.CRC32, meta.CRC32)
}

func TestChecksum(t *testing.T) {
	fmt.Println("--- file.go")
	for _, flag := range flagList {
		lf, err := checksum.GetFileSum("file.go", flag)
		if err != nil {
			t.Fatal(err)
		}
		printFileMeta(&lf.LocalFileMeta)
	}

	fmt.Println("--- /Users/syy/go/src/github.com/felixonmars/BaiduPCS-Go/BaiduPCS-Go")
	for _, flag := range flagList {
		lf := checksum.NewLocalFileChecksumWithBufSize("/Users/syy/go/src/github.com/felixonmars/BaiduPCS-Go/BaiduPCS-Go", checksum.DefaultBufSize-3, checksum.DefaultBufSize)
		err := lf.OpenPath()
		if err != nil {
			t.Fatal(err)
		}
		lf.Sum(flag)
		printFileMeta(&lf.LocalFileMeta)
	}
}



================================================
FILE: pcsutil/checksum/checksum_write.go
================================================
package checksum

import (
	"hash"
	"io"
)

type (
	ChecksumWriter interface {
		io.Writer
		Sum() interface{}
	}

	ChecksumWriteUnit struct {
		SliceEnd       int64
		End            int64
		SliceSum       interface{}
		Sum            interface{}
		OnlySliceSum   bool
		ChecksumWriter ChecksumWriter

		ptr int64
	}

	hashChecksumWriter struct {
		h hash.Hash
	}

	hash32ChecksumWriter struct {
		h hash.Hash32
	}
)

func (wi *ChecksumWriteUnit) handleEnd() error {
	if wi.ptr >= wi.End {
		// å·²å†™å®Œ
		if !wi.OnlySliceSum {
			wi.Sum = wi.ChecksumWriter.Sum()
		}
		return ErrChecksumWriteStop
	}
	return nil
}

func (wi *ChecksumWriteUnit) write(p []byte) (n int, err error) {
	if wi.End <= 0 {
		// do nothing
		err = ErrChecksumWriteStop
		return
	}
	err = wi.handleEnd()
	if err != nil {
		return
	}

	var (
		i    int
		left = wi.End - wi.ptr
		lenP = len(p)
	)
	if left < int64(lenP) {
		// è¯»å–å³å°†å®Œæ¯•
		i = int(left)
	} else {
		i = lenP
	}
	n, err = wi.ChecksumWriter.Write(p[:i])
	if err != nil {
		return
	}
	wi.ptr += int64(n)
	if left < int64(lenP) {
		err = wi.handleEnd()
		return
	}
	return
}

func (wi *ChecksumWriteUnit) Write(p []byte) (n int, err error) {
	if wi.SliceEnd <= 0 { // å¿½ç•¥Slice
		// è¯»å–å…¨éƒ¨
		n, err = wi.write(p)
		return
	}

	// è¦è®¡ç®—Sliceçš„æƒ…å†µ
	// è°ƒæ•´slice
	if wi.SliceEnd > wi.End {
		wi.SliceEnd = wi.End
	}

	// è®¡ç®—å‰©ä½™Slice
	var (
		sliceLeft = wi.SliceEnd - wi.ptr
	)
	if sliceLeft <= 0 {
		// å·²å¤„ç†å®ŒSlice
		if wi.OnlySliceSum {
			err = ErrChecksumWriteStop
			return
		}

		// ç»§ç»­å¤„ç†
		n, err = wi.write(p)
		return
	}

	var (
		lenP = len(p)
	)
	if sliceLeft <= int64(lenP) {
		var n1, n2 int
		n1, err = wi.write(p[:sliceLeft])
		n += n1
		if err != nil {
			return
		}
		wi.SliceSum = wi.ChecksumWriter.Sum().([]byte)
		n2, err = wi.write(p[sliceLeft:])
		n += n2
		if err != nil {
			return
		}
		return
	}
	n, err = wi.write(p)
	return
}

func NewHashChecksumWriter(h hash.Hash) ChecksumWriter {
	return &hashChecksumWriter{
		h: h,
	}
}

func (hc *hashChecksumWriter) Write(p []byte) (n int, err error) {
	return hc.h.Write(p)
}

func (hc *hashChecksumWriter) Sum() interface{} {
	return hc.h.Sum(nil)
}

func NewHash32ChecksumWriter(h32 hash.Hash32) ChecksumWriter {
	return &hash32ChecksumWriter{
		h: h32,
	}
}

func (hc *hash32ChecksumWriter) Write(p []byte) (n int, err error) {
	return hc.h.Write(p)
}

func (hc *hash32ChecksumWriter) Sum() interface{} {
	return hc.h.Sum32()
}



================================================
FILE: pcsutil/checksum/errors.go
================================================
package checksum

import (
	"errors"
)

var (
	ErrFileIsNil            = errors.New("file is nil")
	ErrChecksumWriteStop    = errors.New("checksum write stop")
	ErrChecksumWriteAllStop = errors.New("checksum write all stop")
)



================================================
FILE: pcsutil/checksum/file.go
================================================
package checksum

import (
	"bytes"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"path/filepath"
)

// EqualLengthMD5 æ£€æµ‹md5å’Œå¤§å°æ˜¯å¦ç›¸åŒ
func (lfm *LocalFileMeta) EqualLengthMD5(m *LocalFileMeta) bool {
	if lfm.Length != m.Length {
		return false
	}
	if bytes.Compare(lfm.MD5, m.MD5) != 0 {
		return false
	}
	return true
}

// CompleteAbsPath è¡¥é½ç»å¯¹è·¯å¾„
func (lfm *LocalFileMeta) CompleteAbsPath() {
	if filepath.IsAbs(lfm.Path) {
		return
	}

	absPath, err := filepath.Abs(lfm.Path)
	if err != nil {
		return
	}

	lfm.Path = absPath
}

// GetFileSum è·å–æ–‡ä»¶çš„å¤§å°, md5, å‰256KBåˆ‡ç‰‡çš„ md5, crc32
func GetFileSum(localPath string, flag int) (lfc *LocalFileChecksum, err error) {
	lfc = NewLocalFileChecksum(localPath, int(baidupcs.SliceMD5Size))
	defer lfc.Close()

	err = lfc.OpenPath()
	if err != nil {
		return nil, err
	}

	err = lfc.Sum(flag)
	if err != nil {
		return nil, err
	}
	return lfc, nil
}



================================================
FILE: pcsutil/converter/converter.go
================================================
// Package converter æ ¼å¼, ç±»å‹è½¬æ¢åŒ…
package converter

import (
	"github.com/mattn/go-runewidth"
	"reflect"
	"strconv"
	"strings"
	"unicode"
	"unsafe"
)

const (
	// InvalidChars æ–‡ä»¶åä¸­çš„éæ³•å­—ç¬¦
	InvalidChars = `\/:*?"<>|`
)

// ToString unsafe è½¬æ¢, å°† []byte è½¬æ¢ä¸º string
func ToString(p []byte) string {
	return *(*string)(unsafe.Pointer(&p))
}

// ToBytes unsafe è½¬æ¢, å°† string è½¬æ¢ä¸º []byte
func ToBytes(str string) []byte {
	strHeader := (*reflect.StringHeader)(unsafe.Pointer(&str))
	return *(*[]byte)(unsafe.Pointer(&reflect.SliceHeader{
		Data: strHeader.Data,
		Len:  strHeader.Len,
		Cap:  strHeader.Len,
	}))
}

// ToBytesUnsafe unsafe è½¬æ¢, è¯·ç¡®ä¿è½¬æ¢åçš„ []byte ä¸æ¶‰åŠ cap() æ“ä½œ, å°† string è½¬æ¢ä¸º []byte
func ToBytesUnsafe(str string) []byte {
	return *(*[]byte)(unsafe.Pointer(&str))
}

// IntToBool int ç±»å‹è½¬æ¢ä¸º bool
func IntToBool(i int) bool {
	return i != 0
}

// SliceInt64ToString []int64 è½¬æ¢ä¸º []string
func SliceInt64ToString(si []int64) (ss []string) {
	ss = make([]string, 0, len(si))
	for k := range si {
		ss = append(ss, strconv.FormatInt(si[k], 10))
	}
	return ss
}

// SliceStringToInt64 []string è½¬æ¢ä¸º []int64
func SliceStringToInt64(ss []string) (si []int64) {
	si = make([]int64, 0, len(ss))
	var (
		i   int64
		err error
	)
	for k := range ss {
		i, err = strconv.ParseInt(ss[k], 10, 64)
		if err != nil {
			continue
		}
		si = append(si, i)
	}
	return
}

// SliceStringToInt []string è½¬æ¢ä¸º []int
func SliceStringToInt(ss []string) (si []int) {
	si = make([]int, 0, len(ss))
	var (
		i   int
		err error
	)
	for k := range ss {
		i, err = strconv.Atoi(ss[k])
		if err != nil {
			continue
		}
		si = append(si, i)
	}
	return
}

// MustInt å°†stringè½¬æ¢ä¸ºint, å¿½ç•¥é”™è¯¯
func MustInt(s string) (n int) {
	n, _ = strconv.Atoi(s)
	return
}

// MustInt64 å°†stringè½¬æ¢ä¸ºint64, å¿½ç•¥é”™è¯¯
func MustInt64(s string) (i int64) {
	i, _ = strconv.ParseInt(s, 10, 64)
	return
}

// ShortDisplay ç¼©ç•¥æ˜¾ç¤ºå­—ç¬¦ä¸²s, æ˜¾ç¤ºé•¿åº¦ä¸ºnum, ç¼©ç•¥çš„å†…å®¹ç”¨"..."å¡«å……
func ShortDisplay(s string, num int) string {
	var (
		sb = strings.Builder{}
		n  int
	)
	for _, v := range s {
		if unicode.Is(unicode.C, v) { // å»é™¤æ— æ•ˆå­—ç¬¦
			continue
		}
		n += runewidth.RuneWidth(v)
		if n > num {
			sb.WriteString("...")
			break
		}
		sb.WriteRune(v)
	}

	return sb.String()
}

// TrimPathInvalidChars æ¸…é™¤æ–‡ä»¶åä¸­çš„éæ³•å­—ç¬¦
func TrimPathInvalidChars(fpath string) string {
	buf := make([]byte, 0, len(fpath))

	for _, c := range ToBytesUnsafe(fpath) {
		if strings.ContainsRune(InvalidChars, rune(c)) {
			continue
		}

		buf = append(buf, c)
	}

	return ToString(buf)
}



================================================
FILE: pcsutil/converter/converter_test.go
================================================
package converter_test

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"strings"
	"testing"
)

func TestTrimPathInvalidChars(t *testing.T) {
	trimed := converter.TrimPathInvalidChars("ksjadfi*/?adf")
	if strings.Compare(trimed, "ksjadfiadf") != 0 {
		t.Fatalf("trimed: %s\n", trimed)
	}
	return
}



================================================
FILE: pcsutil/converter/short_display_test.go
================================================
package converter_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"testing"
)

func TestShortDisplay(t *testing.T) {
	for i := 0; i < 20; i++ {
		fmt.Println([]byte(converter.ShortDisplay("\u0000æˆ‘æˆ‘\u0000æˆ‘æˆ‘æˆ‘æˆ‘", i)))
	}
}



================================================
FILE: pcsutil/converter/size.go
================================================
package converter

import (
	"errors"
	"fmt"
	"strconv"
	"strings"
)

const (
	// B byte
	B = (int64)(1 << (10 * iota))
	// KB kilobyte
	KB
	// MB megabyte
	MB
	// GB gigabyte
	GB
	// TB terabyte
	TB
	// PB petabyte
	PB
)

// ConvertFileSize æ–‡ä»¶å¤§å°æ ¼å¼åŒ–è¾“å‡º
func ConvertFileSize(size int64, precision ...int) string {
	pint := "6"
	if len(precision) == 1 {
		pint = fmt.Sprint(precision[0])
	}
	if size < 0 {
		return "0B"
	}
	if size < KB {
		return fmt.Sprintf("%dB", size)
	}
	if size < MB {
		return fmt.Sprintf("%."+pint+"fKB", float64(size)/float64(KB))
	}
	if size < GB {
		return fmt.Sprintf("%."+pint+"fMB", float64(size)/float64(MB))
	}
	if size < TB {
		return fmt.Sprintf("%."+pint+"fGB", float64(size)/float64(GB))
	}
	if size < PB {
		return fmt.Sprintf("%."+pint+"fTB", float64(size)/float64(TB))
	}
	return fmt.Sprintf("%."+pint+"fPB", float64(size)/float64(PB))
}

// ParseFileSizeStr å°†æ–‡ä»¶å¤§å°å­—ç¬¦ä¸²è½¬æ¢æˆå­—èŠ‚æ•°
func ParseFileSizeStr(ss string) (size int64, err error) {
	if ss == "" {
		err = errors.New("converter: size is empty")
		return
	}
	if !(ss[0] == '.' || '0' <= ss[0] && ss[0] <= '9') {
		err = errors.New("converter: invalid size: " + ss)
		return
	}

	var i int
	for i = range ss[1:] {
		i++
		if ss[i] == '.' || ('0' <= ss[i] && ss[i] <= '9') {
			// å±äºæ•°å­—
			continue
		}
		break
	}
	if ss[i] == '.' || ('0' <= ss[i] && ss[i] <= '9') { // æœ€åä¸€ä¸ªåˆ†éš”ç¬¦æ˜¯å¦ä¸ºæ•°å­—
		i++
	}

	var (
		sizeStr      = ss[:i] // æ•°å­—éƒ¨åˆ†
		unitStr      = ss[i:] // å•ä½éƒ¨åˆ†
		sizeFloat, _ = strconv.ParseFloat(sizeStr, 10)
	)
	switch strings.ToUpper(unitStr) {
	case "", "B":
		size = int64(sizeFloat)
	case "K", "KB":
		size = int64(sizeFloat * float64(KB))
	case "M", "MB":
		size = int64(sizeFloat * float64(MB))
	case "G", "GB":
		size = int64(sizeFloat * float64(GB))
	case "T", "TB":
		size = int64(sizeFloat * float64(TB))
	case "P", "PB":
		size = int64(sizeFloat * float64(PB))
	default:
		err = errors.New("converter: invalid unit " + unitStr)
	}
	return
}



================================================
FILE: pcsutil/converter/size_test.go
================================================
package converter_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"testing"
)

func TestParseFileSizeStr(t *testing.T) {
	for _, v := range []string{"1k", "3.86mb", "4.001Gb", "32"} {
		size, err := converter.ParseFileSizeStr(v)
		if err != nil {
			t.Fatalf("%s\n", err)
		}
		fmt.Println(v, size)
	}
}



================================================
FILE: pcsutil/delay/delay.go
================================================
package delay

import (
	"time"
)

// NewDelayChan å‘é€å»¶æ—¶ä¿¡å·
func NewDelayChan(t time.Duration) <-chan struct{} {
	c := make(chan struct{})
	go func() {
		time.Sleep(t)
		close(c)
	}()
	return c
}



================================================
FILE: pcsutil/escaper/escaper.go
================================================
package escaper

import (
	"strings"
)

type (
	// RuneFunc åˆ¤æ–­æŒ‡å®šrune
	RuneFunc func(r rune) bool
)

// EscapeByRuneFunc é€šè¿‡runeFuncè½¬ä¹‰, runeFuncè¿”å›çœŸ, åˆ™è½¬ä¹‰
func EscapeByRuneFunc(s string, runeFunc RuneFunc) string {
	if runeFunc == nil {
		return s
	}

	var (
		builder = &strings.Builder{}
		rs      = []rune(s)
	)

	for k := range rs {
		if !runeFunc(rs[k]) {
			builder.WriteRune(rs[k])
			continue
		}

		if k >= 1 && rs[k-1] == '\\' {
			builder.WriteRune(rs[k])
			continue
		}
		builder.WriteString(`\`)
		builder.WriteRune(rs[k])
	}
	return builder.String()
}

// Escape è½¬ä¹‰æŒ‡å®šçš„escapeRunes, åœ¨escapeRunesçš„å‰é¢åŠ ä¸Šä¸€ä¸ªåæ–œæ 
func Escape(s string, escapeRunes []rune) string {
	return EscapeByRuneFunc(s, func(r rune) bool {
		for k := range escapeRunes {
			if escapeRunes[k] == r {
				return true
			}
		}
		return false
	})
}

// EscapeStrings è½¬ä¹‰å­—ç¬¦ä¸²æ•°ç»„
func EscapeStrings(ss []string, escapeRunes []rune) {
	for k := range ss {
		ss[k] = Escape(ss[k], escapeRunes)
	}
}

// EscapeStringsByRuneFunc è½¬ä¹‰å­—ç¬¦ä¸²æ•°ç»„, é€šè¿‡runeFunc
func EscapeStringsByRuneFunc(ss []string, runeFunc RuneFunc) {
	for k := range ss {
		ss[k] = EscapeByRuneFunc(ss[k], runeFunc)
	}
}



================================================
FILE: pcsutil/escaper/escaper_test.go
================================================
package escaper_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/escaper"
	"testing"
)

func TestEscape(t *testing.T) {
	fmt.Println(escaper.Escape(`asdf'asdfasd[]a[\[][sdf\[d]`, []rune{'[', '\''}))
}



================================================
FILE: pcsutil/getip/errors.go
================================================
package getip

import (
	"errors"
)

var (
	// ErrParseIP è§£æipåœ°å€é”™è¯¯
	ErrParseIP = errors.New("parse ip error")
)



================================================
FILE: pcsutil/getip/getip.go
================================================
// Package getip è·å– ip ä¿¡æ¯åŒ…
package getip

import (
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"net"
	"net/http"
	"unsafe"
)

// IPInfoByClient ç»™å®šclientè·å–ipåœ°å€
func IPInfoByClient(c *requester.HTTPClient) (ipAddr string, err error) {
	if c == nil {
		c = requester.NewHTTPClient()
	}

	body, err := c.Fetch(http.MethodGet, "https://api.ipify.org", nil, nil)
	if err != nil {
		return
	}

	ipAddr = *(*string)(unsafe.Pointer(&body))
	ip := net.ParseIP(ipAddr)
	if ip == nil {
		return "", ErrParseIP
	}
	return
}

//IPInfo ä»ipifyè·å–IPåœ°å€
func IPInfo(https bool) (ipAddr string, err error) {
	c := requester.NewHTTPClient()
	c.SetHTTPSecure(https)
	return IPInfoByClient(c)
}



================================================
FILE: pcsutil/getip/getip_netease.go
================================================
package getip

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/jsonhelper"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"net"
	"net/http"
)

type (
	// IPResNetease ç½‘æ˜“æœåŠ¡å™¨è·å–ipè¿”å›çš„ç»“æœ
	IPResNetease struct {
		Result  string `json:"result"`
		Code    int    `json:"code"`
		Message string `json:"message"`
	}
)

func IPInfoFromNeteaseByClient(c *requester.HTTPClient) (ipAddr string, err error) {
	resp, err := c.Req(http.MethodGet, "http://mam.netease.com/api/config/getClientIp", nil, nil)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		return
	}

	res := &IPResNetease{}
	err = jsonhelper.UnmarshalData(resp.Body, res)
	if err != nil {
		return
	}

	ip := net.ParseIP(res.Result)
	if ip == nil {
		err = ErrParseIP
		return
	}

	ipAddr = res.Result
	return
}

// IPInfoFromNetease ä»ç½‘æ˜“æœåŠ¡å™¨è·å–ip
func IPInfoFromNetease() (ipAddr string, err error) {
	c := requester.NewHTTPClient()
	return IPInfoFromNeteaseByClient(c)
}



================================================
FILE: pcsutil/getip/getip_techain.go
================================================
package getip

import (
	"bytes"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"net/http"
)

func IPInfoFromTechainBaiduByClient(c *requester.HTTPClient) (ipAddr string, err error) {
	body, err := c.Fetch(http.MethodGet, "https://techain.baidu.com/srcmon", nil, map[string]string{
		"User-Agent":      "x18/600000101/10.0.63/4.1.3",
		"Pragma":          "no-cache",
		"Accept":          "*/*",
		"Content-Type":    "application/x-www-form-urlencoded",
		"x-auth-ver":      "1",
		"Accept-Language": "zh-CN",
		"x-device-id":     "00000000000000000000000000000000",
	})
	if err != nil {
		return
	}
	return converter.ToString(bytes.TrimSpace(body)), nil
}

// IPInfoFromTechainBaidu ä» techain.baidu.com è·å–ip
func IPInfoFromTechainBaidu() (ipAddr string, err error) {
	c := requester.NewHTTPClient()
	return IPInfoFromNeteaseByClient(c)
}



================================================
FILE: pcsutil/getip/getip_test.go
================================================
package getip

import (
	"testing"
)

func TestGetIP(t *testing.T) {
	ipAddr, err := IPInfo(false)
	if err != nil {
		t.Errorf("err: %s\n", err)
		return
	}

	t.Logf("from ipify: %s\n", ipAddr)

	ipAddr, err = IPInfoFromNetease()
	if err != nil {
		t.Errorf("err: %s\n", err)
		return
	}

	t.Logf("from netease: %s\n", ipAddr)
}



================================================
FILE: pcsutil/jsonhelper/jsonhelper.go
================================================
package jsonhelper

import (
	"github.com/json-iterator/go"
	"io"
)

// UnmarshalData å°† r ä¸­çš„ json æ ¼å¼çš„æ•°æ®, è§£æåˆ° data
func UnmarshalData(r io.Reader, data interface{}) error {
	d := jsoniter.NewDecoder(r)
	return d.Decode(data)
}

// MarshalData å°† data, ç”Ÿæˆ json æ ¼å¼çš„æ•°æ®, å†™å…¥ w ä¸­
func MarshalData(w io.Writer, data interface{}) error {
	e := jsoniter.NewEncoder(w)
	return e.Encode(data)
}



================================================
FILE: pcsutil/jwted25519/jwted25519.go
================================================
package jwted25519

import (
	"github.com/dgrijalva/jwt-go"
	"golang.org/x/crypto/ed25519"
	"unsafe"
)

type (
	SigningMethodEd25519 struct{}
)

var (
	SigningMethodED25519 *SigningMethodEd25519
)

func init() {
	// ED25519
	SigningMethodED25519 = &SigningMethodEd25519{}
	jwt.RegisterSigningMethod(SigningMethodED25519.Alg(), func() jwt.SigningMethod {
		return SigningMethodED25519
	})
}

func (m *SigningMethodEd25519) Alg() string {
	return "ED25519"
}

func (m *SigningMethodEd25519) Sign(signingString string, key interface{}) (string, error) {
	if privkey, ok := key.(ed25519.PrivateKey); ok {
		if len(privkey) != ed25519.PrivateKeySize {
			return "", jwt.ErrInvalidKey
		}

		signature := ed25519.Sign(privkey, *(*[]byte)(unsafe.Pointer(&signingString)))
		return jwt.EncodeSegment(signature), nil
	}

	return "", jwt.ErrInvalidKeyType
}

func (m *SigningMethodEd25519) Verify(signingString, signature string, key interface{}) error {
	pubkey, ok := key.(ed25519.PublicKey)
	if !ok {
		return jwt.ErrInvalidKeyType
	}

	if len(pubkey) != ed25519.PublicKeySize {
		return jwt.ErrInvalidKey
	}

	message, err := jwt.DecodeSegment(signature)
	if err != nil {
		return err
	}

	ok = ed25519.Verify(pubkey, *(*[]byte)(unsafe.Pointer(&signingString)), message)
	if !ok {
		return jwt.ErrSignatureInvalid
	}

	return nil
}



================================================
FILE: pcsutil/pcstime/time.go
================================================
// Package pcstime æ—¶é—´å·¥å…·åŒ…
package pcstime

import (
	"fmt"
	"time"
)

var (
	// CSTLocation ä¸œå…«åŒºæ—¶åŒº
	CSTLocation = time.FixedZone("CST", 8*3600)
)

/*
BeijingTimeOption æ ¹æ®ç»™å®šçš„ get è¿”å›æ—¶é—´æ ¼å¼.

	get:        æ—¶é—´æ ¼å¼

	"Refer":    2017-7-21 12:02:32.000
	"printLog": 2017-7-21_12:02:32
	"day":      21
	"ymd":      2017-7-21
	"hour":     12
	é»˜è®¤æ—¶é—´æˆ³:   1500609752
*/
func BeijingTimeOption(get string) string {
	//è·å–åŒ—äº¬ï¼ˆä¸œå…«åŒºï¼‰æ—¶é—´
	now := time.Now().In(CSTLocation)
	year, mon, day := now.Date()
	hour, min, sec := now.Clock()
	millisecond := now.Nanosecond() / 1e6
	switch get {
	case "Refer":
		return fmt.Sprintf("%d-%d-%d %02d:%02d:%02d.%03d", year, mon, day, hour, min, sec, millisecond)
	case "printLog":
		return fmt.Sprintf("%d-%d-%d_%02dh%02dm%02ds", year, mon, day, hour, min, sec)
	case "day":
		return fmt.Sprint(day)
	case "ymd":
		return fmt.Sprintf("%d-%d-%d", year, mon, day)
	case "hour":
		return fmt.Sprint(hour)
	default:
		return fmt.Sprint(time.Now().Unix())
	}
}

// FormatTime å°† Unix æ—¶é—´æˆ³, è½¬æ¢ä¸ºå­—ç¬¦ä¸²
func FormatTime(t int64) string {
	tt := time.Unix(t, 0).In(CSTLocation)
	year, mon, day := tt.Date()
	hour, min, sec := tt.Clock()
	return fmt.Sprintf("%d-%02d-%02d %02d:%02d:%02d", year, mon, day, hour, min, sec)
}



================================================
FILE: pcsutil/prealloc/errors.go
================================================
package prealloc

import (
	"fmt"
)

type (
	PreAllocError struct {
		ProcName string
		Err      error
	}
)

func (pe *PreAllocError) Error() string {
	if pe.Err == nil {
		return "<nil>"
	}
	return fmt.Sprintf("%s error: %s\n", pe.ProcName, pe.Err)
}



================================================
FILE: pcsutil/prealloc/prealloc.go
================================================
//+build !windows,!plan9

// Package prealloc åˆå§‹åŒ–åˆ†é…æ–‡ä»¶åŒ…
package prealloc

import (
	"syscall"
)

// PreAlloc é¢„åˆ†é…æ–‡ä»¶ç©ºé—´
func PreAlloc(fd uintptr, length int64) error {
	err := syscall.Ftruncate(int(fd), length)
	if err != nil {
		return &PreAllocError{
			ProcName: "Ftruncate",
			Err:      err,
		}
	}
	return nil
}



================================================
FILE: pcsutil/prealloc/prealloc_plan9.go
================================================
//+build plan9

package prealloc

func PreAlloc(fd uintptr, length int64) error {
	return nil
}



================================================
FILE: pcsutil/prealloc/prealloc_windows.go
================================================
package prealloc

import (
	"golang.org/x/sys/windows"
	"log"
	"syscall"
)

var (
	kernel32             = syscall.NewLazyDLL("kernel32.dll")
	procSetFileValidData = kernel32.NewProc("SetFileValidData")
)

func initPrivilege() error {
	current, err := windows.GetCurrentProcess()
	if err != nil {
		return &PreAllocError{
			ProcName: "GetCurrentProcess",
			Err:      err,
		}
	}

	var hToken windows.Token
	err = windows.OpenProcessToken(current, windows.TOKEN_ADJUST_PRIVILEGES|windows.TOKEN_QUERY, &hToken)
	if err != nil {
		return &PreAllocError{
			ProcName: "OpenProcessToken",
			Err:      err,
		}
	}

	var (
		seManageVolumeName, _ = windows.UTF16PtrFromString("SeManageVolumePrivilege")
		tp                    = windows.Tokenprivileges{
			PrivilegeCount: 1,
			Privileges: [1]windows.LUIDAndAttributes{
				windows.LUIDAndAttributes{
					Luid:       windows.LUID{},
					Attributes: windows.SE_PRIVILEGE_ENABLED,
				},
			},
		}
	)
	err = windows.LookupPrivilegeValue(nil, seManageVolumeName, &tp.Privileges[0].Luid)
	if err != nil {
		return &PreAllocError{
			ProcName: "LookupPrivilegeValue",
			Err:      err,
		}
	}

	err = windows.AdjustTokenPrivileges(hToken, false, &tp, 0, nil, nil)
	if err != nil {
		return &PreAllocError{
			ProcName: "AdjustTokenPrivileges",
			Err:      err,
		}
	}

	return nil
}

// åˆå§‹åŒ–æƒé™
func init() {
	err := initPrivilege()
	if err != nil {
		log.Printf("prealloc: init privileges error: %s\n", err) // æ‰“å°è­¦å‘Š
	}
}

// PreAlloc é¢„åˆ†é…æ–‡ä»¶ç©ºé—´
func PreAlloc(fd uintptr, length int64) error {
	err := syscall.Ftruncate(syscall.Handle(fd), length)
	if err != nil {
		return &PreAllocError{
			ProcName: "Ftruncate",
			Err:      err,
		}
	}

	r1, _, err := procSetFileValidData.Call(fd, uintptr(length))
	if r1 == 0 {
		return &PreAllocError{
			ProcName: "SetFileValidData",
			Err:      err,
		}
	}

	return nil
}



================================================
FILE: pcsutil/taskframework/executor.go
================================================
package taskframework

import (
	"github.com/GeertJohan/go.incremental"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/waitgroup"
	"github.com/oleiade/lane"
	"strconv"
	"time"
)

type (
	TaskExecutor struct {
		incr     *incremental.Int // ä»»åŠ¡idç”Ÿæˆ
		deque    *lane.Deque      // é˜Ÿåˆ—
		parallel int              // ä»»åŠ¡çš„æœ€å¤§å¹¶å‘é‡

		// æ˜¯å¦ç»Ÿè®¡å¤±è´¥é˜Ÿåˆ—
		IsFailedDeque bool
		failedDeque   *lane.Deque
	}
)

func NewTaskExecutor() *TaskExecutor {
	return &TaskExecutor{}
}

func (te *TaskExecutor) lazyInit() {
	if te.deque == nil {
		te.deque = lane.NewDeque()
	}
	if te.incr == nil {
		te.incr = &incremental.Int{}
	}
	if te.parallel < 1 {
		te.parallel = 1
	}
	if te.IsFailedDeque {
		te.failedDeque = lane.NewDeque()
	}
}

// è®¾ç½®ä»»åŠ¡çš„æœ€å¤§å¹¶å‘é‡
func (te *TaskExecutor) SetParallel(parallel int) {
	te.parallel = parallel
}

//Append å°†ä»»åŠ¡åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—æœ«å°¾
func (te *TaskExecutor) Append(unit TaskUnit, maxRetry int) *TaskInfo {
	te.lazyInit()
	taskInfo := &TaskInfo{
		id:       strconv.Itoa(te.incr.Next()),
		maxRetry: maxRetry,
	}
	unit.SetTaskInfo(taskInfo)
	te.deque.Append(&TaskInfoItem{
		Info: taskInfo,
		Unit: unit,
	})
	return taskInfo
}

//AppendNoRetry å°†ä»»åŠ¡åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—æœ«å°¾, ä¸é‡è¯•
func (te *TaskExecutor) AppendNoRetry(unit TaskUnit) {
	te.Append(unit, 0)
}

//Count è¿”å›ä»»åŠ¡æ•°é‡
func (te *TaskExecutor) Count() int {
	if te.deque == nil {
		return 0
	}
	return te.deque.Size()
}

//Execute æ‰§è¡Œä»»åŠ¡
func (te *TaskExecutor) Execute() {
	te.lazyInit()

	for {
		wg := waitgroup.NewWaitGroup(te.parallel)
		for {
			e := te.deque.Shift()
			if e == nil { // ä»»åŠ¡ä¸ºç©º
				break
			}

			// è·å–ä»»åŠ¡
			task := e.(*TaskInfoItem)
			wg.AddDelta()

			go func(task *TaskInfoItem) {
				defer wg.Done()

				result := task.Unit.Run()

				// è¿”å›ç»“æœä¸ºç©º
				if result == nil {
					task.Unit.OnComplete(result)
					return
				}

				if result.Succeed {
					task.Unit.OnSuccess(result)
					task.Unit.OnComplete(result)
					return
				}

				// éœ€è¦è¿›è¡Œé‡è¯•
				if result.NeedRetry {
					// é‡è¯•æ¬¡æ•°è¶…å‡ºé™åˆ¶
					// æ‰§è¡Œå¤±è´¥
					if task.Info.IsExceedRetry() {
						task.Unit.OnFailed(result)
						if te.IsFailedDeque {
							// åŠ å…¥å¤±è´¥é˜Ÿåˆ—
							te.failedDeque.Append(task)
						}
						task.Unit.OnComplete(result)
						return
					}

					task.Info.retry++         // å¢åŠ é‡è¯•æ¬¡æ•°
					task.Unit.OnRetry(result) // è°ƒç”¨é‡è¯•
					task.Unit.OnComplete(result)

					time.Sleep(task.Unit.RetryWait()) // ç­‰å¾…
					te.deque.Append(task)             // é‡æ–°åŠ å…¥é˜Ÿåˆ—æœ«å°¾
					return
				}

				// æ‰§è¡Œå¤±è´¥
				task.Unit.OnFailed(result)
				if te.IsFailedDeque {
					// åŠ å…¥å¤±è´¥é˜Ÿåˆ—
					te.failedDeque.Append(task)
				}
				task.Unit.OnComplete(result)
			}(task)
		}

		wg.Wait()

		// æ²¡æœ‰ä»»åŠ¡äº†
		if te.deque.Size() == 0 {
			break
		}
	}
}

//FailedDeque è·å–å¤±è´¥é˜Ÿåˆ—
func (te *TaskExecutor) FailedDeque() *lane.Deque {
	return te.failedDeque
}

//Stop åœæ­¢æ‰§è¡Œ
func (te *TaskExecutor) Stop() {

}

//Pause æš‚åœæ‰§è¡Œ
func (te *TaskExecutor) Pause() {

}

//Resume æ¢å¤æ‰§è¡Œ
func (te *TaskExecutor) Resume() {
}



================================================
FILE: pcsutil/taskframework/task_unit.go
================================================
[Binary file]


================================================
FILE: pcsutil/taskframework/taskframework_test.go
================================================
package taskframework_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/taskframework"
	"testing"
	"time"
)

type (
	TestUnit struct {
		retry    bool
		taskInfo *taskframework.TaskInfo
	}
)

func (tu *TestUnit) SetTaskInfo(taskInfo *taskframework.TaskInfo) {
	tu.taskInfo = taskInfo
}

func (tu *TestUnit) OnFailed(lastRunResult *taskframework.TaskUnitRunResult) {
	fmt.Printf("[%s] error: %s, failed\n", tu.taskInfo.Id(), lastRunResult.Err)
}

func (tu *TestUnit) OnSuccess(lastRunResult *taskframework.TaskUnitRunResult) {
	fmt.Printf("[%s] success\n", tu.taskInfo.Id())
}

func (tu *TestUnit) OnComplete(lastRunResult *taskframework.TaskUnitRunResult) {
	fmt.Printf("[%s] complete\n", tu.taskInfo.Id())
}

func (tu *TestUnit) Run() (result *taskframework.TaskUnitRunResult) {
	fmt.Printf("[%s] running...\n", tu.taskInfo.Id())
	return &taskframework.TaskUnitRunResult{
		//Succeed:   true,
		NeedRetry: true,
	}
}

func (tu *TestUnit) OnRetry(lastRunResult *taskframework.TaskUnitRunResult) {
	fmt.Printf("[%s] prepare retry, times [%d/%d]...\n", tu.taskInfo.Id(), tu.taskInfo.Retry(), tu.taskInfo.MaxRetry())
}

func (tu *TestUnit) RetryWait() time.Duration {
	return 1 * time.Second
}

func TestTaskExecutor(t *testing.T) {
	te := taskframework.NewTaskExecutor()
	te.SetParallel(2)
	for i := 0; i < 3; i++ {
		tu := TestUnit{
			retry: false,
		}
		te.Append(&tu, 2)
	}
	te.Execute()
}



================================================
FILE: pcsutil/taskframework/taskinfo.go
================================================
package taskframework

type (
	TaskInfo struct {
		id       string
		maxRetry int
		retry    int
	}

	TaskInfoItem struct {
		Info *TaskInfo
		Unit TaskUnit
	}
)

// IsExceedRetry é‡è¯•æ¬¡æ•°è¾¾åˆ°é™åˆ¶
func (t *TaskInfo) IsExceedRetry() bool {
	return t.retry >= t.maxRetry
}

func (t *TaskInfo) Id() string {
	return t.id
}

func (t *TaskInfo) MaxRetry() int {
	return t.maxRetry
}

func (t *TaskInfo) SetMaxRetry(maxRetry int) {
	t.maxRetry = maxRetry
}

func (t *TaskInfo) Retry() int {
	return t.retry
}



================================================
FILE: pcsutil/waitgroup/wait_group.go
================================================
// Package waitgroup sync.WaitGroup extension
package waitgroup

import "sync"

// WaitGroup åœ¨ sync.WaitGroup çš„åŸºç¡€ä¸Š, æ–°å¢çº¿ç¨‹æ§åˆ¶åŠŸèƒ½
type WaitGroup struct {
	wg sync.WaitGroup
	p  chan struct{}

	sync.RWMutex
}

// NewWaitGroup returns a pointer to a new `WaitGroup` object.
// parallel ä¸ºæœ€å¤§å¹¶å‘æ•°, 0 ä»£è¡¨æ— é™åˆ¶
func NewWaitGroup(parallel int) (w *WaitGroup) {
	w = &WaitGroup{
		wg: sync.WaitGroup{},
	}

	if parallel <= 0 {
		return
	}

	w.p = make(chan struct{}, parallel)
	return
}

// AddDelta sync.WaitGroup.Add(1)
func (w *WaitGroup) AddDelta() {
	if w.p != nil {
		w.p <- struct{}{}
	}

	w.wg.Add(1)
}

// Done sync.WaitGroup.Done()
func (w *WaitGroup) Done() {
	w.wg.Done()

	if w.p != nil {
		<-w.p
	}
}

// Wait å‚ç…§ sync.WaitGroup çš„ Wait æ–¹æ³•
func (w *WaitGroup) Wait() {
	w.wg.Wait()
	if w.p != nil {
		close(w.p)
	}
}

// Parallel è¿”å›å½“å‰æ­£åœ¨è¿›è¡Œçš„ä»»åŠ¡æ•°é‡
func (w *WaitGroup) Parallel() int {
	return len(w.p)
}



================================================
FILE: pcsutil/waitgroup/wait_group_test.go
================================================
package waitgroup

import (
	"fmt"
	"testing"
	"time"
)

func TestWg(t *testing.T) {
	wg := NewWaitGroup(2)
	for i := 0; i < 60; i++ {
		wg.AddDelta()
		go func(i int) {
			fmt.Println(i, wg.Parallel())
			time.Sleep(1e9)
			wg.Done()
		}(i)
	}
	wg.Wait()
}



================================================
FILE: pcsverbose/pcsverbose.go
================================================
// Package pcsverbose è°ƒè¯•åŒ…
package pcsverbose

import (
	"fmt"
	"io"
	"os"
)

const (
	// EnvVerbose å¯ç”¨è°ƒè¯•ç¯å¢ƒå˜é‡
	EnvVerbose = "BAIDUPCS_GO_VERBOSE"
)

var (
	// IsVerbose æ˜¯å¦è°ƒè¯•
	IsVerbose = os.Getenv(EnvVerbose) == "1"

	// Outputs è¾“å‡º
	Outputs = []io.Writer{os.Stderr}
)

// PCSVerbose è°ƒè¯•
type PCSVerbose struct {
	Module string
}

// New æ ¹æ®module, åˆå§‹åŒ–PCSVerbose
func New(module string) *PCSVerbose {
	return &PCSVerbose{
		Module: module,
	}
}

// Info æç¤º
func (pv *PCSVerbose) Info(l string) {
	Verbosef("DEBUG: %s INFO: %s\n", pv.Module, l)
}

// Infof æç¤º, æ ¼å¼è¾“å‡º
func (pv *PCSVerbose) Infof(format string, a ...interface{}) {
	Verbosef("DEBUG: %s INFO: %s", pv.Module, fmt.Sprintf(format, a...))
}

// Warn è­¦å‘Š
func (pv *PCSVerbose) Warn(l string) {
	Verbosef("DEBUG: %s WARN: %s\n", pv.Module, l)
}

// Warnf è­¦å‘Š, æ ¼å¼è¾“å‡º
func (pv *PCSVerbose) Warnf(format string, a ...interface{}) {
	Verbosef("DEBUG: %s WARN: %s", pv.Module, fmt.Sprintf(format, a...))
}

// Verbosef è°ƒè¯•æ ¼å¼è¾“å‡º
func Verbosef(format string, a ...interface{}) (n int, err error) {
	if IsVerbose {
		for _, Output := range Outputs {
			n1, err := fmt.Fprintf(Output, TimePrefix()+" "+format, a...)
			n += n1
			if err != nil {
				return n, err
			}
		}
	}
	return
}

// Verboseln è°ƒè¯•è¾“å‡ºä¸€è¡Œ
func Verboseln(a ...interface{}) (n int, err error) {
	if IsVerbose {
		for _, Output := range Outputs {
			n1, err := fmt.Fprint(Output, TimePrefix()+" ")
			n += n1
			if err != nil {
				return n, err
			}
			n2, err := fmt.Fprintln(Output, a...)
			n += n2
			if err != nil {
				return n, err
			}
		}
	}
	return
}



================================================
FILE: pcsverbose/utils.go
================================================
package pcsverbose

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/pcstime"
	"io"
	"io/ioutil"
)

//PrintReader è¾“å‡ºReader
func PrintReader(r io.Reader) {
	b, _ := ioutil.ReadAll(r)
	fmt.Printf("%s\n", b)
}

// PrintArgs è¾“å‡ºå­—ç¬¦ä¸²æ•°ç»„
func PrintArgs(w io.Writer, args ...string) {
	for k, arg := range args {
		io.WriteString(w, fmt.Sprintf("args[%d] = `%s`, ", k, arg))
	}
	w.Write([]byte{'\n'})
}

func TimePrefix() string {
	return "[" + pcstime.BeijingTimeOption("Refer") + "]"
}



================================================
FILE: pcsverbose/pcsdebug/cpu.go
================================================
// Package pcsdebug è°ƒè¯•åŒ…
package pcsdebug

import (
	"context"
	"fmt"
	"os"
	"runtime/pprof"
)

//StartCPUProfile æ”¶é›†cpuä¿¡æ¯
func StartCPUProfile(ctx context.Context, cpuProfile string) {
	if cpuProfile != "" {
		f, err := os.Create(cpuProfile)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Can not create cpu profile output file: %s", err)
			return
		}
		if err := pprof.StartCPUProfile(f); err != nil {
			fmt.Fprintf(os.Stderr, "Can not start cpu profile: %s", err)
			f.Close()
			return
		}
		defer pprof.StopCPUProfile()
	}
	select {
	case <-ctx.Done():
		return
	}
}



================================================
FILE: pcsverbose/pcsdebug/pprof.go
================================================
package pcsdebug

import (
	"net/http"
	_ "net/http/pprof"
)

func StartPprofListen() {
	http.ListenAndServe("0.0.0.0:6060", nil)
}



================================================
FILE: requester/dial.go
================================================
package requester

import (
	"context"
	"crypto/tls"
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires/cachemap"
	mathrand "math/rand"
	"net"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

const (
	// MaxDuration æœ€å¤§çš„Duration
	MaxDuration = 1<<63 - 1
)

var (
	localTCPAddrList = []*net.TCPAddr{}

	// ProxyAddr ä»£ç†åœ°å€
	ProxyAddr string

	// ErrProxyAddrEmpty ä»£ç†åœ°å€ä¸ºç©º
	ErrProxyAddrEmpty = errors.New("proxy addr is empty")

	tcpCache = cachemap.GlobalCacheOpMap.LazyInitCachePoolOp("requester/tcp")
)

// SetLocalTCPAddrList è®¾ç½®ç½‘å¡åœ°å€
func SetLocalTCPAddrList(ips ...string) {
	list := make([]*net.TCPAddr, 0, len(ips))
	for k := range ips {
		p := net.ParseIP(ips[k])
		if p == nil {
			continue
		}

		list = append(list, &net.TCPAddr{
			IP: p,
		})
	}
	localTCPAddrList = list
}

func proxyFunc(req *http.Request) (*url.URL, error) {
	u, err := checkProxyAddr(ProxyAddr)
	if err != nil {
		return http.ProxyFromEnvironment(req)
	}

	return u, err
}

func getLocalTCPAddr() *net.TCPAddr {
	if len(localTCPAddrList) == 0 {
		return nil
	}
	i := mathrand.Intn(len(localTCPAddrList))
	return localTCPAddrList[i]
}

func getDialer() *net.Dialer {
	return &net.Dialer{
		Timeout:   30 * time.Second,
		KeepAlive: 30 * time.Second,
		LocalAddr: getLocalTCPAddr(),
		DualStack: true,
	}
}

func checkProxyAddr(proxyAddr string) (u *url.URL, err error) {
	if proxyAddr == "" {
		return nil, ErrProxyAddrEmpty
	}

	host, port, err := net.SplitHostPort(proxyAddr)
	if err == nil {
		u = &url.URL{
			Host: net.JoinHostPort(host, port),
		}
		return
	}

	u, err = url.Parse(proxyAddr)
	if err == nil {
		return
	}

	return
}

// SetGlobalProxy è®¾ç½®ä»£ç†
func SetGlobalProxy(proxyAddr string) {
	ProxyAddr = proxyAddr
}

// SetTCPHostBind è®¾ç½®hostç»‘å®šip
func SetTCPHostBind(host, ip string) {
	tcpCache.Store(host, expires.NewDataExpires(net.ParseIP(ip), MaxDuration))
	return
}

func getServerName(address string) string {
	host, _, err := net.SplitHostPort(address)
	if err != nil {
		return address
	}
	return host
}

// resolveTCPHost
// è§£æçš„tcpaddræ²¡æœ‰port!!!
func resolveTCPHost(ctx context.Context, host string) (ip net.IP, err error) {
	addrs, err := net.DefaultResolver.LookupIPAddr(ctx, host)
	if err != nil {
		return
	}

	return addrs[0].IP, nil
}

func dialContext(ctx context.Context, network, address string) (conn net.Conn, err error) {
	switch network {
	case "tcp", "tcp4", "tcp6":
		host, portStr, err := net.SplitHostPort(address)
		if err != nil {
			return nil, err
		}
		data, err := cachemap.GlobalCacheOpMap.CacheOperationWithError("requester/tcp", host, func() (expires.DataExpires, error) {
			ip, err := resolveTCPHost(ctx, host)
			if err != nil {
				return nil, err
			}
			return expires.NewDataExpires(ip, 10*time.Minute), nil // ä¼ å€¼
		})
		if err != nil {
			return nil, err
		}

		port, err := strconv.Atoi(portStr)
		if err != nil {
			return nil, err
		}

		return net.DialTCP(network, getLocalTCPAddr(), &net.TCPAddr{
			IP:   data.Data().(net.IP),
			Port: port, // è®¾ç½®ç«¯å£
		})
	}

	// é tcp è¯·æ±‚
	conn, err = getDialer().DialContext(ctx, network, address)
	return
}

func dial(network, address string) (conn net.Conn, err error) {
	return dialContext(context.Background(), network, address)
}

func (h *HTTPClient) dialTLSFunc() func(network, address string) (tlsConn net.Conn, err error) {
	return func(network, address string) (tlsConn net.Conn, err error) {
		conn, err := dialContext(context.Background(), network, address)
		if err != nil {
			return nil, err
		}

		return tls.Client(conn, &tls.Config{
			ServerName:         getServerName(address),
			InsecureSkipVerify: !h.https,
		}), nil
	}
}



================================================
FILE: requester/fetch.go
================================================
package requester

import (
	"bytes"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// HTTPGet ç®€å•å®ç° http è®¿é—® GET è¯·æ±‚
func HTTPGet(urlStr string) (body []byte, err error) {
	resp, err := DefaultClient.Get(urlStr)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		return nil, err
	}
	return ioutil.ReadAll(resp.Body)
}

// Req å‚è§ *HTTPClient.Req, ä½¿ç”¨é»˜è®¤ http å®¢æˆ·ç«¯
func Req(method string, urlStr string, post interface{}, header map[string]string) (resp *http.Response, err error) {
	return DefaultClient.Req(method, urlStr, post, header)
}

// Fetch å‚è§ *HTTPClient.Fetch, ä½¿ç”¨é»˜è®¤ http å®¢æˆ·ç«¯
func Fetch(method string, urlStr string, post interface{}, header map[string]string) (body []byte, err error) {
	return DefaultClient.Fetch(method, urlStr, post, header)
}

// Req å®ç° httpï¼https è®¿é—®ï¼Œ
// æ ¹æ®ç»™å®šçš„ method (GET, POST, HEAD, PUT ç­‰ç­‰), urlStr (ç½‘å€),
// post (post æ•°æ®), header (header è¯·æ±‚å¤´æ•°æ®), è¿›è¡Œç½‘ç«™è®¿é—®ã€‚
// è¿”å›å€¼åˆ†åˆ«ä¸º *http.Response, é”™è¯¯ä¿¡æ¯
func (h *HTTPClient) Req(method string, urlStr string, post interface{}, header map[string]string) (resp *http.Response, err error) {
	h.lazyInit()
	var (
		req           *http.Request
		obody         io.Reader
		contentLength int64
		contentType   string
	)

	if post != nil {
		switch value := post.(type) {
		case io.Reader:
			obody = value
		case map[string]string:
			query := url.Values{}
			for k := range value {
				query.Set(k, value[k])
			}
			obody = strings.NewReader(query.Encode())
		case map[string]interface{}:
			query := url.Values{}
			for k := range value {
				query.Set(k, fmt.Sprint(value[k]))
			}
			obody = strings.NewReader(query.Encode())
		case map[interface{}]interface{}:
			query := url.Values{}
			for k := range value {
				query.Set(fmt.Sprint(k), fmt.Sprint(value[k]))
			}
			obody = strings.NewReader(query.Encode())
		case string:
			obody = strings.NewReader(value)
		case []byte:
			obody = bytes.NewReader(value[:])
		default:
			return nil, fmt.Errorf("requester.Req: unknown post type: %s", value)
		}

		switch value := post.(type) {
		case ContentLengther:
			contentLength = value.ContentLength()
		case rio.Lener:
			contentLength = int64(value.Len())
		case rio.Lener64:
			contentLength = value.Len()
		}

		switch value := post.(type) {
		case ContentTyper:
			contentType = value.ContentType()
		}
	}
	req, err = http.NewRequest(method, urlStr, obody)
	if err != nil {
		return nil, err
	}

	if req.ContentLength <= 0 && contentLength != 0 {
		req.ContentLength = contentLength
	}

	// è®¾ç½®æµè§ˆå™¨æ ‡è¯†
	req.Header.Set("User-Agent", h.UserAgent)

	// è®¾ç½®Content-Type
	if contentType != "" {
		req.Header.Set("Content-Type", contentType)
	}

	if header != nil {
		// å¤„ç†Host
		if host, ok := header["Host"]; ok {
			req.Host = host
		}

		for key := range header {
			req.Header.Set(key, header[key])
		}
	}

	return h.Client.Do(req)
}

// Fetch å®ç° httpï¼https è®¿é—®ï¼Œ
// æ ¹æ®ç»™å®šçš„ method (GET, POST, HEAD, PUT ç­‰ç­‰), urlStr (ç½‘å€),
// post (post æ•°æ®), header (header è¯·æ±‚å¤´æ•°æ®), è¿›è¡Œç½‘ç«™è®¿é—®ã€‚
// è¿”å›å€¼åˆ†åˆ«ä¸º ç½‘ç«™ä¸»ä½“, é”™è¯¯ä¿¡æ¯
func (h *HTTPClient) Fetch(method string, urlStr string, post interface{}, header map[string]string) (body []byte, err error) {
	h.lazyInit()
	resp, err := h.Req(method, urlStr, post, header)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		return nil, err
	}

	return ioutil.ReadAll(resp.Body)
}



================================================
FILE: requester/http_client.go
================================================
package requester

import (
	"crypto/tls"
	"net/http"
	"net/http/cookiejar"
	"time"
)

// HTTPClient http client
type HTTPClient struct {
	http.Client
	transport *http.Transport
	https     bool
	UserAgent string
}

// NewHTTPClient è¿”å› HTTPClient çš„æŒ‡é’ˆ,
// é¢„è®¾äº†ä¸€äº›é…ç½®
func NewHTTPClient() *HTTPClient {
	h := &HTTPClient{
		Client: http.Client{
			Timeout: 30 * time.Second,
		},
		UserAgent: UserAgent,
	}
	h.Client.Jar, _ = cookiejar.New(nil)
	return h
}

func (h *HTTPClient) lazyInit() {
	if h.transport == nil {
		h.transport = &http.Transport{
			Proxy:       proxyFunc,
			DialContext: dialContext,
			Dial:        dial,
			// DialTLS:     h.dialTLSFunc(),
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: !h.https,
			},
			TLSHandshakeTimeout:   10 * time.Second,
			DisableKeepAlives:     false,
			DisableCompression:    false, // gzip
			MaxIdleConns:          100,
			IdleConnTimeout:       90 * time.Second,
			ResponseHeaderTimeout: 10 * time.Second,
			ExpectContinueTimeout: 10 * time.Second,
		}
		h.Client.Transport = h.transport
	}
}

// SetUserAgent è®¾ç½® UserAgent æµè§ˆå™¨æ ‡è¯†
func (h *HTTPClient) SetUserAgent(ua string) {
	h.UserAgent = ua
}

// SetProxy è®¾ç½®ä»£ç†
func (h *HTTPClient) SetProxy(proxyAddr string) {
	h.lazyInit()
	u, err := checkProxyAddr(proxyAddr)
	if err != nil {
		h.transport.Proxy = http.ProxyFromEnvironment
		return
	}

	h.transport.Proxy = http.ProxyURL(u)
}

// SetCookiejar è®¾ç½® cookie
func (h *HTTPClient) SetCookiejar(jar http.CookieJar) {
	h.Client.Jar = jar
}

// ResetCookiejar æ¸…ç©º cookie
func (h *HTTPClient) ResetCookiejar() {
	h.Jar, _ = cookiejar.New(nil)
}

// SetHTTPSecure æ˜¯å¦å¯ç”¨ https å®‰å…¨æ£€æŸ¥, é»˜è®¤ä¸æ£€æŸ¥
func (h *HTTPClient) SetHTTPSecure(b bool) {
	h.https = b
	h.lazyInit()
	if b {
		h.transport.TLSClientConfig = nil
	} else {
		h.transport.TLSClientConfig = &tls.Config{
			InsecureSkipVerify: !b,
		}
	}
}

// SetKeepAlive è®¾ç½® Keep-Alive
func (h *HTTPClient) SetKeepAlive(b bool) {
	h.lazyInit()
	h.transport.DisableKeepAlives = !b
}

// SetGzip æ˜¯å¦å¯ç”¨Gzip
func (h *HTTPClient) SetGzip(b bool) {
	h.lazyInit()
	h.transport.DisableCompression = !b
}

// SetResponseHeaderTimeout è®¾ç½®ç›®æ ‡æœåŠ¡å™¨å“åº”è¶…æ—¶æ—¶é—´
func (h *HTTPClient) SetResponseHeaderTimeout(t time.Duration) {
	h.lazyInit()
	h.transport.ResponseHeaderTimeout = t
}

// SetTLSHandshakeTimeout è®¾ç½®tlsæ¡æ‰‹è¶…æ—¶æ—¶é—´
func (h *HTTPClient) SetTLSHandshakeTimeout(t time.Duration) {
	h.lazyInit()
	h.transport.TLSHandshakeTimeout = t
}

// SetTimeout è®¾ç½® http è¯·æ±‚è¶…æ—¶æ—¶é—´, é»˜è®¤30s
func (h *HTTPClient) SetTimeout(t time.Duration) {
	h.Client.Timeout = t
}



================================================
FILE: requester/requester.go
================================================
// Package requester æä¾›ç½‘ç»œè¯·æ±‚ç®€ä¾¿æ“ä½œ
package requester

const (
	// DefaultUserAgent é»˜è®¤æµè§ˆå™¨æ ‡è¯†
	DefaultUserAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"
)

var (
	// UserAgent æµè§ˆå™¨æ ‡è¯†
	UserAgent = DefaultUserAgent
	// DefaultClient é»˜è®¤ http å®¢æˆ·ç«¯
	DefaultClient = NewHTTPClient()
)

type (
	// ContentTyper Content-Type æ¥å£
	ContentTyper interface {
		ContentType() string
	}

	// ContentLengther Content-Length æ¥å£
	ContentLengther interface {
		ContentLength() int64
	}

	// Event ä¸‹è½½/ä¸Šä¼ ä»»åŠ¡è¿è¡Œæ—¶äº‹ä»¶
	Event func()

	// EventOnError ä»»åŠ¡å‡ºé”™è¿è¡Œæ—¶äº‹ä»¶
	EventOnError func(err error)
)



================================================
FILE: requester/tcpaddr_cache.go
================================================
package requester



================================================
FILE: requester/util.go
================================================
package requester

import (
	"fmt"
	"net/http"
	"strings"
)

// ParseCookieStr è§£æ Cookie å­—ç¬¦ä¸²
func ParseCookieStr(cookieStr string) []*http.Cookie {
	rawCookies := strings.SplitN(cookieStr, ";", -1)
	cookies := make([]*http.Cookie, 0, len(rawCookies))

	for _, rawCookie := range rawCookies {
		s2 := strings.SplitN(rawCookie, "=", 2)
		if len(s2) < 2 {
			fmt.Println(s2)
			continue
		}

		s2[0] = strings.TrimSpace(s2[0])
		s2[1] = strings.TrimSpace(s2[1])

		cookies = append(cookies, &http.Cookie{
			Name:  s2[0],
			Value: s2[1],
		})
	}
	return cookies
}



================================================
FILE: requester/downloader/config.go
================================================
package downloader

import (
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
)

const (
	//CacheSize é»˜è®¤çš„ä¸‹è½½ç¼“å­˜
	CacheSize = 8192
)

var (
	// MinParallelSize å•ä¸ªçº¿ç¨‹æœ€å°çš„æ•°æ®é‡
	MinParallelSize int64 = 128 * 1024 // 128kb
)

//Config ä¸‹è½½é…ç½®
type Config struct {
	Mode                       transfer.RangeGenMode      // ä¸‹è½½Rangeåˆ†é…æ¨¡å¼
	MaxParallel                int                        // æœ€å¤§ä¸‹è½½å¹¶å‘é‡
	CacheSize                  int                        // ä¸‹è½½ç¼“å†²
	BlockSize                  int64                      // æ¯ä¸ªRangeåŒºå—çš„å¤§å°, RangeGenMode ä¸º RangeGenMode2 æ—¶æ‰æœ‰æ•ˆ
	MaxRate                    int64                      // é™åˆ¶æœ€å¤§ä¸‹è½½é€Ÿåº¦
	InstanceStateStorageFormat InstanceStateStorageFormat // æ–­ç‚¹ç»­ä¼ å‚¨å­˜ç±»å‹
	InstanceStatePath          string                     // æ–­ç‚¹ç»­ä¼ ä¿¡æ¯è·¯å¾„
	IsTest                     bool                       // æ˜¯å¦æµ‹è¯•ä¸‹è½½
	TryHTTP                    bool                       // æ˜¯å¦å°è¯•ä½¿ç”¨ http è¿æ¥
}

//NewConfig è¿”å›é»˜è®¤é…ç½®
func NewConfig() *Config {
	return &Config{
		MaxParallel: 5,
		CacheSize:   CacheSize,
		IsTest:      false,
	}
}

//Fix ä¿®å¤é…ç½®ä¿¡æ¯, ä½¿å…¶åˆæ³•
func (cfg *Config) Fix() {
	fixCacheSize(&cfg.CacheSize)
	if cfg.MaxParallel < 1 {
		cfg.MaxParallel = 1
	}
}

//Copy æ‹·è´æ–°çš„é…ç½®
func (cfg *Config) Copy() *Config {
	newCfg := *cfg
	return &newCfg
}



================================================
FILE: requester/downloader/download_firstinfo.go
================================================
package downloader

import (
	"fmt"
	"net/http"
	"reflect"
)

type (
	DownloadFirstInfo struct {
		ContentLength int64
		ContentMD5    string
		ContentCRC32  string
		AcceptRanges  string
		Referer       string
	}
)

func NewDownloadFirstInfoByResp(contentLength int64, resp *http.Response) (dfi *DownloadFirstInfo) {
	dfi = &DownloadFirstInfo{}
	if resp == nil {
		dfi.ContentLength = contentLength
		return
	}
	if contentLength != resp.ContentLength {
		dfi.ContentLength = contentLength
	}
	dfi.AcceptRanges = resp.Header.Get("Accept-Ranges")
	dfi.Referer = resp.Header.Get("Referer")
	return
}

func (dfi *DownloadFirstInfo) Compare(n *DownloadFirstInfo) bool {
	if n == nil {
		return false
	}
	if dfi.ContentLength != n.ContentLength {
		return false
	}
	if dfi.AcceptRanges != n.AcceptRanges {
		return false
	}
	if dfi.Referer != n.Referer {
		return false
	}
	return true
}

// ToMap è½¬æ¢ä¸ºmap
func (dfi *DownloadFirstInfo) ToMap() map[string]string {
	m := map[string]string{
		"Content-MD5":     dfi.ContentMD5,
		"x-bs-meta-crc32": dfi.ContentCRC32,
		"Accept-Ranges":   dfi.AcceptRanges,
		"Referer":         dfi.Referer,
	}
	return m
}

// ToMapByReflect ç”¨reflectè½¬æ¢ä¸ºmap
func (dfi *DownloadFirstInfo) ToMapByReflect() map[string]string {
	te := reflect.TypeOf(dfi).Elem()
	ve := reflect.ValueOf(dfi).Elem()
	n := te.NumField()
	m := map[string]string{}
	for i := 0; i < n; i++ {
		f := te.Field(i)
		m[f.Name] = fmt.Sprint(ve.Field(i).Interface())
	}
	return m
}



================================================
FILE: requester/downloader/download_test.go
================================================
package downloader

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"os"
	"testing"
	"time"
)

var (
	url1 = "https://dldir1.qq.com/qqfile/qq/TIM2.1.8/23475/TIM2.1.8.exe"
	url2 = "https://git.oschina.net/lufenping/pixabay_img/raw/master/tiny-20170712/lizard-2427248_1920.jpg"
)

func TestRandomNumber(t *testing.T) {
	for i := 0; i < 10; i++ {
		fmt.Println(RandomNumber(0, 5))
	}
}

func TestExample(t *testing.T) {
	DoDownload(url2, "lizard-2427248_1920.jpg", nil)
}

func TestDownloadTIM(t *testing.T) {
	pcsverbose.IsVerbose = true

	file, _ := os.OpenFile("tim.exe", os.O_CREATE|os.O_WRONLY, 0777)
	d := NewDownloader(url1, file, &Config{
		MaxParallel:       10,
		CacheSize:         8192,
		InstanceStatePath: "tmp.txt",
	})

	client := requester.NewHTTPClient()
	client.SetTimeout(10 * time.Second)
	d.SetClient(client)

	go func() {
		for {
			if d.monitor != nil {
				fmt.Println(d.monitor.ShowWorkers())
			}
			time.Sleep(1e9)
		}
	}()
	go func() {
		time.Sleep(3e9)
		d.Pause()
		time.Sleep(5e9)
		d.Resume()
		time.Sleep(9e9)
		d.Pause()
		time.Sleep(5e9)
		d.Resume()
		time.Sleep(3e9)
		d.Cancel()
		fmt.Println("canceled")
		time.Sleep(3e9)
	}()
	err := d.Execute()
	if err != nil {
		fmt.Println(err)
	}
}

func newSlice() [][]byte {
	s := make([][]byte, 20)
	s[0] = []byte("kjashdfiuqwheirhwuq")
	s[9] = []byte("kjashdfiuqwheirhwuq")
	return s
}

func rangeSlice(f func(key int, by []byte) bool) {
	s := newSlice()
	for k := range s {
		if s[k] == nil {
			continue
		}
		if !f(k, s[k]) {
			break
		}
	}
}

func BenchmarkRange1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		var a = 0
		rangeSlice(func(key int, s []byte) bool {
			a++
			return true
		})
	}
}

func BenchmarkRange2(b *testing.B) {
	for i := 0; i < b.N; i++ {
		s := newSlice()
		a := 0
		for k := range s {
			if s[k] == nil {
				continue
			}
			a++
		}
	}
}



================================================
FILE: requester/downloader/downloader.go
================================================
// Package downloader å¤šçº¿ç¨‹ä¸‹è½½å™¨, é‡æ„ç‰ˆ
package downloader

import (
	"context"
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/prealloc"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/waitgroup"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio/speeds"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"io"
	"net/http"
	"sync"
	"time"
)

const (
	// DefaultAcceptRanges é»˜è®¤çš„ Accept-Ranges
	DefaultAcceptRanges = "bytes"
)

type (
	// Downloader ä¸‹è½½
	Downloader struct {
		onExecuteEvent        requester.Event    //å¼€å§‹ä¸‹è½½äº‹ä»¶
		onSuccessEvent        requester.Event    //æˆåŠŸä¸‹è½½äº‹ä»¶
		onFinishEvent         requester.Event    //ç»“æŸä¸‹è½½äº‹ä»¶
		onPauseEvent          requester.Event    //æš‚åœä¸‹è½½äº‹ä»¶
		onResumeEvent         requester.Event    //æ¢å¤ä¸‹è½½äº‹ä»¶
		onCancelEvent         requester.Event    //å–æ¶ˆä¸‹è½½äº‹ä»¶
		onDownloadStatusEvent DownloadStatusFunc //çŠ¶æ€å¤„ç†äº‹ä»¶

		monitorCancelFunc context.CancelFunc

		firstInfo               *DownloadFirstInfo      // åˆå§‹ä¿¡æ¯
		loadBalancerCompareFunc LoadBalancerCompareFunc // è´Ÿè½½å‡è¡¡æ£€æµ‹å‡½æ•°
		durlCheckFunc           DURLCheckFunc           // ä¸‹è½½urlæ£€æµ‹å‡½æ•°
		statusCodeBodyCheckFunc StatusCodeBodyCheckFunc
		executeTime             time.Time
		durl                    string
		loadBalansers           []string
		writer                  io.WriterAt
		client                  *requester.HTTPClient
		config                  *Config
		monitor                 *Monitor
		instanceState           *InstanceState
	}

	// DURLCheckFunc ä¸‹è½½URLæ£€æµ‹å‡½æ•°
	DURLCheckFunc func(client *requester.HTTPClient, durl string) (contentLength int64, resp *http.Response, err error)
	// StatusCodeBodyCheckFunc å“åº”çŠ¶æ€ç å‡ºé”™çš„æ£€æŸ¥å‡½æ•°
	StatusCodeBodyCheckFunc func(respBody io.Reader) error
)

//NewDownloader åˆå§‹åŒ–Downloader
func NewDownloader(durl string, writer io.WriterAt, config *Config) (der *Downloader) {
	der = &Downloader{
		durl:   durl,
		config: config,
		writer: writer,
	}

	return
}

// SetFirstInfo è®¾ç½®åˆå§‹ä¿¡æ¯
// å¦‚æœè®¾ç½®äº†æ­¤å€¼, å°†å¿½ç•¥æ£€æµ‹url
func (der *Downloader) SetFirstInfo(i *DownloadFirstInfo) {
	der.firstInfo = i
}

//SetClient è®¾ç½®httpå®¢æˆ·ç«¯
func (der *Downloader) SetClient(client *requester.HTTPClient) {
	der.client = client
}

// SetDURLCheckFunc è®¾ç½®ä¸‹è½½URLæ£€æµ‹å‡½æ•°
func (der *Downloader) SetDURLCheckFunc(f DURLCheckFunc) {
	der.durlCheckFunc = f
}

// SetLoadBalancerCompareFunc è®¾ç½®è´Ÿè½½å‡è¡¡æ£€æµ‹å‡½æ•°
func (der *Downloader) SetLoadBalancerCompareFunc(f LoadBalancerCompareFunc) {
	der.loadBalancerCompareFunc = f
}

//SetStatusCodeBodyCheckFunc è®¾ç½®å“åº”çŠ¶æ€ç å‡ºé”™çš„æ£€æŸ¥å‡½æ•°, å½“FirstCheckMethodä¸ä¸ºHEADæ—¶æ‰æœ‰æ•ˆ
func (der *Downloader) SetStatusCodeBodyCheckFunc(f StatusCodeBodyCheckFunc) {
	der.statusCodeBodyCheckFunc = f
}

func (der *Downloader) lazyInit() {
	if der.config == nil {
		der.config = NewConfig()
	}
	if der.client == nil {
		der.client = requester.NewHTTPClient()
		der.client.SetTimeout(20 * time.Minute)
	}
	if der.monitor == nil {
		der.monitor = NewMonitor()
	}
	if der.durlCheckFunc == nil {
		der.durlCheckFunc = DefaultDURLCheckFunc
	}
	if der.loadBalancerCompareFunc == nil {
		der.loadBalancerCompareFunc = DefaultLoadBalancerCompareFunc
	}
}

// SelectParallel è·å–åˆé€‚çš„ parallel
func (der *Downloader) SelectParallel(single bool, maxParallel int, totalSize int64, instanceRangeList transfer.RangeList) (parallel int) {
	isRange := instanceRangeList != nil && len(instanceRangeList) > 0
	if single { //ä¸æ”¯æŒå¤šçº¿ç¨‹
		parallel = 1
	} else if isRange {
		parallel = len(instanceRangeList)
	} else {
		parallel = der.config.MaxParallel
		if int64(parallel) > totalSize/int64(MinParallelSize) {
			parallel = int(totalSize/int64(MinParallelSize)) + 1
		}
	}

	if parallel < 1 {
		parallel = 1
	}
	return
}

// SelectBlockSizeAndInitRangeGen è·å–åˆé€‚çš„ BlockSize, å’Œåˆå§‹åŒ– RangeGen
func (der *Downloader) SelectBlockSizeAndInitRangeGen(single bool, status *transfer.DownloadStatus, parallel int) (blockSize int64, initErr error) {
	// Range ç”Ÿæˆå™¨
	if single { // å•çº¿ç¨‹
		blockSize = -1
		return
	}
	gen := status.RangeListGen()
	if gen == nil {
		switch der.config.Mode {
		case transfer.RangeGenMode_Default:
			gen = transfer.NewRangeListGenDefault(status.TotalSize(), 0, 0, parallel)
			blockSize = gen.LoadBlockSize()
		case transfer.RangeGenMode_BlockSize:
			b2 := status.TotalSize()/int64(parallel) + 1
			if b2 > der.config.BlockSize { // é€‰å°çš„BlockSize, ä»¥æ›´é«˜å¹¶å‘
				blockSize = der.config.BlockSize
			} else {
				blockSize = b2
			}

			gen = transfer.NewRangeListGenBlockSize(status.TotalSize(), 0, blockSize)
		default:
			initErr = transfer.ErrUnknownRangeGenMode
			return
		}
	} else {
		blockSize = gen.LoadBlockSize()
	}
	status.SetRangeListGen(gen)
	return
}

// SelectCacheSize è·å–åˆé€‚çš„ cacheSize
func (der *Downloader) SelectCacheSize(confCacheSize int, blockSize int64) (cacheSize int) {
	if blockSize > 0 && int64(confCacheSize) > blockSize {
		// å¦‚æœ cache size è¿‡é«˜, åˆ™è°ƒä½
		cacheSize = int(blockSize)
	} else {
		cacheSize = confCacheSize
	}
	return
}

// DefaultDURLCheckFunc é»˜è®¤çš„ DURLCheckFunc
func DefaultDURLCheckFunc(client *requester.HTTPClient, durl string) (contentLength int64, resp *http.Response, err error) {
	resp, err = client.Req(http.MethodGet, durl, nil, nil)
	if err != nil {
		if resp != nil {
			resp.Body.Close()
		}
		return 0, nil, err
	}
	return resp.ContentLength, resp, nil
}

func (der *Downloader) checkLoadBalancers() *LoadBalancerResponseList {
	var (
		loadBalancerResponses = make([]*LoadBalancerResponse, 0, len(der.loadBalansers)+1)
		handleLoadBalancer    = func(req *http.Request) {
			if req == nil {
				return
			}

			if der.config.TryHTTP {
				req.URL.Scheme = "http"
			}

			loadBalancer := &LoadBalancerResponse{
				URL:     req.URL.String(),
				Referer: req.Referer(),
			}

			loadBalancerResponses = append(loadBalancerResponses, loadBalancer)
			pcsverbose.Verbosef("DEBUG: load balance task: URL: %s, Referer: %s\n", loadBalancer.URL, loadBalancer.Referer)
		}
	)

	// åŠ å…¥ç¬¬ä¸€ä¸ª
	loadBalancerResponses = append(loadBalancerResponses, &LoadBalancerResponse{
		URL: der.durl,
	})

	// è´Ÿè½½å‡è¡¡
	wg := waitgroup.NewWaitGroup(10)
	privTimeout := der.client.Client.Timeout
	der.client.SetTimeout(5 * time.Second)
	for _, loadBalanser := range der.loadBalansers {
		wg.AddDelta()
		go func(loadBalanser string) {
			defer wg.Done()

			subContentLength, subResp, subErr := der.durlCheckFunc(der.client, loadBalanser)
			if subResp != nil {
				subResp.Body.Close() // ä¸è¯»Body, é©¬ä¸Šå…³é—­è¿æ¥
			}
			if subErr != nil {
				pcsverbose.Verbosef("DEBUG: loadBalanser Error: %s\n", subErr)
				return
			}

			// æ£€æµ‹çŠ¶æ€ç 
			switch subResp.StatusCode / 100 {
			case 2: // succeed
			case 4, 5: // error
				var err error
				if der.statusCodeBodyCheckFunc != nil {
					err = der.statusCodeBodyCheckFunc(subResp.Body)
				} else {
					err = errors.New(subResp.Status)
				}
				pcsverbose.Verbosef("DEBUG: loadBalanser Status Error: %s\n", err)
				return
			}

			// æ£€æµ‹é•¿åº¦
			if der.firstInfo.ContentLength != subContentLength {
				pcsverbose.Verbosef("DEBUG: loadBalanser Content-Length not equal to main server\n")
				return
			}

			if !der.loadBalancerCompareFunc(der.firstInfo.ToMap(), subResp) {
				pcsverbose.Verbosef("DEBUG: loadBalanser not equal to main server\n")
				return
			}

			handleLoadBalancer(subResp.Request)
		}(loadBalanser)
	}
	wg.Wait()
	der.client.SetTimeout(privTimeout)

	loadBalancerResponseList := NewLoadBalancerResponseList(loadBalancerResponses)
	return loadBalancerResponseList
}

//Execute å¼€å§‹ä»»åŠ¡
func (der *Downloader) Execute() error {
	der.lazyInit()

	var (
		resp *http.Response
	)
	if der.firstInfo == nil {
		// æ£€æµ‹
		contentLength, resp, err := der.durlCheckFunc(der.client, der.durl)
		if err != nil {
			return err
		}

		// æ£€æµ‹ç½‘ç»œé”™è¯¯
		switch resp.StatusCode / 100 {
		case 2: // succeed
		case 4, 5: // error
			if der.statusCodeBodyCheckFunc != nil {
				err = der.statusCodeBodyCheckFunc(resp.Body)
				resp.Body.Close() // å…³é—­è¿æ¥
				if err != nil {
					return err
				}
			}
			return errors.New(resp.Status)
		}

		acceptRanges := resp.Header.Get("Accept-Ranges")
		if contentLength < 0 {
			acceptRanges = ""
		} else {
			acceptRanges = DefaultAcceptRanges
		}

		// åˆå§‹åŒ–firstInfo
		der.firstInfo = &DownloadFirstInfo{
			ContentLength: contentLength,
			ContentMD5:    resp.Header.Get("Content-MD5"),
			ContentCRC32:  resp.Header.Get("x-bs-meta-crc32"),
			AcceptRanges:  acceptRanges,
			Referer:       resp.Header.Get("Referer"),
		}
		pcsverbose.Verbosef("DEBUG: download task: URL: %s, Referer: %s\n", resp.Request.URL, resp.Request.Referer())
	} else {
		if der.firstInfo.AcceptRanges == "" {
			der.firstInfo.AcceptRanges = DefaultAcceptRanges
		}
	}

	var (
		loadBalancerResponseList = der.checkLoadBalancers()
		single                   = der.firstInfo.AcceptRanges == ""
		bii                      *transfer.DownloadInstanceInfo
	)

	if !single {
		//load breakpoint
		//æœåŠ¡ç«¯ä¸æ”¯æŒå¤šçº¿ç¨‹æ—¶, ä¸è®°å½•æ–­ç‚¹
		err := der.initInstanceState(der.config.InstanceStateStorageFormat)
		if err != nil {
			return err
		}
		bii = der.instanceState.Get()
	}

	var (
		isInstance = bii != nil // æ˜¯å¦å­˜åœ¨æ–­ç‚¹ä¿¡æ¯
		status     *transfer.DownloadStatus
	)
	if !isInstance {
		bii = &transfer.DownloadInstanceInfo{}
	}

	if bii.DownloadStatus != nil {
		// ä½¿ç”¨æ–­ç‚¹ä¿¡æ¯çš„çŠ¶æ€
		status = bii.DownloadStatus
	} else {
		// æ–°å»ºçŠ¶æ€
		status = transfer.NewDownloadStatus()
		status.SetTotalSize(der.firstInfo.ContentLength)
	}

	// è®¾ç½®é™é€Ÿ
	if der.config.MaxRate > 0 {
		rl := speeds.NewRateLimit(der.config.MaxRate)
		status.SetRateLimit(rl)
		defer rl.Stop()
	}

	// æ•°æ®å¤„ç†
	parallel := der.SelectParallel(single, der.config.MaxParallel, status.TotalSize(), bii.Ranges) // å®é™…çš„ä¸‹è½½å¹¶è¡Œé‡
	blockSize, err := der.SelectBlockSizeAndInitRangeGen(single, status, parallel)                 // å®é™…çš„BlockSize
	if err != nil {
		return err
	}

	cacheSize := der.SelectCacheSize(der.config.CacheSize, blockSize) // å®é™…ä¸‹è½½ç¼“å­˜
	cachepool.SetSyncPoolSize(cacheSize)                              // è°ƒæ•´poolå¤§å°

	pcsverbose.Verbosef("DEBUG: download task CREATED: parallel: %d, cache size: %d\n", parallel, cacheSize)

	der.monitor.InitMonitorCapacity(parallel)

	var writer Writer
	if !der.config.IsTest {
		// å°è¯•ä¿®å‰ªæ–‡ä»¶
		if fder, ok := der.writer.(Fder); ok {
			err = prealloc.PreAlloc(fder.Fd(), status.TotalSize())
			if err != nil {
				pcsverbose.Verbosef("DEBUG: truncate file error: %s\n", err)
			}
		}
		writer = der.writer // éæµ‹è¯•æ¨¡å¼, èµ‹å€¼writer
	}

	// æ•°æ®å¹³å‡åˆ†é…ç»™å„ä¸ªçº¿ç¨‹
	isRange := bii.Ranges != nil && len(bii.Ranges) > 0
	if !isRange {
		// æ²¡æœ‰ä½¿ç”¨æ–­ç‚¹ç»­ä¼ 
		// åˆ†é…çº¿ç¨‹
		bii.Ranges = make(transfer.RangeList, 0, parallel)
		if single { // å•çº¿ç¨‹
			bii.Ranges = append(bii.Ranges, &transfer.Range{})
		} else {
			gen := status.RangeListGen()
			for i := 0; i < cap(bii.Ranges); i++ {
				_, r := gen.GenRange()
				if r == nil { // æ²¡æœ‰äº†ï¼ˆä¸æ­£å¸¸ï¼‰
					break
				}
				bii.Ranges = append(bii.Ranges, r)
			}
		}
	}

	var (
		writeMu = &sync.Mutex{}
	)
	for k, r := range bii.Ranges {
		loadBalancer := loadBalancerResponseList.SequentialGet()
		if loadBalancer == nil {
			continue
		}

		worker := NewWorker(k, loadBalancer.URL, writer)
		worker.SetClient(der.client)
		worker.SetWriteMutex(writeMu)
		worker.SetReferer(loadBalancer.Referer)
		worker.SetTotalSize(der.firstInfo.ContentLength)

		// ä½¿ç”¨ç¬¬ä¸€ä¸ªè¿æ¥
		// æ–­ç‚¹ç»­ä¼ æ—¶ä¸ä½¿ç”¨
		if k == 0 && !isInstance {
			worker.firstResp = resp
		}

		worker.SetAcceptRange(der.firstInfo.AcceptRanges)
		worker.SetRange(r) // åˆ†é…Range
		der.monitor.Append(worker)
	}

	der.monitor.SetStatus(status)

	// æœåŠ¡å™¨ä¸æ”¯æŒæ–­ç‚¹ç»­ä¼ , æˆ–è€…å•çº¿ç¨‹ä¸‹è½½, éƒ½ä¸é‡è½½worker
	der.monitor.SetReloadWorker(parallel > 1)

	moniterCtx, moniterCancelFunc := context.WithCancel(context.Background())
	der.monitorCancelFunc = moniterCancelFunc

	der.monitor.SetInstanceState(der.instanceState)

	// å¼€å§‹æ‰§è¡Œ
	der.executeTime = time.Now()
	pcsutil.Trigger(der.onExecuteEvent)
	der.downloadStatusEvent() // å¯åŠ¨æ‰§è¡ŒçŠ¶æ€å¤„ç†äº‹ä»¶
	der.monitor.Execute(moniterCtx)

	// æ£€æŸ¥é”™è¯¯
	err = der.monitor.Err()
	if err == nil { // æˆåŠŸ
		pcsutil.Trigger(der.onSuccessEvent)
		if !single {
			der.removeInstanceState() // ç§»é™¤æ–­ç‚¹ç»­ä¼ æ–‡ä»¶
		}
	}

	// æ‰§è¡Œç»“æŸ
	pcsutil.Trigger(der.onFinishEvent)
	return err
}

//downloadStatusEvent æ‰§è¡ŒçŠ¶æ€å¤„ç†äº‹ä»¶
func (der *Downloader) downloadStatusEvent() {
	if der.onDownloadStatusEvent == nil {
		return
	}

	status := der.monitor.Status()
	go func() {
		ticker := time.NewTicker(1 * time.Second)
		defer ticker.Stop()
		for {
			select {
			case <-der.monitor.completed:
				return
			case <-ticker.C:
				der.onDownloadStatusEvent(status, der.monitor.RangeWorker)
			}
		}
	}()
}

//Pause æš‚åœ
func (der *Downloader) Pause() {
	if der.monitor == nil {
		return
	}
	pcsutil.Trigger(der.onPauseEvent)
	der.monitor.Pause()
}

//Resume æ¢å¤
func (der *Downloader) Resume() {
	if der.monitor == nil {
		return
	}
	pcsutil.Trigger(der.onResumeEvent)
	der.monitor.Resume()
}

//Cancel å–æ¶ˆ
func (der *Downloader) Cancel() {
	if der.monitor == nil {
		return
	}
	pcsutil.Trigger(der.onCancelEvent)
	pcsutil.Trigger(der.monitorCancelFunc)
}

//OnExecute è®¾ç½®å¼€å§‹ä¸‹è½½äº‹ä»¶
func (der *Downloader) OnExecute(onExecuteEvent requester.Event) {
	der.onExecuteEvent = onExecuteEvent
}

//OnSuccess è®¾ç½®æˆåŠŸä¸‹è½½äº‹ä»¶
func (der *Downloader) OnSuccess(onSuccessEvent requester.Event) {
	der.onSuccessEvent = onSuccessEvent
}

//OnFinish è®¾ç½®ç»“æŸä¸‹è½½äº‹ä»¶
func (der *Downloader) OnFinish(onFinishEvent requester.Event) {
	der.onFinishEvent = onFinishEvent
}

//OnPause è®¾ç½®æš‚åœä¸‹è½½äº‹ä»¶
func (der *Downloader) OnPause(onPauseEvent requester.Event) {
	der.onPauseEvent = onPauseEvent
}

//OnResume è®¾ç½®æ¢å¤ä¸‹è½½äº‹ä»¶
func (der *Downloader) OnResume(onResumeEvent requester.Event) {
	der.onResumeEvent = onResumeEvent
}

//OnCancel è®¾ç½®å–æ¶ˆä¸‹è½½äº‹ä»¶
func (der *Downloader) OnCancel(onCancelEvent requester.Event) {
	der.onCancelEvent = onCancelEvent
}

//OnDownloadStatusEvent è®¾ç½®çŠ¶æ€å¤„ç†å‡½æ•°
func (der *Downloader) OnDownloadStatusEvent(f DownloadStatusFunc) {
	der.onDownloadStatusEvent = f
}



================================================
FILE: requester/downloader/example.go
================================================
package downloader

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"io"
	"os"
)

// DoDownload æ‰§è¡Œä¸‹è½½
func DoDownload(durl string, savePath string, cfg *Config) {
	var (
		file   *os.File
		writer io.WriterAt
		err    error
	)

	if savePath != "" {
		writer, file, err = NewDownloaderWriterByFilename(savePath, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0666)
		if err != nil {
			fmt.Println(err)
			return
		}
		defer file.Close()
	}

	download := NewDownloader(durl, writer, cfg)

	exitDownloadFunc := make(chan struct{})

	download.OnDownloadStatusEvent(func(status transfer.DownloadStatuser, workersCallback func(RangeWorkerFunc)) {
		var ts string
		if status.TotalSize() <= 0 {
			ts = converter.ConvertFileSize(status.Downloaded(), 2)
		} else {
			ts = converter.ConvertFileSize(status.TotalSize(), 2)
		}

		fmt.Printf("\r â†“ %s/%s %s/s in %s ............",
			converter.ConvertFileSize(status.Downloaded(), 2),
			ts,
			converter.ConvertFileSize(status.SpeedsPerSecond(), 2),
			status.TimeElapsed(),
		)
	})

	err = download.Execute()
	close(exitDownloadFunc)
	if err != nil {
		fmt.Printf("err: %s\n", err)
	}
}



================================================
FILE: requester/downloader/instance_state.go
================================================
package downloader

import (
	"errors"
	"github.com/golang/protobuf/proto"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"github.com/json-iterator/go"
	"os"
	"sync"
)

type (
	//InstanceState çŠ¶æ€, æ–­ç‚¹ç»­ä¼ ä¿¡æ¯
	InstanceState struct {
		saveFile *os.File
		format   InstanceStateStorageFormat
		ii       transfer.DownloadInstanceInfoExporter
		mu       sync.Mutex
	}

	// InstanceStateStorageFormat æ–­ç‚¹ç»­ä¼ å‚¨å­˜ç±»å‹
	InstanceStateStorageFormat int
)

const (
	// InstanceStateStorageFormatJSON json æ ¼å¼
	InstanceStateStorageFormatJSON = iota
	// InstanceStateStorageFormatProto3 protobuf æ ¼å¼
	InstanceStateStorageFormatProto3
)

//NewInstanceState åˆå§‹åŒ–InstanceState
func NewInstanceState(saveFile *os.File, format InstanceStateStorageFormat) *InstanceState {
	return &InstanceState{
		saveFile: saveFile,
		format:   format,
	}
}

func (is *InstanceState) checkSaveFile() bool {
	return is.saveFile != nil
}

func (is *InstanceState) getSaveFileContents() []byte {
	if !is.checkSaveFile() {
		return nil
	}

	finfo, err := is.saveFile.Stat()
	if err != nil {
		panic(err)
	}

	size := finfo.Size()
	if size > 0xffffffff {
		panic("savePath too large")
	}
	intSize := int(size)

	buf := cachepool.RawMallocByteSlice(intSize)

	n, _ := is.saveFile.ReadAt(buf, 0)
	return buf[:n]
}

//Get è·å–æ–­ç‚¹ç»­ä¼ ä¿¡æ¯
func (is *InstanceState) Get() (eii *transfer.DownloadInstanceInfo) {
	if !is.checkSaveFile() {
		return nil
	}

	is.mu.Lock()
	defer is.mu.Unlock()

	contents := is.getSaveFileContents()
	if len(contents) <= 0 {
		return
	}

	is.ii = &transfer.DownloadInstanceInfoExport{}
	var err error
	switch is.format {
	case InstanceStateStorageFormatProto3:
		err = proto.Unmarshal(contents, is.ii.(*transfer.DownloadInstanceInfoExport))
	default:
		err = jsoniter.Unmarshal(contents, is.ii)
	}

	if err != nil {
		pcsverbose.Verbosef("DEBUG: InstanceInfo unmarshal error: %s\n", err)
		return
	}

	eii = is.ii.GetInstanceInfo()
	return
}

//Put æäº¤æ–­ç‚¹ç»­ä¼ ä¿¡æ¯
func (is *InstanceState) Put(eii *transfer.DownloadInstanceInfo) {
	if !is.checkSaveFile() {
		return
	}

	is.mu.Lock()
	defer is.mu.Unlock()

	if is.ii == nil {
		is.ii = &transfer.DownloadInstanceInfoExport{}
	}
	is.ii.SetInstanceInfo(eii)
	var (
		data []byte
		err  error
	)
	switch is.format {
	case InstanceStateStorageFormatProto3:
		data, err = proto.Marshal(is.ii.(*transfer.DownloadInstanceInfoExport))
	default:
		data, err = jsoniter.Marshal(is.ii)
	}
	if err != nil {
		panic(err)
	}

	err = is.saveFile.Truncate(int64(len(data)))
	if err != nil {
		pcsverbose.Verbosef("DEBUG: truncate file error: %s\n", err)
	}

	_, err = is.saveFile.WriteAt(data, 0)
	if err != nil {
		pcsverbose.Verbosef("DEBUG: write instance state error: %s\n", err)
	}
}

//Close å…³é—­
func (is *InstanceState) Close() error {
	if !is.checkSaveFile() {
		return nil
	}

	return is.saveFile.Close()
}

func (der *Downloader) initInstanceState(format InstanceStateStorageFormat) (err error) {
	if der.instanceState != nil {
		return errors.New("already initInstanceState")
	}

	var saveFile *os.File
	if !der.config.IsTest && der.config.InstanceStatePath != "" {
		saveFile, err = os.OpenFile(der.config.InstanceStatePath, os.O_RDWR|os.O_CREATE, 0777)
		if err != nil {
			return err
		}
	}

	der.instanceState = NewInstanceState(saveFile, format)
	return nil
}

func (der *Downloader) removeInstanceState() error {
	der.instanceState.Close()
	if !der.config.IsTest && der.config.InstanceStatePath != "" {
		return os.Remove(der.config.InstanceStatePath)
	}
	return nil
}



================================================
FILE: requester/downloader/loadbalance.go
================================================
package downloader

import (
	"net/http"
	"sync/atomic"
)

type (
	// LoadBalancerResponse è´Ÿè½½å‡è¡¡å“åº”çŠ¶æ€
	LoadBalancerResponse struct {
		URL     string
		Referer string
	}

	// LoadBalancerResponseList è´Ÿè½½å‡è¡¡åˆ—è¡¨
	LoadBalancerResponseList struct {
		lbr    []*LoadBalancerResponse
		cursor int32
	}

	LoadBalancerCompareFunc func(info map[string]string, subResp *http.Response) bool
)

// NewLoadBalancerResponseList åˆå§‹åŒ–è´Ÿè½½å‡è¡¡åˆ—è¡¨
func NewLoadBalancerResponseList(lbr []*LoadBalancerResponse) *LoadBalancerResponseList {
	return &LoadBalancerResponseList{
		lbr: lbr,
	}
}

// SequentialGet é¡ºåºè·å–
func (lbrl *LoadBalancerResponseList) SequentialGet() *LoadBalancerResponse {
	if len(lbrl.lbr) == 0 {
		return nil
	}

	if int(lbrl.cursor) >= len(lbrl.lbr) {
		lbrl.cursor = 0
	}

	lbr := lbrl.lbr[int(lbrl.cursor)]
	atomic.AddInt32(&lbrl.cursor, 1)
	return lbr
}

// RandomGet éšæœºè·å–
func (lbrl *LoadBalancerResponseList) RandomGet() *LoadBalancerResponse {
	return lbrl.lbr[RandomNumber(0, len(lbrl.lbr))]
}

// AddLoadBalanceServer å¢åŠ è´Ÿè½½å‡è¡¡æœåŠ¡å™¨
func (der *Downloader) AddLoadBalanceServer(urls ...string) {
	der.loadBalansers = append(der.loadBalansers, urls...)
}

// DefaultLoadBalancerCompareFunc æ£€æµ‹è´Ÿè½½å‡è¡¡çš„æœåŠ¡å™¨æ˜¯å¦ä¸€è‡´
func DefaultLoadBalancerCompareFunc(info map[string]string, subResp *http.Response) bool {
	if info == nil || subResp == nil {
		return false
	}

	for headerKey, value := range info {
		if value != subResp.Header.Get(headerKey) {
			return false
		}
	}

	return true
}



================================================
FILE: requester/downloader/monitor.go
================================================
package downloader

import (
	"context"
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"sort"
	"time"
)

var (
	//ErrNoWokers no workers
	ErrNoWokers = errors.New("no workers")
)

type (
	//Monitor çº¿ç¨‹ç›‘æ§å™¨
	Monitor struct {
		workers         WorkerList
		status          *transfer.DownloadStatus
		instanceState   *InstanceState
		completed       chan struct{}
		err             error
		resetController *ResetController
		isReloadWorker  bool //æ˜¯å¦é‡è½½worker, å•çº¿ç¨‹æ¨¡å¼ä¸é‡è½½

		// ä¸´æ—¶å˜é‡
		lastAvaliableIndex int
	}

	// RangeWorkerFunc éå†workersçš„å‡½æ•°
	RangeWorkerFunc func(key int, worker *Worker) bool
)

//NewMonitor åˆå§‹åŒ–Monitor
func NewMonitor() *Monitor {
	monitor := &Monitor{}
	return monitor
}

func (mt *Monitor) lazyInit() {
	if mt.workers == nil {
		mt.workers = make(WorkerList, 0, 100)
	}
	if mt.status == nil {
		mt.status = transfer.NewDownloadStatus()
	}
	if mt.resetController == nil {
		mt.resetController = NewResetController(80)
	}
}

//InitMonitorCapacity åˆå§‹åŒ–workers, ç”¨äºAppend
func (mt *Monitor) InitMonitorCapacity(capacity int) {
	mt.workers = make(WorkerList, 0, capacity)
}

//Append å¢åŠ Worker
func (mt *Monitor) Append(worker *Worker) {
	if worker == nil {
		return
	}
	mt.workers = append(mt.workers, worker)
}

//SetWorkers è®¾ç½®workers, æ­¤æ“ä½œä¼šè¦†ç›–åŸæœ‰çš„workers
func (mt *Monitor) SetWorkers(workers WorkerList) {
	mt.workers = workers
}

//SetStatus è®¾ç½®DownloadStatus
func (mt *Monitor) SetStatus(status *transfer.DownloadStatus) {
	mt.status = status
}

//SetInstanceState è®¾ç½®çŠ¶æ€
func (mt *Monitor) SetInstanceState(instanceState *InstanceState) {
	mt.instanceState = instanceState
}

//Status è¿”å›DownloadStatus
func (mt *Monitor) Status() *transfer.DownloadStatus {
	return mt.status
}

//Err è¿”å›é‡åˆ°çš„é”™è¯¯
func (mt *Monitor) Err() error {
	return mt.err
}

//CompletedChan è·å–completed chan
func (mt *Monitor) CompletedChan() <-chan struct{} {
	return mt.completed
}

//GetAvailableWorker è·å–ç©ºé—²çš„worker
func (mt *Monitor) GetAvailableWorker() *Worker {
	workerCount := len(mt.workers)
	for i := mt.lastAvaliableIndex; i < mt.lastAvaliableIndex+workerCount; i++ {
		index := i % workerCount
		worker := mt.workers[index]
		if worker.Completed() {
			mt.lastAvaliableIndex = index
			return worker
		}
	}
	return nil
}

//GetAllWorkersRange è·å–æ‰€æœ‰workerçš„èŒƒå›´
func (mt *Monitor) GetAllWorkersRange() transfer.RangeList {
	allWorkerRanges := make(transfer.RangeList, 0, len(mt.workers))
	for _, worker := range mt.workers {
		allWorkerRanges = append(allWorkerRanges, worker.GetRange())
	}
	return allWorkerRanges
}

//NumLeftWorkers å‰©ä½™çš„workeræ•°é‡
func (mt *Monitor) NumLeftWorkers() (num int) {
	for _, worker := range mt.workers {
		if !worker.Completed() {
			num++
		}
	}
	return
}

//SetReloadWorker æ˜¯å¦é‡è½½worker
func (mt *Monitor) SetReloadWorker(b bool) {
	mt.isReloadWorker = b
}

//IsLeftWorkersAllFailed å‰©ä¸‹çš„çº¿ç¨‹æ˜¯å¦å…¨éƒ¨å¤±è´¥
func (mt *Monitor) IsLeftWorkersAllFailed() bool {
	failedNum := 0
	for _, worker := range mt.workers {
		if worker.Completed() {
			continue
		}

		if !worker.Failed() {
			failedNum++
			return false
		}
	}
	return failedNum != 0
}

//registerAllCompleted å…¨éƒ¨å®Œæˆåˆ™å‘é€æ¶ˆæ¯
func (mt *Monitor) registerAllCompleted() {
	mt.completed = make(chan struct{}, 0)
	var (
		workerNum   = len(mt.workers)
		completeNum = 0
	)

	go func() {
		for {
			time.Sleep(1 * time.Second)

			completeNum = 0
			for _, worker := range mt.workers {
				switch worker.GetStatus().StatusCode() {
				case StatusCodeInternalError:
					// æ£€æµ‹åˆ°å†…éƒ¨é”™è¯¯
					// é©¬ä¸Šåœæ­¢æ‰§è¡Œ
					mt.err = worker.Err()
					close(mt.completed)
					return
				case StatusCodeSuccessed, StatusCodeCanceled:
					completeNum++
				}
			}
			// status åœ¨ lazyInit ä¹‹å, ä¸å¯èƒ½ä¸ºç©º
			// å®Œæˆæ¡ä»¶: æ‰€æœ‰worker éƒ½å·²ç»å®Œæˆ, ä¸” rangeGen å·²ç”Ÿæˆå®Œæ¯•
			gen := mt.status.RangeListGen()
			if completeNum >= workerNum && (gen == nil || gen.IsDone()) { // å·²å®Œæˆ
				close(mt.completed)
				return
			}
		}
	}()
}

//ResetFailedAndNetErrorWorkers é‡è®¾éƒ¨åˆ†ç½‘ç»œé”™è¯¯çš„worker
func (mt *Monitor) ResetFailedAndNetErrorWorkers() {
	for k := range mt.workers {
		if !mt.resetController.CanReset() {
			continue
		}

		switch mt.workers[k].GetStatus().StatusCode() {
		case StatusCodeNetError:
			pcsverbose.Verbosef("DEBUG: monitor: ResetFailedAndNetErrorWorkers: reset StatusCodeNetError worker, id: %d\n", mt.workers[k].id)
			goto reset
		case StatusCodeFailed:
			pcsverbose.Verbosef("DEBUG: monitor: ResetFailedAndNetErrorWorkers: reset StatusCodeFailed worker, id: %d\n", mt.workers[k].id)
			goto reset
		default:
			continue
		}

	reset:
		mt.workers[k].Reset()
		mt.resetController.AddResetNum()
	}
}

//RangeWorker éå†worker
func (mt *Monitor) RangeWorker(f RangeWorkerFunc) {
	for k := range mt.workers {
		if !f(k, mt.workers[k]) {
			break
		}
	}
}

//Pause æš‚åœæ‰€æœ‰çš„ä¸‹è½½
func (mt *Monitor) Pause() {
	for k := range mt.workers {
		mt.workers[k].Pause()
	}
}

//Resume æ¢å¤æ‰€æœ‰çš„ä¸‹è½½
func (mt *Monitor) Resume() {
	for k := range mt.workers {
		mt.workers[k].Resume()
	}
}

// TryAddNewWork å°è¯•åŠ å…¥æ–°range
func (mt *Monitor) TryAddNewWork() {
	if mt.status == nil {
		return
	}
	gen := mt.status.RangeListGen()
	if gen == nil || gen.IsDone() {
		return
	}

	if !mt.resetController.CanReset() { //èƒ½å¦å»ºç«‹æ–°è¿æ¥
		return
	}

	availableWorker := mt.GetAvailableWorker()
	if availableWorker == nil {
		return
	}

	// æœ‰ç©ºé—²çš„range, æ‰§è¡Œ
	_, r := gen.GenRange()
	if r == nil {
		// æ²¡æœ‰rangeäº†
		return
	}

	availableWorker.SetRange(r)
	availableWorker.ClearStatus()

	mt.resetController.AddResetNum()
	pcsverbose.Verbosef("MONITER: worker[%d] add new range: %s\n", availableWorker.ID(), r.ShowDetails())
	go availableWorker.Execute()
}

// DynamicSplitWorker åŠ¨æ€åˆ†é…çº¿ç¨‹
func (mt *Monitor) DynamicSplitWorker(worker *Worker) {
	if !mt.resetController.CanReset() {
		return
	}

	switch worker.status.statusCode {
	case StatusCodeDownloading, StatusCodeFailed, StatusCodeNetError:
	//pass
	default:
		return
	}

	// ç­›é€‰ç©ºé—²çš„Worker
	availableWorker := mt.GetAvailableWorker()
	if availableWorker == nil || worker == availableWorker { // æ²¡æœ‰ç©ºçš„
		return
	}

	workerRange := worker.GetRange()

	end := workerRange.LoadEnd()
	middle := (workerRange.LoadBegin() + end) / 2

	if end-middle < MinParallelSize/5 { // å¦‚æœçº¿ç¨‹å‰©ä½™çš„ä¸‹è½½é‡å¤ªå°‘, ä¸åˆ†é…ç©ºé—²çº¿ç¨‹
		return
	}

	// æŠ˜åŠ
	availableWorkerRange := availableWorker.GetRange()
	availableWorkerRange.StoreBegin(middle) // middleä¸èƒ½åŠ 1
	availableWorkerRange.StoreEnd(end)
	availableWorker.ClearStatus()

	workerRange.StoreEnd(middle)

	mt.resetController.AddResetNum()
	pcsverbose.Verbosef("MONITOR: worker duplicated: %d <- %d\n", availableWorker.ID(), worker.ID())
	go availableWorker.Execute()
}

// ResetWorker é‡è®¾é•¿æ—¶é—´æ— å“åº”, å’Œä¸‹è½½é€Ÿåº¦ä¸º 0 çš„ Worker
func (mt *Monitor) ResetWorker(worker *Worker) {
	if !mt.resetController.CanReset() { //è¾¾åˆ°æœ€å¤§é‡è½½æ¬¡æ•°
		return
	}

	if worker.Completed() {
		return
	}

	// å¿½ç•¥æ­£åœ¨å†™å…¥æ•°æ®åˆ°ç¡¬ç›˜çš„
	// è¿‡æ»¤é€Ÿåº¦æœ‰å˜åŒ–çš„çº¿ç¨‹
	status := worker.GetStatus()
	speeds := worker.GetSpeedsPerSecond()
	if speeds != 0 {
		return
	}

	switch status.StatusCode() {
	case StatusCodePending, StatusCodeReseted:
		fallthrough
	case StatusCodeWaitToWrite: // æ­£åœ¨å†™å…¥æ•°æ®
		fallthrough
	case StatusCodePaused: // å·²æš‚åœ
		// å¿½ç•¥, è¿”å›
		return
	}

	mt.resetController.AddResetNum()

	// é‡è®¾è¿æ¥
	pcsverbose.Verbosef("MONITOR: worker[%d] reload\n", worker.ID())
	worker.Reset()
}

//Execute æ‰§è¡Œä»»åŠ¡
func (mt *Monitor) Execute(cancelCtx context.Context) {
	if len(mt.workers) == 0 {
		mt.err = ErrNoWokers
		return
	}

	mt.lazyInit()
	for _, worker := range mt.workers {
		worker.SetDownloadStatus(mt.status)
		go worker.Execute()
	}

	mt.registerAllCompleted() // æ³¨å†Œcompleted
	ticker := time.NewTicker(990 * time.Millisecond)
	defer ticker.Stop()

	//å¼€å§‹ç›‘æ§
	for {
		select {
		case <-cancelCtx.Done():
			for _, worker := range mt.workers {
				err := worker.Cancel()
				if err != nil {
					pcsverbose.Verbosef("DEBUG: cancel failed, worker id: %d, err: %s\n", worker.ID(), err)
				}
			}
			return
		case <-mt.completed:
			return
		case <-ticker.C:
			// åˆå§‹åŒ–ç›‘æ§å·¥ä½œ
			mt.ResetFailedAndNetErrorWorkers()

			mt.status.UpdateSpeeds() // æ›´æ–°é€Ÿåº¦

			// ä¿å­˜æ–­ç‚¹ä¿¡æ¯åˆ°æ–‡ä»¶
			if mt.instanceState != nil {
				mt.instanceState.Put(&transfer.DownloadInstanceInfo{
					DownloadStatus: mt.status,
					Ranges:         mt.GetAllWorkersRange(),
				})
			}

			// åŠ å…¥æ–°range
			mt.TryAddNewWork()

			// ä¸é‡è½½worker
			if !mt.isReloadWorker {
				continue
			}

			// æ›´æ–°maxSpeeds
			mt.status.SetMaxSpeeds(mt.status.SpeedsPerSecond())

			// é€Ÿåº¦å‡æ…¢æˆ–è€…å…¨éƒ¨å¤±è´¥, å¼€å§‹ç›‘æ§
			// åªæœ‰ä¸€ä¸ªworkeræ—¶ä¸é‡è®¾è¿æ¥
			isLeftWorkersAllFailed := mt.IsLeftWorkersAllFailed()
			if mt.status.SpeedsPerSecond() < mt.status.MaxSpeeds()/6 || isLeftWorkersAllFailed {
				if isLeftWorkersAllFailed {
					pcsverbose.Verbosef("DEBUG: monitor: All workers failed\n")
				}
				mt.status.ClearMaxSpeeds() //æ¸…ç©ºæœ€å¤§é€Ÿåº¦çš„ç»Ÿè®¡

				// å…ˆè¿›è¡ŒåŠ¨æ€åˆ†é…çº¿ç¨‹
				pcsverbose.Verbosef("DEBUG: monitor: start duplicate.\n")
				sort.Sort(ByLeftDesc{mt.workers})
				for _, worker := range mt.workers {
					//åŠ¨æ€åˆ†é…çº¿ç¨‹
					mt.DynamicSplitWorker(worker)
				}

				// é‡è®¾é•¿æ—¶é—´æ— å“åº”, å’Œä¸‹è½½é€Ÿåº¦ä¸º 0 çš„çº¿ç¨‹
				pcsverbose.Verbosef("DEBUG: monitor: start reload.\n")
				for _, worker := range mt.workers {
					mt.ResetWorker(worker)
				}
			} // end if 2
		} //end select
	} //end for
}



================================================
FILE: requester/downloader/range_test.go
================================================
package downloader_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/requester/downloader"
	"testing"
)

func TestRangeListGen(t *testing.T) {
	gen1 := downloader.NewRangeListGenDefault(1024, 0, 0, 10)
	gen2 := downloader.NewRangeListGenBlockSize(1024, 0, 53)

	for mode, gen := range []*downloader.RangeListGen{gen1, gen2} {
		fmt.Printf("[%d] ----\n", mode+1)
		for i, r := gen.GenRange(); r != nil; i, r = gen.GenRange() {
			fmt.Printf("%d: %s\n", i, r.ShowDetails())
		}
		fmt.Println()
	}
}



================================================
FILE: requester/downloader/resetcontroler.go
================================================
package downloader

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"sync"
	"time"
)

// ResetController ç½‘ç»œè¿æ¥æ§åˆ¶å™¨
type ResetController struct {
	mu          sync.Mutex
	currentTime time.Time
	maxResetNum int
	resetEntity map[expires.Expires]struct{}
}

// NewResetController åˆå§‹åŒ–*ResetController
func NewResetController(maxResetNum int) *ResetController {
	return &ResetController{
		currentTime: time.Now(),
		maxResetNum: maxResetNum,
		resetEntity: map[expires.Expires]struct{}{},
	}
}

func (rc *ResetController) update() {
	for k := range rc.resetEntity {
		if k.IsExpires() {
			delete(rc.resetEntity, k)
		}
	}
}

// AddResetNum å¢åŠ è¿æ¥
func (rc *ResetController) AddResetNum() {
	rc.mu.Lock()
	defer rc.mu.Unlock()
	rc.update()
	rc.resetEntity[expires.NewExpires(9*time.Second)] = struct{}{}
}

// CanReset æ˜¯å¦å¯ä»¥å»ºç«‹è¿æ¥
func (rc *ResetController) CanReset() bool {
	rc.mu.Lock()
	defer rc.mu.Unlock()
	rc.update()
	return len(rc.resetEntity) < rc.maxResetNum
}



================================================
FILE: requester/downloader/sort.go
================================================
package downloader

type (
	// ByLeftDesc æ ¹æ®å‰©ä½™ä¸‹è½½é‡å€’åºæ’åº
	ByLeftDesc struct {
		WorkerList
	}
)

// Len è¿”å›é•¿åº¦
func (wl WorkerList) Len() int {
	return len(wl)
}

// Swap äº¤æ¢
func (wl WorkerList) Swap(i, j int) {
	wl[i], wl[j] = wl[j], wl[i]
}

// Less å®ç°å€’åº
func (wl ByLeftDesc) Less(i, j int) bool {
	return wl.WorkerList[i].wrange.Len() > wl.WorkerList[j].wrange.Len()
}



================================================
FILE: requester/downloader/status.go
================================================
package downloader

import (
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
)

type (
	//WorkerStatuser çŠ¶æ€
	WorkerStatuser interface {
		StatusCode() StatusCode //çŠ¶æ€ç 
		StatusText() string
	}

	//StatusCode çŠ¶æ€ç 
	StatusCode int

	//WorkerStatus workerçŠ¶æ€
	WorkerStatus struct {
		statusCode StatusCode
	}

	// DownloadStatusFunc ä¸‹è½½çŠ¶æ€å¤„ç†å‡½æ•°
	DownloadStatusFunc func(status transfer.DownloadStatuser, workersCallback func(RangeWorkerFunc))
)

const (
	//StatusCodeInit åˆå§‹åŒ–
	StatusCodeInit StatusCode = iota
	//StatusCodeSuccessed æˆåŠŸ
	StatusCodeSuccessed
	//StatusCodePending ç­‰å¾…å“åº”
	StatusCodePending
	//StatusCodeDownloading ä¸‹è½½ä¸­
	StatusCodeDownloading
	//StatusCodeWaitToWrite ç­‰å¾…å†™å…¥æ•°æ®
	StatusCodeWaitToWrite
	//StatusCodeInternalError å†…éƒ¨é”™è¯¯
	StatusCodeInternalError
	//StatusCodeTooManyConnections è¿æ¥æ•°å¤ªå¤š
	StatusCodeTooManyConnections
	//StatusCodeNetError ç½‘ç»œé”™è¯¯
	StatusCodeNetError
	//StatusCodeFailed ä¸‹è½½å¤±è´¥
	StatusCodeFailed
	//StatusCodePaused å·²æš‚åœ
	StatusCodePaused
	//StatusCodeReseted å·²é‡è®¾è¿æ¥
	StatusCodeReseted
	//StatusCodeCanceled å·²å–æ¶ˆ
	StatusCodeCanceled
)

//GetStatusText æ ¹æ®çŠ¶æ€ç è·å–çŠ¶æ€ä¿¡æ¯
func GetStatusText(sc StatusCode) string {
	switch sc {
	case StatusCodeInit:
		return "åˆå§‹åŒ–"
	case StatusCodeSuccessed:
		return "æˆåŠŸ"
	case StatusCodePending:
		return "ç­‰å¾…å“åº”"
	case StatusCodeDownloading:
		return "ä¸‹è½½ä¸­"
	case StatusCodeWaitToWrite:
		return "ç­‰å¾…å†™å…¥æ•°æ®"
	case StatusCodeInternalError:
		return "å†…éƒ¨é”™è¯¯"
	case StatusCodeTooManyConnections:
		return "è¿æ¥æ•°å¤ªå¤š"
	case StatusCodeNetError:
		return "ç½‘ç»œé”™è¯¯"
	case StatusCodeFailed:
		return "ä¸‹è½½å¤±è´¥"
	case StatusCodePaused:
		return "å·²æš‚åœ"
	case StatusCodeReseted:
		return "å·²é‡è®¾è¿æ¥"
	case StatusCodeCanceled:
		return "å·²å–æ¶ˆ"
	default:
		return "æœªçŸ¥çŠ¶æ€ç "
	}
}

//NewWorkerStatus åˆå§‹åŒ–WorkerStatus
func NewWorkerStatus() *WorkerStatus {
	return &WorkerStatus{
		statusCode: StatusCodeInit,
	}
}

//SetStatusCode è®¾ç½®workerçŠ¶æ€ç 
func (ws *WorkerStatus) SetStatusCode(sc StatusCode) {
	ws.statusCode = sc
}

//StatusCode è¿”å›çŠ¶æ€ç 
func (ws *WorkerStatus) StatusCode() StatusCode {
	return ws.statusCode
}

//StatusText è¿”å›çŠ¶æ€ä¿¡æ¯
func (ws *WorkerStatus) StatusText() string {
	return GetStatusText(ws.statusCode)
}



================================================
FILE: requester/downloader/utils.go
================================================
package downloader

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	mathrand "math/rand"
	"mime"
	"net/url"
	"path"
	"regexp"
	"strconv"
	"time"
)

var (
	// ContentRangeRE Content-Range æ­£åˆ™
	ContentRangeRE = regexp.MustCompile(`^.*? \d*?-\d*?/(\d*?)$`)

	// ranSource éšæœºæ•°ç§å­
	ranSource = mathrand.NewSource(time.Now().UnixNano())

	// ran ä¸€ä¸ªéšæœºæ•°å®ä¾‹
	ran = mathrand.New(ranSource)
)

// RandomNumber ç”ŸæˆæŒ‡å®šåŒºé—´éšæœºæ•°
func RandomNumber(min, max int) int {
	if min > max {
		min, max = max, min
	}
	return ran.Intn(max-min) + min
}

// GetFileName è·å–æ–‡ä»¶å
func GetFileName(uri string, client *requester.HTTPClient) (filename string, err error) {
	if client == nil {
		client = requester.NewHTTPClient()
	}

	resp, err := client.Req("HEAD", uri, nil, nil)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		return "", err
	}

	_, params, err := mime.ParseMediaType(resp.Header.Get("Content-Disposition"))
	if err != nil {
		pcsverbose.Verbosef("DEBUG: GetFileName ParseMediaType error: %s\n", err)
		return path.Base(uri), nil
	}

	filename, err = url.QueryUnescape(params["filename"])
	if err != nil {
		return
	}

	if filename == "" {
		filename = path.Base(uri)
	}

	return
}

// ParseContentRange è§£æContent-Range
func ParseContentRange(contentRange string) (contentLength int64) {
	raw := ContentRangeRE.FindStringSubmatch(contentRange)
	if len(raw) < 2 {
		return -1
	}

	c, err := strconv.ParseInt(raw[1], 10, 64)
	if err != nil {
		return -1
	}
	return c
}

func fixCacheSize(size *int) {
	if *size < 1024 {
		*size = 1024
	}
}



================================================
FILE: requester/downloader/worker.go
================================================
package downloader

import (
	"context"
	"errors"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio/speeds"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"io"
	"net/http"
	"sync"
)

type (
	//Worker å·¥ä½œå•å…ƒ
	Worker struct {
		totalSize    int64 // æ•´ä¸ªæ–‡ä»¶çš„å¤§å°, workerè¯·æ±‚rangeæ—¶ä¼šè·å–å°è¯•è·å–è¯¥å€¼, å¦‚æœä¸åŒ¹é…, åˆ™è¿”å›é”™è¯¯
		wrange       *transfer.Range
		speedsStat   *speeds.Speeds
		id           int    //id
		url          string //ä¸‹è½½åœ°å€
		referer      string //æ¥æºåœ°å€
		acceptRanges string
		client       *requester.HTTPClient
		firstResp    *http.Response // ç¬¬ä¸€ä¸ªå“åº”
		writerAt     io.WriterAt
		writeMu      *sync.Mutex
		execMu       sync.Mutex

		pauseChan              chan struct{}
		workerCancelFunc       context.CancelFunc
		resetFunc              context.CancelFunc
		readRespBodyCancelFunc func()
		err                    error //é”™è¯¯ä¿¡æ¯
		status                 WorkerStatus
		downloadStatus         *transfer.DownloadStatus //æ€»çš„ä¸‹è½½çŠ¶æ€
	}

	// WorkerList workeråˆ—è¡¨
	WorkerList []*Worker
)

// Duplicate æ„é€ æ–°çš„åˆ—è¡¨
func (wl WorkerList) Duplicate() WorkerList {
	n := make(WorkerList, len(wl))
	copy(n, wl)
	return n
}

//NewWorker åˆå§‹åŒ–Worker
func NewWorker(id int, durl string, writerAt io.WriterAt) *Worker {
	return &Worker{
		id:       id,
		url:      durl,
		writerAt: writerAt,
	}
}

//ID è¿”å›worker ID
func (wer *Worker) ID() int {
	return wer.id
}

func (wer *Worker) lazyInit() {
	if wer.client == nil {
		wer.client = requester.NewHTTPClient()
	}
	if wer.pauseChan == nil {
		wer.pauseChan = make(chan struct{})
	}
	if wer.wrange == nil {
		wer.wrange = &transfer.Range{}
	}
	if wer.wrange.LoadBegin() == 0 && wer.wrange.LoadEnd() == 0 {
		// å–æ¶ˆå¤šçº¿ç¨‹ä¸‹è½½
		wer.acceptRanges = ""
		wer.wrange.StoreEnd(-2)
	}
	if wer.speedsStat == nil {
		wer.speedsStat = &speeds.Speeds{}
	}
}

// SetTotalSize è®¾ç½®æ•´ä¸ªæ–‡ä»¶çš„å¤§å°, workerè¯·æ±‚rangeæ—¶ä¼šè·å–å°è¯•è·å–è¯¥å€¼, å¦‚æœä¸åŒ¹é…, åˆ™è¿”å›é”™è¯¯
func (wer *Worker) SetTotalSize(size int64) {
	wer.totalSize = size
}

//SetClient è®¾ç½®httpå®¢æˆ·ç«¯
func (wer *Worker) SetClient(c *requester.HTTPClient) {
	wer.client = c
}

//SetAcceptRange è®¾ç½®AcceptRange
func (wer *Worker) SetAcceptRange(acceptRanges string) {
	wer.acceptRanges = acceptRanges
}

//SetRange è®¾ç½®è¯·æ±‚èŒƒå›´
func (wer *Worker) SetRange(r *transfer.Range) {
	if wer.wrange == nil {
		wer.wrange = r
		return
	}
	wer.wrange.StoreBegin(r.LoadBegin())
	wer.wrange.StoreEnd(r.LoadEnd())
}

//SetReferer è®¾ç½®æ¥æº
func (wer *Worker) SetReferer(referer string) {
	wer.referer = referer
}

//SetWriteMutex è®¾ç½®æ•°æ®å†™é”
func (wer *Worker) SetWriteMutex(mu *sync.Mutex) {
	wer.writeMu = mu
}

//SetDownloadStatus å¢åŠ å…¶ä»–éœ€è¦ç»Ÿè®¡çš„æ•°æ®
func (wer *Worker) SetDownloadStatus(downloadStatus *transfer.DownloadStatus) {
	wer.downloadStatus = downloadStatus
}

//GetStatus è¿”å›ä¸‹è½½çŠ¶æ€
func (wer *Worker) GetStatus() WorkerStatuser {
	// ç©ºæ¥å£ä¸ç©ºæŒ‡é’ˆä¸ç­‰ä»·
	return &wer.status
}

//GetRange è¿”å›workerèŒƒå›´
func (wer *Worker) GetRange() *transfer.Range {
	return wer.wrange
}

//GetSpeedsPerSecond è·å–æ¯ç§’çš„é€Ÿåº¦
func (wer *Worker) GetSpeedsPerSecond() int64 {
	return wer.speedsStat.GetSpeeds()
}

//Pause æš‚åœä¸‹è½½
func (wer *Worker) Pause() {
	wer.lazyInit()
	if wer.acceptRanges == "" {
		pcsverbose.Verbosef("WARNING: worker unsupport pause")
		return
	}

	if wer.status.statusCode == StatusCodePaused {
		return
	}
	wer.pauseChan <- struct{}{}
	wer.status.statusCode = StatusCodePaused
}

//Resume æ¢å¤ä¸‹è½½
func (wer *Worker) Resume() {
	if wer.status.statusCode != StatusCodePaused {
		return
	}
	go wer.Execute()
}

//Cancel å–æ¶ˆä¸‹è½½
func (wer *Worker) Cancel() error {
	if wer.workerCancelFunc == nil {
		return errors.New("cancelFunc not set")
	}
	wer.workerCancelFunc()
	if wer.readRespBodyCancelFunc != nil {
		wer.readRespBodyCancelFunc()
	}
	return nil
}

//Reset é‡è®¾è¿æ¥
func (wer *Worker) Reset() {
	if wer.resetFunc == nil {
		pcsverbose.Verbosef("DEBUG: worker: resetFunc not set")
		return
	}
	wer.resetFunc()
	if wer.readRespBodyCancelFunc != nil {
		wer.readRespBodyCancelFunc()
	}
	wer.ClearStatus()
	go wer.Execute()
}

// Canceled æ˜¯å¦å·²ç»å–æ¶ˆ
func (wer *Worker) Canceled() bool {
	return wer.status.statusCode == StatusCodeCanceled
}

//Completed æ˜¯å¦å·²ç»å®Œæˆ
func (wer *Worker) Completed() bool {
	switch wer.status.statusCode {
	case StatusCodeSuccessed, StatusCodeCanceled:
		return true
	default:
		return false
	}
}

//Failed æ˜¯å¦å¤±è´¥
func (wer *Worker) Failed() bool {
	switch wer.status.statusCode {
	case StatusCodeFailed, StatusCodeInternalError, StatusCodeTooManyConnections, StatusCodeNetError:
		return true
	default:
		return false
	}
}

//ClearStatus æ¸…ç©ºçŠ¶æ€
func (wer *Worker) ClearStatus() {
	wer.status.statusCode = StatusCodeInit
}

//Err è¿”å›workeré”™è¯¯
func (wer *Worker) Err() error {
	return wer.err
}

//Execute æ‰§è¡Œä»»åŠ¡
func (wer *Worker) Execute() {
	wer.lazyInit()

	wer.execMu.Lock()
	defer wer.execMu.Unlock()

	wer.status.statusCode = StatusCodeInit
	single := wer.acceptRanges == ""

	// å¦‚æœå·²æš‚åœ, é€€å‡º
	if wer.status.statusCode == StatusCodePaused {
		return
	}

	if !single {
		// å·²å®Œæˆ
		if rlen := wer.wrange.Len(); rlen <= 0 {
			if rlen < 0 {
				pcsverbose.Verbosef("DEBUG: RangeLen is negative at begin: %v, %d\n", wer.wrange, wer.wrange.Len())
			}
			wer.status.statusCode = StatusCodeSuccessed
			return
		}
	}

	workerCancelCtx, workerCancelFunc := context.WithCancel(context.Background())
	wer.workerCancelFunc = workerCancelFunc
	resetCtx, resetFunc := context.WithCancel(context.Background())
	wer.resetFunc = resetFunc

	header := map[string]string{}
	if wer.referer != "" {
		header["Referer"] = wer.referer
	}
	//æ£€æµ‹æ˜¯å¦æ”¯æŒrange
	if wer.acceptRanges != "" && wer.wrange.Len() >= 0 {
		header["Range"] = fmt.Sprintf("%s=%d-%d", wer.acceptRanges, wer.wrange.LoadBegin(), wer.wrange.LoadEnd()-1)
	}

	wer.status.statusCode = StatusCodePending

	var resp *http.Response
	if wer.firstResp != nil {
		resp = wer.firstResp // ä½¿ç”¨ç¬¬ä¸€ä¸ªè¿æ¥
	} else {
		resp, wer.err = wer.client.Req(http.MethodGet, wer.url, nil, header)
	}
	if resp != nil {
		defer func() {
			resp.Body.Close()
			wer.firstResp = nil // å»æ‰ç¬¬ä¸€ä¸ªè¿æ¥
		}()
		wer.readRespBodyCancelFunc = func() {
			resp.Body.Close()
		}
	}
	if wer.err != nil {
		wer.status.statusCode = StatusCodeNetError
		return
	}

	// åˆ¤æ–­å“åº”çŠ¶æ€
	switch resp.StatusCode {
	case 200, 206:
		// do nothing, continue
	case 416: //Requested Range Not Satisfiable
		fallthrough
	case 403: // Forbidden
		fallthrough
	case 406: // Not Acceptable
		wer.status.statusCode = StatusCodeNetError
		wer.err = errors.New(resp.Status)
		return
	case 429, 509: // Too Many Requests
		wer.status.SetStatusCode(StatusCodeTooManyConnections)
		wer.err = errors.New(resp.Status)
		return
	default:
		wer.status.statusCode = StatusCodeNetError
		wer.err = fmt.Errorf("unexpected http status code, %d, %s", resp.StatusCode, resp.Status)
		return
	}

	var (
		contentLength = resp.ContentLength
		rangeLength   = wer.wrange.Len()
	)

	if !single {
		// æ£€æŸ¥è¯·æ±‚é•¿åº¦
		if contentLength != rangeLength && wer.firstResp == nil { // è·³è¿‡æ£€æŸ¥ç¬¬ä¸€ä¸ªè¿æ¥
			wer.status.statusCode = StatusCodeNetError
			wer.err = fmt.Errorf("Content-Length is unexpected: %d, need %d", contentLength, rangeLength)
			return
		}
		// æ£€æŸ¥æ€»å¤§å°
		if wer.totalSize > 0 {
			total := ParseContentRange(resp.Header.Get("Content-Range"))
			if total > 0 {
				if total != wer.totalSize {
					wer.status.statusCode = StatusCodeInternalError // è¿™é‡Œè®¾ç½®ä¸ºå†…éƒ¨é”™è¯¯, å¼ºåˆ¶åœæ­¢ä¸‹è½½
					wer.err = fmt.Errorf("Content-Range total length is unexpected: %d, need %d", total, wer.totalSize)
					return
				}
			}
		}
	}

	var (
		buf       = cachepool.SyncPool.Get().([]byte)
		n, nn     int
		n64, nn64 int64
	)
	defer cachepool.SyncPool.Put(buf)

	for {
		select {
		case <-workerCancelCtx.Done(): //å–æ¶ˆ
			wer.status.statusCode = StatusCodeCanceled
			return
		case <-resetCtx.Done(): //é‡è®¾è¿æ¥
			wer.status.statusCode = StatusCodeReseted
			return
		case <-wer.pauseChan: //æš‚åœ
			return
		default:
			wer.status.statusCode = StatusCodeDownloading

			// åˆå§‹åŒ–æ•°æ®
			var readErr error
			n = 0

			// è¯»å–æ•°æ®
			for n < len(buf) && readErr == nil && (single || wer.wrange.Len() > 0) {
				nn, readErr = resp.Body.Read(buf[n:])
				nn64 = int64(nn)

				// æ›´æ–°é€Ÿåº¦ç»Ÿè®¡
				if wer.downloadStatus != nil {
					wer.downloadStatus.AddSpeedsDownloaded(nn64) // é™é€Ÿåœ¨è¿™é‡Œé˜»å¡
				}
				wer.speedsStat.Add(nn64)
				n += nn
			}

			if n > 0 && readErr == io.EOF {
				readErr = io.ErrUnexpectedEOF
			}

			n64 = int64(n)

			// éå•çº¿ç¨‹æ¨¡å¼ä¸‹
			if !single {
				rangeLength = wer.wrange.Len()

				// å·²å®Œæˆ (æœªé›¨ç»¸ç¼ª)
				if rangeLength <= 0 {
					wer.status.statusCode = StatusCodeCanceled
					wer.err = errors.New("worker already complete")
					return
				}

				if n64 > rangeLength {
					// æ•°æ®å¤§å°ä¸æ­£å¸¸
					n64 = rangeLength
					n = int(rangeLength)
					readErr = io.EOF
				}
			}

			// å†™å…¥æ•°æ®
			if wer.writerAt != nil {
				wer.status.statusCode = StatusCodeWaitToWrite
				if wer.writeMu != nil {
					wer.writeMu.Lock() // åŠ é”, å‡è½»ç¡¬ç›˜çš„å‹åŠ›
				}
				_, wer.err = wer.writerAt.WriteAt(buf[:n], wer.wrange.Begin) // å†™å…¥æ•°æ®
				if wer.err != nil {
					if wer.writeMu != nil {
						wer.writeMu.Unlock() //è§£é”
					}
					wer.status.statusCode = StatusCodeInternalError
					return
				}

				if wer.writeMu != nil {
					wer.writeMu.Unlock() //è§£é”
				}
				wer.status.statusCode = StatusCodeDownloading
			}

			// æ›´æ–°ä¸‹è½½ç»Ÿè®¡æ•°æ®
			wer.wrange.AddBegin(n64)
			if wer.downloadStatus != nil {
				wer.downloadStatus.AddDownloaded(n64)
				if single {
					wer.downloadStatus.AddTotalSize(n64)
				}
			}

			if readErr != nil {
				rlen := wer.wrange.Len()
				switch {
				case single && readErr == io.ErrUnexpectedEOF:
					// å•çº¿ç¨‹åˆ¤æ–­ä¸‹è½½æˆåŠŸ
					fallthrough
				case readErr == io.EOF:
					fallthrough
				case rlen <= 0:
					// ä¸‹è½½å®Œæˆ
					// å°äº0å¯èƒ½æ˜¯å› ä¸º worker è¢« duplicate
					wer.status.statusCode = StatusCodeSuccessed
					if rlen < 0 {
						pcsverbose.Verbosef("DEBUG: RangeLen is negative at end: %v, %d\n", wer.wrange, wer.wrange.Len())
					}
					return
				default:
					// å…¶ä»–é”™è¯¯, è¿”å›
					wer.status.statusCode = StatusCodeFailed
					wer.err = readErr
					return
				}
			}
		}
	}
}



================================================
FILE: requester/downloader/writer.go
================================================
package downloader

import (
	"io"
	"os"
)

type (
	// Fder è·å–fdæ¥å£
	Fder interface {
		Fd() uintptr
	}

	// Writer ä¸‹è½½å™¨æ•°æ®è¾“å‡ºæ¥å£
	Writer interface {
		io.WriterAt
	}
)

// NewDownloaderWriterByFilename åˆ›å»ºä¸‹è½½å™¨æ•°æ®è¾“å‡ºæ¥å£, ç±»ä¼¼äºos.OpenFile
func NewDownloaderWriterByFilename(name string, flag int, perm os.FileMode) (writer Writer, file *os.File, err error) {
	file, err = os.OpenFile(name, flag, perm)
	if err != nil {
		return
	}

	writer = file
	return
}



================================================
FILE: requester/multipartreader/multipartreader.go
================================================
// Package multipartreader helps you encode large files in MIME multipart format
// without reading the entire content into memory.
package multipartreader

import (
	"errors"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"io"
	"mime/multipart"
	"strings"
	"sync"
	"sync/atomic"
)

type (
	// MultipartReader MIME multipart format
	MultipartReader struct {
		length      int64
		contentType string
		boundary    string

		formBody  string
		parts     []*part
		part64s   []*part64
		formClose string

		mu          sync.Mutex
		closed      bool
		multiReader io.Reader
	}

	part struct {
		form      string
		readerlen rio.ReaderLen
	}

	part64 struct {
		form        string
		readerlen64 rio.ReaderLen64
	}
)

// NewMultipartReader è¿”å›åˆå§‹åŒ–çš„ *MultipartReader
func NewMultipartReader() (mr *MultipartReader) {
	builder := &strings.Builder{}
	writer := multipart.NewWriter(builder)
	mr = &MultipartReader{
		contentType: writer.FormDataContentType(),
		boundary:    writer.Boundary(),
	}

	mr.length += int64(builder.Len())
	mr.formBody = builder.String()
	return
}

// AddFormFeild å¢åŠ  form è¡¨å•
func (mr *MultipartReader) AddFormFeild(fieldname string, readerlen rio.ReaderLen) {
	if readerlen == nil {
		return
	}

	mpart := &part{
		form:      fmt.Sprintf("--%s\r\nContent-Disposition: form-data; name=\"%s\"\r\n\r\n", mr.boundary, fieldname),
		readerlen: readerlen,
	}
	atomic.AddInt64(&mr.length, int64(len(mpart.form)+mpart.readerlen.Len()))
	mr.parts = append(mr.parts, mpart)
}

// AddFormFile å¢åŠ  form æ–‡ä»¶è¡¨å•
func (mr *MultipartReader) AddFormFile(fieldname, filename string, readerlen64 rio.ReaderLen64) {
	if readerlen64 == nil {
		return
	}

	mpart64 := &part64{
		form:        fmt.Sprintf("--%s\r\nContent-Disposition: form-data; name=\"%s\"; filename=\"%s\"\r\n\r\n", mr.boundary, fieldname, filename),
		readerlen64: readerlen64,
	}
	atomic.AddInt64(&mr.length, int64(len(mpart64.form))+mpart64.readerlen64.Len())
	mr.part64s = append(mr.part64s, mpart64)
}

//CloseMultipart å…³é—­multipartreader
func (mr *MultipartReader) CloseMultipart() error {
	mr.mu.Lock()
	defer mr.mu.Unlock()
	if mr.closed {
		return errors.New("multipartreader already closed")
	}

	mr.formClose = "\r\n--" + mr.boundary + "--\r\n"
	atomic.AddInt64(&mr.length, int64(len(mr.formClose)))

	numReaders := 0
	if mr.formBody != "" {
		numReaders++
	}
	numReaders += 2*len(mr.parts) + 2*len(mr.part64s)
	if mr.formClose != "" {
		numReaders++
	}

	readers := make([]io.Reader, 0, numReaders)
	readers = append(readers, strings.NewReader(mr.formBody))
	for k := range mr.parts {
		readers = append(readers, strings.NewReader(mr.parts[k].form), mr.parts[k].readerlen)
	}
	for k := range mr.part64s {
		readers = append(readers, strings.NewReader(mr.part64s[k].form), mr.part64s[k].readerlen64)
	}
	readers = append(readers, strings.NewReader(mr.formClose))
	mr.multiReader = io.MultiReader(readers...)

	mr.closed = true
	return nil
}

//ContentType è¿”å›Content-Type
func (mr *MultipartReader) ContentType() string {
	return mr.contentType
}

func (mr *MultipartReader) Read(p []byte) (n int, err error) {
	if !mr.closed {
		return 0, errors.New("multipartreader not closed")
	}
	n, err = mr.multiReader.Read(p)
	return n, err
}

// Len è¿”å›è¡¨å•å†…å®¹æ€»é•¿åº¦
func (mr *MultipartReader) Len() int64 {
	return atomic.LoadInt64(&mr.length)
}



================================================
FILE: requester/rio/buf.go
================================================
package rio

import (
	"unsafe"
)

// Buffer ä¸ºå›ºå®šé•¿åº¦çš„ Buf, å®ç° io.WriterAt æ¥å£
type Buffer struct {
	Buf []byte
}

// NewBuffer åˆå§‹åŒ– Buffer
func NewBuffer(buf []byte) *Buffer {
	return &Buffer{
		Buf: buf,
	}
}

// ReadAt å®ç° io.ReadAt æ¥å£
// ä¸è¿›è¡Œè¶Šç•Œæ£€æŸ¥
func (b *Buffer) ReadAt(p []byte, off int64) (n int, err error) {
	n = copy(p, b.Buf[off:])
	return n, nil
}

// WriteAt å®ç° io.WriterAt æ¥å£
// ä¸è¿›è¡Œè¶Šç•Œæ£€æŸ¥
func (b *Buffer) WriteAt(p []byte, off int64) (n int, err error) {
	n = copy(b.Buf[off:], p)
	return n, nil
}

// Bytes è¿”å› buf
func (b *Buffer) Bytes() []byte {
	return b.Buf
}

func (b *Buffer) String() string {
	return *(*string)(unsafe.Pointer(&b.Buf))
}



================================================
FILE: requester/rio/file.go
================================================
package rio

import (
	cryptorand "crypto/rand"
	"io"
	"os"
	"sync/atomic"
)

type (
	fileReadedlen64 struct {
		readed int64
		f      *os.File
	}

	rdReadedlen64 struct {
		readed int64
		size   int64
		rd     io.Reader
	}
)

// NewFileReaderLen64 *os.File å®ç° ReadedLen64 æ¥å£
func NewFileReaderLen64(f *os.File) ReaderLen64 {
	if f == nil {
		return nil
	}

	return &fileReadedlen64{
		f: f,
	}
}

// NewFileReaderAtLen64 *os.File å®ç° ReaderAtLen64 æ¥å£
func NewFileReaderAtLen64(f *os.File) ReaderAtLen64 {
	if f == nil {
		return nil
	}

	return &fileReadedlen64{
		f: f,
	}
}

func NewCryptoRandReaderAtLen64(size int64) ReaderAtLen64 {
	return &rdReadedlen64{
		rd:   cryptorand.Reader,
		size: size,
	}
}

// Read è¯»æ–‡ä»¶, å¹¶è®°å½•å·²è¯»å–æ•°æ®é‡
func (fr *fileReadedlen64) Read(b []byte) (n int, err error) {
	n, err = fr.f.Read(b)
	atomic.AddInt64(&fr.readed, int64(n))
	return n, err
}

// ReadAt è¯»æ–‡ä»¶, ä¸è®°å½•å·²è¯»å–æ•°æ®é‡
func (fr *fileReadedlen64) ReadAt(b []byte, off int64) (n int, err error) {
	n, err = fr.f.ReadAt(b, off)
	return n, err
}

// Len è¿”å›æ–‡ä»¶çš„å¤§å°
func (fr *fileReadedlen64) Len() int64 {
	info, err := fr.f.Stat()
	if err != nil {
		return 0
	}
	return info.Size() - fr.readed
}

func (rr *rdReadedlen64) Read(b []byte) (n int, err error) {
	n, err = rr.ReadAt(b, 0)
	atomic.AddInt64(&rr.readed, int64(n))
	return n, err
}

func (rr *rdReadedlen64) ReadAt(b []byte, off int64) (n int, err error) {
	n, err = rr.rd.Read(b)
	return n, err
}

func (rr *rdReadedlen64) Len() int64 {
	return rr.size - rr.readed
}



================================================
FILE: requester/rio/multi.go
================================================
package rio

import (
	"io"
)

// MultiReaderLen åˆå¹¶å¤šä¸ªReaderLen
func MultiReaderLen(readerLens ...ReaderLen) ReaderLen {
	// TODO: å’Œcopyå¯¹æ¯”
	r := make([]io.Reader, 0, len(readerLens))
	for k := range readerLens {
		if readerLens[k] == nil {
			continue
		}
		r = append(r, readerLens[k])
	}
	return &multiReaderLen{
		mrls:        readerLens,
		multiReader: io.MultiReader(r...),
	}
}

type multiReaderLen struct {
	mrls        []ReaderLen
	multiReader io.Reader
}

func (mrl *multiReaderLen) Read(p []byte) (n int, err error) {
	return mrl.multiReader.Read(p)
}

func (mrl *multiReaderLen) Len() int {
	var i int
	for k := range mrl.mrls {
		i += mrl.mrls[k].Len()
	}
	return i
}

// MultiReaderLen64 åˆå¹¶å¤šä¸ªReaderLen64
func MultiReaderLen64(readerLen64s ...ReaderLen64) ReaderLen64 {
	// TODO: å’Œcopyå¯¹æ¯”
	r := make([]io.Reader, 0, len(readerLen64s))
	for k := range readerLen64s {
		if readerLen64s[k] == nil {
			continue
		}
		r = append(r, readerLen64s[k])
	}
	return &multiReaderLen64{
		mrl64s:      readerLen64s,
		multiReader: io.MultiReader(r...),
	}
}

type multiReaderLen64 struct {
	mrl64s      []ReaderLen64
	multiReader io.Reader
}

func (mrl64 *multiReaderLen64) Read(p []byte) (n int, err error) {
	return mrl64.multiReader.Read(p)
}

func (mrl64 *multiReaderLen64) Len() int64 {
	var l int64
	for k := range mrl64.mrl64s {
		l += mrl64.mrl64s[k].Len()
	}
	return l
}



================================================
FILE: requester/rio/multi_test.go
================================================
package rio

import (
	"fmt"
	"io"
	"os"
	"strings"
	"testing"
)

func TestMultiReaderLen(t *testing.T) {
	rd1, rd2 := strings.NewReader("asdkfljalf"), strings.NewReader("---asva sdf")
	multi := MultiReaderLen(rd1, rd2)
	fmt.Println(multi.Len())
	io.Copy(os.Stdout, multi)
}



================================================
FILE: requester/rio/rio.go
================================================
// Package rio rquester io å·¥å…·åŒ…
package rio

import (
	"io"
)

type (
	// Lener è¿”å›32-bité•¿åº¦æ¥å£
	Lener interface {
		Len() int
	}

	// Lener64 è¿”å›64-bité•¿åº¦æ¥å£
	Lener64 interface {
		Len() int64
	}

	// ReaderLen å®ç°io.Readerå’Œ32-bité•¿åº¦æ¥å£
	ReaderLen interface {
		io.Reader
		Lener
	}

	// ReaderLen64 å®ç°io.Readerå’Œ64-bité•¿åº¦æ¥å£
	ReaderLen64 interface {
		io.Reader
		Lener64
	}

	// ReaderAtLen64 å®ç°io.ReaderAtå’Œ64-bité•¿åº¦æ¥å£
	ReaderAtLen64 interface {
		io.ReaderAt
		Lener64
	}

	// WriterLen64 å®ç°io.Writerå’Œ64-bité•¿åº¦æ¥å£
	WriterLen64 interface {
		io.Writer
		Lener64
	}

	// WriteCloserAt å®ç°io.WriteCloserå’Œio.WriterAtæ¥å£
	WriteCloserAt interface {
		io.WriteCloser
		io.WriterAt
	}

	// WriteCloserLen64At å®ç°rio.WriteCloserAtå’Œ64-bité•¿åº¦æ¥å£
	WriteCloserLen64At interface {
		WriteCloserAt
		Lener64
	}
)



================================================
FILE: requester/rio/speeds/ratelimit.go
================================================
package speeds

import (
	"sync"
	"sync/atomic"
	"time"
)

type (
	RateLimit struct {
		MaxRate int64

		count           int64
		interval        time.Duration
		ticker          *time.Ticker
		muChan          chan struct{}
		closeChan       chan struct{}
		backServiceOnce sync.Once
	}

	// AddCountFunc func() (count int64)
)

func NewRateLimit(maxRate int64) *RateLimit {
	return &RateLimit{
		MaxRate: maxRate,
	}
}

func (rl *RateLimit) SetInterval(i time.Duration) {
	if i <= 0 {
		i = 1 * time.Second
	}
	rl.interval = i
	if rl.ticker != nil {
		rl.ticker.Stop()
		rl.ticker = time.NewTicker(i)
	}
}

func (rl *RateLimit) Stop() {
	if rl.ticker != nil {
		rl.ticker.Stop()
	}
	if rl.closeChan != nil {
		close(rl.closeChan)
	}
	return
}

func (rl *RateLimit) resetChan() {
	if rl.muChan != nil {
		close(rl.muChan)
	}
	rl.muChan = make(chan struct{})
}

func (rl *RateLimit) backService() {
	if rl.interval <= 0 {
		rl.interval = 1 * time.Second
	}
	rl.ticker = time.NewTicker(rl.interval)
	rl.closeChan = make(chan struct{})
	rl.resetChan()
	go func() {
		for {
			select {
			case <-rl.ticker.C:
				rl.resetChan()
				atomic.StoreInt64(&rl.count, 0)
			case <-rl.closeChan:
				return
			}
		}
	}()
}

func (rl *RateLimit) Add(count int64) {
	rl.backServiceOnce.Do(rl.backService)
	for {
		if atomic.LoadInt64(&rl.count) >= rl.MaxRate { // è¶…å‡ºæœ€å¤§é™é¢
			// é˜»å¡
			<-rl.muChan
			continue
		}
		atomic.AddInt64(&rl.count, count)
		break
	}
}



================================================
FILE: requester/rio/speeds/ratelimit_test.go
================================================
package speeds_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio/speeds"
	"testing"
	"time"
)

func TestRateLimit(t *testing.T) {
	r := speeds.NewRateLimit(100)
	fmt.Println("adding 101...")
	r.Add(101)
	fmt.Println("adding 10...")
	r.Add(10)
	fmt.Println("adding 11...")
	r.Add(11)
	fmt.Println("adding 12...")
	r.Add(12)
	fmt.Println("adding 13...")
	r.Add(13)
	fmt.Println("adding 22...")
	r.Add(22)
	fmt.Println("adding 35...")
	r.Add(35)
	fmt.Println("adding 25...")
	r.Add(25)
	fmt.Println("adding 11...")
	r.Add(11)

	r.Stop()
	time.Sleep(10e9)
}



================================================
FILE: requester/rio/speeds/speeds.go
================================================
// Package speeds é€Ÿåº¦è®¡ç®—å·¥å…·åŒ…
package speeds

import (
	"sync"
	"sync/atomic"
	"time"
)

type (
	// Speeds ç»Ÿè®¡é€Ÿåº¦
	Speeds struct {
		count    int64
		interval time.Duration // åˆ·æ–°å‘¨æœŸ
		nowTime  time.Time
		once     sync.Once
	}
)

func (sps *Speeds) initOnce() {
	sps.once.Do(func() {
		sps.nowTime = time.Now()
		if sps.interval <= 0 {
			sps.interval = 1 * time.Second
		}
	})
}

// SetInterval è®¾ç½®åˆ·æ–°å‘¨æœŸ
func (sps *Speeds) SetInterval(interval time.Duration) {
	if interval <= 0 {
		return
	}
	sps.interval = interval
}

// Add åŸå­æ“ä½œ, å¢åŠ æ•°æ®é‡
func (sps *Speeds) Add(count int64) {
	// åˆå§‹åŒ–
	sps.initOnce()
	atomic.AddInt64(&sps.count, count)
}

// GetSpeeds ç»“æŸç»Ÿè®¡é€Ÿåº¦, å¹¶è¿”å›é€Ÿåº¦
func (sps *Speeds) GetSpeeds() (speeds int64) {
	sps.initOnce()

	since := time.Since(sps.nowTime)
	if since <= 0 {
		return 0
	}
	speeds = int64(float64(atomic.LoadInt64(&sps.count)) * sps.interval.Seconds() / since.Seconds())

	// æ›´æ–°ä¸‹ä¸€è½®
	if since >= sps.interval {
		atomic.StoreInt64(&sps.count, 0)
		sps.nowTime = time.Now()
	}
	return
}



================================================
FILE: requester/transfer/download_instanceinfo.go
================================================
package transfer

import (
	"time"
)

type (
	//DownloadInstanceInfo çŠ¶æ€è¯¦ç»†ä¿¡æ¯, ç”¨äºå¯¼å‡ºçŠ¶æ€æ–‡ä»¶
	DownloadInstanceInfo struct {
		DownloadStatus *DownloadStatus
		Ranges         RangeList
	}

	// DownloadInstanceInfoExporter æ–­ç‚¹ç»­ä¼ ç±»å‹æ¥å£
	DownloadInstanceInfoExporter interface {
		GetInstanceInfo() *DownloadInstanceInfo
		SetInstanceInfo(*DownloadInstanceInfo)
	}
)

// GetInstanceInfo ä»æ–­ç‚¹ä¿¡æ¯è·å–ä¸‹è½½çŠ¶æ€
func (m *DownloadInstanceInfoExport) GetInstanceInfo() (eii *DownloadInstanceInfo) {
	eii = &DownloadInstanceInfo{
		Ranges: m.Ranges,
	}

	var downloaded int64
	switch m.RangeGenMode {
	case RangeGenMode_BlockSize:
		downloaded = m.GenBegin - eii.Ranges.Len()
	default:
		downloaded = m.TotalSize - eii.Ranges.Len()
	}
	eii.DownloadStatus = &DownloadStatus{
		startTime:  time.Now(),
		totalSize:  m.TotalSize,
		downloaded: downloaded,
		gen:        NewRangeListGenBlockSize(m.TotalSize, m.GenBegin, m.BlockSize),
	}
	switch m.RangeGenMode {
	case RangeGenMode_BlockSize:
		eii.DownloadStatus.gen = NewRangeListGenBlockSize(m.TotalSize, m.GenBegin, m.BlockSize)
	default:
		eii.DownloadStatus.gen = NewRangeListGenDefault(m.TotalSize, m.TotalSize, len(m.Ranges), len(m.Ranges))
	}
	return eii
}

// SetInstanceInfo ä»ä¸‹è½½çŠ¶æ€å¯¼å‡ºæ–­ç‚¹ä¿¡æ¯
func (m *DownloadInstanceInfoExport) SetInstanceInfo(eii *DownloadInstanceInfo) {
	if eii == nil {
		return
	}

	if eii.DownloadStatus != nil {
		m.TotalSize = eii.DownloadStatus.TotalSize()
		if eii.DownloadStatus.gen != nil {
			m.GenBegin = eii.DownloadStatus.gen.LoadBegin()
			m.BlockSize = eii.DownloadStatus.gen.LoadBlockSize()
			m.RangeGenMode = eii.DownloadStatus.gen.RangeGenMode()
		} else {
			m.RangeGenMode = RangeGenMode_Default
		}
	}
	m.Ranges = eii.Ranges
}



================================================
FILE: requester/transfer/download_status.go
================================================
package transfer

import (
	"github.com/felixonmars/BaiduPCS-Go/requester/rio/speeds"
	"sync"
	"sync/atomic"
	"time"
)

type (
	//DownloadStatuser ä¸‹è½½çŠ¶æ€æ¥å£
	DownloadStatuser interface {
		TotalSize() int64
		Downloaded() int64
		SpeedsPerSecond() int64
		TimeElapsed() time.Duration // å·²å¼€å§‹æ—¶é—´
		TimeLeft() time.Duration    // é¢„è®¡å‰©ä½™æ—¶é—´, è´Ÿæ•°ä»£è¡¨æœªçŸ¥
	}

	//DownloadStatus ä¸‹è½½çŠ¶æ€åŠç»Ÿè®¡ä¿¡æ¯
	DownloadStatus struct {
		totalSize        int64         // æ€»å¤§å°
		downloaded       int64         // å·²ä¸‹è½½çš„æ•°æ®é‡
		speedsDownloaded int64         // ç”¨äºç»Ÿè®¡é€Ÿåº¦çš„downloaded
		maxSpeeds        int64         // æœ€å¤§ä¸‹è½½é€Ÿåº¦
		tmpSpeeds        int64         // ç¼“å­˜çš„é€Ÿåº¦
		speedsStat       speeds.Speeds // é€Ÿåº¦ç»Ÿè®¡ (æ³¨æ„å¯¹é½)

		startTime time.Time // å¼€å§‹ä¸‹è½½çš„æ—¶é—´

		rateLimit *speeds.RateLimit // é™é€Ÿæ§åˆ¶

		gen *RangeListGen // Rangeç”ŸæˆçŠ¶æ€
		mu  sync.Mutex
	}
)

//NewDownloadStatus åˆå§‹åŒ–DownloadStatus
func NewDownloadStatus() *DownloadStatus {
	return &DownloadStatus{
		startTime: time.Now(),
	}
}

// SetRateLimit è®¾ç½®é™é€Ÿ
func (ds *DownloadStatus) SetRateLimit(rl *speeds.RateLimit) {
	ds.rateLimit = rl
}

//SetTotalSize è¿”å›æ€»å¤§å°
func (ds *DownloadStatus) SetTotalSize(size int64) {
	ds.totalSize = size
}

//AddDownloaded å¢åŠ å·²ä¸‹è½½æ•°æ®é‡
func (ds *DownloadStatus) AddDownloaded(d int64) {
	atomic.AddInt64(&ds.downloaded, d)
}

//AddTotalSize å¢åŠ æ€»å¤§å° (ä¸æ”¯æŒå¤šçº¿ç¨‹)
func (ds *DownloadStatus) AddTotalSize(size int64) {
	ds.totalSize += size
}

//AddSpeedsDownloaded å¢åŠ å·²ä¸‹è½½æ•°æ®é‡, ç”¨äºç»Ÿè®¡é€Ÿåº¦
func (ds *DownloadStatus) AddSpeedsDownloaded(d int64) {
	if ds.rateLimit != nil {
		ds.rateLimit.Add(d)
	}
	ds.speedsStat.Add(d)
}

//SetMaxSpeeds è®¾ç½®æœ€å¤§é€Ÿåº¦, åŸå­æ“ä½œ
func (ds *DownloadStatus) SetMaxSpeeds(speeds int64) {
	if speeds > atomic.LoadInt64(&ds.maxSpeeds) {
		atomic.StoreInt64(&ds.maxSpeeds, speeds)
	}
}

//ClearMaxSpeeds æ¸…ç©ºç»Ÿè®¡æœ€å¤§é€Ÿåº¦, åŸå­æ“ä½œ
func (ds *DownloadStatus) ClearMaxSpeeds() {
	atomic.StoreInt64(&ds.maxSpeeds, 0)
}

//TotalSize è¿”å›æ€»å¤§å°
func (ds *DownloadStatus) TotalSize() int64 {
	return ds.totalSize
}

//Downloaded è¿”å›å·²ä¸‹è½½æ•°æ®é‡
func (ds *DownloadStatus) Downloaded() int64 {
	return atomic.LoadInt64(&ds.downloaded)
}

// UpdateSpeeds æ›´æ–°speeds
func (ds *DownloadStatus) UpdateSpeeds() {
	atomic.StoreInt64(&ds.tmpSpeeds, ds.speedsStat.GetSpeeds())
}

//SpeedsPerSecond è¿”å›æ¯ç§’é€Ÿåº¦
func (ds *DownloadStatus) SpeedsPerSecond() int64 {
	return atomic.LoadInt64(&ds.tmpSpeeds)
}

//MaxSpeeds è¿”å›æœ€å¤§é€Ÿåº¦
func (ds *DownloadStatus) MaxSpeeds() int64 {
	return atomic.LoadInt64(&ds.maxSpeeds)
}

//TimeElapsed è¿”å›èŠ±è´¹çš„æ—¶é—´
func (ds *DownloadStatus) TimeElapsed() (elapsed time.Duration) {
	return time.Since(ds.startTime)
}

//TimeLeft è¿”å›é¢„è®¡å‰©ä½™æ—¶é—´
func (ds *DownloadStatus) TimeLeft() (left time.Duration) {
	speeds := atomic.LoadInt64(&ds.tmpSpeeds)
	if speeds <= 0 {
		left = -1
	} else {
		left = time.Duration((ds.totalSize-ds.downloaded)/(speeds)) * time.Second
	}
	return
}

// RangeListGen è¿”å›RangeListGen
func (ds *DownloadStatus) RangeListGen() *RangeListGen {
	return ds.gen
}

// SetRangeListGen è®¾ç½®RangeListGen
func (ds *DownloadStatus) SetRangeListGen(gen *RangeListGen) {
	ds.gen = gen
}



================================================
FILE: requester/transfer/rangelist.go
================================================
package transfer

import (
	"errors"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"sync"
	"sync/atomic"
)

type (
	//RangeList è¯·æ±‚èŒƒå›´åˆ—è¡¨
	RangeList []*Range

	//RangeListGen Range ç”Ÿæˆå™¨
	RangeListGen struct {
		total        int64
		begin        int64
		blockSize    int64
		parallel     int
		count        int // å·²ç”Ÿæˆæ¬¡æ•°
		rangeGenMode RangeGenMode
		mu           sync.Mutex
	}
)

const (
	// DefaultBlockSize é»˜è®¤çš„BlockSize
	DefaultBlockSize = 256 * converter.KB
)

var (
	// ErrUnknownRangeGenMode RangeGenMode éæ³•
	ErrUnknownRangeGenMode = errors.New("Unknown RangeGenMode")
)

//Len é•¿åº¦
func (r *Range) Len() int64 {
	return r.LoadEnd() - r.LoadBegin()
}

//LoadBegin è¯»å–Begin, åŸå­æ“ä½œ
func (r *Range) LoadBegin() int64 {
	return atomic.LoadInt64(&r.Begin)
}

//AddBegin å¢åŠ Begin, åŸå­æ“ä½œ
func (r *Range) AddBegin(i int64) (newi int64) {
	return atomic.AddInt64(&r.Begin, i)
}

//LoadEnd è¯»å–End, åŸå­æ“ä½œ
func (r *Range) LoadEnd() int64 {
	return atomic.LoadInt64(&r.End)
}

//StoreBegin å‚¨å­˜End, åŸå­æ“ä½œ
func (r *Range) StoreBegin(end int64) {
	atomic.StoreInt64(&r.Begin, end)
}

//StoreEnd å‚¨å­˜End, åŸå­æ“ä½œ
func (r *Range) StoreEnd(end int64) {
	atomic.StoreInt64(&r.End, end)
}

// ShowDetails æ˜¾ç¤ºRangeç»†èŠ‚
func (r *Range) ShowDetails() string {
	return fmt.Sprintf("{%d-%d}", r.LoadBegin(), r.LoadEnd())
}

//Len è·å–æ‰€æœ‰çš„Rangeçš„å‰©ä½™é•¿åº¦
func (rl *RangeList) Len() int64 {
	var l int64
	for _, wrange := range *rl {
		if wrange == nil {
			continue
		}
		l += wrange.Len()
	}
	return l
}

// NewRangeListGenDefault åˆå§‹åŒ–é»˜è®¤Rangeç”Ÿæˆå™¨, æ ¹æ®parallelå¹³å‡ç”Ÿæˆ
func NewRangeListGenDefault(totalSize, begin int64, count, parallel int) *RangeListGen {
	return &RangeListGen{
		total:        totalSize,
		begin:        begin,
		parallel:     parallel,
		count:        count,
		rangeGenMode: RangeGenMode_Default,
	}
}

// NewRangeListGenBlockSize åˆå§‹åŒ–Rangeç”Ÿæˆå™¨, æ ¹æ®blockSizeç”Ÿæˆ
func NewRangeListGenBlockSize(totalSize, begin, blockSize int64) *RangeListGen {
	return &RangeListGen{
		total:        totalSize,
		begin:        begin,
		blockSize:    blockSize,
		rangeGenMode: RangeGenMode_BlockSize,
	}
}

// RangeGenMode è¿”å›Rangeç”Ÿæˆæ–¹å¼
func (gen *RangeListGen) RangeGenMode() RangeGenMode {
	return gen.rangeGenMode
}

// RangeCount è¿”å›é¢„è®¡ç”Ÿæˆçš„Rangeæ•°é‡
func (gen *RangeListGen) RangeCount() (rangeCount int) {
	switch gen.rangeGenMode {
	case RangeGenMode_Default:
		rangeCount = gen.parallel - gen.count
	case RangeGenMode_BlockSize:
		rangeCount = int((gen.total - gen.begin) / gen.blockSize)
		if gen.total%gen.blockSize != 0 {
			rangeCount++
		}
	}
	return
}

// LoadBegin è¿”å›begin
func (gen *RangeListGen) LoadBegin() (begin int64) {
	gen.mu.Lock()
	begin = gen.begin
	gen.mu.Unlock()
	return
}

// LoadBlockSize è¿”å›blockSize
func (gen *RangeListGen) LoadBlockSize() (blockSize int64) {
	switch gen.rangeGenMode {
	case RangeGenMode_Default:
		if gen.blockSize <= 0 {
			gen.blockSize = (gen.total - gen.begin) / int64(gen.parallel)
		}
		blockSize = gen.blockSize
	case RangeGenMode_BlockSize:
		blockSize = gen.blockSize
	}
	return
}

// IsDone æ˜¯å¦å·²åˆ†é…å®Œæˆ
func (gen *RangeListGen) IsDone() bool {
	return gen.begin >= gen.total
}

// GenRange ç”Ÿæˆ Range
func (gen *RangeListGen) GenRange() (index int, r *Range) {
	var (
		end int64
	)
	if gen.parallel < 1 {
		gen.parallel = 1
	}
	switch gen.rangeGenMode {
	case RangeGenMode_Default:
		gen.LoadBlockSize()
		gen.mu.Lock()
		defer gen.mu.Unlock()

		if gen.IsDone() {
			return gen.count, nil
		}

		gen.count++
		if gen.count >= gen.parallel {
			end = gen.total
		} else {
			end = gen.begin + gen.blockSize
		}
		r = &Range{
			Begin: gen.begin,
			End:   end,
		}

		gen.begin = end
		index = gen.count - 1
		return
	case RangeGenMode_BlockSize:
		if gen.blockSize <= 0 {
			gen.blockSize = DefaultBlockSize
		}
		gen.mu.Lock()
		defer gen.mu.Unlock()

		if gen.IsDone() {
			return gen.count, nil
		}

		gen.count++
		end = gen.begin + gen.blockSize
		if end >= gen.total {
			end = gen.total
		}
		r = &Range{
			Begin: gen.begin,
			End:   end,
		}
		gen.begin = end
		index = gen.count - 1
		return
	}

	return 0, nil
}



================================================
FILE: requester/transfer/transfer.pb.go
================================================
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: transfer/transfer.proto

package transfer

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// RangeGenMode çº¿ç¨‹åˆ†é…æ–¹å¼
type RangeGenMode int32

const (
	// RangeGenMode_Default æ ¹æ®parallelå¹³å‡ç”Ÿæˆ
	RangeGenMode_Default RangeGenMode = 0
	// RangeGenMode_BlockSize æ ¹æ®blockSizeç”Ÿæˆ
	RangeGenMode_BlockSize RangeGenMode = 1
)

var RangeGenMode_name = map[int32]string{
	0: "Default",
	1: "BlockSize",
}

var RangeGenMode_value = map[string]int32{
	"Default":   0,
	"BlockSize": 1,
}

func (x RangeGenMode) String() string {
	return proto.EnumName(RangeGenMode_name, int32(x))
}

func (RangeGenMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_44038b0c710d7f2f, []int{0}
}

//Range è¯·æ±‚èŒƒå›´
type Range struct {
	Begin                int64    `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End                  int64    `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_44038b0c710d7f2f, []int{0}
}

func (m *Range) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Range.Unmarshal(m, b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Range.Marshal(b, m, deterministic)
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return xxx_messageInfo_Range.Size(m)
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetBegin() int64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *Range) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

// DownloadInstanceInfoExport æ–­ç‚¹ç»­ä¼ 
type DownloadInstanceInfoExport struct {
	RangeGenMode         RangeGenMode `protobuf:"varint,1,opt,name=range_gen_mode,json=rangeGenMode,proto3,enum=transfer.RangeGenMode" json:"range_gen_mode,omitempty"`
	TotalSize            int64        `protobuf:"varint,2,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	GenBegin             int64        `protobuf:"varint,3,opt,name=gen_begin,json=genBegin,proto3" json:"gen_begin,omitempty"`
	BlockSize            int64        `protobuf:"varint,4,opt,name=block_size,json=blockSize,proto3" json:"block_size,omitempty"`
	Ranges               []*Range     `protobuf:"bytes,5,rep,name=ranges,proto3" json:"ranges,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *DownloadInstanceInfoExport) Reset()         { *m = DownloadInstanceInfoExport{} }
func (m *DownloadInstanceInfoExport) String() string { return proto.CompactTextString(m) }
func (*DownloadInstanceInfoExport) ProtoMessage()    {}
func (*DownloadInstanceInfoExport) Descriptor() ([]byte, []int) {
	return fileDescriptor_44038b0c710d7f2f, []int{1}
}

func (m *DownloadInstanceInfoExport) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DownloadInstanceInfoExport.Unmarshal(m, b)
}
func (m *DownloadInstanceInfoExport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DownloadInstanceInfoExport.Marshal(b, m, deterministic)
}
func (m *DownloadInstanceInfoExport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadInstanceInfoExport.Merge(m, src)
}
func (m *DownloadInstanceInfoExport) XXX_Size() int {
	return xxx_messageInfo_DownloadInstanceInfoExport.Size(m)
}
func (m *DownloadInstanceInfoExport) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadInstanceInfoExport.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadInstanceInfoExport proto.InternalMessageInfo

func (m *DownloadInstanceInfoExport) GetRangeGenMode() RangeGenMode {
	if m != nil {
		return m.RangeGenMode
	}
	return RangeGenMode_Default
}

func (m *DownloadInstanceInfoExport) GetTotalSize() int64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *DownloadInstanceInfoExport) GetGenBegin() int64 {
	if m != nil {
		return m.GenBegin
	}
	return 0
}

func (m *DownloadInstanceInfoExport) GetBlockSize() int64 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *DownloadInstanceInfoExport) GetRanges() []*Range {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func init() {
	proto.RegisterEnum("transfer.RangeGenMode", RangeGenMode_name, RangeGenMode_value)
	proto.RegisterType((*Range)(nil), "transfer.Range")
	proto.RegisterType((*DownloadInstanceInfoExport)(nil), "transfer.DownloadInstanceInfoExport")
}

func init() { proto.RegisterFile("transfer/transfer.proto", fileDescriptor_44038b0c710d7f2f) }

var fileDescriptor_44038b0c710d7f2f = []byte{
	// 260 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x90, 0x41, 0x4b, 0xc3, 0x40,
	0x10, 0x85, 0x8d, 0x31, 0xb5, 0x99, 0xd6, 0x1a, 0x16, 0xd1, 0xa0, 0x14, 0x4a, 0x2f, 0x96, 0x1e,
	0x5a, 0xa8, 0x57, 0x4f, 0xa5, 0x22, 0x3d, 0x78, 0x89, 0x3f, 0x20, 0x6c, 0x9a, 0x49, 0x08, 0xc6,
	0x99, 0xb2, 0x59, 0x51, 0xfa, 0x63, 0xfd, 0x2d, 0x92, 0x49, 0x23, 0xa1, 0xb7, 0x7d, 0x6f, 0x78,
	0xef, 0x7d, 0x2c, 0xdc, 0x59, 0xa3, 0xa9, 0xca, 0xd0, 0x2c, 0xdb, 0xc7, 0x62, 0x6f, 0xd8, 0xb2,
	0xea, 0xb7, 0x7a, 0xba, 0x04, 0x2f, 0xd2, 0x94, 0xa3, 0xba, 0x01, 0x2f, 0xc1, 0xbc, 0xa0, 0xd0,
	0x99, 0x38, 0x33, 0x37, 0x6a, 0x84, 0x0a, 0xc0, 0x45, 0x4a, 0xc3, 0x73, 0xf1, 0xea, 0xe7, 0xf4,
	0xd7, 0x81, 0xfb, 0x0d, 0x7f, 0x53, 0xc9, 0x3a, 0xdd, 0x52, 0x65, 0x35, 0xed, 0x70, 0x4b, 0x19,
	0xbf, 0xfc, 0xec, 0xd9, 0x58, 0xf5, 0x0c, 0x23, 0x53, 0xf7, 0xc5, 0x39, 0x52, 0xfc, 0xc9, 0x29,
	0x4a, 0xdf, 0x68, 0x75, 0xbb, 0xf8, 0x47, 0x90, 0xbd, 0x57, 0xa4, 0x37, 0x4e, 0x31, 0x1a, 0x9a,
	0x8e, 0x52, 0x63, 0x00, 0xcb, 0x56, 0x97, 0x71, 0x55, 0x1c, 0xf0, 0xb8, 0xea, 0x8b, 0xf3, 0x5e,
	0x1c, 0x50, 0x3d, 0x80, 0x5f, 0xd7, 0x36, 0x9c, 0xae, 0x5c, 0xfb, 0x39, 0xd2, 0x5a, 0x50, 0xc7,
	0x00, 0x49, 0xc9, 0xbb, 0x8f, 0x26, 0x7b, 0xd1, 0x64, 0xc5, 0x91, 0xec, 0x23, 0xf4, 0x64, 0xaa,
	0x0a, 0xbd, 0x89, 0x3b, 0x1b, 0xac, 0xae, 0x4f, 0x80, 0xa2, 0xe3, 0x79, 0x3e, 0x87, 0x61, 0x97,
	0x50, 0x0d, 0xe0, 0x72, 0x83, 0x99, 0xfe, 0x2a, 0x6d, 0x70, 0xa6, 0xae, 0xc0, 0x5f, 0xb7, 0x95,
	0x81, 0x93, 0xf4, 0xe4, 0x3b, 0x9f, 0xfe, 0x02, 0x00, 0x00, 0xff, 0xff, 0xe8, 0x5c, 0x09, 0xcc,
	0x69, 0x01, 0x00, 0x00,
}



================================================
FILE: requester/transfer/transfer.proto
================================================
syntax = "proto3";

package transfer;

// RangeGenMode çº¿ç¨‹åˆ†é…æ–¹å¼
enum RangeGenMode {
    // RangeGenMode_Default æ ¹æ®parallelå¹³å‡ç”Ÿæˆ
	Default = 0;
	// RangeGenMode_BlockSize æ ¹æ®blockSizeç”Ÿæˆ
	BlockSize = 1;
}

//Range è¯·æ±‚èŒƒå›´
message Range {
    int64 begin = 1;
    int64 end = 2;
}

// DownloadInstanceInfoExport æ–­ç‚¹ç»­ä¼ 
message DownloadInstanceInfoExport {
    RangeGenMode range_gen_mode = 1;
    int64 total_size = 2;  // æ€»å¤§å°
    int64 gen_begin = 3;
    int64 block_size = 4;
    repeated Range ranges = 5;
}



================================================
FILE: requester/uploader/block.go
================================================
package uploader

import (
	"bufio"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio/speeds"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"io"
	"os"
	"sync"
)

type (
	// SplitUnit å°† io.ReaderAt åˆ†å‰²å•å…ƒ
	SplitUnit interface {
		Readed64
		io.Seeker
		Range() transfer.Range
		Left() int64
	}

	fileBlock struct {
		readRange     transfer.Range
		readed        int64
		readerAt      io.ReaderAt
		speedsStatRef *speeds.Speeds
		rateLimit     *speeds.RateLimit
		mu            sync.Mutex
	}

	bufioFileBlock struct {
		*fileBlock
		bufio *bufio.Reader
	}
)

// SplitBlock æ–‡ä»¶åˆ†å—
func SplitBlock(fileSize, blockSize int64) (blockList []*BlockState) {
	gen := transfer.NewRangeListGenBlockSize(fileSize, 0, blockSize)
	rangeCount := gen.RangeCount()
	blockList = make([]*BlockState, 0, rangeCount)
	for i := 0; i < rangeCount; i++ {
		id, r := gen.GenRange()
		blockList = append(blockList, &BlockState{
			ID:    id,
			Range: *r,
		})
	}
	return
}

// NewBufioSplitUnit io.ReaderAtå®ç°SplitUnitæ¥å£, æœ‰Bufferæ”¯æŒ
func NewBufioSplitUnit(readerAt io.ReaderAt, readRange transfer.Range, speedsStat *speeds.Speeds, rateLimit *speeds.RateLimit) SplitUnit {
	su := &fileBlock{
		readerAt:      readerAt,
		readRange:     readRange,
		speedsStatRef: speedsStat,
		rateLimit:     rateLimit,
	}
	return &bufioFileBlock{
		fileBlock: su,
		bufio:     bufio.NewReaderSize(su, BufioReadSize),
	}
}

func (bfb *bufioFileBlock) Read(b []byte) (n int, err error) {
	return bfb.bufio.Read(b) // é—´æ¥è°ƒç”¨fileBlock çš„Read
}

// Read åªå…è®¸ä¸€ä¸ªçº¿ç¨‹è¯»åŒä¸€ä¸ªæ–‡ä»¶
func (fb *fileBlock) Read(b []byte) (n int, err error) {
	fb.mu.Lock()
	defer fb.mu.Unlock()

	left := int(fb.Left())
	if left <= 0 {
		return 0, io.EOF
	}

	if len(b) > left {
		n, err = fb.readerAt.ReadAt(b[:left], fb.readed+fb.readRange.Begin)
	} else {
		n, err = fb.readerAt.ReadAt(b, fb.readed+fb.readRange.Begin)
	}

	n64 := int64(n)
	fb.readed += n64
	if fb.rateLimit != nil {
		fb.rateLimit.Add(n64) // é™é€Ÿé˜»å¡
	}
	if fb.speedsStatRef != nil {
		fb.speedsStatRef.Add(n64)
	}
	return
}

func (fb *fileBlock) Seek(offset int64, whence int) (int64, error) {
	fb.mu.Lock()
	defer fb.mu.Unlock()

	switch whence {
	case os.SEEK_SET:
		fb.readed = offset
	case os.SEEK_CUR:
		fb.readed += offset
	case os.SEEK_END:
		fb.readed = fb.readRange.End - fb.readRange.Begin + offset
	default:
		return 0, fmt.Errorf("unsupport whence: %d", whence)
	}
	if fb.readed < 0 {
		fb.readed = 0
	}
	return fb.readed, nil
}

func (fb *fileBlock) Len() int64 {
	return fb.readRange.End - fb.readRange.Begin
}

func (fb *fileBlock) Left() int64 {
	return fb.readRange.End - fb.readRange.Begin - fb.readed
}

func (fb *fileBlock) Range() transfer.Range {
	return fb.readRange
}

func (fb *fileBlock) Readed() int64 {
	return fb.readed
}



================================================
FILE: requester/uploader/block_test.go
================================================
package uploader_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"github.com/felixonmars/BaiduPCS-Go/requester/uploader"
	"io"
	"testing"
)

var (
	blockList = uploader.SplitBlock(10000, 999)
)

func TestSplitBlock(t *testing.T) {
	for k, e := range blockList {
		fmt.Printf("%d %#v\n", k, e)
	}
}

func TestSplitUnitRead(t *testing.T) {
	var size int64 = 65536*2+3432
	buffer := rio.NewBuffer(cachepool.RawMallocByteSlice(int(size)))
	unit := uploader.NewBufioSplitUnit(buffer, transfer.Range{Begin: 2, End: size}, nil, nil)

	buf := cachepool.RawMallocByteSlice(1022)
	for {
		n, err := unit.Read(buf)
		if err != nil {
			if err == io.EOF {
				break
			}
			t.Fatalf("read error: %s\n", err)
		}
		fmt.Printf("n: %d, left: %d\n", n, unit.Left())
	}
}



================================================
FILE: requester/uploader/error.go
================================================
package uploader

type (
	// MultiError å¤šçº¿ç¨‹ä¸Šä¼ çš„é”™è¯¯
	MultiError struct {
		Err error
		// IsRetry æ˜¯å¦é‡è¯•,
		Terminated bool
	}
)

func (me *MultiError) Error() string {
	return me.Err.Error()
}



================================================
FILE: requester/uploader/example.go
================================================
package uploader

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
)

// DoUpload æ‰§è¡Œä¸Šä¼ 
func DoUpload(uploadURL string, readerlen64 rio.ReaderLen64, checkFunc CheckFunc) {
	u := NewUploader(uploadURL, readerlen64)
	u.SetCheckFunc(checkFunc)

	exitChan := make(chan struct{})

	u.OnExecute(func() {
		statusChan := u.GetStatusChan()
		for {
			select {
			case <-exitChan:
				return
			case v, ok := <-statusChan:
				if !ok {
					return
				}

				fmt.Printf("\r â†‘ %s/%s %s/s in %s ............",
					converter.ConvertFileSize(v.Uploaded(), 2),
					converter.ConvertFileSize(v.TotalSize(), 2),
					converter.ConvertFileSize(v.SpeedsPerSecond(), 2),
					v.TimeElapsed(),
				)
			}
		}
	})

	u.Execute()
	close(exitChan)

	return
}



================================================
FILE: requester/uploader/instance_state.go
================================================
package uploader

import (
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
)

type (
	// BlockState æ–‡ä»¶åŒºå—ä¿¡æ¯
	BlockState struct {
		ID       int            `json:"id"`
		Range    transfer.Range `json:"range"`
		CheckSum string         `json:"checksum"`
	}

	// InstanceState ä¸Šä¼ æ–­ç‚¹ç»­ä¼ ä¿¡æ¯
	InstanceState struct {
		BlockList []*BlockState `json:"block_list"`
	}
)

func (muer *MultiUploader) getWorkerListByInstanceState(is *InstanceState) workerList {
	workers := make(workerList, 0, len(is.BlockList))
	for _, blockState := range is.BlockList {
		if blockState.CheckSum == "" {
			workers = append(workers, &worker{
				id:         blockState.ID,
				partOffset: blockState.Range.Begin,
				splitUnit:  NewBufioSplitUnit(muer.file, blockState.Range, muer.speedsStat, muer.rateLimit),
				checksum:   blockState.CheckSum,
			})
		} else {
			// å·²ç»å®Œæˆçš„, ä¹Ÿè¦åŠ å…¥ (å¯ç»§ç»­ä¼˜åŒ–)
			workers = append(workers, &worker{
				id:         blockState.ID,
				partOffset: blockState.Range.Begin,
				splitUnit: &fileBlock{
					readRange: blockState.Range,
					readed:    blockState.Range.End - blockState.Range.Begin,
					readerAt:  muer.file,
				},
				checksum: blockState.CheckSum,
			})
		}
	}
	return workers
}



================================================
FILE: requester/uploader/multiuploader.go
================================================
package uploader

import (
	"context"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio/speeds"
	"sync"
	"time"
)

type (
	// MultiUpload æ”¯æŒå¤šçº¿ç¨‹çš„ä¸Šä¼ , å¯ç”¨äºæ–­ç‚¹ç»­ä¼ 
	MultiUpload interface {
		Precreate() (perr error)
		TmpFile(ctx context.Context, partseq int, partOffset int64, readerlen64 rio.ReaderLen64) (checksum string, terr error)
		CreateSuperFile(checksumList ...string) (cerr error)
	}

	// MultiUploader å¤šçº¿ç¨‹ä¸Šä¼ 
	MultiUploader struct {
		onExecuteEvent      requester.Event        //å¼€å§‹ä¸Šä¼ äº‹ä»¶
		onSuccessEvent      requester.Event        //æˆåŠŸä¸Šä¼ äº‹ä»¶
		onFinishEvent       requester.Event        //ç»“æŸä¸Šä¼ äº‹ä»¶
		onCancelEvent       requester.Event        //å–æ¶ˆä¸Šä¼ äº‹ä»¶
		onErrorEvent        requester.EventOnError //ä¸Šä¼ å‡ºé”™äº‹ä»¶
		onUploadStatusEvent UploadStatusFunc       //ä¸Šä¼ çŠ¶æ€äº‹ä»¶

		instanceState *InstanceState

		multiUpload MultiUpload       // ä¸Šä¼ ä½“æ¥å£
		file        rio.ReaderAtLen64 // ä¸Šä¼ 
		config      *MultiUploaderConfig
		workers     workerList
		speedsStat  *speeds.Speeds
		rateLimit   *speeds.RateLimit

		executeTime             time.Time
		finished                chan struct{}
		canceled                chan struct{}
		closeCanceledOnce       sync.Once
		updateInstanceStateChan chan struct{}
	}

	// MultiUploaderConfig å¤šçº¿ç¨‹ä¸Šä¼ é…ç½®
	MultiUploaderConfig struct {
		Parallel  int   // ä¸Šä¼ å¹¶å‘é‡
		BlockSize int64 // ä¸Šä¼ åˆ†å—
		MaxRate   int64 // é™åˆ¶æœ€å¤§ä¸Šä¼ é€Ÿåº¦
	}
)

// NewMultiUploader åˆå§‹åŒ–ä¸Šä¼ 
func NewMultiUploader(multiUpload MultiUpload, file rio.ReaderAtLen64, config *MultiUploaderConfig) *MultiUploader {
	return &MultiUploader{
		multiUpload: multiUpload,
		file:        file,
		config:      config,
	}
}

// SetInstanceState è®¾ç½®InstanceState, æ–­ç‚¹ç»­ä¼ ä¿¡æ¯
func (muer *MultiUploader) SetInstanceState(is *InstanceState) {
	muer.instanceState = is
}

func (muer *MultiUploader) lazyInit() {
	if muer.finished == nil {
		muer.finished = make(chan struct{}, 1)
	}
	if muer.canceled == nil {
		muer.canceled = make(chan struct{})
	}
	if muer.updateInstanceStateChan == nil {
		muer.updateInstanceStateChan = make(chan struct{}, 1)
	}
	if muer.config == nil {
		muer.config = &MultiUploaderConfig{}
	}
	if muer.config.Parallel <= 0 {
		muer.config.Parallel = 4
	}
	if muer.config.BlockSize <= 0 {
		muer.config.BlockSize = 1 * converter.GB
	}
	if muer.speedsStat == nil {
		muer.speedsStat = &speeds.Speeds{}
	}
}

func (muer *MultiUploader) check() {
	if muer.file == nil {
		panic("file is nil")
	}
	if muer.multiUpload == nil {
		panic("multiUpload is nil")
	}
}

// Execute æ‰§è¡Œä¸Šä¼ 
func (muer *MultiUploader) Execute() {
	muer.check()
	muer.lazyInit()

	// åˆå§‹åŒ–é™é€Ÿ
	if muer.config.MaxRate > 0 {
		muer.rateLimit = speeds.NewRateLimit(muer.config.MaxRate)
		defer muer.rateLimit.Stop()
	}

	// åˆ†é…ä»»åŠ¡
	if muer.instanceState != nil {
		muer.workers = muer.getWorkerListByInstanceState(muer.instanceState)
		uploaderVerbose.Infof("upload task CREATED from instance state\n")
	} else {
		muer.workers = muer.getWorkerListByInstanceState(&InstanceState{
			BlockList: SplitBlock(muer.file.Len(), muer.config.BlockSize),
		})

		uploaderVerbose.Infof("upload task CREATED: block size: %d, num: %d\n", muer.config.BlockSize, len(muer.workers))
	}

	// å¼€å§‹ä¸Šä¼ 
	muer.executeTime = time.Now()
	pcsutil.Trigger(muer.onExecuteEvent)

	muer.uploadStatusEvent()

	err := muer.upload()

	// å®Œæˆ
	muer.finished <- struct{}{}
	if err != nil {
		if err == context.Canceled {
			if muer.onCancelEvent != nil {
				muer.onCancelEvent()
			}
		} else if muer.onErrorEvent != nil {
			muer.onErrorEvent(err)
		}
	} else {
		pcsutil.TriggerOnSync(muer.onSuccessEvent)
	}
	pcsutil.TriggerOnSync(muer.onFinishEvent)
}

// InstanceState è¿”å›æ–­ç‚¹ç»­ä¼ ä¿¡æ¯
func (muer *MultiUploader) InstanceState() *InstanceState {
	blockStates := make([]*BlockState, 0, len(muer.workers))
	for _, wer := range muer.workers {
		blockStates = append(blockStates, &BlockState{
			ID:       wer.id,
			Range:    wer.splitUnit.Range(),
			CheckSum: wer.checksum,
		})
	}
	return &InstanceState{
		BlockList: blockStates,
	}
}

// Cancel å–æ¶ˆä¸Šä¼ 
func (muer *MultiUploader) Cancel() {
	close(muer.canceled)
}

//OnExecute è®¾ç½®å¼€å§‹ä¸Šä¼ äº‹ä»¶
func (muer *MultiUploader) OnExecute(onExecuteEvent requester.Event) {
	muer.onExecuteEvent = onExecuteEvent
}

//OnSuccess è®¾ç½®æˆåŠŸä¸Šä¼ äº‹ä»¶
func (muer *MultiUploader) OnSuccess(onSuccessEvent requester.Event) {
	muer.onSuccessEvent = onSuccessEvent
}

//OnFinish è®¾ç½®ç»“æŸä¸Šä¼ äº‹ä»¶
func (muer *MultiUploader) OnFinish(onFinishEvent requester.Event) {
	muer.onFinishEvent = onFinishEvent
}

//OnCancel è®¾ç½®å–æ¶ˆä¸Šä¼ äº‹ä»¶
func (muer *MultiUploader) OnCancel(onCancelEvent requester.Event) {
	muer.onCancelEvent = onCancelEvent
}

//OnError è®¾ç½®ä¸Šä¼ å‘ç”Ÿé”™è¯¯äº‹ä»¶
func (muer *MultiUploader) OnError(onErrorEvent requester.EventOnError) {
	muer.onErrorEvent = onErrorEvent
}

//OnUploadStatusEvent è®¾ç½®ä¸Šä¼ çŠ¶æ€äº‹ä»¶
func (muer *MultiUploader) OnUploadStatusEvent(f UploadStatusFunc) {
	muer.onUploadStatusEvent = f
}



================================================
FILE: requester/uploader/multiworker.go
================================================
package uploader

import (
	"context"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/waitgroup"
	"github.com/oleiade/lane"
	"os"
)

type (
	worker struct {
		id         int
		partOffset int64
		splitUnit  SplitUnit
		checksum   string
	}

	workerList []*worker
)

// CheckSumList è¿”å›æ‰€ä»¥workerçš„checksum
// TODO: å®ç°sort
func (werl *workerList) CheckSumList() []string {
	checksumList := make([]string, 0, len(*werl))
	for _, wer := range *werl {
		checksumList = append(checksumList, wer.checksum)
	}
	return checksumList
}

func (werl *workerList) Readed() int64 {
	var readed int64
	for _, wer := range *werl {
		readed += wer.splitUnit.Readed()
	}
	return readed
}

func (muer *MultiUploader) upload() (uperr error) {
	err := muer.multiUpload.Precreate()
	if err != nil {
		return err
	}

	var (
		uploadDeque = lane.NewDeque()
	)

	// åŠ å…¥é˜Ÿåˆ—
	for _, wer := range muer.workers {
		if wer.checksum == "" {
			uploadDeque.Append(wer)
		}
	}

	for {
		wg := waitgroup.NewWaitGroup(muer.config.Parallel)
		for {
			e := uploadDeque.Shift()
			if e == nil { // ä»»åŠ¡ä¸ºç©º
				break
			}

			wer := e.(*worker)
			wg.AddDelta()
			go func() {
				defer wg.Done()

				var (
					ctx, cancel = context.WithCancel(context.Background())
					doneChan    = make(chan struct{})
					checksum    string
					terr        error
				)
				go func() {
					checksum, terr = muer.multiUpload.TmpFile(ctx, int(wer.id), wer.partOffset, wer.splitUnit)
					close(doneChan)
				}()
				select {
				case <-muer.canceled:
					cancel()
					return
				case <-doneChan:
					// continue
				}
				cancel()
				if terr != nil {
					if me, ok := terr.(*MultiError); ok {
						if me.Terminated { // ç»ˆæ­¢
							muer.closeCanceledOnce.Do(func() { // åªå…³é—­ä¸€æ¬¡
								close(muer.canceled)
							})
							uperr = me.Err
							return
						}
					}

					uploaderVerbose.Warnf("upload err: %s, id: %d\n", terr, wer.id)
					wer.splitUnit.Seek(0, os.SEEK_SET)
					uploadDeque.Append(wer)
					return
				}
				wer.checksum = checksum

				// é€šçŸ¥æ›´æ–°
				if muer.updateInstanceStateChan != nil && len(muer.updateInstanceStateChan) < cap(muer.updateInstanceStateChan) {
					muer.updateInstanceStateChan <- struct{}{}
				}
			}()
		}
		wg.Wait()

		// æ²¡æœ‰ä»»åŠ¡äº†
		if uploadDeque.Size() == 0 {
			break
		}
	}

	select {
	case <-muer.canceled:
		if uperr != nil {
			return uperr
		}
		return context.Canceled
	default:
	}

	cerr := muer.multiUpload.CreateSuperFile(muer.workers.CheckSumList()...)
	if cerr != nil {
		return cerr
	}

	return
}



================================================
FILE: requester/uploader/readed.go
================================================
package uploader

import (
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"sync/atomic"
)

type (
	// Readed64 å¢åŠ è·å–å·²è¯»å–æ•°æ®é‡, ç”¨äºç»Ÿè®¡é€Ÿåº¦
	Readed64 interface {
		rio.ReaderLen64
		Readed() int64
	}

	readed64 struct {
		readed int64
		rio.ReaderLen64
	}
)

// NewReaded64 å®ç°Readed64æ¥å£
func NewReaded64(rl rio.ReaderLen64) Readed64 {
	return &readed64{
		readed:      0,
		ReaderLen64: rl,
	}
}

func (r64 *readed64) Read(p []byte) (n int, err error) {
	n, err = r64.ReaderLen64.Read(p)
	atomic.AddInt64(&r64.readed, int64(n))
	return n, err
}

func (r64 *readed64) Readed() int64 {
	return atomic.LoadInt64(&r64.readed)
}



================================================
FILE: requester/uploader/status.go
================================================
package uploader

import (
	"time"
)

type (
	// Status ä¸Šä¼ çŠ¶æ€æ¥å£
	Status interface {
		TotalSize() int64           // æ€»å¤§å°
		Uploaded() int64            // å·²ä¸Šä¼ æ•°æ®
		SpeedsPerSecond() int64     // æ¯ç§’çš„ä¸Šä¼ é€Ÿåº¦
		TimeElapsed() time.Duration // ä¸Šä¼ æ—¶é—´
	}

	// UploadStatus ä¸Šä¼ çŠ¶æ€
	UploadStatus struct {
		totalSize       int64         // æ€»å¤§å°
		uploaded        int64         // å·²ä¸Šä¼ æ•°æ®
		speedsPerSecond int64         // æ¯ç§’çš„ä¸Šä¼ é€Ÿåº¦
		timeElapsed     time.Duration // ä¸Šä¼ æ—¶é—´
	}

	UploadStatusFunc func(status Status, updateChan <-chan struct{})
)

// TotalSize è¿”å›æ€»å¤§å°
func (us *UploadStatus) TotalSize() int64 {
	return us.totalSize
}

// Uploaded è¿”å›å·²ä¸Šä¼ æ•°æ®
func (us *UploadStatus) Uploaded() int64 {
	return us.uploaded
}

// SpeedsPerSecond è¿”å›æ¯ç§’çš„ä¸Šä¼ é€Ÿåº¦
func (us *UploadStatus) SpeedsPerSecond() int64 {
	return us.speedsPerSecond
}

// TimeElapsed è¿”å›ä¸Šä¼ æ—¶é—´
func (us *UploadStatus) TimeElapsed() time.Duration {
	return us.timeElapsed
}

// GetStatusChan è·å–ä¸Šä¼ çŠ¶æ€
func (u *Uploader) GetStatusChan() <-chan Status {
	c := make(chan Status)

	go func() {
		for {
			select {
			case <-u.finished:
				close(c)
				return
			default:
				if !u.executed {
					time.Sleep(1 * time.Second)
					continue
				}

				old := u.readed64.Readed()
				time.Sleep(1 * time.Second) // æ¯ç§’ç»Ÿè®¡

				readed := u.readed64.Readed()
				c <- &UploadStatus{
					totalSize:       u.readed64.Len(),
					uploaded:        readed,
					speedsPerSecond: readed - old,
					timeElapsed:     time.Since(u.executeTime) / 1e7 * 1e7,
				}
			}
		}
	}()
	return c
}

func (muer *MultiUploader) uploadStatusEvent() {
	if muer.onUploadStatusEvent == nil {
		return
	}

	go func() {
		ticker := time.NewTicker(1 * time.Second) // æ¯ç§’ç»Ÿè®¡
		defer ticker.Stop()
		for {
			select {
			case <-muer.finished:
				return
			case <-ticker.C:
				readed := muer.workers.Readed()
				muer.onUploadStatusEvent(&UploadStatus{
					totalSize:       muer.file.Len(),
					uploaded:        readed,
					speedsPerSecond: muer.speedsStat.GetSpeeds(),
					timeElapsed:     time.Since(muer.executeTime) / 1e8 * 1e8,
				}, muer.updateInstanceStateChan)
			}
		}
	}()
}



================================================
FILE: requester/uploader/uploader.go
================================================
// Package uploader ä¸Šä¼ åŒ…
package uploader

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"net/http"
	"time"
)

const (
	// BufioReadSize bufio ç¼“å†²åŒºå¤§å°, ç”¨äºä¸Šä¼ æ—¶è¯»å–æ–‡ä»¶
	BufioReadSize = int(64 * converter.KB) // 64KB
)

type (
	//CheckFunc ä¸Šä¼ å®Œæˆçš„æ£€æµ‹å‡½æ•°
	CheckFunc func(resp *http.Response, uploadErr error)

	// Uploader ä¸Šä¼ 
	Uploader struct {
		url         string   // ä¸Šä¼ åœ°å€
		readed64    Readed64 // è¦ä¸Šä¼ çš„å¯¹è±¡
		contentType string

		client *requester.HTTPClient

		executeTime time.Time
		executed    bool
		finished    chan struct{}

		checkFunc CheckFunc
		onExecute func()
		onFinish  func()
	}
)

var (
	uploaderVerbose = pcsverbose.New("UPLOADER")
)

// NewUploader è¿”å› uploader å¯¹è±¡, url: ä¸Šä¼ åœ°å€, readerlen64: å®ç° rio.ReaderLen64 æ¥å£çš„å¯¹è±¡, ä¾‹å¦‚æ–‡ä»¶
func NewUploader(url string, readerlen64 rio.ReaderLen64) (uploader *Uploader) {
	uploader = &Uploader{
		url:      url,
		readed64: NewReaded64(readerlen64),
	}

	return
}

func (u *Uploader) lazyInit() {
	if u.finished == nil {
		u.finished = make(chan struct{})
	}
	if u.client == nil {
		u.client = requester.NewHTTPClient()
	}
	u.client.SetTimeout(0)
	u.client.SetResponseHeaderTimeout(0)
}

// SetClient è®¾ç½®httpå®¢æˆ·ç«¯
func (u *Uploader) SetClient(c *requester.HTTPClient) {
	u.client = c
}

//SetContentType è®¾ç½®Content-Type
func (u *Uploader) SetContentType(contentType string) {
	u.contentType = contentType
}

//SetCheckFunc è®¾ç½®ä¸Šä¼ å®Œæˆçš„æ£€æµ‹å‡½æ•°
func (u *Uploader) SetCheckFunc(checkFunc CheckFunc) {
	u.checkFunc = checkFunc
}

// Execute æ‰§è¡Œä¸Šä¼ , æ”¶åˆ°è¿”å›å€¼ä¿¡å·åˆ™ä¸ºä¸Šä¼ ç»“æŸ
func (u *Uploader) Execute() {
	pcsutil.Trigger(u.onExecute)

	// å¼€å§‹ä¸Šä¼ 
	u.executeTime = time.Now()
	u.executed = true
	resp, _, err := u.execute()

	// ä¸Šä¼ ç»“æŸ
	close(u.finished)

	if u.checkFunc != nil {
		u.checkFunc(resp, err)
	}

	pcsutil.Trigger(u.onFinish) // è§¦å‘ä¸Šä¼ ç»“æŸçš„äº‹ä»¶
}

func (u *Uploader) execute() (resp *http.Response, code int, err error) {
	u.lazyInit()
	header := map[string]string{}
	if u.contentType != "" {
		header["Content-Type"] = u.contentType
	}

	resp, err = u.client.Req(http.MethodPost, u.url, u.readed64, header)
	if err != nil {
		return nil, 2, err
	}

	return resp, 0, nil
}

// OnExecute ä»»åŠ¡å¼€å§‹æ—¶è§¦å‘çš„äº‹ä»¶
func (u *Uploader) OnExecute(fn func()) {
	u.onExecute = fn
}

// OnFinish ä»»åŠ¡å®Œæˆæ—¶è§¦å‘çš„äº‹ä»¶
func (u *Uploader) OnFinish(fn func()) {
	u.onFinish = fn
}



================================================
FILE: .github/RELEASE_TEMPLATE.md
================================================
# æ›´æ–°æ—¥å¿—: 

1. ä¿®å¤æ–‡ä»¶md5æ˜¾ç¤ºé”™è¯¯
2. ä¿®å¤æ— æ³•ä¸Šä¼ 
3. ä¿®å¤åˆ†äº«åˆ—è¡¨è·å–ä¸åˆ°å¯†ç 
4. æ›´æ–°ä¸Šä¼ ã€ä¸‹è½½å¤„ç†æµç¨‹ï¼Œä¼˜åŒ–é‡è¯•çš„åˆ¤æ–­æ¡ä»¶
5. æ›´æ–°downloadå‘½ä»¤, ç§»é™¤ä¹‹å‰çš„-stream -share -locateç­‰å‚æ•°ï¼Œæ–°å¢-modeå‚æ•°, è®¾ç½®ä¸‹è½½æ¨¡å¼
6. æ›´æ–°é»˜è®¤çš„ä¸‹è½½æ¨¡å¼modeä¸ºlocate, å‚è§ [#858](https://github.com/iikira/BaiduPCS-Go/issues/858)
7. ç§»é™¤åå°ä¸‹è½½(bg)åŠŸèƒ½

ä¸ªäººé¡¹ç›®bugåœ¨æ‰€éš¾å…! æ¬¢è¿æ issue å’Œ pull request!!.

# ä¸‹è½½è¯´æ˜

## è§£é‡Š CPUæ¶æ„

|amd|arm| mips| è¯´æ˜ |
|-----|----------------|------------------|------------------|
|amd64, x64 |arm64   | mips64, mips64le |é€‚ç”¨äº64ä½CPUæˆ–æ“ä½œç³»ç»Ÿçš„è®¡ç®—æœº|
|386, x86 |armv5, armv7  | mips, mipsle |é€‚ç”¨äº32ä½CPUæˆ–æ“ä½œç³»ç»Ÿçš„è®¡ç®—æœº|

## æ³¨æ„åŒºåˆ« `arm` å’Œ `amd`, ä¸è¦æé”™äº†!!!!

## ä¸‹è½½

* PC/ç”µè„‘: 
    è¯·é€‰æ‹©å¯¹åº”çš„ç³»ç»Ÿ (windows, linux, darwin(è‹¹æœç³»ç»Ÿ), freebsd), å¯¹åº”çš„CPUæ¶æ„ (ä¸€èˆ¬æƒ…å†µä¸‹æ˜¯ amd), å¯¹åº”çš„CPUæˆ–æ“ä½œç³»ç»Ÿä½æ•° (è¯¦è§ä¸Šè¡¨), ä¸‹è½½.

* Android: 
    é€‰æ‹©å¯¹åº”çš„CPUæ¶æ„ (ä¸€èˆ¬æƒ…å†µä¸‹æ˜¯ arm, é™¤äº†å°‘æ•°æ‰‹æœºçš„CPUæ¶æ„è¦é€‰ amd, ä¾‹å¦‚è”æƒ³K800, è”æƒ³K900ç­‰), å¯¹åº”çš„CPUæˆ–æ“ä½œç³»ç»Ÿä½æ•°  (è¯¦è§ä¸Šè¡¨), ä¸‹è½½.

* iOS:
    æ— éœ€é€‰æ‹©CPUæ¶æ„ï¼Œé€‰æ‹© darwin-ios ä¸‹è½½è§£å‹åå³å¯ä½¿ç”¨. æ³¨æ„: armv7sæ¶æ„çš„è®¾å¤‡ (iPhone 5, iPhone 5c, iPad 4) æˆ– iOS ç³»ç»Ÿç‰ˆæœ¬ä½äº5.0, å¯èƒ½æ— æ³•æ­£å¸¸è¿è¡Œ.

## æ³¨æ„

Android 5.0 ä»¥ä¸Šçš„è®¾å¤‡è¯·ä¸è¦ä¸‹è½½ä½¿ç”¨linuxç‰ˆæœ¬çš„, å¦åˆ™ç½‘ç»œè¯·æ±‚å¯èƒ½ä¼šå‡ºç°é—®é¢˜.

ç›¸å…³çš„å…³é”®è¯, å‡èƒ½åœ¨æ–‡ä»¶åä¸­æ‰¾åˆ°. 

æ–‡ä»¶æ ¼å¼å‡ä¸ºzipå‹ç¼©åŒ…æ ¼å¼, åˆ‡å‹¿æœªè§£å‹ç¨‹åºå°±ç›´æ¥è¿è¡Œ!! ç¨‹åºè§£å‹ä¹‹åæ‰å¯ä»¥æ­£å¸¸ä½¿ç”¨.
</file>

<file path="README.md">
# ç™¾åº¦ç½‘ç›˜åˆ†äº«èµ„æºç›´é“¾ä¸‹è½½ç³»ç»Ÿ

[![CI](https://github.com/yourusername/baidu-direct-link/workflows/CI/badge.svg)](https://github.com/yourusername/baidu-direct-link/actions)
[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)

## âœ¨ åŠŸèƒ½ç‰¹æ€§

- âœ… ä½¿ç”¨ç™¾åº¦å¼€æ”¾å¹³å° OAuth 2.0ï¼ˆå®‰å…¨åˆè§„ï¼‰
- âœ… è‡ªåŠ¨ Token ç®¡ç†ï¼ˆ30å¤©æœ‰æ•ˆæœŸï¼‰
- âœ… æ™ºèƒ½ç¼“å­˜ï¼ˆ8å°æ—¶é“¾æ¥æœ‰æ•ˆæœŸï¼‰
- âœ… å…¨å±€é™æµï¼ˆé˜²è´¦å·é£æ§ï¼‰
- âœ… å†…å­˜å ç”¨ < 200MB

## ğŸš€ å¿«é€Ÿå¼€å§‹

### 1. è·å–ç™¾åº¦å¼€æ”¾å¹³å°å‡­è¯

è®¿é—® https://pan.baidu.com/union/main/application/personal åˆ›å»ºåº”ç”¨

### 2. å®‰è£… Rust
</file>

<file path="share_page.html">
<!DOCTYPE html>
<html lang="en">
    <head>
        <script>window.host={"HOST_PAN":"pan.baidu.com","HOST_D_PCS":"d.pcs.baidu.com","HOST_C_PCS":"c.pcs.baidu.com","HOST_NEST":"yq01nest.pcs.baidu.com","HOST_PCS_DATA":"pcsdata.baidu.com","HOST_PCS":"pcs.baidu.com","HOST_BAIDU_PCS":"baidupcs.com","HOST_THUMBNAIL":"thumbnail.baidupcs.com","PASS_TPL":"netdisk","SOURCE_VALUE":"10"}</script>
        <title>æ•°å­¦åˆ†æ_å…è´¹é«˜é€Ÿä¸‹è½½|ç™¾åº¦ç½‘ç›˜-åˆ†äº«æ— é™åˆ¶</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
        <meta http-equiv="Cache-Control" content="max-age=30"/>
        <meta name="renderer" content="origin"/>
        <meta name="baidu-tc-verification" content="b31ebb7c3759312418b3645de4991aef"/>
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover"/>
        <meta name="keywords" content="ç½‘ç›˜,ç™¾åº¦ç½‘ç›˜,ç™¾åº¦äº‘,ç½‘ç»œUç›˜,ç½‘ç»œç¡¬ç›˜,å…è´¹ç½‘ç›˜,ç½‘ç›˜ä¸‹è½½,ç½‘ç›˜èµ„æº,åŒæ­¥,äº‘å­˜å‚¨,å¤–é“¾åˆ†äº«,ç¦»çº¿ä¸‹è½½"/>
        <meta name="description" content="ç™¾åº¦ç½‘ç›˜ä¸ºæ‚¨æä¾›æ–‡ä»¶çš„ç½‘ç»œå¤‡ä»½ã€åŒæ­¥å’Œåˆ†äº«æœåŠ¡ã€‚ç©ºé—´å¤§ã€é€Ÿåº¦å¿«ã€å®‰å…¨ç¨³å›ºï¼Œæ”¯æŒæ•™è‚²ç½‘åŠ é€Ÿï¼Œæ”¯æŒæ‰‹æœºç«¯ã€‚æ³¨å†Œä½¿ç”¨ç™¾åº¦ç½‘ç›˜å³å¯äº«å—å…è´¹å­˜å‚¨ç©ºé—´"/>
        <link rel="dns-prefetch" href="//pcs.baidu.com"/>
        <link rel="dns-prefetch" href="//pcsdata.baidu.com"/>
        <link rel="dns-prefetch" href="//passport.baidu.com"/>
        <link rel="dns-prefetch" href="//yun.baidu.com"/>
        <link rel="dns-prefetch" href="//d.pcs.baidu.com"/>
        <link rel="dns-prefetch" href="//c.pcs.baidu.com"/>
        <link rel="dns-prefetch" href="//webpush.pan.baidu.com"/>
        <link rel="dns-prefetch" href="//hm.baidu.com"/>
        <link rel="shortcut icon" type="image/x-icon" href="/m-static/base/static/images/favicon.ico"/>
        <style>
            html{font-feature-settings:"lnum";-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,textarea,select,optgroup,option,fieldset,legend,p,blockquote,th,td{margin:0;padding:0}body{background:#fff;font-family:PingFangSC-Regular,"Helvetica Neue",Helvetica,Arial,sans-serif,"Microsoft YaHei"}fieldset,img{border:0}ul,li,ol{list-style:none}h1,h2,h3,h4,h5,h6{font-size:100%}legend{color:#000}input,button,textarea,select,optgroup,option{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit}input,button,select{margin:0;*font-size:100%;line-height:1.2}a{color:#09AAFF;text-decoration:none}a img,img{-ms-interpolation-mode:bicubic}a:hover,a:active,a:focus{color:#0098EA;text-decoration:underline}table{border-collapse:collapse;border-spacing:0}header,aside,section{display:block}input::-ms-clear{display:none}#TANGRAM__PSP_10__qrcode .tips{margin-top:10px;text-align:center;font-size:12px;color:#999}p.Qrcode-status-animation{background:url(https://nd-static.bdstatic.com/m-static/base/static/images/app-intr-bg_99e9d55.png) no-repeat center}.tang-pass-pop-login .tang-pass-qrcode .tips{text-align:center}.nd-tang-pass-v4 .pass-login-pop-content{border-radius:0!important}.tang-pass-pop-login div.tang-title{height:0!important}.tang-pass-pop-login .pass-login-pop-form{padding-top:20px}body,button,input,select,textarea{font-size:12px;line-height:1.5;color:#666}a{color:#09AAFF;text-decoration:none;outline:0}a:hover,a:active,a:focus{color:#0098EA;text-decoration:underline}.global-clearfix:after,.g-clearfix:after{content:'.';display:block;visibility:hidden;height:0;line-height:0;font-size:0;clear:both}.global-clearfix,.g-clearfix{zoom:1}.global-clear,.g-clear{clear:both}.global-hide,.g-hide{display:none}.global-bold,.g-bold{font-weight:700}.global-center,.g-center{text-align:center}.global-float-left,.g-float-left{float:left}.global-float-right,.g-float-right{float:right}.global-ellipsis,.g-ellipsis{word-break:break-all;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.global-disabled,.global-disabled:hover,.global-disabled:active,.g-disabled,.g-disabled:hover,.g-disabled:active{filter:alpha(opacity=50);-ms-filter:"alpha(opacity=50)";opacity:.5;color:#ccc;cursor:default!important}.global-border-radius-3,.g-border-radius-3{-moz-border-radius:3px;-webkit-border-radius:3px;border-radius:3px}.global-box-shadow,.g-box-shadow{-moz-box-shadow:1px 2px 5px rgba(0,0,0,.5);-webkit-box-shadow:1px 2px 5px rgba(0,0,0,.5);box-shadow:1px 2px 5px rgba(0,0,0,.5)}
        </style>
        
    <script>
        if (window.performance && window.performance.now && typeof window.performance.now === 'function') {
            window.__perf_white_screen = performance.now();
        }
    </script>
    <!--[if !IE]><!-->
    <script type="text/javascript" src="https://staticiot.cdn.bcebos.com/union/badjs-sdk-min-2.0.1.js"></script>
    <!--<![endif]-->
    <script type="text/javascript" src="https://staticiot.cdn.bcebos.com/union/bpdatajs-sdk-min-1.3.3.js"></script>
    <script>
        if (window.BadJs) {
            var HOST_PAN = ((window.host && window.host.HOST_PAN) || 'pan.baidu.com');
            window.BadSDK = new BadJs({
                host: 'https://' + HOST_PAN, path: '/bpapi/analytics', namespace: 'netdisk_share',
                productId: '100710', rules: {path: true, hash: false}, clienttype: 0, promiseError: false,
                vueError: false, env: window, downgrade: {
                    error: {p2: [/Script error/, /chrome-extension/, /moz-extension/]},
                    resource: {p2: [/hm.baidu.com/, /webpush.pan.baidu.com/]}}
            });
        }
    </script>
    <script>
        if (window.BpData) {
            window.BpDataInstance = new BpData({
                serverId: 13328,
                from: 'main',
                page: 'share_common_page',
                parasitifer: 'web'
            })
        }
    </script>
    
    
    
    
    
    
    


    <link rel="stylesheet" href="https://nd-static.bdstatic.com/m-static/system-core/pkg/context-all_aba8f5b.css" /><link rel="stylesheet" href="https://nd-static.bdstatic.com/m-static/disk-share/css/cover_8d02d44.css" /><link rel="stylesheet" href="https://nd-static.bdstatic.com/m-static/disk-share/css/layout/layout2-1_515d387.css" /><link rel="stylesheet" href="https://nd-static.bdstatic.com/m-static/disk-share/pkg/singleNew-all_f0364d1.css" /><link rel="stylesheet" href="https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/videoPlay-all_b50fdf1.css" /><link rel="stylesheet" href="https://nd-static.bdstatic.com/m-static/disk-share/pkg/single-all_0478c8b.css" /><link rel="stylesheet" href="https://nd-static.bdstatic.com/m-static/disk-share/pkg/multiNew-all_c7692bc.css" /><link rel="stylesheet" href="https://nd-static.bdstatic.com/m-static/disk-share/pkg/multi-all_fd2eb72.css" /></head>
    
    <script>
        eval(decodeURIComponent('function%20fn%28a%29%7Bwindow.jsToken%20%3D%20a%7D%3Bfn%28%225BE077ABB8D3D94FD5868211CCFAFF1CCC981445B72F4690E7FDB74165B183F9FE91129FCC8FBF809F7A8D5BD73D4BE2%22%29'))
    </script>
    
    <body >
        
    

    
    <style>.icon-qrCode-gray{background:url(https://nd-static.bdstatic.com/m-static/disk-share/widget/plugin/qrCode/img/qrCode-gray-default_0713026.png?__sprite) center no-repeat}.g-button:hover .icon-qrCode-gray{background:url(https://nd-static.bdstatic.com/m-static/disk-share/widget/plugin/qrCode/img/qrCode-gray-hover_2cb8c84.png?__sprite) center no-repeat}.icon-shareSave-gray{background:url(https://nd-static.bdstatic.com/m-static/disk-share/widget/plugin/shareFileSave/img/shareSave-gray-default_1e32df2.png?__sprite) center no-repeat}.g-button:hover .icon-shareSave-gray{background:url(https://nd-static.bdstatic.com/m-static/disk-share/widget/plugin/shareFileSave/img/shareSave-gray-hover_43ad6aa.png?__sprite) center no-repeat}.icon-shareSave-white{background:url(https://nd-static.bdstatic.com/m-static/disk-share/widget/plugin/shareFileSave/img/shareSave-white-default_3477e0e.png?__sprite) center no-repeat}.g-button:hover .icon-shareSave-white{background:url(https://nd-static.bdstatic.com/m-static/disk-share/widget/plugin/shareFileSave/img/shareSave-white-hover_3477e0e.png?__sprite) center no-repeat}.icon-shareSave-blue{background:url(https://nd-static.bdstatic.com/m-static/disk-share/widget/plugin/shareFileSave/img/shareSave-blue-default_005ff9d.png?__sprite) center no-repeat}.g-button:hover .icon-shareSave-blue{background:url(https://nd-static.bdstatic.com/m-static/disk-share/widget/plugin/shareFileSave/img/shareSave-blue-hover_43ad6aa.png?__sprite) center no-repeat}.icon-unlinkShare-gray{background:url(https://nd-static.bdstatic.com/m-static/disk-share/widget/plugin/unLinkShare/img/unlinkShare-gray-default_7d06e77.png?__sprite) center no-repeat}.g-button:hover .icon-unlinkShare-gray{background:url(https://nd-static.bdstatic.com/m-static/disk-share/widget/plugin/unLinkShare/img/unlinkShare-gray-hover_3dff822.png?__sprite) center no-repeat}.fileicon-small-bt{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/BT_24_28214b3.png?__sprite) center no-repeat}.fileicon-large-bt{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/BT_54_23d058b.png) center no-repeat}.fileicon-middle-bt{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -440px -1px}.fileicon-small-dws{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/CAD_24_a226395.png?__sprite) center no-repeat}.fileicon-large-dws{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/CAD_54_7300372.png) center no-repeat}.fileicon-middle-dws{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -120px -51px}.fileicon-small-code{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Code_24_1193b7e.png?__sprite) center no-repeat}.fileicon-large-code{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Code_54_d20ce86.png) center no-repeat!important}.fileicon-small-txt{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Text_24_28fd206.png?__sprite) center no-repeat}.fileicon-large-txt{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Text_54_cd97e6a.png) center no-repeat}.fileicon-middle-txt{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -161px -1px}.fileicon-small-pdf{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/PDF_24_928dc9a.png?__sprite) center no-repeat}.fileicon-middle-pdf{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -41px -1px}.fileicon-large-pdf{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/PDF_54_85c3cb5.png) center no-repeat}.fileicon-small-doc{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Word_24_b91d37e.png?__sprite) center no-repeat}.fileicon-small-ppt{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/PPT_24_4112bb0.png?__sprite) center no-repeat}.fileicon-small-xls{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Excel_24_aa33358.png?__sprite) center no-repeat}.fileicon-large-doc{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Word_54_661a5bf.png) center no-repeat}.fileicon-large-ppt{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/PPT_54_0eb8805.png) center no-repeat}.fileicon-large-xls{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Excel_54_a923c0a.png) center no-repeat}.fileicon-middle-doc{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -81px -1px}.fileicon-middle-ppt{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -281px -1px}.fileicon-middle-xls{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -121px -1px}.fileicon-small-rtf{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/doc-small_25e59d6.png) center no-repeat}.fileicon-small-vsd{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Visio_24_24da2eb.png?__sprite) center no-repeat}.fileicon-middle-vsd{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -1px -1px}.fileicon-large-vsd{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Visio_54_bebd451.png) center no-repeat}.fileicon-small-pic{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Picture_24_942ff50.png?__sprite) center no-repeat}.fileicon-middle-pic{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -1px -51px}.fileicon-large-pic{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Picture_54_917a23a.png) center no-repeat}.fileicon-small-mmap{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/MMAP_24_6b87d2d.png?__sprite) center no-repeat}.fileicon-small-xmind{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Xmind_24_971f99f.png?__sprite) center no-repeat}.fileicon-small-mm{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/MM_24_ae6b4ef.png?__sprite) center no-repeat}.fileicon-large-mmap{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/MMAP_54_e279ee5.png) center no-repeat}.fileicon-large-xmind{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Xmind_54_42acd00.png) center no-repeat}.fileicon-large-mm{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/MM_54_6d94f94.png) center no-repeat}.fileicon-middle-mmap{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -161px -51px}.fileicon-middle-xmind{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -201px -51px}.fileicon-middle-mm{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -241px -51px}.fileicon-small-mp3{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Music_24_27ab88b.png?__sprite) center no-repeat}.fileicon-large-mp3{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Music_54_20bc900.png) center no-repeat}.icon-play-music{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/plugin-icon_c2f0235.png?__sprite) 0 -30px no-repeat}.g-button:hover .icon-play-music{background-position:-30px -30px}.fileicon-middle-mp3{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -201px -1px}.dialog.dialog2024{border-radius:12px}.dialog.dialog2024 .dialog-min-header,.dialog2024.dialog .dialog-header{background-color:#FFF;box-shadow:0 1px 0 0 #F1F3F8;border-bottom:0}.dialog.dialog2024 .dialog-header-title{color:#03081A;font-family:PingFang SC;font-size:14px;font-weight:500}.dialog.dialog2024 .dialog-body{font-family:PingFang SC;font-size:16px;font-weight:500;text-align:center;color:#030B1A}.dialog.dialog2024 .dialog-footer .g-button-blue{background-color:#f0faff!important;color:#06a7ff!important;font-weight:700;font-size:14px;border-radius:18px;border:0;position:relative;line-height:36px;height:36px}.dialog.dialog2024 .dialog-footer .g-button .g-button-right{height:36px;line-height:36px}.dialog.dialog2024 .dialog-footer .g-button-blue .g-button-right .text{color:#06a7ff!important}.dialog.dialog2024-new .select-text{height:48px}.dialog.dialog2024-new .dialog-footer a:last-child{box-sizing:border-box;width:128px;padding-left:29px!important}.dialog.dialog2024-new .dialog-footer .g-button-blue .g-button-right .text{color:#fff!important}.dialog.dialog2024 .dialog-footer .g-button .g-button-right .text{color:#fff}.dialog.dialog2024 .dialog-footer .g-button-blue.text{color:#06a7ff!important;font-family:PingFang SC;font-size:14px;font-weight:500}.dialog.dialog2024 .dialog-footer .g-button{background-color:#06a7ff;color:#fff;font-weight:700;font-size:14px;border-radius:18px;border:0;position:relative;line-height:36px;height:36px}.dialog.dialog2024 .dialog-footer .g-button:hover,.dialog.dialog2024 .dialog-footer .g-button:link,.dialog.dialog2024 .dialog-footer .g-button:visited{color:#0098EA!important}.dialog.dialog2024 .dialog-control{right:20px}.dialog.dialog2024 .dialog-control .icon-close{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/close-20_b432430.png) 100% 100% no-repeat;font-family:PingFang SC!important;width:16px;height:16px;background-size:cover}.dialog.dialog2024 .dialog-control .icon-close:before{content:none}.dialog.dialog2024 .dialog-header h3{text-indent:24px}.dialog.dialog2024-new .audio-inner-wrap{display:flex;justify-content:space-between;margin-top:-22px}.dialog.dialog2024-new .audio-inner-left,.dialog.dialog2024-new .audio-inner-right{background-color:rgba(247,249,252,1);width:300px;height:164px}.dialog.dialog2024-new .recommend{left:268px!important}.dialog.dialog2024-new .desc{color:#495366!important}.dialog.dialog2024-new .dialog-footer{position:absolute;padding:0 110px 32px;bottom:20px;left:50%;transform:translateX(-50%);display:flex;box-sizing:border-box}.dialog.dialog2024-new .dialog-footer .g-button:first-child{background-color:#0095FF!important;margin-right:184px}.dialog.dialog2024-new .dialog-footer .g-button,.dialog.dialog2024-new .dialog-footer .g-button-blue{background-color:#0095FF!important}.g-button:hover .icon-edit{background-position:-90px -27px}.default-small{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Misc_24_af08942.png?__sprite) center no-repeat}.dir-multi-small{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/listIcon_cfba575.png?__sprite) -120px -30px no-repeat}.dir-multi-middle{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/sprite_list_icon30_c092ae8.png?__sprite) -280px -50px no-repeat}.dir-small{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Folder_24_35f88d9.png?__sprite) center no-repeat}.dir-share-small{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Share_24_4875a10.png) center no-repeat}.dir-cang-small{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Collection_24_3d9b327.png?__sprite) center no-repeat}.dir-card-small{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/card_24_2f79e41.png) center no-repeat}.dir-source-small{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/source_24_ab9b274.png) center no-repeat}.dir-app-small,.dir-apps-small{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/MyData_24_a3a980f.png?__sprite) center no-repeat}.dir-backup-small{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/PC_24_5238f5e.png?__sprite) center no-repeat}.wp-small{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/wp26_7c0f175.png?__sprite) center no-repeat}.default-middle{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/sprite_list_icon30_c092ae8.png) -561px 0 no-repeat}.dir-middle{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/sprite_list_icon30_c092ae8.png) -202px -100px no-repeat}.dir-share-middle{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Share_30_d865728.png?__sprite) center no-repeat}.dir-cang-middle{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/sprite_list_icon30_c092ae8.png) -82px -100px no-repeat}.dir-app-middle,.dir-apps-middle{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/sprite_list_icon30_c092ae8.png) -2px -100px no-repeat}.dir-backup-middle{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/sprite_list_icon30_c092ae8.png) -122px -100px no-repeat}.default-large{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Misc_54_441d234.png) center no-repeat}.dir-large{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Folder_54_78c9568.png) center no-repeat}.dir-share-large{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Share_54_142956d.png) center no-repeat}.dir-cang-large{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Collection_54_7d61f0d.png) center no-repeat}.dir-card-large{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/card_54_25f7f47.png) center no-repeat}.dir-source-large{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/source_54_4c37fd2.png) center no-repeat}.dir-app-large,.dir-apps-large{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/MyData_54_500e8ec.png) center no-repeat}.dir-backup-large{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/PC_54_e16989b.png) center no-repeat}.dir-multi-large{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/gridIcon_1ca1cf0.png) -600px -100px no-repeat}.dir-phone-large{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Phone_54_7f262c3.png) center no-repeat}.dir-phone-small{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Phone_24_aab61ee.png?__sprite) center no-repeat}.wp-large{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/wp56_06d47eb.png?__sprite) center no-repeat}.fileicon-sys-s-exe{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/EXE_24_fb4c338.png?__sprite) center no-repeat}.fileicon-sys-s-apk{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Android_24_8d7683b.png?__sprite) center no-repeat}.fileicon-sys-s-psd{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/PS_24_45bd2e8.png?__sprite) center no-repeat}.fileicon-sys-s-key{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Keynote_24_7d5f799.png?__sprite) center no-repeat}.fileicon-sys-s-ai{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/AI_24_2fe3a26.png?__sprite) center no-repeat}.fileicon-sys-s-ipa{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Apple_24_2bc4a91.png?__sprite) center no-repeat}.fileicon-sys-s-vsd{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Visio_24_eb5acf4.png?__sprite) center no-repeat}.fileicon-sys-s-pages{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Pages_24_d779f70.png?__sprite) center no-repeat}.fileicon-sys-s-numbers{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Numbers_24_f017dd3.png?__sprite) center no-repeat}.fileicon-sys-s-fonts{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Fonts_24_2fb4683.png?__sprite) center no-repeat}.fileicon-sys-s-code{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Code_24_cbd51f7.png?__sprite) center no-repeat}.fileicon-sys-s-web{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Web_24_18700b5.png?__sprite) center no-repeat}.fileicon-sys-s-links{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Links_24_c800711.png?__sprite) center no-repeat}.fileicon-sys-s-eps{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/EPS_24_b0fd54a.png?__sprite) center no-repeat}.fileicon-sys-s-swf{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Flash_24_4a1cea7.png?__sprite) center no-repeat}.fileicon-sys-s-video{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Video_24_703ade3.png?__sprite) center no-repeat}.fileicon-sys-l-dmg,.fileicon-sys-l-exe{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/EXE_54_7d37e74.png) center no-repeat}.fileicon-sys-l-apk{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Android_54_daaaf00.png) center no-repeat}.fileicon-sys-l-psd{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/PS_54_53f38c4.png) center no-repeat}.fileicon-sys-l-key{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Keynote_54_0f6905d.png) center no-repeat}.fileicon-sys-l-ai{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/AI_54_b6553d9.png) center no-repeat}.fileicon-sys-l-vsd{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Visio_54_9948b72.png) center no-repeat}.fileicon-sys-l-ipa{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Apple_54_3f940b5.png) center no-repeat}.fileicon-sys-l-pages{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Pages_54_bf96030.png) center no-repeat}.fileicon-sys-l-numbers{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Numbers_54_397f8aa.png) center no-repeat}.fileicon-sys-l-fonts{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Fonts_54_31425f7.png) center no-repeat}.fileicon-sys-l-code{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Code_54_dc1557f.png) center no-repeat}.fileicon-sys-l-web{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Web_54_8b00f4d.png) center no-repeat}.fileicon-sys-l-links{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Links_54_de14a60.png) center no-repeat}.fileicon-sys-l-eps{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/EPS_54_7f8fbd3.png) center no-repeat}.fileicon-sys-l-swf{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Flash_54_ac112d6.png) center no-repeat}.fileicon-sys-l-video{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/sysIcon/img/Video_54_7e51352.png) center no-repeat}.fileicon-small-video{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Video_24_94bee9e.png?__sprite) center no-repeat}.fileicon-large-video{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/Video_54_6a69ad2.png) center no-repeat}.fileicon-middle-video{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -240px -1px}.fileicon-small-zip{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/ZIP_24_84f79a8.png?__sprite) center no-repeat}.fileicon-large-zip{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/ZIP_54_e01b06d.png) center no-repeat}.fileicon-small-rar{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/RAR_24_a5de267.png?__sprite) center no-repeat}.fileicon-large-rar{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/RAR_54_4314747.png) center no-repeat}.fileicon-middle-rar{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -319px -51px}.fileicon-middle-zip{background:url(https://nd-static.bdstatic.com/m-static/file-widget-1/common/middleListIcon_1d4103e.png) -41px -52px}.icon-online{background:url(https://nd-static.bdstatic.com/m-static/function-widget-1/device/img/device-online_f7d41b9.png) no-repeat}.icon-history-gray{background:url(https://nd-static.bdstatic.com/m-static/function-widget-1/common/plugin-icon_2d3430c.png) -30px -58px no-repeat}.g-button:hover .icon-history-gray{background-position:-30px -58px}.icon-aside-share{background:url(https://nd-static.bdstatic.com/m-static/function-widget-1/common/navigator_d6e02f4.png)}a:hover .icon-aside-share{background-position:-23px 0}.icon-print-gray{background:url(https://nd-static.bdstatic.com/m-static/function-widget-1/common/plugin-icon_2d3430c.png) -180px -28px no-repeat}.g-button:hover .icon-print-gray{background-position:-210px -28px}.icon-beautify-gray{background:url(https://nd-static.bdstatic.com/m-static/function-widget-1/common/plugin-icon_2d3430c.png) -60px -58px no-repeat}.g-button:hover .icon-beautify-gray{background-position:-90px -58px}.icon-puzzle-gray{background:url(https://nd-static.bdstatic.com/m-static/function-widget-1/common/plugin-icon_2d3430c.png) -120px -60px no-repeat}.g-button:hover .icon-puzzle-gray{background-position:-150px -60px}.icon-aside-recyclebin{background:url(https://nd-static.bdstatic.com/m-static/function-widget-1/common/navigator_d6e02f4.png) 0 -22px}a:hover .icon-aside-recyclebin{background-position:-23px -22px}.icon-share-gray{background:url(https://nd-static.bdstatic.com/m-static/function-widget-1/common/plugin-icon_2d3430c.png) -180px 0 no-repeat}.g-button:hover .icon-share-gray{background-position:-240px 0}.icon-share-blue{background:url(https://nd-static.bdstatic.com/m-static/function-widget-1/common/plugin-icon_2d3430c.png) -210px 0 no-repeat}.icon-share-blue:hover{background-position:-240px 0}.icon-aside-transfer.iconfont.icon{font-size:14px}</style>
    <div id="layoutApp" class="frame-all">
        <div id="layoutHeader">
            <div node-type="module" class="module-header" style="position: relative;z-index: 45 !important;">
                <div node-type="module-header-wrapper" class="module-header-wrapper" style="height: 62px;position:relative;"></div>
            </div>
        </div>
        <div id="bd" class="global-clearfix">
            <div id="bd-main">
                <div class="bd-left">
                     
    <div node-type="module" class="module-share-header">

    <div class="slide-show-header clearfix">
        <div class="slide-show-left">
            <h2 class="file-name" title="æ–‡ä»¶å">
                <em class="global-icon-16"></em> æ–‡ä»¶å
            </h2>
        </div>
        <div class="slide-show-center">
             <div class="subscribe-btn">
                <em class="icon noicon pdr3px noicon-dingyue" title="è®¢é˜…é“¾æ¥"></em>è®¢é˜…é“¾æ¥
            </div>
            <div class="subscribe-tips">è®¢é˜…åé“¾æ¥å†…å®¹æ›´æ–°æ—¶æ‚¨å°†æ”¶åˆ°å®æ—¶é€šçŸ¥</div>
        </div>
        <div class="slide-show-right">
            <span class="slide-header-funcs">
            </span>
            <div class="module-share-top-bar g-clearfix">
                <div class="bar"></div>
            </div>
        </div>
        <div class="cb"></div>
        <div class="slide-show-other-infos" style="margin-top: 3px !important;">
            <div class="share-file-info" style="padding-left: 20px !important;;">
                <span>2015-06-28 17:49</span>
            </div>
             <div class="risk-label" >
                <div class="risk-tooltip" >
                    <div class="risk-tooltip-inner">
                        éƒ¨åˆ†æ–‡ä»¶è¿è§„ï¼Œå·²è¢«è¿‡æ»¤
                    </div>
                </div>
            </div>
            
                
                    <div class="share-valid-check">è¿‡æœŸæ—¶é—´ï¼šæ°¸ä¹…æœ‰æ•ˆ</div>
                
            
            <div class="cert-user-share-list">æ¥è‡ªä¼ä¸šçš„åˆ†äº«</div>
            <div class="cert-user-share-bind-info">
                <span class="cert-user-share-bind-info-head"></span>
                <span class="cert-user-share-bind-info-tail">å·²å¤±æ•ˆ</span>
            </div>
            <div class="verify-user-protect-share-list icon icon-share-lock" style="display: none">
                <span class="verify-user-protect-share-list-text">å¯†äº«</span>
            </div>
            

            <div class="slide-show-other-cns clearfix">
              <span class="title-funcs">
                  
                   <span class="funcs-share-area">
                   </span>
              </span>
            </div>

            <div class="cb"></div>

        </div>
    </div>
</div>

                    
    <div class="share-list" id="shareqr">
        <div class="module-toolbar g-clearfix">
    <div class="default-dom">
        <div class="list-grid-switch list-switched-on">
            <a class="list-switch" href="javascript:void(0)" node-type="sypnkVRo" style="display:none"></a>
            <a class="grid-switch" href="javascript:void(0)" node-type="ecwDEG"></a>
        </div>
    </div>
    <div class="after-dom"></div>
    <div class="user-dom">
    </div>
</div>


<!--[if IE]><iframe id="historyIFrameEmulator" style="display: none"></iframe><![endif]-->
<div node-type="KPDwCE" class="KPDwCE">

</div>
    </div>
    <div class="ad-platform-tips ad-multi-tips" node-type="share-mutil-bottom" id="web-multi-bottom" node-id="web-sharemultibanner">
        <div style="margin: 0 auto; width: 960px;" id="cpro_u2164871"></div>
    </div>
    
    

                </div>
            </div>
            
                <div class="bd-aside">
            
            <div class="cert-top-banner"></div>
<div node-type="module" class="module-share-person-info false">
    <div class="share-person-inner global-clearfix haha">
        <div class="share-person-avatar theme-share-page-head">
            
                <a href="//yun.baidu.com/buy/center?tag=1&from=sicon" class="unvip-icon sicon"><em></em></a>
            
            <a href="javascript:void(0)" title="å»Taçš„åˆ†äº«ä¸»é¡µ" class="person-icon">
                <img class="theme-share-page-head" alt="å¶å°”**å¸–å­" src="https://himg.bdimg.com/sys/portrait/item/public.1.ecf025aa.o97DTSwCGWOcCYB8iDA9tQ.jpg">
                <span class="cert-info"></span>
            </a>
        </div>
        <div class="share-person-data self">
            <div class="share-person-data-top">
                <a href="javascript:;" class="share-person-username global-ellipsis theme-share-page-name">
                    å¶å°”**å¸–å­
                </a>
                
                <a href="//yun.baidu.com/buy/center?tag=1&from=sicon" class="unvip-icon sicon"><em></em></a>
                
            </div>
        </div>
         
        <div class="author-desc">
            <div class="author-intro theme-share-page-name">æš‚æ— ç­¾å</div>
        </div>
        <div class="enterprise-info">
            <span class="from-info"></span>
        </div>
        <div class="enterprise-memo">
            <span class="memo-info"></span>
        </div>
        <div class="enterprise-follow">
            <div class="btn follow" role="button">å…³æ³¨</div>
            <div class="btn go-im" role="button">
                <a class="" role="button" target="_blank" href="" title="å‘æ¶ˆæ¯">
                    å‘æ¶ˆæ¯
                </a>
            </div>
            <div class="text not-open-im">è¯¥ä¼ä¸šæœªå¼€é€šä¼ä¸šå·</div>
        </div>
        <div class="enterprise-card">
            <!-- ä¼ä¸šåç‰‡ -->
            <div class="ent-card ent-card-detail">
                <div class="e-row phone">
                    <div class="left">
                      <i class="icon phone"></i>
                      <input class="value ent-phone-value" value="" disabled />
                    </div>
                    <div class="btn ent-phone-copy" role="button">å¤åˆ¶</div>
                </div>
                <div class="e-row email">
                    <div class="left">
                      <i class="icon email"></i>
                      <input class="value ent-email-value" value="" disabled />
                    </div>
                    <div class="btn ent-email-copy" role="button">å¤åˆ¶</div>
                </div>
                <div class="e-row address">
                    <div class="left">
                      <i class="icon address"></i>
                      <input class="value ent-address-value" value="" disabled />
                    </div>
                    <div class="btn ent-address-copy" role="button">å¤åˆ¶</div>
                </div>
            </div>
            <!-- å‘˜å·¥åç‰‡ -->
            <div class="staff-card staff-card-detail">
                <div class="e-row phone">
                    <div class="left">
                      <i class="icon phone"></i>
                      <input class="value staff-phone-value" value="" disabled />
                    </div>
                    <div class="btn staff-phone-copy" role="button">å¤åˆ¶</div>
                </div>
                <div class="e-row wechat">
                    <div class="left">
                      <i class="icon wechat"></i>
                      <input class="value staff-wechat-value" value="" disabled />
                    </div>
                    <div class="btn staff-wechat-copy" role="button">å¤åˆ¶</div>
                </div>
                <div class="e-row email">
                    <div class="left">
                      <i class="icon email"></i>
                      <input class="value staff-email-value" value="" disabled />
                    </div>
                    <div class="btn staff-email-copy" role="button">å¤åˆ¶</div>
                </div>
            </div>
        </div>
        <div class="share-person-certinfo">
            <a target="_blank" href="https://pan.baidu.com/disk/cert/#/web/home?from=sharelist" title="äº†è§£ä¼ä¸šè®¤è¯">
                <span>äº†è§£ä¼ä¸šè®¤è¯</span>
            </a>
        </div>
        
        
        
            <div class="verify-friend theme-share-page-name-hover">åŠ ä¸ºå¥½å‹</div>
        
    </div>
    <ul class="share-person-numbers" node-type="share-person-numbers">
        <li class="sharecnt">
            <a href="/share/home?uk=124137116&suk=&view=share">
                <em title="<%= data.pubshare_count %>"><%= data.pubshare_count %></em><span>åˆ†äº«</span>
            </a>
        </li>
        <li class="albumcnt">
            <a href="/share/home?uk=124137116&suk=&view=album">
                <em title="<%= data.album_count %>"><%= data.album_count %></em><span>ä¸“è¾‘</span>
            </a>
        </li>
        <li class="fanscnt">
            <a href="/share/home?uk=124137116&suk=&view=fans">
                <em title="<%= data.fans_count %>"><%= data.fans_count %></em><span>ç²‰ä¸</span>
            </a>
        </li>
    </ul>
</div>
<div id='web-right-view' type='4' style="margin-top:10px" node-id="web-sharelinkpic" class="ad-platform-tips"></div>

            </div>
        </div>
    </div>
    <link rel="stylesheet" node-type="theme-link" type="text/css" href="https://pannss.bdstatic.com/m-static/disk-theme/theme/white/header-theme.css"/>
    <script>;[].push.apply(window.manifest||(window.manifest=[]),[{"name":"ç½‘ç›˜é“¾æ¥ç®¡ç†-è¯„è®º","group":"com.baidu.pan.share","locals":{"share":["bdstoken"]},"entranceFile":"disk-share:widget/plugin/comment/start.js","assets":["https://nd-static.bdstatic.com/m-static/disk-share/pkg/plugin-all_5c97e17.css","https://nd-static.bdstatic.com/m-static/disk-share/pkg/plugin-all_d3634a9.js"]},{"name":"ç½‘ç›˜é“¾æ¥ç®¡ç†-ç‚¹èµ","group":"com.baidu.pan.share","description":"The likes plugin.","entranceFile":"disk-share:widget/plugin/likes/start.js","assets":["https://nd-static.bdstatic.com/m-static/disk-share/pkg/plugin-all_d3634a9.js"]},{"name":"ç½‘ç›˜å¤–é“¾-è°ƒç«¯","group":"com.baidu.pan","namespace":"disk-share","buttons":[{"position":"shareTools","index":4,"title":"<%=window.locals.get('file_list').length === 1 && window.locals.get('file_list')[0].category === 2 ? 'ç”µè„‘ç«¯å¬' : 'ç”µè„‘ç«¯çœ‹'%>","buttonStyle":"normal","icon":"noicon-pc","name":"pcCallClient","externalClass":"tools-share-V20-btn hassep new-disk-call-client","enable":"callback((window.SHARETYPE ==='new_single_disk_share' || window.SHARETYPE ==='new_multi_disk_share') && window.location.pathname.indexOf('/link/') === -1) "}],"locals":{"share":["file_list"]},"entranceFile":"disk-share:widget/plugin/pcCallClient/start.js","assets":["https://nd-static.bdstatic.com/m-static/disk-share/pkg/singleNew-all_f0364d1.css","https://nd-static.bdstatic.com/m-static/disk-share/pkg/common-chunks-all_213b9f4.js","https://nd-static.bdstatic.com/m-static/disk-share/pkg/plugin-all_d3634a9.js"]},{"name":"ç½‘ç›˜é“¾æ¥ç®¡ç†-äºŒç»´ç ","group":"com.baidu.pan","namespace":"disk-share","buttons":[{"position":"shareTools","index":3,"title":"<%=window.SHARETYPE ==='new_single_disk_share' || window.SHARETYPE ==='new_multi_disk_share' ? 'æ‰‹æœºçœ‹' : 'åœ¨æ‰‹æœºæŸ¥çœ‹'%>","buttonStyle":"normal","icon":"noicon-shouji","name":"qrCode","externalClass":"tools-share-V20-btn hassep","mouseEnter":"mouseEnter","enable":"callback(!(location.pathname.indexOf('/link/') > -1 || /(\\?|&)linksource=/.test(location.search)))"}],"locals":{"share":["file_list"]},"entranceFile":"disk-share:widget/plugin/qrCode/start.js","assets":["https://nd-static.bdstatic.com/m-static/disk-share/pkg/plugin-all_5c97e17.css","https://nd-static.bdstatic.com/m-static/disk-share/pkg/plugin-all_d3634a9.js"]},{"name":"ç½‘ç›˜é“¾æ¥ç®¡ç†-ä¸¾æŠ¥","group":"com.baidu.pan.share","description":"The qrCode plugin.","buttons":[{"position":"shareTools","index":4,"title":"ä¸¾æŠ¥","buttonStyle":"normal","externalClass":"tools-share-V20-btn","name":"reportBad","enable":false,"enable1":"callback(!ctx.locals.get('self'))"}],"locals":{"share":["self","loginstate","share_uk","shareid"]},"entranceFile":"disk-share:widget/plugin/reportBad/start.js","assets":["https://nd-static.bdstatic.com/m-static/disk-share/pkg/plugin-all_5c97e17.css","https://nd-static.bdstatic.com/m-static/disk-share/pkg/plugin-all_d3634a9.js"]},{"name":"ä¿å­˜åˆ°ç½‘ç›˜","group":"com.baidu.pan.share","description":"The tools of transferFiles plugin.","buttons":[{"position":"shareTools","index":8,"title":"ä¿å­˜åˆ°ç½‘ç›˜","buttonStyle":"normal","icon":"noicon-zhuancun_bai","name":"shareSave","externalClass":"tools-share-save-hb tools-share-V20-btn save_btn","backgroundImgUrl":"https://staticwx.cdn.bcebos.com/mini-program%2Fimages%2Ftrans_btn_tag_lhb.png","enable":"callback(!ctx.locals.get('self') && window.SHARETYPE !=='new_single_disk_share' && window.SHARETYPE !=='new_multi_disk_share')"},{"position":"shareBottomTools","index":1,"title":"ä¿å­˜åˆ°ç½‘ç›˜","buttonStyle":"normal","name":"bottomShareSave","externalClass":"tools-share-save-hb tools-share-V20-btn save_btn bottom_save_btn","backgroundImgUrl":"https://staticwx.cdn.bcebos.com/mini-program%2Fimages%2Ftrans_btn_tag_lhb.png"},{"position":"shareListTools","index":2,"title":"ä¿å­˜åˆ°ç½‘ç›˜","buttonStyle":"normal","icon":"noicon-zhuancun_lan","name":"shareSave","externalClass":"tools-share-V20-btn first_btn","enable":"callback(!ctx.locals.get('self') && window.SHARETYPE !=='new_single_disk_share' && window.SHARETYPE !=='new_multi_disk_share')"},{"position":"shareList","index":8,"title":"ä¿å­˜åˆ°æˆ‘çš„ç™¾åº¦ç½‘ç›˜","buttonStyle":"normal","icon":"noicon-zhuancun_lan","name":"shareSave","enable":"callback(!ctx.locals.get('self'))"}],"locals":{"share":["self","file_list","uk","bdstoken","username","linkusername","cfrom_id","share_uk","shareid","vip_level","is_svip","is_vip"]},"entranceFile":"disk-share:widget/plugin/shareFileSave/start.js","assets":["https://nd-static.bdstatic.com/m-static/disk-share/widget/system/util/logs/shareFileSaveLog_e570716.js","https://nd-static.bdstatic.com/m-static/disk-share/widget/system/util/chooseAreaPageLog_b05caeb.js","https://nd-static.bdstatic.com/m-static/disk-share/pkg/common-chunks-all_213b9f4.js","https://nd-static.bdstatic.com/m-static/disk-share/pkg/plugin-all_5c97e17.css","https://nd-static.bdstatic.com/m-static/disk-share/pkg/plugin-all_d3634a9.js"]},{"name":"ç½‘ç›˜é“¾æ¥ç®¡ç†-å–æ¶ˆåˆ†äº«é“¾æ¥","group":"com.baidu.pan.share","description":"The unlinkShare plugin.","buttons":[{"position":"shareTools","index":1,"title":"å–æ¶ˆåˆ†äº«","buttonStyle":"normal","icon":"icon-share-cancel","externalClass":"tools-share-V20-btn","name":"unLinkShare","enable":"callback(ctx.locals.get('self'))"}],"locals":{"share":["self","shareid"]},"entranceFile":"disk-share:widget/plugin/unLinkShare/start.js","assets":["https://nd-static.bdstatic.com/m-static/disk-share/pkg/plugin-all_d3634a9.js"]},{"name":"ç½‘ç›˜äº‘è§£å‹å·¥å…·","group":"com.baidu.pan.share","description":"The unzipTools plugin.","buttons":[{"position":"shareList","index":1,"title":"äº‘è§£å‹","buttonStyle":"normal","icon":"noicon-unzip_icon","externalClass":"tools-share-unzip icon-share-V20-btn unzip_btn","conditions":{"filesLimit":1,"filesType":"rar,zip"}}],"locals":{"share":["self","file_list","uk","bdstoken","username","linkusername","cfrom_id","share_uk","shareid","vip_level","is_svip","is_vip"]},"entranceFile":"disk-share:widget/plugin/unzipTool/start.js","assets":["https://nd-static.bdstatic.com/m-static/disk-share/pkg/plugin-all_d3634a9.js"]},{"name":"ç½‘ç›˜äº‘æ‰“å°","group":"com.baidu.pan.share","description":"The yunPrint plugin.","buttons":[{"position":"shareListTools","index":4,"title":"äº‘æ‰“å°","buttonStyle":"normal","icon":"noicon-yundayin","externalClass":"tools-share-V20-btn hassep first_btn last_btn","name":"shareYunPrint","conditions":{"filesType":"ppt,pptx,pdf,doc,docx","filesLimit":">0"}}],"locals":{"share":["self","file_list","uk","bdstoken","username","linkusername","cfrom_id","share_uk","shareid","vip_level","is_svip","is_vip"]},"entranceFile":"disk-share:widget/plugin/yunPrint/start.js","assets":["https://nd-static.bdstatic.com/m-static/disk-share/pkg/plugin-all_d3634a9.js"]}]);;;[].push.apply(window.manifest||(window.manifest=[]),[{"name":"ç½‘ç›˜BTç¦»çº¿ä¸‹è½½","group":"com.baidu.pan","filesType":"*.bt,*.torrent","namespace":"disk-system,disk-share","filesIcon":{"bt,torrent":["fileicon-small-bt","fileicon-large-bt","fileicon-middle-bt"]},"entranceFile":"file-widget-1:bt/start.js","assets":["https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/bt-all_95cbb55.css","https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/bt-all_4e95401.js"]},{"name":"æµ©è¾°CAD","group":"com.gstarcad.web","notSupport":"ie6","filesType":"*.dws,*.dwt,*.dxf,*.dwg,*.cad","namespace":"disk-system,disk-share","filesIcon":{"dws,dwt,dxf,dwg,cad":["fileicon-small-dws","fileicon-large-dws","fileicon-middle-dws"]},"entranceFile":"file-widget-1:cad/start.js","assets":["https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/cad-all_6eba8dd.js"]},{"name":"ç½‘ç›˜ä»£ç é˜…è¯»å™¨","group":"com.baidu.pan","notSupport":"ie","namespace":"disk-system,disk-share","filesType":"*.txt,*.as,*.sh,*.c,*.cpp,*.h,*.cs,*.asp,*.css,*.scss,*.sass,*.less,*.pas,*.diff,*.patch,*.erl,*.groovy,*.java,*.jsp,*.js,*.json,*.pl,*.php,*.py,*.rb,*.sass,*.scss,*.scala,*.sql,*.vb,*.xml,*.xhtml,*.html,*.htm,*.md,*.lua,*.go,*.bat,*.wml,*.cc,*.ejs,*.vue,*.jsx","filesIcon":{"txt":["fileicon-small-txt","fileicon-large-txt","fileicon-middle-txt"],"as,sh,c,cpp,h,cs,asp,css,scss,sass,less,pas,diff,patch,erl,groovy,java,jsp,js,json,pl,php,py,rb,sass,scss,scala,sql,vb,xml,xhtml,html,htm,md,lua,go,bat,wml,cc,ejs,vue,jsx,ts":["fileicon-small-code","fileicon-large-code"]},"locals":{"pan":["uk","shareid","sign","servertime"],"share":["share_uk","sign1","servertime"]},"assets":["https://nd-static.bdstatic.com/m-static/base/thirdParty/SyntaxHighlighter/_nomd5_nomod/styles/shCoreDefault.css","https://nd-static.bdstatic.com/m-static/base/thirdParty/SyntaxHighlighter/_nomd5_nomod/styles/shThemeDefault.css","https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/codeReader-all_76c6000.css","https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/codeReader-all_b55b22a.js"],"entranceFile":"file-widget-1:codeReader/start.js"},{"name":"ç½‘ç›˜æ–‡æ¡£é˜…è¯»å™¨","group":"com.baidu.pan","namespace":"disk-system,disk-share","filesType":"*.pdf,*.doc,*.docx,*.ppt,*.pptx,*.xls,*.xlsx","filesIcon":{"pdf":["fileicon-small-pdf","fileicon-large-pdf","fileicon-middle-pdf"],"doc,docx":["fileicon-small-doc","fileicon-large-doc","fileicon-middle-doc"],"ppt,pptx":["fileicon-small-ppt","fileicon-large-ppt","fileicon-middle-ppt"],"xls,xlsx":["fileicon-small-xls","fileicon-large-xls","fileicon-middle-xls"]},"locals":{"pan":["uk"],"share":["self","loginstate"]},"entranceFile":"file-widget-1:doc/start.js","assets":["https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/doc-all_b5b81dd.js"]},{"name":"æ–‡æ¡£å›¾ç‰‡åŒ–æ¸²æŸ“å™¨","group":"com.baidu.pan","namespace":"disk-system,disk-share","locals":{"pan":["uk"],"share":["self","loginstate"]},"assets":["https://nd-static.bdstatic.com/m-static/base/thirdParty/dgr/dgr-1.2.0.min.js","https://nd-static.bdstatic.com/m-static/base/thirdParty/ubc/bpdatajs.min.js","https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/docGraphicRender-all_614a0f5.js"],"entranceFile":"file-widget-1:docGraphicRender/start.js"},{"name":"ç½‘ç›˜æ–‡æ¡£é¢„è§ˆé˜…è¯»å™¨","group":"com.baidu.pan","namespace":"disk-system,disk-share","filesType":"*.rtf,*.vsd","filesIcon":{"rtf":["fileicon-small-txt","fileicon-large-txt","fileicon-middle-txt"],"vsd":["fileicon-small-vsd","fileicon-large-vsd","fileicon-middle-vsd"]},"locals":{"pan":["uk"],"share":["self","loginstate"]},"entranceFile":"file-widget-1:docPreview/start.js","assets":["https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/docPreview-all_05246b6.css","https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/docPreview-all_6a16fc1.js"]},{"name":"ç½‘ç›˜PDFé˜…è¯»å™¨","group":"com.baidu.pan","namespace":"disk-system,disk-share","locals":{"pan":["uk"],"share":["self","loginstate"]},"entranceFile":"file-widget-1:docPreviewNew/start.js","assets":["https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/docPreview-new-all_bfae043.css","https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/docPreview-new-all_f170e7b.js"]},{"name":"ç½‘ç›˜å›¾ç‰‡é¢„è§ˆ","group":"com.baidu.pan","namespace":"disk-system,disk-share,pan-timeline","filesType":"*.jpg,*.jpeg,*.livp,*.gif,*.bmp,*.png,*.jpe,*.cur,*.svgz,*.ico,*.heic,*.heif,*.avci,*.webp","filesIcon":{"jpg,jpeg,livp,gif,bmp,png,jpe,cur,svgz,ico,heic,heif,avci,webp":["fileicon-small-pic","fileicon-large-pic","fileicon-middle-pic"]},"locals":{"pan":["uk","sign1","sign2","sign3","servertime"],"share":[]},"entranceFile":"file-widget-1:image/start.js","assets":["https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/image-all_9852daa.css","https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/image-all_de433ca.js"]},{"name":"ç™¾åº¦è„‘å›¾","group":"com.baidu.naotu","filesType":"*.mmap,*.xmind,*.mm","namespace":"disk-system,disk-share","notSupport":"ie6","filesIcon":{"mmap":["fileicon-small-mmap","fileicon-large-mmap","fileicon-middle-mmap"],"xmind":["fileicon-small-xmind","fileicon-large-xmind","fileicon-middle-xmind"],"mm":["fileicon-small-mm","fileicon-large-mm","fileicon-middle-mm"]},"locals":{"pan":["uk","sign1","servertime"],"share":["share_uk","shareid","sign","servertime"]},"entranceFile":"file-widget-1:mindmap/start.js","assets":["https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/mindmap-all_43ad53f.css","https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/mindmap-all_79f0037.js"]},{"name":"ç½‘ç›˜éŸ³é¢‘æ’­æ”¾å™¨","group":"com.baidu.pan","notSupport":"ie6","namespace":"disk-system,disk-share","filesType":"*.wma,*.wav,*.mp3,*.aac,*.ra,*.ram,*.mp2,*.ogg,*.aif,*.mpega,*.amr,*.mid,*.midi,*.m4a","filesIcon":{"wma,wav,mp3,aac,ra,ram,mp2,ogg,aif,mpega,amr,mid,midi,m4a":["fileicon-small-mp3","fileicon-large-mp3","fileicon-middle-mp3"]},"buttons":[{"title":"éŸ³ä¹æ’­æ”¾","name":"play-music","position":"listTools","index":3,"disabled":"none","icon":"icon-play","buttonStyle":"normal","conditions":{"pageModule":"list,share,search,category,searchGlobal","filesType":"wma,wav,mp3,aac,ra,ram,mp2,ogg,aif,mpega,amr,mid,midi,m4a","filesTypeStrongMatch":true}}],"locals":{"pan":["uk","sign1","servertime"],"share":["share_uk","shareid","sign","servertime"]},"entranceFile":"file-widget-1:musicPlay/start.js","assets":["https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/musicPlay-all_12e87fb.css","https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/musicPlay-all_a198ee5.js"]},{"name":"wpsOffice","group":"com.baidu.www","ignore":false,"namespace":"disk-system,disk-share","filesType":"*.dot,*.wps,*.wpt,*.dotx,*.docm,*.dotm,*.pptm,*.ppsx,*.ppsm,*.pps,*.potx,*.potm,*.dpt,*.dps,*.xlt,*.et,*.xltx,*.csv,*.xlsm,*.xltm","filesIcon":{"csv":["fileicon-small-xls","fileicon-large-xls","fileicon-middle-xls"]},"contextMenu":[{"type":"file","title":"ç¼–è¾‘","index":1.5,"log":"web_listTools_click_editDocWp","variableMenu":"onVariableMenu","conditions":{"filesTypeStrongMatch":true,"filesType":"doc,docx","filesLimit":1}},{"type":"file","title":"ç¼–è¾‘","index":1.5,"action":"wpsEditRight","log":"web_listTools_click_editDocWp","conditions":{"filesTypeStrongMatch":true,"filesType":"ppt,pptx,xls,xlsx","filesLimit":1}}],"buttons":[{"title":"ç¼–è¾‘","name":"editWp","position":"list","index":0,"click":"wpsEdit","icon":"icon-wpedit","buttonStyle":"normal","conditions":{"pageModule":"list,search,category,searchGlobal","excludeDirType":"sourceHolder,cardHolder,shareHolder","filesTypeStrongMatch":true,"filesType":"ppt,pptx,xls,xlsx","filesLimit":1,"meta":{"share":0}}},{"title":"ç¼–è¾‘","name":"toolEdit","position":"listTools","index":2,"icon":"icon-wpedit","click":"wpsEdit","externalClass":"g-custom","conditions":{"filesTypeStrongMatch":true,"filesType":"ppt,pptx,xls,xlsx","filesLimit":1,"pageModule":"list,search,category,searchGlobal","excludeDirType":"sourceHolder,cardHolder,shareHolder","meta":{"share":0}}},{"title":"ç¼–è¾‘","name":"editTools","position":"listTools","index":2,"click":"wpsEdit","icon":"icon-wpedit","externalClass":"g-custom","externalDropClass":"g-custom-drom","type":"dropdown","menu":[{"title":"WPS Office","click":"wpsEdit"},{"title":"ç½‘ç›˜åœ¨çº¿æ–‡æ¡£","click":"onlineEdit"}],"conditions":{"filesTypeStrongMatch":true,"filesType":"doc,docx","filesLimit":1,"pageModule":"list,search,category,searchGlobal","excludeDirType":"sourceHolder,cardHolder,shareHolder","meta":{"share":0}}},{"title":"ç¼–è¾‘","name":"editDocList","position":"list","index":0,"icon":"icon-wpedit","click":"onlineEdit","buttonStyle":"dropdown","type":"dropdown","externalDropClass":"g-custom-width","menu":[{"title":"WPS Office","click":"wpsEdit"},{"title":"ç½‘ç›˜åœ¨çº¿æ–‡æ¡£","click":"onlineEdit"}],"conditions":{"pageModule":"list,search,category,searchGlobal","excludeDirType":"sourceHolder,cardHolder,shareHolder","filesTypeStrongMatch":true,"filesType":"doc,docx","filesLimit":1}}],"locals":{"pan":["bdstoken","uk","wpsauth"]},"entranceFile":"file-widget-1:officeEdit/start.js","assets":["https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/officeEdit-all_10311e2.css","https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/officeEdit-all_50febde.js"]},{"name":"ç½‘ç›˜å¤§å›¾é¢„è§ˆ","group":"com.baidu.pan","namespace":"disk-system,disk-share,pan-timeline","filesType":"*.jpg,*.jpeg,*.gif,*.bmp,*.png,*.jpe,*.cur,*.svgz,*.ico","filesIcon":{"jpg,jpeg,gif,bmp,png,jpe,cur,svgz,ico":["fileicon-small-pic","fileicon-large-pic","fileicon-middle-pic"]},"entranceFile":"file-widget-1:preview/start.js","assets":["https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/preview-all_283c691.css","https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/preview-all_8961c50.js"]},{"name":"sysIcon","group":"com.baidu.pan","filesIcon":{"exe,msi":["fileicon-sys-s-exe","fileicon-sys-l-exe"],"dmg,pkg":["fileicon-sys-s-exe","fileicon-sys-l-dmg"],"psd":["fileicon-sys-s-psd","fileicon-sys-l-psd"],"apk":["fileicon-sys-s-apk","fileicon-sys-l-apk"],"key":["fileicon-sys-s-key","fileicon-sys-l-key"],"ai":["fileicon-sys-s-ai","fileicon-sys-l-ai"],"ipa":["fileicon-sys-s-ipa","fileicon-sys-l-ipa"],"pages":["fileicon-sys-s-pages","fileicon-sys-l-pages"],"numbers":["fileicon-sys-s-numbers","fileicon-sys-l-numbers"],"eot,ttf,woff":["fileicon-sys-s-fonts","fileicon-sys-l-fonts"],"eps":["fileicon-sys-s-eps","fileicon-sys-l-eps"],"lnk,link":["fileicon-sys-s-links","fileicon-sys-l-links"],"swf":["fileicon-sys-s-swf","fileicon-sys-l-swf"],"ts":["fileicon-sys-s-video","fileicon-sys-l-video"]}},{"name":"ç½‘ç›˜è§†é¢‘","group":"com.baidu.pan","namespace":"disk-system,disk-share","filesType":"*.wmv,*.rmvb,*.mpeg4,*.mpeg2,*.flv,*.avi,*.3gp,*.mpga,*.qt,*.rm,*.wmz,*.wmd,*.wvx,*.wmx,*.wm,*.mpg,*.mp4,*.mkv,*.mpeg,*.mov,*.asf,*.m4v,*.m3u8","filesIcon":{"wmv,rmvb,mpeg4,mpeg2,flv,avi,3gp,mpga,qt,rm,wmz,wmd,wvx,wmx,wm,mpg,mp4,mkv,mpeg,mov,asf,m4v,m3u8":["fileicon-small-video","fileicon-large-video","fileicon-middle-video"]},"locals":{"share":["shareid","share_uk"]},"entranceFile":"file-widget-1:video/start.js","assets":["https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/video-all_3335923.js"]},{"name":"ç½‘ç›˜è§†é¢‘æ’­æ”¾å™¨","group":"com.baidu.pan","namespace":"disk-system,disk-share","locals":{"pan":["uk"],"share":["uk"]},"assets":["https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/videoPlay-all_b50fdf1.css","https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/videoPlay-all_bcdaffc.js"],"entranceFile":"file-widget-1:videoPlay/start.js"},{"name":"ç½‘ç›˜è§£å‹ç¼©","group":"com.baidu.pan","filesType":"*.rar,*.zip","notSupport":"ie6","namespace":"disk-system,disk-share","filesIcon":{"rar,zip":["fileicon-small-zip","fileicon-large-zip","fileicon-middle-zip"]},"locals":{"share":["share_uk","shareid","public","share_page_type","vip_level","file_list"]},"entranceFile":"file-widget-1:zip/start.js","assets":["https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/zip-all_6f9911d.css","https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/zip-all_a85b795.js"]}]);;;[].push.apply(window.manifest||(window.manifest=[]),[{"name":"å•†ä¸šä»˜è´¹","group":"com.baidu.pan","supportManage":false,"namespace":"disk-system,disk-share,disk-clear","buttons":[],"entranceFile":"function-widget-1:buyGuide/start.js","assets":["https://nd-static.bdstatic.com/m-static/function-widget-1/buyGuide/util/buyGuideContent_76a0cb5.css","https://nd-static.bdstatic.com/m-static/function-widget-1/buyGuide/util/buyGuideContent_16d744e.js","https://nd-static.bdstatic.com/m-static/function-widget-1/buyGuide/start_74677c0.js"]},{"name":"å†…åµŒæ”¶é“¶å°","group":"com.baidu.pan","supportManage":false,"namespace":"disk-system,disk-share,disk-clear","buttons":[],"entranceFile":"function-widget-1:buyIframe/start.js","assets":["https://nd-static.bdstatic.com/m-static/function-widget-1/pkg/buy-all_d5d49d6.css","https://nd-static.bdstatic.com/m-static/function-widget-1/pkg/buy-all_09c99d1.js"]},{"name":"ç½‘ç›˜ä¸‹è½½","group":"com.baidu.pan","supportManage":false,"namespace":"disk-system,disk-share,pan-timeline,disk-clear","contextMenu":{"type":"file","title":"ä¸‹è½½","index":2,"log":"web_listTools_click_download","conditions":{"excludeDirType":"sourceHolder,cardHolder,shareHolder","meta":{"wpfile.loose":0}}},"buttons":[{"title":"ä¸‹è½½","name":"download","position":"listTools","index":5,"disabled":"disable","icon":"icon-download","buttonStyle":"normal","log":"web_listTools_click_download","conditions":[{"pageModule":"list,share,search,category,searchGlobal","excludeDirType":"sourceHolder,cardHolder,shareHolder","meta":{"wpfile.loose":0}},{"pageModule":"sharedir","path":"!/","meta":{"wpfile.loose":0}}]},{"name":"download","position":"list","index":3,"disabled":"disable","title":"ä¸‹è½½","icon":"icon-download","log":"web_listTools_click_download","conditions":[{"pageModule":"list,share,search,category,searchGlobal","excludeDirType":"sourceHolder,cardHolder,shareHolder","meta":{"wpfile.loose":0}},{"pageModule":"sharedir","path":"!/","meta":{"wpfile.loose":0}}]},{"position":"shareListTools","index":3,"disabled":"disable","title":"ä¸‹è½½","icon":"noicon-xiazai","externalClass":"tools-share-V20-btn last_btn hassep","buttonStyle":"normal","log":"web_listTools_click_download","conditions":{"excludeDirType":"sourceHolder,cardHolder,shareHolder"},"enable":"callback(window.SHARETYPE==='new_single_disk_share' && window.SHARETYPE==='new_multi_disk_share')"},{"position":"shareBottomTools","index":2,"disabled":"disable","title":"ä¸‹è½½","externalClass":"tools-share-V20-btn  bottom_download_btn","buttonStyle":"normal","log":"web_listTools_click_download","conditions":{"excludeDirType":"sourceHolder,cardHolder,shareHolder"}},{"position":"shareList","disabled":"disable","title":"ä¸‹è½½","icon":"noicon-xiazai","log":"web_listTools_click_download","index":2,"conditions":{"excludeDirType":"sourceHolder,cardHolder,shareHolder"}},{"position":"shareTools","disabled":"disable","externalClass":"tools-share-V20-btn hassep","title":"ä¸‹è½½<%=window.SHAREPAGETYPE=='single_file_page'?(window.metaData.FIRST_FILE_SIZE?('('+window.metaData.FIRST_FILE_SIZE+')'):''):''%>","icon":"noicon-xiazai","log":"web_listTools_click_download","index":2,"enable":"callback(window.SHARETYPE!=='new_single_disk_share' && window.SHARETYPE!=='new_multi_disk_share')","conditions":{"excludeDirType":"sourceHolder,cardHolder,shareHolder"}}],"locals":{"pan":["uk","is_svip","is_vip","loginstate","username","sign1","sign2","sign3","servertime","docuserchannel"],"share":["share_uk","is_svip","is_vip","loginstate","username","public","sign","shareid","servertime","docuserchannel"]},"entranceFile":"function-widget-1:download/start.js","assets":["https://nd-static.bdstatic.com/m-static/function-widget-1/pkg/download-all_e1d6e99.css","https://nd-static.bdstatic.com/m-static/function-widget-1/widget/system/utils/ab_56b4fb0.js","https://nd-static.bdstatic.com/m-static/function-widget-1/pkg/download-all_40d4796.js"]},{"name":"ç½‘ç›˜äºŒçº§å¯†ç ","group":"com.baidu.pan","namespace":"disk-system,disk-share,pan-timeline","locals":{"pan":["uk","bdstoken"]},"entranceFile":"function-widget-1:password/start.js","assets":["https://nd-static.bdstatic.com/m-static/function-widget-1/pkg/password-all_88ff584.css","https://nd-static.bdstatic.com/m-static/function-widget-1/pkg/password-all_ab772d7.js"]},{"name":"ç½‘ç›˜PDFè½¬Word","group":"com.baidu.pan","supportManage":false,"namespace":"disk-system,disk-share","contextMenu":[{"type":"file","title":"PDFè½¬Word","index":4,"log":"netdisk_pdf2word_contextMenu_click","conditions":{"filesType":"*.pdf","pageModule":"list,share,search,category,searchGlobal,sharedir","excludeDirType":"sourceHolder,cardHolder,shareHolder"}}],"buttons":[{"title":"PDFè½¬Word","name":"pdf2word","position":"listTools","index":7,"log":"netdisk_pdf2word_listTools_click","icon":"icon-pdf2word","buttonStyle":"normal","conditions":{"filesType":"*.pdf","pageModule":"list,share,search,category,searchGlobal,sharedir","excludeDirType":"sourceHolder,cardHolder,shareHolder"}},{"title":"PDFè½¬Word","name":"pdf2word","position":"list","index":1,"log":"netdisk_pdf2word_list_click","icon":"icon-pdf2word","buttonStyle":"normal","conditions":{"filesType":"*.pdf","pageModule":"list,share,search,category,searchGlobal,sharedir","excludeDirType":"sourceHolder,cardHolder,shareHolder"}}],"locals":{"pan":["is_svip","is_vip"]},"entranceFile":"function-widget-1:pdf2word/start.js","assets":["https://nd-static.bdstatic.com/m-static/function-widget-1/pkg/pdf2word-all_4de1714.css","https://nd-static.bdstatic.com/m-static/function-widget-1/pkg/pdf2word-all_1a7b73c.js"]},{"name":"IEæµè§ˆå™¨å‡çº§æç¤º","group":"com.baidu.pan","namespace":"*","autoExecute":true,"ignore":"/yunguanjia/ig.test(window.navigator.userAgent) || (window.$ && window.$.support.leadingWhitespace)","entranceFile":"function-widget-1:upgradeWarning/start.js","assets":["https://nd-static.bdstatic.com/m-static/function-widget-1/upgradeWarning/start_69eda86.css","https://nd-static.bdstatic.com/m-static/function-widget-1/upgradeWarning/start_c7004c4.js"]},{"name":"ä¼šå‘˜å¼•å¯¼","group":"com.baidu.pan","supportManage":false,"namespace":"disk-system,disk-share,disk-clear","buttons":[],"entranceFile":"function-widget-1:vipGuide/start.js","assets":["https://nd-static.bdstatic.com/m-static/function-widget-1/vipGuide/util/vipService_2a83b98.js","https://nd-static.bdstatic.com/m-static/function-widget-1/vipGuide/util/newProductGuide_b150940.css","https://nd-static.bdstatic.com/m-static/function-widget-1/vipGuide/util/newProductGuide_3933674.js","https://nd-static.bdstatic.com/m-static/function-widget-1/vipGuide/util/vipGuide_e780dc0.css","https://nd-static.bdstatic.com/m-static/function-widget-1/vipGuide/util/vipGuide_1938ae1.js","https://nd-static.bdstatic.com/m-static/function-widget-1/vipGuide/start_be2cb1d.js"]}]);</script>

    
    
    <div class="module-share-footer" id="ft">
        <div>&copy;2025 Baidu <a target="_blank" href="/disk/duty/">æœåŠ¡åè®®</a>|<a target="_blank" href="//yun.baidu.com/disk/privacy">æƒåˆ©å£°æ˜</a>|<a href="//yun.baidu.com/disk/version" target="_blank">ç‰ˆæœ¬æ›´æ–°</a>|<a target="_blank" href="http://yun.baidu.com/disk/help">å¸®åŠ©ä¸­å¿ƒ</a>|<a id="feedback-link" target="_blank" href="https://pan.baidu.com/embed/service?theme=light&client=web&version=0&from=share_bottom&source=web_share&clienttype=0">é—®é¢˜åé¦ˆ</a>|<a href="http://copyright.baidu.com/index.php/index/complaint" target="_blank">ç‰ˆæƒæŠ•è¯‰</a>|<a target="_blank" id="panHostBase" class="b-lnk-gy" >ä¼ä¸šè®¤è¯</a></div>
    </div>
    
    <script>
        var HOST_PAN = ((window.host && window.host.HOST_PAN) || 'pan.baidu.com');
        document.querySelector('#panHostBase').href = '//' + HOST_PAN + '/disk/cert/#/web/home?from=shareFooter';
    </script>

    
    

    <script type="text/javascript" src="https://nd-static.bdstatic.com/m-static/base/static/js/lib/mod.js?t=1762402227446"></script><script type="text/javascript">require.resourceMap({"res":{"disk-share:widget/pageModule/list/mouse-utils/mouse-select.js":{"url":"https://nd-static.bdstatic.com/m-static/disk-share/widget/pageModule/list/mouse-utils/mouse-select_6f5e570.js","deps":["base:widget/mouse-utils/mouse-selection.js"],"pkg":"disk-share:p0"},"disk-share:widget/system/verifyCodeDialog/verifyUser.min.js":{"url":"https://nd-static.bdstatic.com/m-static/disk-share/widget/system/verifyCodeDialog/verifyUser.min_9f76080.js","pkg":"disk-share:p0"}},"pkg":{"disk-share:p0":{"url":"https://nd-static.bdstatic.com/m-static/disk-share/pkg/async-all_cb994bd.js"}}});</script><script type="text/javascript" crossorigin="anonymous"  src="https://nd-static.bdstatic.com/m-static/system-core/pkg/context-all_5bdfc43.js"></script><script type="text/javascript" crossorigin="anonymous"  src="https://nd-static.bdstatic.com/m-static/base/pkg/base_a669b9c.js"></script><script type="text/javascript" crossorigin="anonymous"  src="https://nd-static.bdstatic.com/m-static/disk-share/widget/system/util/deviceType_48d87b6.js"></script><script type="text/javascript" crossorigin="anonymous"  src="https://nd-static.bdstatic.com/m-static/disk-share/widget/system/util/browser_4f04d62.js"></script><script type="text/javascript" crossorigin="anonymous"  src="https://nd-static.bdstatic.com/m-static/disk-share/js/boot_4d6e1b4.js"></script><script type="text/javascript" crossorigin="anonymous"  src="https://nd-static.bdstatic.com/m-static/disk-header/disk.header.1762402454685.js?t=1762402454684"></script><script type="text/javascript" crossorigin="anonymous"  src="https://nd-static.bdstatic.com/m-static/file-widget-1/pkg/videoPlay-all_bcdaffc.js"></script><script type="text/javascript" crossorigin="anonymous"  src="https://nd-static.bdstatic.com/m-static/disk-share/pkg/common-chunks-all_213b9f4.js"></script><script type="text/javascript" crossorigin="anonymous"  src="https://nd-static.bdstatic.com/m-static/disk-share/pkg/multi-all_7aa35de.js"></script><script type="text/javascript">!function() {
        window.SHAREPAGETYPE='multi_file';
        var context = require('system-core:context/context.js').instanceForSystem;
        context.pluginControl.init();
    }();
!function() {
        window.yunData={skinName:'white', neglect:1, bdstoken:'f084ff60fdbac9dd5ece5e09accd1aa1', uk:'124137116', loginstate:'1', share_uk:"37541615", shareid:"2102429705"};
        locals.set('servertime', 1765871256589);
        locals.mset({"uk":"124137116","username":"Develata","loginstate":1,"vip_level":7,"skinName":"white","bdstoken":"f084ff60fdbac9dd5ece5e09accd1aa1","photo":"https://dgss0.bdstatic.com/6LZ1dD3d1sgCo2Kml5_Y_D3/sys/portrait/item/6007446576656c6174614362","is_vip":1,"is_svip":1,"is_evip":1,"vip_identity":22,"now":"2025-12-16T07:47:36.589Z","XDUSS":"Fs5dHvbxq1ybjk8BEcdFNaD1wALeNFHefJ4%2Bbp9LlbWx9t9t8eqkYVl2%2FAWuD4c6BxaJVjblH4w5xboefVL4ppseRskDEHUwe%2FKACZDsZcc%2BNxalIBON%2F2v7eKtgrNc%2FjZzeAbFmSNo08KJEw3dWooSenhcdT%2Brg7zMbkcxFB7%2FUZVj82NC%2Ff%2B0rKWItqh5CIMiOR%2BHa3f9UD56XjLtKZe3kWyKqCXTYE5KwsvYPiVi33dT15%2Bl%2B7zHjaAHbNg3RUqbuKOnC8nz983lss8vEGg%3D%3D","curr_activity_code":0,"show_vip_ad":0,"share_photo":"https://himg.bdimg.com/sys/portrait/item/public.1.ecf025aa.o97DTSwCGWOcCYB8iDA9tQ.jpg","share_uk":"37541615","shareid":2102429705,"hit_ogc":false,"expiredType":0,"public":0,"ctime":1435484993,"description":"","followFlag":0,"access_list_flag":true,"Elink_info":{"isElink":0,"eflag_disable":false},"sharetype":0,"view_visited":0,"view_limit":0,"owner_vip_level":1,"owner_svip10_id":"","owner_vip_type":0,"linkusername":"å¶å°”**å¸–å­","share_page_type":"multi","title_img":["iVBORw0KGgoAAAANSUhEUgAAARsAAAAeCAIAAACT9S1xAAAG00lEQVR42uzcf0gTbxwH8GfZNIfmkTOnQmlaSSqaRZZSKeavsrJSC4eEQ5lSUBGBVFTK8ke/S9kkNIfDwrLSsF9mMpk1xibIkNWYi2ppWy7blPRuu3Vf6PqOfad9/+qPBp/XX7u75547fHjvuedz6kKKohAA4A9ZAD8CACBRAECiAIBEAQAgUQBAogCARAEAfpso+sWUWq3u7u5GCNntdnr/2bNnzWaz22larZb+8O7du4aGBud+giBUKtXcyxgMBrVajRD6+PHjhQsX5r2VBw8e0G3mZbPZYLSAB6B+wnE8ISFhdHS0tbWVy+XiOJ6YmDg4ODg2Nubr60sQBOXCZrOtWrVKJBJRFDUxMREcHPzo0SP6UFlZWWxsrN1up/4rPT29vLycoqhv375hGKZQKKg5uFyuRCKhP1dXV1dUVBQXF+/evXvt2rWBgYGLFy+enp6mAPi7/ZqjfHx8eDyeQCCgN+vq6hITE1NSUnp7e1NTU729vV1DyGQy7969e/LkSZPJxGazL1261NLSghB6+PDhkydPenp6Fi5c6Nr+xo0bWq2WnpowDDt16hSPx5udnf2fnF+/fp3NZm/btq20tFQkEo2MjFgsFj8/P/gGBH85Bv2wp1AolEolSZJDQ0NarTY/P5/JZBYUFJSVlQ0MDHh7e1MUZbfbMzMzb/yEEPr69WtgYKBzomMwGA6H49OnT8uXL0cIVVRUREZGIoQGBgZycnL6+vqSk5Ppxg6HIz09HcOwe/fuMZlMhFBtbW13d7derw8ICGCz2UKhMDMzU6VShYeHwwgBj1xH4ThusViMRmNnZydBEDMzM9+/f1er1c+fP9doNBaL5c6dO2vWrOnq6hofHxeLxRwOJyYmhvOvkJAQDocTFhaWlJTE4XDa29sNBgNCSCaT7dy58+rVq844IYS8vLw6Ozt1Ol1WVpbRaEQIlZSUiMXi4OBgPp8vFoujo6NhYICH+vV4tnXr1tDQ0IKCguTkZJ1O9+zZs46OjkOHDiGExsfHw8PDP3z4EBERQTfGMOzIkSNDQ0Nzu2MymevWrROLxQihtrY2Pp8vEAj4fL5bMzabLZVK8/LyYmJi6uvrS0tLSZLUaDRyufzAgQMsFgsh1NjYiGGY61mhoaE8Hg/GDHhAohoaGmpqaoRCodVq7evry8zMzMjIOHjwIIZhKpUqOTlZrVbHx8cjhOLi4rq6uqanp48ePerW1/DwsL+//8TEREdHx7Jly3Q6XVNTk1wuLy8vn/favb29ly9fXrFiBUKoubl5wYIFZrM5Ly/v9evXdNkQx3GE0M2bN3fs2BEWFkYQBAwY8IxaX39/v8FgGBkZKS4uHh0dpShqcnKSoqhbt27l5ORQFBUZGdnX1/e7+oZKpdq8eXNaWtrw8LDrfpIkRT/l5+cnJCSI/lVfX08vqOhmU1NTwcHBGRkZEolk165dV65cYbFYY2Nj9NGYmBi5XA5FJOARflUmzp8/L5PJdDodjuNxcXEIoaCgIIlE8uXLl4iICIlEwufzP3/+7FbEo7169So3N7elpWXv3r2/y+2xY8dIknS+uXr//n10dDQ9BSGETpw4YTKZfvz4kZ2dnZuby2Qy/fz8ZmZmfH19EUKxsbHNzc0bN26Erz/gMZUJLpebkpKyZMmSx48f19XVrV+/3mQyIYSWLl2al5fH5XJ5PB4dp8LCwkX/lZaWZrVai4qKXHe6pUsmkyUlJTk3cRx3LYWTJFldXe1cpL158yYkJISOEwAeuY6iaw82m02v10dHR7e2tj59+pQ+lJCQcPv2bWce2tvbHQ6HaxcvXryorKx0K1R4eXk5Pw8ODr59+zY3N9e5x2Kx+Pv7OzcvXrzoOvtJpVKYkYBnJ4quDSiVysLCQoPBkJ+fv3r1avo3g6qqqkpKSng8XkhIyKZNm5g/udX3GAzGokWL5r2ARqPZv3//6dOnXQt3CoWCfm316yZc4kSSpFAopBdaAHhqooxGY09PT0tLS2BgoEAgEIlEhw8fjoqKqqqqam9v37NnT2hoaGpqak1NzfHjx+lTCIIQCoUBAQH9/f1sNntu11artbGxsba2ls/nV1ZW2my2ffv2BQUFkSTZ2dnZ1NQ07w1VV1ezWKz/WZIB4AGJOnfu3OTk5JkzZ7KzsxkMBpfL1ev1RUVFUql0w4YNCCGBQLBy5Uqr1eo808fHR6lUzs7Oslisa9euze3abDa/fPny/v37WVlZCCFvb+/t27dPTU0hhEpLS7ds2eLWPioqKigoiCCItrY214fG+Ph410dEAP5mDPhfSAD8QfD3UQBAogCARAEAiQIAQKIAgEQBAIkCALj7JwAA///gvpYkGQkuYAAAAABJRU5ErkJggg=="],"file_list":[{"app_id":"250528","black_tag":"0","category":6,"delete_fs_id":"0","extent_int3":"0","extent_int8":"0","extent_tinyint1":"0","extent_tinyint2":"0","extent_tinyint3":"0","extent_tinyint4":"0","file_key":"","file_tag":"0","fs_id":237758062532270,"is_scene":"1","isdelete":"0","isdir":1,"local_ctime":1427622268,"local_mtime":1427622268,"md5":"","oper_id":"0","owner_id":"0","owner_type":"0","parent_path":"%2Fsharelink37541615-237758062532270","path":"/sharelink37541615-237758062532270/æ•°å­¦åˆ†æ","path_md5":"9648567881535071577","privacy":"0","real_category":"","root_ns":942670488,"server_atime":"0","server_ctime":1427622268,"server_filename":"æ•°å­¦åˆ†æ","server_mtime":1438702670,"share":"0","size":0,"source":"0","status":"0","tkbind_id":"0","videotag":"0","wpfile":"0"}],"errortype":-1,"errno":0,"ufcTime":344,"error":0,"data":{},"self":0,"elink_self":0});
        window.BadSDK && window.BadSDK.updateConfig({ 
            uk: locals.get('uk'),
            sessionId: window.BpDataInstance && window.BpDataInstance.sessionId
        });
    }();
!function() {
        require('disk-share:widget/pageModule/start/multi.js');
    }();</script></body>
    
    <script async defer type="text/javascript" src="https://hm.baidu.com/h.js?7a3960b6f067eb0085b7f96ff5e660b0"></script>
</html>
</file>

<file path="test_debug_list.sh">
#!/bin/bash
# æµ‹è¯•è°ƒè¯•æ¥å£ - åˆ—ä¸¾ç½‘ç›˜ç›®å½•

echo "=== æµ‹è¯•è°ƒè¯•æ¥å£ ==="

# æµ‹è¯•æ ¹ç›®å½•
echo ""
echo "1ï¸âƒ£ æµ‹è¯•åˆ—ä¸¾æ ¹ç›®å½• /"
curl -X POST http://localhost:5200/api/debug/list \
  -H "Content-Type: application/json" \
  -d '{"path":"/"}' | jq .

# æµ‹è¯• /æˆ‘çš„èµ„æº
echo ""
echo "2ï¸âƒ£ æµ‹è¯•åˆ—ä¸¾ /æˆ‘çš„èµ„æº"
curl -X POST http://localhost:5200/api/debug/list \
  -H "Content-Type: application/json" \
  -d '{"path":"/æˆ‘çš„èµ„æº"}' | jq .

# æµ‹è¯•å¯èƒ½çš„å¼‚æ­¥è½¬å­˜ç›®å½•
echo ""
echo "3ï¸âƒ£ æµ‹è¯•åˆ—ä¸¾ /asyncè½¬å­˜"
curl -X POST http://localhost:5200/api/debug/list \
  -H "Content-Type: application/json" \
  -d '{"path":"/asyncè½¬å­˜"}' | jq .

echo ""
echo "âœ… æµ‹è¯•å®Œæˆï¼æŸ¥çœ‹å“ªä¸ªç›®å½•æœ‰æ–‡ä»¶ï¼Œç„¶åä¿®æ”¹ config.toml ä¸­çš„ savepath"
</file>

<file path="test_extract.sh">
#!/bin/bash

echo "=== æµ‹è¯• shorturl æå–é€»è¾‘ ==="

cat > /tmp/test_surl.rs << 'EOF'
fn extract_surl(share_url: &str) -> Option<String> {
    let url = share_url.trim();
    
    if let Some(pos) = url.find("/s/") {
        let start = pos + 3;
        if start >= url.len() {
            return None;
        }
        
        let surl = &url[start..];
        let end = surl
            .find(|c: char| !c.is_alphanumeric() && c != '_' && c != '-')
            .unwrap_or(surl.len());
        
        if end > 0 {
            return Some(surl[..end].to_string());
        }
    }
    
    if let Some(pos) = url.find("surl=") {
        let start = pos + 5;
        if start >= url.len() {
            return None;
        }
        
        let surl = &url[start..];
        let end = surl
            .find(|c: char| !c.is_alphanumeric() && c != '_' && c != '-')
            .unwrap_or(surl.len());
        
        if end > 0 {
            return Some(surl[..end].to_string());
        }
    }
    
    None
}

fn main() {
    let test_cases = vec![
        "https://pan.baidu.com/s/158pDc",
        "https://pan.baidu.com/s/1abcdefg",
        "pan.baidu.com/s/1xyz",
        "https://pan.baidu.com/share/init?surl=test123",
    ];

    for url in test_cases {
        match extract_surl(url) {
            Some(surl) => println!("âœ… {} -> {}", url, surl),
            None => println!("âŒ {} -> None", url),
        }
    }
}
EOF

cd /tmp
rustc test_surl.rs && ./test_surl
rm -f test_surl.rs test_surl
</file>

<file path="TRANSFER_FIX.md">
# è½¬å­˜æµç¨‹ä¿®å¤è¯´æ˜

## ğŸ”´ å·²ä¿®å¤çš„å…³é”®Bug

### 1. æ–‡ä»¶åŒ¹é…é€»è¾‘Bugï¼ˆæœ€ä¸¥é‡ï¼‰

**é—®é¢˜**ï¼š
```rust
// æ—§ä»£ç ï¼ˆé”™è¯¯ï¼‰
name_lower.contains(&expected_lower) || expected_lower.contains(&name_lower)
// "è¥¿åŒ—å¤§å­¦632æ•°å­¦åˆ†æ.pdf" åŒ…å« "p"ï¼Œå¯¼è‡´åŒ¹é…åˆ°æ–‡ä»¶åä¸º "P" çš„é”™è¯¯æ–‡ä»¶ï¼
```

**ä¿®å¤**ï¼š
```rust
// æ–°ä»£ç ï¼ˆæ­£ç¡®ï¼‰
// 1. å®Œå…¨ç²¾ç¡®åŒ¹é…
f.server_filename == *expected_name

// 2. å¿½ç•¥å¤§å°å†™çš„ç²¾ç¡®åŒ¹é…
f.server_filename.eq_ignore_ascii_case(expected_name)

// 3. å»é™¤æ‰©å±•ååç²¾ç¡®åŒ¹é…
file_stem.eq_ignore_ascii_case(expected_stem)
```

### 2. è½¬å­˜å‚æ•°ä¼˜åŒ–

**ä¿®æ”¹å‰**ï¼š
```rust
("ondup", "newcopy"),  // æ–‡ä»¶å·²å­˜åœ¨æ—¶æ–°å»ºå‰¯æœ¬
("async", "1"),        // å¼‚æ­¥æ¨¡å¼
```

**ä¿®æ”¹å**ï¼š
```rust
("ondup", "overwrite"), // âœ… è¦†ç›–æ¨¡å¼ï¼Œé¿å… "æ–‡ä»¶å·²å­˜åœ¨" é”™è¯¯
("async", "0"),         // âœ… åŒæ­¥æ¨¡å¼ï¼Œç«‹å³å®Œæˆè½¬å­˜
```

### 3. ä¿å­˜è·¯å¾„ç®€åŒ–

**ä¿®æ”¹å‰**ï¼š
- ä½¿ç”¨ `config.toml` ä¸­çš„ `savepath`
- å°è¯•å¤šä¸ªå¯èƒ½çš„è·¯å¾„
- å®¹æ˜“å‡ºç°è·¯å¾„ä¸ä¸€è‡´é—®é¢˜

**ä¿®æ”¹å**ï¼š
```rust
let save_path = "/";  // ç›´æ¥ä¿å­˜åˆ°æ ¹ç›®å½•
```

### 4. ç­‰å¾…æ—¶é—´ä¼˜åŒ–

**ä¿®æ”¹å‰**ï¼šç­‰å¾… 8 ç§’ï¼ˆå¼‚æ­¥æ¨¡å¼ï¼‰

**ä¿®æ”¹å**ï¼šç­‰å¾… 3 ç§’ï¼ˆåŒæ­¥æ¨¡å¼ï¼Œå®é™…ä¸Šè½¬å­˜å·²å®Œæˆï¼‰

## ğŸ“ ä¿®æ”¹çš„æ–‡ä»¶

### 1. `src/service/workflow.rs`
- è½¬å­˜åˆ°æ ¹ç›®å½•
- ä¿®å¤æ–‡ä»¶åŒ¹é…é€»è¾‘ï¼ˆç²¾ç¡®åŒ¹é…ï¼‰
- ä¼˜åŒ–æ—¥å¿—è¾“å‡º

### 2. `src/baidupcs/transfer.rs`
- ä¿å­˜è·¯å¾„æ”¹ä¸ºæ ¹ç›®å½• "/"
- è½¬å­˜æ¨¡å¼æ”¹ä¸ºåŒæ­¥ `async=0`
- é‡å¤å¤„ç†æ”¹ä¸ºè¦†ç›– `ondup=overwrite`

## ğŸ§ª æµ‹è¯•æ­¥éª¤

1. **ç¼–è¯‘**
```bash
cargo build --release
```

2. **å¯åŠ¨æœåŠ¡**
```bash
cargo run --release
```

3. **æµ‹è¯•è½¬å­˜**
```bash
curl -X POST http://localhost:5200/api/convert \
  -H "Content-Type: application/json" \
  -d '{
    "share_url": "https://pan.baidu.com/s/1xxxx",
    "pwd": "æå–ç "
  }'
```

4. **ä½¿ç”¨è°ƒè¯•æ¥å£æŸ¥çœ‹æ–‡ä»¶**
```bash
curl -X POST http://localhost:5200/api/debug/list \
  -H "Content-Type: application/json" \
  -d '{"path":"/"}'
```

## âœ… é¢„æœŸæ•ˆæœ

1. âœ… æ–‡ä»¶æ­£ç¡®åŒ¹é…ï¼ˆä¸ä¼šåŒ¹é…åˆ°é”™è¯¯æ–‡ä»¶ï¼‰
2. âœ… è½¬å­˜ç«‹å³å®Œæˆï¼ˆåŒæ­¥æ¨¡å¼ï¼‰
3. âœ… æ–‡ä»¶ä¿å­˜åœ¨æ ¹ç›®å½•ï¼ˆè·¯å¾„æ¸…æ™°ï¼‰
4. âœ… è¦†ç›–é‡å¤æ–‡ä»¶ï¼ˆé¿å… errno=2 é”™è¯¯ï¼‰

## ğŸ” è°ƒè¯•æ—¥å¿—å…³é”®ç‚¹

æˆåŠŸçš„æ—¥å¿—åº”è¯¥æ˜¯ï¼š
```
ğŸ“¦ å¼€å§‹è½¬å­˜ 1 ä¸ªæ–‡ä»¶åˆ°æ ¹ç›®å½•
âœ… è½¬å­˜æˆåŠŸ (errno=0)
â³ ç­‰å¾…è½¬å­˜å®Œæˆ...
ğŸ“ åˆ—ä¸¾æ ¹ç›®å½•
ğŸ“‹ åœ¨ / æ‰¾åˆ° X ä¸ªæ–‡ä»¶
  [1] è¥¿åŒ—å¤§å­¦632æ•°å­¦åˆ†æ.pdf
ğŸ“‹ å¼€å§‹åŒ¹é…æ–‡ä»¶ï¼ŒæœŸæœ› 1 ä¸ªæ–‡ä»¶
âœ… åŒ¹é…æˆåŠŸ - æœŸæœ›: è¥¿åŒ—å¤§å­¦632æ•°å­¦åˆ†æ.pdf, å®é™…: è¥¿åŒ—å¤§å­¦632æ•°å­¦åˆ†æ.pdf, fs_id: xxx
âœ… æˆåŠŸåŒ¹é… 1/1 ä¸ªæ–‡ä»¶
```

å¤±è´¥çš„æ—¥å¿—ä¼šæ˜¾ç¤ºï¼š
```
âš ï¸ æœªåŒ¹é…åˆ°æ–‡ä»¶: xxx
å¯ç”¨æ–‡ä»¶åˆ—è¡¨:
  [1] æ–‡ä»¶å1 (fs_id: xxx)
  [2] æ–‡ä»¶å2 (fs_id: xxx)
```
</file>

<file path=".devcontainer/devcontainer.json">
{
  "name": "Rust Pan Server",
  "image": "rust:1.91",
  
  // --- ğŸ‘‡ æ·»åŠ è¿™ä¸€æ®µ ğŸ‘‡ ---
  // å¼ºåˆ¶æŒ‡å®šå®¹å™¨å†…çš„ç¯å¢ƒå˜é‡ï¼Œç›´æ¥æŒ‡å‘ Windows ä¸»æœºçš„ 10808 ç«¯å£
  // è¿™æ ·æ—¢è¦†ç›–äº† VS Code å¯èƒ½æ³¨å…¥çš„é”™è¯¯ IP (127.0.0.1)ï¼Œä¹Ÿä¸éœ€è¦æ¯æ¬¡æ‰‹åŠ¨ export
  "containerEnv": {
    "http_proxy": "http://host.docker.internal:10808",
    "https_proxy": "http://host.docker.internal:10808",
    "HTTP_PROXY": "http://host.docker.internal:10808",
    "HTTPS_PROXY": "http://host.docker.internal:10808",
    "ALL_PROXY": "http://host.docker.internal:10808",
    "NO_PROXY": "localhost,127.0.0.1,::1,rsproxy.cn,crates.io"
  },
  // --- ğŸ‘† æ·»åŠ è¿™ä¸€æ®µ ğŸ‘† ---

  "customizations": {
    // ... å…¶ä»–é…ç½®ä¿æŒä¸å˜ ...
  },
  "remoteUser": "root",
  "postCreateCommand": "apt-get update && apt-get install -y pkg-config libssl-dev"
}
</file>

<file path="src/main.rs">
use anyhow::{anyhow, Result};
use std::sync::Arc;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

use baidu_direct_link::{
    config::Config,
    baidupcs,
    AppState,
};

#[tokio::main]
async fn main() -> Result<()> {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "baidu_direct_link=debug".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    tracing::info!("ğŸš€ ç™¾åº¦ç½‘ç›˜è½¬å­˜å·¥å…·å¯åŠ¨ä¸­...");

    // ç”¨æ³•ï¼šbaidu-direct-link <share_url> [pwd] [config_path]
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 2 {
        return Err(anyhow!(
            "ç”¨æ³•: {} <share_url> [pwd] [config_path]",
            args.get(0).map(|s| s.as_str()).unwrap_or("baidu-direct-link")
        ));
    }

    let share_url = args[1].clone();
    let pwd = args.get(2).cloned().unwrap_or_default();
    let config_path = args.get(3).map(|s| s.as_str()).unwrap_or("config.toml");

    // åŠ è½½é…ç½®
    let config = Config::load(config_path)?;
    tracing::info!("âœ… é…ç½®åŠ è½½å®Œæˆ: {}", config_path);

    // åˆå§‹åŒ–åº”ç”¨çŠ¶æ€ï¼ˆä»… Cookie + HTTP clientï¼‰
    let state = Arc::new(AppState::new(config)?);
    tracing::info!("âœ… HTTP Client åˆå§‹åŒ–å®Œæˆ");

    // æå– surl
    let surl = baidupcs::extract_surl(&share_url)
        .ok_or_else(|| anyhow!("æ— æ³•ä»é“¾æ¥ä¸­æå– surl: {}", share_url))?;

    // 1) è·å–åˆ†äº«ä¿¡æ¯
    let info = baidupcs::get_share_info(&state, &share_url, &surl, &pwd).await?;
    tracing::info!("ğŸ“¦ è·å–åˆ° {} ä¸ªæ–‡ä»¶ï¼Œå¼€å§‹è½¬å­˜...", info.fs_ids.len());

    // 2) è½¬å­˜
    baidupcs::transfer_files(
        &state,
        &info.shareid,
        &info.uk,
        &info.fs_ids,
        &info.bdstoken,
        &surl,
    )
    .await?;

    tracing::info!("âœ… è½¬å­˜è¯·æ±‚å·²å®Œæˆï¼Œä¿å­˜è·¯å¾„: {}", state.config.baidu.save_path);
    Ok(())
}
</file>

<file path="Cargo.toml">
[package]
name = "baidu-direct-link"
version = "1.0.0"
edition = "2021"
license = "MIT"
authors = ["Your Name <your.email@example.com>"]
repository = "https://github.com/yourusername/baidu-direct-link"
description = "ç™¾åº¦ç½‘ç›˜åˆ†äº«èµ„æºç›´é“¾ä¸‹è½½ç³»ç»Ÿï¼ˆOAuth 2.0ï¼‰"

[[bin]]
name = "baidu-direct-link"
path = "src/main.rs"

[lib]
name = "baidu_direct_link"
path = "src/lib.rs"

[dependencies]
tokio = { version = "1", features = ["rt-multi-thread", "macros", "fs"] }

# HTTP å®¢æˆ·ç«¯
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls", "json", "cookies"] }

# åºåˆ—åŒ–
serde = { version = "1", features = ["derive"] }
serde_json = "1"
toml = "0.8"

# é”™è¯¯å¤„ç†
anyhow = "1"

# æ­£åˆ™ï¼ˆç”¨äºæå– shareid/uk/bdstokenï¼‰
regex = "1"


# æ—¥å¿—
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }


[profile.release]
opt-level = 3
lto = true
codegen-units = 1
strip = true
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  app:
    image: rust:1.91
    container_name: pcs_dev
    # è‡ªåŠ¨æŠŠå½“å‰ç›®å½•æŒ‚è½½è¿›å»
    volumes:
      - .:/app
    working_dir: /app
    ports:
      - "5200:5200"
    # è¿™é‡Œé…ç½®ä¸€æ¬¡ï¼Œä»¥åå°±ä¸ç”¨ç®¡äº†
    environment:
      - http_proxy=http://host.docker.internal:10808
      - https_proxy=http://host.docker.internal:10808
      - HTTP_PROXY=http://host.docker.internal:10808
      - HTTPS_PROXY=http://host.docker.internal:10808
      - no_proxy=localhost,127.0.0.1,::1,rsproxy.cn,crates.io
    # å®¹å™¨å¯åŠ¨åè‡ªåŠ¨å®‰è£…ä¾èµ–å¹¶è¿è¡Œ
    # æ³¨æ„ï¼šè¿™é‡ŒæŠŠ apt install å’Œ cargo run è¿èµ·æ¥äº†
    command: >
      bash -c "apt-get update && apt-get install -y pkg-config libssl-dev && cargo run"
</file>

</files>
