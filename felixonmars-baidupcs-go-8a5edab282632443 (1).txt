Directory structure:
└── felixonmars-baidupcs-go/
    ├── README.md
    ├── BaiduPCS-Go.exe.manifest
    ├── build.sh
    ├── entitlements.xml
    ├── go.mod
    ├── go.sum
    ├── Info.plist
    ├── LICENSE
    ├── versioninfo.json
    ├── baidupcs/
    │   ├── baidupcs.go
    │   ├── cache.go
    │   ├── cloud_dl.go
    │   ├── cp_mv_rename.go
    │   ├── download.go
    │   ├── extends.go
    │   ├── file_directory.go
    │   ├── jsontable.go
    │   ├── prepare.go
    │   ├── publicsuffix.go
    │   ├── quota.go
    │   ├── recycle.go
    │   ├── rm_mkdir.go
    │   ├── share.go
    │   ├── upload.go
    │   ├── util.go
    │   ├── expires/
    │   │   ├── dataexpires.go
    │   │   ├── expires.go
    │   │   ├── expires.s
    │   │   └── cachemap/
    │   │       ├── cachemap.go
    │   │       ├── cachemap_test.go
    │   │       ├── cacheunit.go
    │   │       └── utils.go
    │   ├── internal/
    │   │   └── panhome/
    │   │       ├── cache.go
    │   │       ├── panhome.go
    │   │       ├── parse.go
    │   │       └── sign.go
    │   ├── netdisksign/
    │   │   ├── devuid.go
    │   │   ├── locatedownloadsign.go
    │   │   ├── locatedownloadsign_test.go
    │   │   ├── share_sign.go
    │   │   ├── sign2.go
    │   │   ├── sign2.js
    │   │   └── sign2_test.go
    │   └── pcserror/
    │       ├── dlinkerrinfo.go
    │       ├── panerrorinfo.go
    │       ├── pcserror.go
    │       └── pcserrorinfo.go
    ├── cmd/
    │   └── AndroidNDKBuild/
    │       └── main.go
    ├── debian/
    │   ├── copyright
    │   ├── Packages.sh
    │   ├── iphoneos-arm/
    │   │   └── control
    │   └── linux-amd64/
    │       └── control
    ├── docs/
    │   ├── README.md
    │   ├── file_data_apis_error.md
    │   ├── overview.md
    │   ├── structured_data_apis_error.md
    │   └── structured_data_apis_overview.md
    ├── internal/
    │   ├── pcscommand/
    │   │   ├── cd.go
    │   │   ├── cloud_dl.go
    │   │   ├── cp_mv.go
    │   │   ├── download.go
    │   │   ├── export.go
    │   │   ├── fixmd5.go
    │   │   ├── locatedonwload.go
    │   │   ├── login.go
    │   │   ├── ls_search.go
    │   │   ├── meta.go
    │   │   ├── pcscommand.go
    │   │   ├── quota.go
    │   │   ├── recycle.go
    │   │   ├── rm_mkdir.go
    │   │   ├── runner.go
    │   │   ├── share.go
    │   │   ├── tree.go
    │   │   ├── upload.go
    │   │   └── util.go
    │   ├── pcsconfig/
    │   │   ├── baidu.go
    │   │   ├── errors.go
    │   │   ├── export.go
    │   │   ├── maniper.go
    │   │   ├── pcsconfig.go
    │   │   └── util.go
    │   ├── pcsfunctions/
    │   │   ├── common.go
    │   │   ├── statistic.go
    │   │   ├── pcscaptcha/
    │   │   │   ├── captchapath.go
    │   │   │   └── pcscaptcha.go
    │   │   ├── pcsdownload/
    │   │   │   ├── download_link.go
    │   │   │   ├── download_statistic.go
    │   │   │   ├── download_task_unit.go
    │   │   │   ├── errors.go
    │   │   │   ├── pcsdownload.go
    │   │   │   └── utils.go
    │   │   └── pcsupload/
    │   │       ├── pcsupload.go
    │   │       ├── upload.go
    │   │       ├── upload2.go
    │   │       ├── upload_database.go
    │   │       ├── upload_statistic.go
    │   │       ├── upload_task_unit.go
    │   │       └── utils.go
    │   ├── pcsinit/
    │   │   ├── pcsinit.go
    │   │   └── pcsinit.s
    │   └── pcsupdate/
    │       ├── github.go
    │       ├── pcsupdate.go
    │       └── updatefile.go
    ├── pcsliner/
    │   ├── clear.go
    │   ├── clear.s
    │   ├── clear_windows.go
    │   ├── linehistory.go
    │   ├── pcsliner.go
    │   └── args/
    │       ├── args.go
    │       └── args_test.go
    ├── pcstable/
    │   └── pcstable.go
    ├── pcsutil/
    │   ├── addr.go
    │   ├── crypto.go
    │   ├── error.go
    │   ├── file.go
    │   ├── file_test.go
    │   ├── log_colorable_prefix.go
    │   ├── pcsutil.go
    │   ├── regexp_pre.go
    │   ├── cachepool/
    │   │   ├── cachepool.go
    │   │   ├── idcachepool.go
    │   │   ├── malloc.go
    │   │   ├── malloc.s
    │   │   ├── malloc_test.go
    │   │   └── syncpool.go
    │   ├── checkaccess/
    │   │   ├── check_others.go
    │   │   ├── check_unix.go
    │   │   ├── check_windows.go
    │   │   └── checkaccess.go
    │   ├── checksum/
    │   │   ├── checksum.go
    │   │   ├── checksum_test.go
    │   │   ├── checksum_write.go
    │   │   ├── errors.go
    │   │   └── file.go
    │   ├── converter/
    │   │   ├── converter.go
    │   │   ├── converter_test.go
    │   │   ├── short_display_test.go
    │   │   ├── size.go
    │   │   └── size_test.go
    │   ├── delay/
    │   │   └── delay.go
    │   ├── escaper/
    │   │   ├── escaper.go
    │   │   └── escaper_test.go
    │   ├── getip/
    │   │   ├── errors.go
    │   │   ├── getip.go
    │   │   ├── getip_netease.go
    │   │   ├── getip_techain.go
    │   │   └── getip_test.go
    │   ├── jsonhelper/
    │   │   └── jsonhelper.go
    │   ├── jwted25519/
    │   │   └── jwted25519.go
    │   ├── pcstime/
    │   │   └── time.go
    │   ├── prealloc/
    │   │   ├── errors.go
    │   │   ├── prealloc.go
    │   │   ├── prealloc_plan9.go
    │   │   └── prealloc_windows.go
    │   ├── taskframework/
    │   │   ├── executor.go
    │   │   ├── task_unit.go
    │   │   ├── taskframework_test.go
    │   │   └── taskinfo.go
    │   └── waitgroup/
    │       ├── wait_group.go
    │       └── wait_group_test.go
    ├── pcsverbose/
    │   ├── pcsverbose.go
    │   ├── utils.go
    │   └── pcsdebug/
    │       ├── cpu.go
    │       └── pprof.go
    ├── requester/
    │   ├── dial.go
    │   ├── fetch.go
    │   ├── http_client.go
    │   ├── requester.go
    │   ├── tcpaddr_cache.go
    │   ├── util.go
    │   ├── downloader/
    │   │   ├── config.go
    │   │   ├── download_firstinfo.go
    │   │   ├── download_test.go
    │   │   ├── downloader.go
    │   │   ├── example.go
    │   │   ├── instance_state.go
    │   │   ├── loadbalance.go
    │   │   ├── monitor.go
    │   │   ├── range_test.go
    │   │   ├── resetcontroler.go
    │   │   ├── sort.go
    │   │   ├── status.go
    │   │   ├── utils.go
    │   │   ├── worker.go
    │   │   └── writer.go
    │   ├── multipartreader/
    │   │   └── multipartreader.go
    │   ├── rio/
    │   │   ├── buf.go
    │   │   ├── file.go
    │   │   ├── multi.go
    │   │   ├── multi_test.go
    │   │   ├── rio.go
    │   │   └── speeds/
    │   │       ├── ratelimit.go
    │   │       ├── ratelimit_test.go
    │   │       └── speeds.go
    │   ├── transfer/
    │   │   ├── download_instanceinfo.go
    │   │   ├── download_status.go
    │   │   ├── rangelist.go
    │   │   ├── transfer.pb.go
    │   │   └── transfer.proto
    │   └── uploader/
    │       ├── block.go
    │       ├── block_test.go
    │       ├── error.go
    │       ├── example.go
    │       ├── instance_state.go
    │       ├── multiuploader.go
    │       ├── multiworker.go
    │       ├── readed.go
    │       ├── status.go
    │       └── uploader.go
    └── .github/
        └── RELEASE_TEMPLATE.md

================================================
FILE: README.md
================================================
# BaiduPCS-Go 百度网盘客户端

[![Build status](https://ci.appveyor.com/api/projects/status/nhx92nqyrfq9su7y?svg=true)](https://ci.appveyor.com/project/iikira/baidupcs-go)
[![GoDoc](https://godoc.org/github.com/iikira/BaiduPCS-Go?status.svg)](https://godoc.org/github.com/iikira/BaiduPCS-Go)

仿 Linux shell 文件处理命令的百度网盘命令行客户端.

This project was largely inspired by [GangZhuo/BaiduPCS](https://github.com/GangZhuo/BaiduPCS)

## 注意

此文档只针对于最新的commit, 可能不适用于已发布的最新版本.

<!-- toc -->
## 目录

- [特色](#特色)
- [编译/交叉编译 说明](#编译交叉编译-说明)
- [下载/运行 说明](#下载运行-说明)
  * [Windows](#windows)
  * [Linux / macOS](#linux--macos)
  * [Android / iOS](#android--ios)
- [命令列表及说明](#命令列表及说明)
  * [注意 ! ! !](#注意---)
  * [检测程序更新](#检测程序更新)
  * [登录百度帐号](#登录百度帐号)
  * [列出帐号列表](#列出帐号列表)
  * [获取当前帐号](#获取当前帐号)
  * [切换百度帐号](#切换百度帐号)
  * [退出百度帐号](#退出百度帐号)
  * [获取网盘配额](#获取网盘配额)
  * [切换工作目录](#切换工作目录)
  * [输出工作目录](#输出工作目录)
  * [列出目录](#列出目录)
  * [列出目录树形图](#列出目录树形图)
  * [获取文件/目录的元信息](#获取文件目录的元信息)
  * [搜索文件](#搜索文件)
  * [下载文件/目录](#下载文件目录)
  * [上传文件/目录](#上传文件目录)
  * [获取下载直链](#获取下载直链)
  * [手动秒传文件](#手动秒传文件)
  * [修复文件MD5](#修复文件MD5)
  * [获取本地文件的秒传信息](#获取本地文件的秒传信息)
  * [导出文件/目录](#导出文件目录)
  * [创建目录](#创建目录)
  * [删除文件/目录](#删除文件目录)
  * [拷贝文件/目录](#拷贝文件目录)
  * [移动/重命名文件/目录](#移动重命名文件目录)
  * [分享文件/目录](#分享文件目录)
    + [设置分享文件/目录](#设置分享文件目录)
    + [列出已分享文件/目录](#列出已分享文件目录)
    + [取消分享文件/目录](#取消分享文件目录)
  * [离线下载](#离线下载)
    + [添加离线下载任务](#添加离线下载任务)
    + [精确查询离线下载任务](#精确查询离线下载任务)
    + [查询离线下载任务列表](#查询离线下载任务列表)
    + [取消离线下载任务](#取消离线下载任务)
    + [删除离线下载任务](#删除离线下载任务)
  * [回收站](#回收站)
    + [列出回收站文件列表](#列出回收站文件列表)
    + [还原回收站文件或目录](#还原回收站文件或目录)
    + [删除回收站文件或目录/清空回收站](#删除回收站文件或目录清空回收站)
  * [显示和修改程序配置项](#显示和修改程序配置项)
  * [测试通配符](#测试通配符)
  * [工具箱](#工具箱)
- [初级使用教程](#初级使用教程)
  * [1. 查看程序使用说明](#1-查看程序使用说明)
  * [2. 登录百度帐号 (必做)](#2-登录百度帐号-必做)
  * [3. 切换网盘工作目录](#3-切换网盘工作目录)
  * [4. 网盘内列出文件和目录](#4-网盘内列出文件和目录)
  * [5. 下载文件](#5-下载文件)
  * [6. 设置下载最大并发量](#6-设置下载最大并发量)
  * [7. 退出程序](#7-退出程序)
- [常见问题](#常见问题)
- [TODO](#todo)
- [相关文档](#相关文档)
- [交流反馈](#交流反馈)
- [捐助](#捐助)

<!-- tocstop -->

# 特色

多平台支持, 支持 Windows, macOS, linux, 移动设备等.

百度帐号多用户支持;

通配符匹配网盘路径和 Tab 自动补齐命令和路径, [通配符_百度百科](https://baike.baidu.com/item/通配符);

[下载](#下载文件目录)网盘内文件, 支持多个文件或目录下载, 支持断点续传和单文件并行下载;

[上传](#上传文件目录)本地文件, 支持上传大文件(>2GB), 支持多个文件或目录上传;

[离线下载](#离线下载), 支持http/https/ftp/电驴/磁力链协议.

# 编译/交叉编译 说明
参见 [编译/交叉编译帮助](https://github.com/iikira/BaiduPCS-Go/wiki/编译-交叉编译帮助)

# 下载/运行 说明

Go语言程序, 可直接在[发布页](https://github.com/iikira/BaiduPCS-Go/releases)下载使用.

可在这里下载最新commit对应的**测试版**: https://ci.appveyor.com/project/iikira/baidupcs-go/build/artifacts

如果程序运行时输出乱码, 请检查下终端的编码方式是否为 `UTF-8`.

使用本程序之前, 建议学习一些 linux 基础知识 和 基础命令.

如果未带任何参数运行程序, 程序将会进入仿Linux shell系统用户界面的cli交互模式, 可直接运行相关命令.

cli交互模式下, 光标所在行的前缀应为 `BaiduPCS-Go >`, 如果登录了百度帐号则格式为 `BaiduPCS-Go:<工作目录> <百度ID>$ `

程序会提供相关命令的使用说明.

## Windows

程序应在 命令提示符 (Command Prompt) 或 PowerShell 中运行, 在 mintty (例如: GitBash) 可能会有显示问题.

也可直接双击程序运行, 具体使用方法请参见 [命令列表及说明](#命令列表及说明) 和 [初级使用教程](#初级使用教程).

## Linux / macOS

程序应在 终端 (Terminal) 运行.

具体使用方法请参见 [命令列表及说明](#命令列表及说明) 和 [初级使用教程](#初级使用教程).

## Android / iOS

> Android / iOS 移动设备操作比较麻烦, 不建议在移动设备上使用本程序.

安卓, 建议使用 [Termux](https://termux.com) 或 [NeoTerm](https://github.com/NeoTerm/NeoTerm) 或 终端模拟器, 以提供终端环境.

示例: [Android 运行本项目程序参考示例](https://github.com/iikira/BaiduPCS-Go/wiki/Android-运行本项目程序参考示例), 有兴趣的可以参考一下.

苹果iOS, 需要越狱, 在 Cydia 搜索下载并安装 MobileTerminal, 或者其他提供终端环境的软件.

示例: [iOS 运行本项目程序参考示例](https://github.com/iikira/BaiduPCS-Go/wiki/iOS-运行本项目程序参考示例), 有兴趣的可以参考一下.

具体使用方法请参见 [命令列表及说明](#命令列表及说明) 和 [初级使用教程](#初级使用教程).

# 命令列表及说明

## 注意 ! ! !

命令的前缀 `BaiduPCS-Go` 为指向程序运行的全路径名 (ARGv 的第一个参数)

直接运行程序时, 未带任何其他参数, 则程序进入cli交互模式, 运行以下命令时, 要把命令的前缀 `BaiduPCS-Go` 去掉!

cli交互模式已支持按tab键自动补全命令和路径.

## 检测程序更新
```
BaiduPCS-Go update
```

## 登录百度帐号

### 常规登录百度帐号

支持在线验证绑定的手机号或邮箱,
```
BaiduPCS-Go login
```

### 使用百度 BDUSS 来登录百度帐号

[关于 获取百度 BDUSS](https://github.com/iikira/BaiduPCS-Go/wiki/关于-获取百度-BDUSS)

```
BaiduPCS-Go login -bduss=<BDUSS>
```

#### 例子
```
BaiduPCS-Go login -bduss=1234567
```
```
BaiduPCS-Go login
请输入百度用户名(手机号/邮箱/用户名), 回车键提交 > 1234567
```

## 列出帐号列表

```
BaiduPCS-Go loglist
```

列出所有已登录的百度帐号

## 获取当前帐号

```
BaiduPCS-Go who
```

## 切换百度帐号

切换已登录的百度帐号
```
BaiduPCS-Go su <uid>
```
```
BaiduPCS-Go su

请输入要切换帐号的 # 值 >
```

## 退出百度帐号

退出当前登录的百度帐号
```
BaiduPCS-Go logout
```

程序会进一步确认退出帐号, 防止误操作.

## 获取网盘配额

```
BaiduPCS-Go quota
```
获取网盘的总储存空间, 和已使用的储存空间

## 切换工作目录
```
BaiduPCS-Go cd <目录>
```

### 切换工作目录后自动列出工作目录下的文件和目录
```
BaiduPCS-Go cd -l <目录>
```

#### 例子
```
# 切换 /我的资源 工作目录
BaiduPCS-Go cd /我的资源

# 切换 上级目录
BaiduPCS-Go cd ..

# 切换 根目录
BaiduPCS-Go cd /

# 切换 /我的资源 工作目录, 并自动列出 /我的资源 下的文件和目录
BaiduPCS-Go cd -l 我的资源

# 使用通配符
BaiduPCS-Go cd /我的*
```

## 输出工作目录
```
BaiduPCS-Go pwd
```

## 列出目录

列出当前工作目录的文件和目录或指定目录
```
BaiduPCS-Go ls
```
```
BaiduPCS-Go ls <目录>
```

### 可选参数
```
-asc: 升序排序
-desc: 降序排序
-time: 根据时间排序
-name: 根据文件名排序
-size: 根据大小排序
```

#### 例子
```
# 列出 我的资源 内的文件和目录
BaiduPCS-Go ls 我的资源

# 绝对路径
BaiduPCS-Go ls /我的资源

# 降序排序
BaiduPCS-Go ls -desc 我的资源

# 按文件大小降序排序
BaiduPCS-Go ls -size -desc 我的资源

# 使用通配符
BaiduPCS-Go ls /我的*
```

## 列出目录树形图

列出当前工作目录的文件和目录或指定目录的树形图
```
BaiduPCS-Go tree <目录>

# 默认获取工作目录元信息
BaiduPCS-Go tree
```

## 获取文件/目录的元信息
```
BaiduPCS-Go meta <文件/目录1> <文件/目录2> <文件/目录3> ...

# 默认获取工作目录元信息
BaiduPCS-Go meta
```

#### 例子
```
BaiduPCS-Go meta 我的资源
BaiduPCS-Go meta /
```

## 搜索文件

按文件名搜索文件（不支持查找目录）。

默认在当前工作目录搜索.

```
BaiduPCS-Go search [-path=<需要检索的目录>] [-r] <关键字>
```

#### 例子
```
# 搜索根目录的文件
BaiduPCS-Go search -path=/ 关键字

# 搜索当前工作目录的文件
BaiduPCS-Go search 关键字

# 递归搜索当前工作目录的文件
BaiduPCS-Go search -r 关键字
```

## 下载文件/目录
```
BaiduPCS-Go download <网盘文件或目录的路径1> <文件或目录2> <文件或目录3> ...
BaiduPCS-Go d <网盘文件或目录的路径1> <文件或目录2> <文件或目录3> ...
```

### 可选参数
```
  --test          测试下载, 此操作不会保存文件到本地
  --ow            overwrite, 覆盖已存在的文件
  --status        输出所有线程的工作状态
  --save          将下载的文件直接保存到当前工作目录
  --saveto value  将下载的文件直接保存到指定的目录
  -x              为文件加上执行权限, (windows系统无效)
  --mode value    下载模式, 可选值: pcs, stream, locate, 默认为 locate, 相关说明见上面的帮助 (default: "locate")
  -p value        指定下载线程数 (default: 0)
  -l value        指定同时进行下载文件的数量 (default: 0)
  --retry value   下载失败最大重试次数 (default: 3)
  --nocheck       下载文件完成后不校验文件

```

下载的文件默认保存到 **程序所在目录** 的 download/ 目录, 支持设置指定目录, 重名的文件会自动跳过!

下载的文件默认保存到, **程序所在目录**的 **download/** 目录.

通过 `BaiduPCS-Go config set -savedir <savedir>`, 自定义保存的目录.

支持多个文件或目录下载.
 
支持下载完成后自动校验文件, 但并不是所有的文件都支持校验!
 
自动跳过下载重名的文件!

[关于下载的简单说明](https://github.com/iikira/BaiduPCS-Go/wiki/%E5%85%B3%E4%BA%8E%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E)

#### 下载模式说明

* pcs: 通过百度网盘的 PCS API 下载

* stream: 通过百度网盘的 PCS API, 以流式文件的方式下载, 效果同 pcs

* locate: 默认的下载模式。从百度网盘 Android 客户端, 获取下载链接的方式来下载

#### 例子
```
# 设置保存目录, 保存到 D:\Downloads
# 注意区别反斜杠 "\" 和 斜杠 "/" !!!
BaiduPCS-Go config set -savedir D:/Downloads

# 下载 /我的资源/1.mp4
BaiduPCS-Go d /我的资源/1.mp4

# 下载 /我的资源 整个目录!!
BaiduPCS-Go d /我的资源

# 下载网盘内的全部文件!!
BaiduPCS-Go d /
BaiduPCS-Go d *
```

## 上传文件/目录
```
BaiduPCS-Go upload <本地文件/目录的路径1> <文件/目录2> <文件/目录3> ... <目标目录>
BaiduPCS-Go u <本地文件/目录的路径1> <文件/目录2> <文件/目录3> ... <目标目录>
```

* 上传默认采用分片上传的方式, 上传的文件将会保存到, <目标目录>.

* 遇到同名文件将会自动覆盖!!

* 当上传的文件名和网盘的目录名称相同时, 不会覆盖目录, 防止丢失数据.


#### 注意:

* 分片上传之后, 服务器可能会记录到错误的文件md5, 可使用 fixmd5 命令尝试修复文件的MD5值, 修复md5不一定能成功, 但文件的完整性是没问题的.

fixmd5 命令使用方法:
```
BaiduPCS-Go fixmd5 -h
```

* 禁用分片上传可以保证服务器记录到正确的md5.

* 禁用分片上传时只能使用单线程上传, 指定的单个文件上传最大线程数将会无效.

#### 例子:
```
# 将本地的 C:\Users\Administrator\Desktop\1.mp4 上传到网盘 /视频 目录
# 注意区别反斜杠 "\" 和 斜杠 "/" !!!
BaiduPCS-Go upload C:/Users/Administrator/Desktop/1.mp4 /视频

# 将本地的 C:\Users\Administrator\Desktop\1.mp4 和 C:\Users\Administrator\Desktop\2.mp4 上传到网盘 /视频 目录
BaiduPCS-Go upload C:/Users/Administrator/Desktop/1.mp4 C:/Users/Administrator/Desktop/2.mp4 /视频

# 将本地的 C:\Users\Administrator\Desktop 整个目录上传到网盘 /视频 目录
BaiduPCS-Go upload C:/Users/Administrator/Desktop /视频
```

## 获取下载直链
```
BaiduPCS-Go locate <文件1> <文件2> ...
```

#### 注意

若该功能无法正常使用, 提示`user is not authorized, hitcode:xxx`, 尝试更换 User-Agent 为 `netdisk;2.2.51.6;netdisk;10.0.63;PC;android-android`:
```
BaiduPCS-Go config set -user_agent "netdisk;2.2.51.6;netdisk;10.0.63;PC;android-android"
```

## 手动秒传文件
```
BaiduPCS-Go rapidupload -length=<文件的大小> -md5=<文件的md5值> -slicemd5=<文件前256KB切片的md5值(可选)> -crc32=<文件的crc32值(可选)> <保存的网盘路径, 需包含文件名>
BaiduPCS-Go ru -length=<文件的大小> -md5=<文件的md5值> -slicemd5=<文件前256KB切片的md5值(可选)> -crc32=<文件的crc32值(可选)> <保存的网盘路径, 需包含文件名>
```

注意: 使用此功能秒传文件, 前提是知道文件的大小, md5, 前256KB切片的 md5 (可选), crc32 (可选), 且百度网盘中存在一模一样的文件.

上传的文件将会保存到网盘的目标目录.

遇到同名文件将会自动覆盖! 

可能无法秒传 20GB 以上的文件!!

#### 例子:
```
# 如果秒传成功, 则保存到网盘路径 /test
BaiduPCS-Go rapidupload -length=56276137 -md5=fbe082d80e90f90f0fb1f94adbbcfa7f -slicemd5=38c6a75b0ec4499271d4ea38a667ab61 -crc32=314332359 /test
```


## 修复文件MD5
```
BaiduPCS-Go fixmd5 <文件1> <文件2> <文件3> ...
```

尝试修复文件的MD5值, 以便于校验文件的完整性和导出文件.

使用分片上传文件, 当文件分片数大于1时, 百度网盘服务端最终计算所得的md5值和本地的不一致, 这可能是百度网盘的bug.

不过把上传的文件下载到本地后，对比md5值是匹配的, 也就是文件在传输中没有发生损坏.

对于MD5值可能有误的文件, 程序会在获取文件的元信息时, 给出MD5值 "可能不正确" 的提示, 表示此文件可以尝试进行MD5值修复.

修复文件MD5不一定能成功, 原因可能是服务器未刷新, 可过几天后再尝试.

修复文件MD5的原理为秒传文件, 即修复文件MD5成功后, 文件的**创建日期, 修改日期, fs_id, 版本历史等信息**将会被覆盖, 修复的MD5值将覆盖原先的MD5值, 但不影响文件的完整性.

注意: 无法修复 **20GB** 以上文件的 md5!!

#### 例子:
```
# 修复 /我的资源/1.mp4 的 MD5 值
BaiduPCS-Go fixmd5 /我的资源/1.mp4
```

## 获取本地文件的秒传信息
```
BaiduPCS-Go sumfile <本地文件的路径>
BaiduPCS-Go sf <本地文件的路径>
```

获取本地文件的大小, md5, 前256KB切片的 md5, crc32, 可用于秒传文件.

#### 例子:
```
# 获取 C:\Users\Administrator\Desktop\1.mp4 的秒传信息
BaiduPCS-Go sumfile C:/Users/Administrator/Desktop/1.mp4
```

## 导出文件/目录
```
BaiduPCS-Go export <文件/目录1> <文件/目录2> ...
BaiduPCS-Go ep <文件/目录1> <文件/目录2> ...
```

导出网盘内的文件或目录, 原理为秒传文件, 此操作会生成导出文件或目录的命令.

#### 注意

**无法导出 20GB 以上的文件!!**

**无法导出文件的版本历史等数据!!**

并不是所有的文件都能导出成功, 程序会列出无法导出的文件列表

#### 例子:
```
# 导出当前工作目录:
BaiduPCS-Go export

# 导出所有文件和目录, 并设置新的根目录为 /root
BaiduPCS-Go export -root=/root /

# 导出 /我的资源
BaiduPCS-Go export /我的资源
```

## 创建目录
```
BaiduPCS-Go mkdir <目录>
```

#### 例子
```
BaiduPCS-Go mkdir 123
```

## 删除文件/目录
```
BaiduPCS-Go rm <网盘文件或目录的路径1> <文件或目录2> <文件或目录3> ...
```

注意: 删除多个文件和目录时, 请确保每一个文件和目录都存在, 否则删除操作会失败.

被删除的文件或目录可在网盘文件回收站找回.

#### 例子
```
# 删除 /我的资源/1.mp4
BaiduPCS-Go rm /我的资源/1.mp4

# 删除 /我的资源/1.mp4 和 /我的资源/2.mp4
BaiduPCS-Go rm /我的资源/1.mp4 /我的资源/2.mp4

# 删除 /我的资源 内的所有文件和目录, 但不删除该目录
BaiduPCS-Go rm /我的资源/*

# 删除 /我的资源 整个目录 !!
BaiduPCS-Go rm /我的资源
```

## 拷贝文件/目录
```
BaiduPCS-Go cp <文件/目录> <目标 文件/目录>
BaiduPCS-Go cp <文件/目录1> <文件/目录2> <文件/目录3> ... <目标目录>
```

注意: 拷贝多个文件和目录时, 请确保每一个文件和目录都存在, 否则拷贝操作会失败.

#### 例子
```
# 将 /我的资源/1.mp4 复制到 根目录 /
BaiduPCS-Go cp /我的资源/1.mp4 /

# 将 /我的资源/1.mp4 和 /我的资源/2.mp4 复制到 根目录 /
BaiduPCS-Go cp /我的资源/1.mp4 /我的资源/2.mp4 /
```

## 移动/重命名文件/目录
```
# 移动:
BaiduPCS-Go mv <文件/目录1> <文件/目录2> <文件/目录3> ... <目标目录>
# 重命名:
BaiduPCS-Go mv <文件/目录> <重命名的文件/目录>
```

注意: 移动多个文件和目录时, 请确保每一个文件和目录都存在, 否则移动操作会失败.

#### 例子
```
# 将 /我的资源/1.mp4 移动到 根目录 /
BaiduPCS-Go mv /我的资源/1.mp4 /

# 将 /我的资源/1.mp4 重命名为 /我的资源/3.mp4
BaiduPCS-Go mv /我的资源/1.mp4 /我的资源/3.mp4
```

## 分享文件/目录
```
BaiduPCS-Go share
```

### 设置分享文件/目录
```
BaiduPCS-Go share set <文件/目录1> <文件/目录2> ...
BaiduPCS-Go share s <文件/目录1> <文件/目录2> ...
```

### 列出已分享文件/目录
```
BaiduPCS-Go share list
BaiduPCS-Go share l
```

### 取消分享文件/目录
```
BaiduPCS-Go share cancel <shareid_1> <shareid_2> ...
BaiduPCS-Go share c <shareid_1> <shareid_2> ...
```

目前只支持通过分享id (shareid) 来取消分享.

## 离线下载
```
BaiduPCS-Go offlinedl
BaiduPCS-Go clouddl
BaiduPCS-Go od
```

离线下载支持http/https/ftp/电驴/磁力链协议

离线下载同时进行的任务数量有限, 超出限制的部分将无法添加.

### 添加离线下载任务
```
BaiduPCS-Go offlinedl add -path=<离线下载文件保存的路径> 资源地址1 地址2 ...
```

添加任务成功之后, 返回离线下载的任务ID.

### 精确查询离线下载任务
```
BaiduPCS-Go offlinedl query 任务ID1 任务ID2 ...
```

### 查询离线下载任务列表
```
BaiduPCS-Go offlinedl list
```

### 取消离线下载任务
```
BaiduPCS-Go offlinedl cancel 任务ID1 任务ID2 ...
```

### 删除离线下载任务
```
BaiduPCS-Go offlinedl delete 任务ID1 任务ID2 ...

# 清空离线下载任务记录, 程序不会进行二次确认, 谨慎操作!!!
BaiduPCS-Go offlinedl delete -all
```

#### 例子
```
# 将百度和腾讯主页, 离线下载到根目录 /
BaiduPCS-Go offlinedl add -path=/ http://baidu.com http://qq.com

# 添加磁力链接任务
BaiduPCS-Go offlinedl add magnet:?xt=urn:btih:xxx

# 查询任务ID为 12345 的离线下载任务状态
BaiduPCS-Go offlinedl query 12345

# 取消任务ID为 12345 的离线下载任务
BaiduPCS-Go offlinedl cancel 12345
```

## 回收站
```
BaiduPCS-Go recycle
```

回收站操作.

### 列出回收站文件列表
```
BaiduPCS-Go recycle list
```

#### 可选参数
```
  --page value  回收站文件列表页数 (default: 1)
```

### 还原回收站文件或目录
```
BaiduPCS-Go recycle restore <fs_id 1> <fs_id 2> <fs_id 3> ...
```

根据文件/目录的 fs_id, 还原回收站指定的文件或目录.

### 删除回收站文件或目录/清空回收站
```
BaiduPCS-Go recycle delete [-all] <fs_id 1> <fs_id 2> <fs_id 3> ...
```

根据文件/目录的 fs_id 或 -all 参数, 删除回收站指定的文件或目录或清空回收站.

#### 例子
```
# 从回收站还原两个文件, 其中的两个文件的 fs_id 分别为 1013792297798440 和 643596340463870
BaiduPCS-Go recycle restore 1013792297798440 643596340463870

# 从回收站删除两个文件, 其中的两个文件的 fs_id 分别为 1013792297798440 和 643596340463870
BaiduPCS-Go recycle delete 1013792297798440 643596340463870

# 清空回收站, 程序不会进行二次确认, 谨慎操作!!!
BaiduPCS-Go recycle delete -all
```

## 显示程序环境变量
```
BaiduPCS-Go env
```

BAIDUPCS_GO_CONFIG_DIR: 配置文件路径,

BAIDUPCS_GO_VERBOSE: 是否启用调试.

## 显示和修改程序配置项
```
# 显示配置
BaiduPCS-Go config

# 设置配置
BaiduPCS-Go config set
```

注意: v3.5 以后, 程序对配置文件储存路径的寻找做了调整, 配置文件所在的目录可以是程序本身所在目录, 也可以是家目录.

配置文件所在的目录为家目录的情况:

Windows: `%APPDATA%\BaiduPCS-Go`

其他操作系统: `$HOME/.config/BaiduPCS-Go`

可通过设置环境变量 `BAIDUPCS_GO_CONFIG_DIR`, 指定配置文件存放的目录.

谨慎修改 `appid`, `user_agent`, `pcs_ua`, `pan_ua` 的值, 否则访问网盘服务器时, 可能会出现错误.

`cache_size` 的值支持可选设置单位了, 单位不区分大小写, `b` 和 `B` 均表示字节的意思, 如 `64KB`, `1MB`, `32kb`, `65536b`, `65536`.

`max_upload_parallel`, `max_download_load` 的值支持可选设置单位了, 单位为每秒的传输速率, 后缀`/s` 可省略, 如 `2MB/s`, `2MB`, `2m`, `2mb` 均为一个意思.

#### 例子
```
# 显示所有可以设置的值
BaiduPCS-Go config -h
BaiduPCS-Go config set -h

# 设置下载文件的储存目录
BaiduPCS-Go config set -savedir D:/Downloads

# 设置下载最大并发量为 150
BaiduPCS-Go config set -max_parallel 150

# 组合设置
BaiduPCS-Go config set -max_parallel 150 -savedir D:/Downloads
```

## 测试通配符
```
BaiduPCS-Go match <通配符表达式>
```

测试通配符匹配路径, 操作成功则输出所有匹配到的路径.

#### 例子
```
# 匹配 /我的资源 目录下所有mp4格式的文件
BaiduPCS-Go match /我的资源/*.mp4
```

## 工具箱
```
BaiduPCS-Go tool
```

目前工具箱支持加解密文件等.

# 初级使用教程

新手建议: **双击运行程序**, 进入仿 Linux shell 的 cli 交互模式;

cli交互模式下, 光标所在行的前缀应为 `BaiduPCS-Go >`, 如果登录了百度帐号则格式为 `BaiduPCS-Go:<工作目录> <百度ID>$ `

以下例子的命令, 均为 cli交互模式下的命令

运行命令的正确操作: **输入命令, 按一下回车键 (键盘上的 Enter 键)**, 程序会接收到命令并输出结果

## 1. 查看程序使用说明

cli交互模式下, 运行命令 `help`

## 2. 登录百度帐号 (必做)

cli交互模式下, 运行命令 `login -h` (注意空格) 查看帮助

cli交互模式下, 运行命令 `login` 程序将会提示你输入百度用户名(手机号/邮箱/用户名)和密码, 必要时还可以在线验证绑定的手机号或邮箱

## 3. 切换网盘工作目录

cli交互模式下, 运行命令 `cd /我的资源` 将工作目录切换为 `/我的资源` (前提: 该目录存在于网盘)

目录支持通配符匹配, 所以你也可以这样: 运行命令 `cd /我的*` 或 `cd /我的??` 将工作目录切换为 `/我的资源`, 简化输入.

将工作目录切换为 `/我的资源` 成功后, 运行命令 `cd ..` 切换上级目录, 即将工作目录切换为 `/`

为什么要这样设计呢, 举个例子,

假设 你要下载 `/我的资源` 内名为 `1.mp4` 和 `2.mp4` 两个文件, 而未切换工作目录, 你需要依次运行以下命令:

```
d /我的资源/1.mp4
d /我的资源/2.mp4
```

而切换网盘工作目录之后, 依次运行以下命令:

```
cd /我的资源
d 1.mp4
d 2.mp4
```

这样就达到了简化输入的目的

## 4. 网盘内列出文件和目录

cli交互模式下, 运行命令 `ls -h` (注意空格) 查看帮助

cli交互模式下, 运行命令 `ls` 来列出当前所在目录的文件和目录

cli交互模式下, 运行命令 `ls /我的资源` 来列出 `/我的资源` 内的文件和目录

cli交互模式下, 运行命令 `ls ..` 来列出当前所在目录的上级目录的文件和目录

## 5. 下载文件

说明: 下载的文件默认保存到 download/ 目录 (文件夹)

cli交互模式下, 运行命令 `d -h` (注意空格) 查看帮助

cli交互模式下, 运行命令 `d /我的资源/1.mp4` 来下载位于 `/我的资源/1.mp4` 的文件 `1.mp4` , 该操作等效于运行以下命令:

```
cd /我的资源
d 1.mp4
```

现在已经支持目录 (文件夹) 下载, 所以, 运行以下命令, 会下载 `/我的资源` 内的所有文件 (违规文件除外):

```
d /我的资源
```

## 6. 设置下载最大并发量

cli交互模式下, 运行命令 `config set -h` (注意空格) 查看设置帮助以及可供设置的值

cli交互模式下, 运行命令 `config set -max_parallel 2` 将下载最大并发量设置为 2

注意：下载最大并发量的值不易设置过高, 可能会导致百度帐号被限制下载

## 7. 退出程序

运行命令 `quit` 或 `exit` 或 组合键 `Ctrl+C` 或 组合键 `Ctrl+D`

# 已知问题

* 分片上传文件时, 当文件分片数大于1, 网盘端最终计算所得的md5值和本地的不一致, 这可能是百度网盘的bug, 测试把上传的文件下载到本地后，对比md5值是匹配的. 可通过秒传的原理来修复md5值.

# 常见问题

参见 [常见问题](https://github.com/iikira/BaiduPCS-Go/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98)

# TODO


# 相关文档
详见: https://github.com/iikira/BaiduPCS-Go/tree/master/docs

# 交流反馈

提交Issue: [Issues](https://github.com/iikira/BaiduPCS-Go/issues)

邮箱: i@mail.iikira.com

QQ群: 178324706



================================================
FILE: BaiduPCS-Go.exe.manifest
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
	<assemblyIdentity version="1.0.0.0" processorArchitecture="*" name="com.iikira.baidupcsgo" type="win32"/>
	<dependency>
		<dependentAssembly>
			<assemblyIdentity type="win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*"/>
		</dependentAssembly>
	</dependency>
	<asmv3:application>
		<asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
			<dpiAware>true</dpiAware>
		</asmv3:windowsSettings>
	</asmv3:application>
</assembly>


================================================
FILE: build.sh
================================================
#!/bin/sh

name="BaiduPCS-Go"
version=$1

if [ "$1" = "" ]; then
  version=v3.6.2
fi

output="out/"

GOROOT=/usr

old_golang() {
  #GOROOT=/usr/local/go1.10.8
  go=$GOROOT/bin/go
}

new_golang() {
  #GOROOT=/usr/local/go
  go=$GOROOT/bin/go
}

Build() {
  old_golang
  goarm=$4
  if [ "$4" = "" ]; then
    goarm=7
  fi

  echo "Building $1..."
  export GOOS=$2 GOARCH=$3 GO386=sse2 CGO_ENABLED=0 GOARM=$4
  if [ $2 = "windows" ]; then
    goversioninfo -o=resource_windows_386.syso
    goversioninfo -64 -o=resource_windows_amd64.syso
    $go build -ldflags "-X main.Version=$version -s -w" -o "$output/$1/$name.exe"
    RicePack $1 $name.exe
  else
    $go build -ldflags "-X main.Version=$version -s -w" -o "$output/$1/$name"
    RicePack $1 $name
  fi

  Pack $1
}

AndroidBuild() {
  new_golang
  echo "Building $1..."
  export GOOS=$2 GOARCH=$3 GOARM=$4 CGO_ENABLED=1
  go build -ldflags "-X main.Version=$version -s -w -linkmode=external -extldflags=-pie" -o "$output/$1/$name"

  RicePack $1 $name
  Pack $1
}

IOSBuild() {
  old_golang
  echo "Building $1..."
  mkdir -p "$output/$1"
  cd "$output/$1"
  export CC=/usr/local/go/misc/ios/clangwrap.sh GOOS=darwin GOARCH=arm GOARM=7 CGO_ENABLED=1
  $go build -ldflags "-X main.Version=$version -s -w" -o "armv7" github.com/felixonmars/BaiduPCS-Go
  jtool --sign --inplace --ent ../../entitlements.xml "armv7"
  export GOARCH=arm64
  $go build -ldflags "-X main.Version=$version -s -w" -o "arm64" github.com/felixonmars/BaiduPCS-Go
  jtool --sign --inplace --ent ../../entitlements.xml "arm64"
  lipo -create "armv7" "arm64" -output $name # merge
  rm "armv7" "arm64"
  cd ../..
  RicePack $1 $name
  Pack $1
}

# zip 打包
Pack() {
  cp README.md "$output/$1"

  cd $output
  zip -q -r "$1.zip" "$1"

  # 删除
  rm -rf "$1"

  cd ..
}

# rice 打包静态资源
RicePack() {
  return # 已取消web功能
  rice -i github.com/felixonmars/BaiduPCS-Go/internal/pcsweb append --exec "$output/$1/$2"
}

touch ./vendor/golang.org/x/sys/windows/windows.s

# Android
export NDK_INSTALL=$ANDROID_NDK_ROOT/bin
# CC=$NDK_INSTALL/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-gcc AndroidBuild $name-$version"-android-16-armv5" android arm 5
# CC=$NDK_INSTALL/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-gcc AndroidBuild $name-$version"-android-16-armv6" android arm 6
#CC=$NDK_INSTALL/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-gcc AndroidBuild $name-$version"-android-16-armv7" android arm 7
#CC=$NDK_INSTALL/aarch64-linux-android-4.9/bin/aarch64-linux-android-gcc AndroidBuild $name-$version"-android-21-arm64" android arm64 7
#CC=$NDK_INSTALL/i686-linux-android-4.9/bin/i686-linux-android-gcc AndroidBuild $name-$version"-android-16-386" android 386 7
#CC=$NDK_INSTALL/x86_64-linux-android-4.9/bin/x86_64-linux-android-gcc AndroidBuild $name-$version"-android-21-amd64" android amd64 7

# iOS
IOSBuild $name-$version"-darwin-ios-arm"

# OS X / macOS
Build $name-$version"-darwin-osx-amd64" darwin amd64
# Build $name-$version"-darwin-osx-386" darwin 386

# Windows
Build $name-$version"-windows-x86" windows 386
Build $name-$version"-windows-x64" windows amd64

# Linux
Build $name-$version"-linux-386" linux 386
Build $name-$version"-linux-amd64" linux amd64
Build $name-$version"-linux-armv5" linux arm 5
Build $name-$version"-linux-armv7" linux arm 7
Build $name-$version"-linux-arm64" linux arm64
GOMIPS=softfloat Build $name-$version"-linux-mips" linux mips
Build $name-$version"-linux-mips64" linux mips64
GOMIPS=softfloat Build $name-$version"-linux-mipsle" linux mipsle
Build $name-$version"-linux-mips64le" linux mips64le
# Build $name-$version"-linux-ppc64" linux ppc64
# Build $name-$version"-linux-ppc64le" linux ppc64le
# Build $name-$version"-linux-s390x" linux s390x

# Others
# Build $name-$version"-solaris-amd64" solaris amd64
Build $name-$version"-freebsd-386" freebsd 386
Build $name-$version"-freebsd-amd64" freebsd amd64
# Build $name-$version"-freebsd-arm" freebsd arm
# Build $name-$version"-netbsd-386" netbsd	386
# Build $name-$version"-netbsd-amd64" netbsd amd64
# Build $name-$version"-netbsd-arm" netbsd	arm
# Build $name-$version"-openbsd-386" openbsd 386
# Build $name-$version"-openbsd-amd64" openbsd	amd64
# Build $name-$version"-openbsd-arm" openbsd arm
# Build $name-$version"-plan9-386" plan9 386
# Build $name-$version"-plan9-amd64" plan9 amd64
# Build $name-$version"-plan9-arm" plan9 arm
# Build $name-$version"-nacl-386" nacl 386
# Build $name-$version"-nacl-amd64p32" nacl amd64p32
# Build $name-$version"-nacl-arm" nacl arm
# Build $name-$version"-dragonflybsd-amd64" dragonfly amd64



================================================
FILE: entitlements.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>application-identifier</key>
        <string>com.iikira.baidupcsgo</string>
        <key>get-task-allow</key>
        <true/>
        <key>platform-application</key>
        <true/>
        <key>keychain-access-groups</key>
        <array>
            <string>com.iikira.baidupcsgo</string>
        </array>
    </dict>
</plist>


================================================
FILE: go.mod
================================================
module github.com/felixonmars/BaiduPCS-Go

go 1.12

require (
	github.com/GeertJohan/go.incremental v1.0.0
	github.com/GeertJohan/go.rice v0.0.0-20170420135705-c02ca9a983da // indirect
	github.com/astaxie/beego v1.10.1 // indirect
	github.com/bitly/go-simplejson v0.5.0 // indirect
	github.com/daaku/go.zipexe v0.0.0-20150329023125-a5fe2436ffcb // indirect
	github.com/dgrijalva/jwt-go v3.2.0+incompatible
	github.com/fatih/color v0.0.0-20150510220652-1b35f289c47d
	github.com/felixonmars/Baidu-Login v1.2.2-0.20180427090606-ecf146973528
	github.com/felixonmars/baidu-tools v0.0.0-20190609113215-4dd64618064d
	github.com/golang/protobuf v1.3.2
	github.com/iikira/Baidu-Login v1.2.2 // indirect
	github.com/iikira/BaiduPCS-Go v3.5.6+incompatible // indirect
	github.com/iikira/baidu-tools v0.0.0-20190609113215-4dd64618064d // indirect
	github.com/json-iterator/go v1.1.7
	github.com/kardianos/osext v0.0.0-20170510131534-ae77be60afb1
	github.com/mattn/go-runewidth v0.0.5-0.20181218000649-703b5e6b11ae
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/oleiade/lane v0.0.0-20160817071224-3053869314bb
	github.com/olekukonko/tablewriter v0.0.2-0.20190618033246-cc27d85e17ce
	github.com/peterh/liner v1.1.1-0.20190305032635-6f820f8f90ce
	github.com/shiena/ansicolor v0.0.0-20151119151921-a422bbe96644 // indirect
	github.com/urfave/cli v1.21.1-0.20190817182405-23c83030263f
	golang.org/x/crypto v0.0.0-20190820162420-60c769a6c586
	golang.org/x/sys v0.0.0-20191025090151-53bf42e6b339
)



================================================
FILE: go.sum
================================================
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/GeertJohan/go.incremental v1.0.0 h1:7AH+pY1XUgQE4Y1HcXYaMqAI0m9yrFqo/jt0CW30vsg=
github.com/GeertJohan/go.incremental v1.0.0/go.mod h1:6fAjUhbVuX1KcMD3c8TEgVUqmo4seqhv0i0kdATSkM0=
github.com/GeertJohan/go.rice v0.0.0-20170420135705-c02ca9a983da h1:UVU3a9pRUyLdnBtn60WjRl0s4SEyJc2ChCY56OAR6wI=
github.com/GeertJohan/go.rice v0.0.0-20170420135705-c02ca9a983da/go.mod h1:DgrzXonpdQbfN3uYaGz1EG4Sbhyum/MMIn6Cphlh2bw=
github.com/GeertJohan/go.rice v1.0.0 h1:KkI6O9uMaQU3VEKaj01ulavtF7o1fWT7+pk/4voiMLQ=
github.com/GeertJohan/go.rice v1.0.0/go.mod h1:eH6gbSOAUv07dQuZVnBmoDP8mgsM1rtixis4Tib9if0=
github.com/akavel/rsrc v0.8.0/go.mod h1:uLoCtb9J+EyAqh+26kdrTgmzRBFPGOolLWKpdxkKq+c=
github.com/astaxie/beego v1.10.1 h1:M2ciUnyiZycuTpGEA+idJF0gX24h58EbPvGqjnO/DCg=
github.com/astaxie/beego v1.10.1/go.mod h1:0R4++1tUqERR0WYFWdfkcrsyoVBCG4DgpDGokT3yb+U=
github.com/bitly/go-simplejson v0.5.0 h1:6IH+V8/tVMab511d5bn4M7EwGXZf9Hj6i2xSwkNEM+Y=
github.com/bitly/go-simplejson v0.5.0/go.mod h1:cXHtHw4XUPsvGaxgjIAn8PhEWG9NfngEKAMDJEczWVA=
github.com/cpuguy83/go-md2man v1.0.10 h1:BSKMNlYxDvnunlTymqtgONjNnaRV1sTpcovwwjF22jk=
github.com/cpuguy83/go-md2man v1.0.10/go.mod h1:SmD6nW6nTyfqj6ABTjUi3V3JVMnlJmwcJI5acqYI6dE=
github.com/daaku/go.zipexe v0.0.0-20150329023125-a5fe2436ffcb h1:tUf55Po0vzOendQ7NWytcdK0VuzQmfAgvGBUOQvN0WA=
github.com/daaku/go.zipexe v0.0.0-20150329023125-a5fe2436ffcb/go.mod h1:U0vRfAucUOohvdCxt5MWLF+TePIL0xbCkbKIiV8TQCE=
github.com/daaku/go.zipexe v1.0.0 h1:VSOgZtH418pH9L16hC/JrgSNJbbAL26pj7lmD1+CGdY=
github.com/daaku/go.zipexe v1.0.0/go.mod h1:z8IiR6TsVLEYKwXAoE/I+8ys/sDkgTzSL0CLnGVd57E=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dgrijalva/jwt-go v3.2.0+incompatible h1:7qlOGliEKZXTDg6OTjfoBKDXWrumCAMpl/TFQ4/5kLM=
github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=
github.com/fatih/color v0.0.0-20150510220652-1b35f289c47d h1:wMOLsfJ92CRGk3+GtVk+aaUme+jWTH21jH3cVL1jzmI=
github.com/fatih/color v0.0.0-20150510220652-1b35f289c47d/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=
github.com/felixonmars/Baidu-Login v0.0.0-20180427090606-ecf146973528 h1:WaZCDfR+C0z17lO7syZFXpJ7d8YUxv5iG1/PeYzjKiM=
github.com/felixonmars/Baidu-Login v0.0.0-20180427090606-ecf146973528/go.mod h1:iANGZirDaKKKiijrX6J9Tqy4D+BYIBi/NkoZ0weUdbo=
github.com/felixonmars/Baidu-Login v1.2.2-0.20180427090606-ecf146973528 h1:FzumOZ5hWbUnCe3ZE6uN/2D5F6WVUtOmHRPiRPPqneU=
github.com/felixonmars/Baidu-Login v1.2.2-0.20180427090606-ecf146973528/go.mod h1:iANGZirDaKKKiijrX6J9Tqy4D+BYIBi/NkoZ0weUdbo=
github.com/felixonmars/baidu-tools v0.0.0-20180922000818-79c93d8033cd h1:meH/UWnJi8GuWEjMFivCnwp2NWdqhDnTsIIkb5SptZQ=
github.com/felixonmars/baidu-tools v0.0.0-20180922000818-79c93d8033cd/go.mod h1:pThvOx25nUwZM1zTireFAPHxT8Yj75oR4P5MbGJbKQ0=
github.com/felixonmars/baidu-tools v0.0.0-20190609113215-4dd64618064d h1:DwIXGc5ac7cp6wXYgach2ZHYqFLFIiQFsoLszR/BsgU=
github.com/felixonmars/baidu-tools v0.0.0-20190609113215-4dd64618064d/go.mod h1:pThvOx25nUwZM1zTireFAPHxT8Yj75oR4P5MbGJbKQ0=
github.com/golang/protobuf v1.3.2 h1:6nsPYzhq5kReh6QImI3k5qWzO4PEbvbIW2cwSfR/6xs=
github.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
github.com/iikira/Baidu-Login v1.2.2 h1:1R/ptmJdMIIMUaXSdtcrgf6JuULmo9ZyDYn9m3kiMBQ=
github.com/iikira/Baidu-Login v1.2.2/go.mod h1:oMWxZOoEMgQG+0rq8xhEIdxvXwkyG4aN3sZoOQ59R4Q=
github.com/iikira/BaiduPCS-Go v3.5.6+incompatible h1:oKsLtn0zPCsuQZs8AXuLTdd3PVyFnzjqcFnv7jGb8v8=
github.com/iikira/BaiduPCS-Go v3.5.6+incompatible/go.mod h1:/Dv6EqOSD+ihyltwf0i//5shl8feBdebd92bqB9faYM=
github.com/iikira/baidu-tools v0.0.0-20190609113215-4dd64618064d h1:nmsuPx1si1QI3boPuaQjxp536X7RAeLW26DBmcdRXO0=
github.com/iikira/baidu-tools v0.0.0-20190609113215-4dd64618064d/go.mod h1:UHD1R9RGXz5nDsKm3KbdD3yxCJZ18nmR+1ZAc5GkrNw=
github.com/jessevdk/go-flags v1.4.0/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=
github.com/json-iterator/go v1.1.5 h1:gL2yXlmiIo4+t+y32d4WGwOjKGYcGOuyrg46vadswDE=
github.com/json-iterator/go v1.1.5/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=
github.com/json-iterator/go v1.1.7 h1:KfgG9LzI+pYjr4xvmz/5H4FXjokeP+rlHLhv3iH62Fo=
github.com/json-iterator/go v1.1.7/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=
github.com/kardianos/osext v0.0.0-20170510131534-ae77be60afb1 h1:PJPDf8OUfOK1bb/NeTKd4f1QXZItOX389VN3B6qC8ro=
github.com/kardianos/osext v0.0.0-20170510131534-ae77be60afb1/go.mod h1:1NbS8ALrpOvjt0rHPNLyCIeMtbizbir8U//inJ+zuB8=
github.com/mattn/go-runewidth v0.0.3 h1:a+kO+98RDGEfo6asOGMmpodZq4FNtnGP54yps8BzLR4=
github.com/mattn/go-runewidth v0.0.3/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=
github.com/mattn/go-runewidth v0.0.4/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=
github.com/mattn/go-runewidth v0.0.5-0.20181218000649-703b5e6b11ae h1:575usOHCDzxtuyWeSjPySew7uvoOuaCsM0uUesjgAo4=
github.com/mattn/go-runewidth v0.0.5-0.20181218000649-703b5e6b11ae/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=
github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742 h1:Esafd1046DLDQ0W1YjYsBW+p8U2u7vzgW2SQVmlNazg=
github.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=
github.com/nkovacs/streamquote v0.0.0-20170412213628-49af9bddb229/go.mod h1:0aYXnNPJ8l7uZxf45rWW1a/uME32OF0rhiYGNQ2oF2E=
github.com/oleiade/lane v0.0.0-20160817071224-3053869314bb h1:x0yCvYsspui5SAxSRvLd2zFg7PfFijzKdCo7QAtN92I=
github.com/oleiade/lane v0.0.0-20160817071224-3053869314bb/go.mod h1:ym0w0flrmBtGvApLDgFLa0sfGJkWxDQqnm0/0ok5w3Y=
github.com/olekukonko/tablewriter v0.0.1 h1:b3iUnf1v+ppJiOfNX4yxxqfWKMQPZR5yoh8urCTFX88=
github.com/olekukonko/tablewriter v0.0.1/go.mod h1:vsDQFd/mU46D+Z4whnwzcISnGGzXWMclvtLoiIKAKIo=
github.com/olekukonko/tablewriter v0.0.2-0.20190618033246-cc27d85e17ce h1:RLmZmfx/K62HKpbwPqtW3tg+V2GgugN/XNNx+uiMH/Y=
github.com/olekukonko/tablewriter v0.0.2-0.20190618033246-cc27d85e17ce/go.mod h1:rSAaSIOAGT9odnlyGlUfAJaoc5w2fSBUmeGDbRWPxyQ=
github.com/peterh/liner v1.1.0 h1:f+aAedNJA6uk7+6rXsYBnhdo4Xux7ESLe+kcuVUF5os=
github.com/peterh/liner v1.1.0/go.mod h1:CRroGNssyjTd/qIG2FyxByd2S8JEAZXBl4qUrZf8GS0=
github.com/peterh/liner v1.1.1-0.20190305032635-6f820f8f90ce h1:Lz+a/i+oS4A7tb6J6IyH4ZFiWgqvNv2yslv0Qn79wok=
github.com/peterh/liner v1.1.1-0.20190305032635-6f820f8f90ce/go.mod h1:CRroGNssyjTd/qIG2FyxByd2S8JEAZXBl4qUrZf8GS0=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/russross/blackfriday v1.5.2 h1:HyvC0ARfnZBqnXwABFeSZHpKvJHJJfPz81GNueLj0oo=
github.com/russross/blackfriday v1.5.2/go.mod h1:JO/DiYxRf+HjHt06OyowR9PTA263kcR/rfWxYHBV53g=
github.com/shiena/ansicolor v0.0.0-20151119151921-a422bbe96644 h1:X+yvsM2yrEktyI+b2qND5gpH8YhURn0k8OCaeRnkINo=
github.com/shiena/ansicolor v0.0.0-20151119151921-a422bbe96644/go.mod h1:nkxAfR/5quYxwPZhyDxgasBMnRtBZd0FCEpawpjMUFg=
github.com/shurcooL/httpfs v0.0.0-20190707220628-8d4bc4ba7749/go.mod h1:ZY1cvUeJuFPAdZ/B6v7RHavJWZn2YPVFQ1OSXhCGOkg=
github.com/shurcooL/vfsgen v0.0.0-20181202132449-6a9ea43bcacd/go.mod h1:TrYk7fJVaAttu97ZZKrO9UbRa8izdowaMIZcxYMbVaw=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/urfave/cli v1.20.0 h1:fDqGv3UG/4jbVl/QkFwEdddtEDjh/5Ov6X+0B/3bPaw=
github.com/urfave/cli v1.20.0/go.mod h1:70zkFmudgCuE/ngEzBv17Jvp/497gISqfk5gWijbERA=
github.com/urfave/cli v1.21.1-0.20190817182405-23c83030263f h1:xKDKjIsL76VUyHcA0G4Qe1cIAUB/nrq6Pt8D411bd1g=
github.com/urfave/cli v1.21.1-0.20190817182405-23c83030263f/go.mod h1:qXyCeJubPqsgeiLd3kvHOGHHSrQcNdjZ2ScXIcVZK/I=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/fasttemplate v1.0.1/go.mod h1:UQGH1tvbgY+Nz5t2n7tXsz52dQxojPUpymEIMZ47gx8=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20190820162420-60c769a6c586 h1:7KByu05hhLed2MO29w7p1XfZvZ13m8mub3shuVftRs0=
golang.org/x/crypto v0.0.0-20190820162420-60c769a6c586/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d h1:+R4KGOnez64A81RvjARKc4UT5/tI9ujCIVX+P5KiHuI=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191025090151-53bf42e6b339 h1:zSqWKgm/o7HAnlAzBQ+aetp9fpuyytsXnKA8eiLHYQM=
golang.org/x/sys v0.0.0-20191025090151-53bf42e6b339/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=



================================================
FILE: Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<dict>
		<key>CFBundleName</key>
		<string>BaiduPCS-Go</string>
		<key>CFBundleSupportedPlatforms</key>
		<array>
			<string>iPhoneOS</string>
		</array>
		<key>CFBundleExecutable</key>
		<string>BaiduPCS-Go</string>
		<key>CFBundleVersion</key>
		<string>1.0</string>
		<key>CFBundleIdentifier</key>
		<string>com.iikira.baidupcsgo</string>
		<key>LSRequiresIPhoneOS</key>
		<true/>
		<key>CFBundleDisplayName</key>
		<string>BaiduPCS-Go</string>
	</dict>
</plist>


================================================
FILE: LICENSE
================================================
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright iikira.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.




================================================
FILE: versioninfo.json
================================================
{
    "FixedFileInfo": {
        "FileVersion": {
            "Major": 3,
            "Minor": 6,
            "Patch": 2,
            "Build": 0
        },
        "ProductVersion": {
            "Major": 3,
            "Minor": 6,
            "Patch": 2,
            "Build": 0
        },
        "FileFlagsMask": "3f",
        "FileFlags ": "00",
        "FileOS": "040004",
        "FileType": "01",
        "FileSubType": "00"
    },
    "StringFileInfo": {
        "Comments": "",
        "CompanyName": "iikira",
        "FileDescription": "百度网盘客户端",
        "FileVersion": "v3.6.2",
        "InternalName": "",
        "LegalCopyright": "© 2016-2020 iikira.",
        "LegalTrademarks": "",
        "OriginalFilename": "",
        "PrivateBuild": "",
        "ProductName": "BaiduPCS-Go",
        "ProductVersion": "v3.6.2",
        "SpecialBuild": ""
    },
    "VarFileInfo": {
        "Translation": {
            "LangID": "0409",
            "CharsetID": "04B0"
        }
    },
    "IconPath": "assets/BaiduPCS-Go.ico",
    "ManifestPath": "BaiduPCS-Go.exe.manifest"
}


================================================
FILE: baidupcs/baidupcs.go
================================================
// Package baidupcs BaiduPCS RESTful API 工具包
package baidupcs

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires/cachemap"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/internal/panhome"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"strconv"
)

const (
	// OperationGetUK 获取UK
	OperationGetUK = "获取UK"
	// OperationQuotaInfo 获取当前用户空间配额信息
	OperationQuotaInfo = "获取当前用户空间配额信息"
	// OperationFilesDirectoriesMeta 获取文件/目录的元信息
	OperationFilesDirectoriesMeta = "获取文件/目录的元信息"
	// OperationFilesDirectoriesList 获取目录下的文件列表
	OperationFilesDirectoriesList = "获取目录下的文件列表"
	// OperationSearch 搜索
	OperationSearch = "搜索"
	// OperationRemove 删除文件/目录
	OperationRemove = "删除文件/目录"
	// OperationMkdir 创建目录
	OperationMkdir = "创建目录"
	// OperationRename 重命名文件/目录
	OperationRename = "重命名文件/目录"
	// OperationCopy 拷贝文件/目录
	OperationCopy = "拷贝文件/目录"
	// OperationMove 移动文件/目录
	OperationMove = "移动文件/目录"
	// OperationRapidUpload 秒传文件
	OperationRapidUpload = "秒传文件"
	// OperationUpload 上传单个文件
	OperationUpload = "上传单个文件"
	// OperationUploadTmpFile 分片上传—文件分片及上传
	OperationUploadTmpFile = "分片上传—文件分片及上传"
	// OperationUploadCreateSuperFile 分片上传—合并分片文件
	OperationUploadCreateSuperFile = "分片上传—合并分片文件"
	// OperationUploadPrecreate 分片上传—Precreate
	OperationUploadPrecreate = "分片上传—Precreate"
	// OperationUploadSuperfile2 分片上传—Superfile2
	OperationUploadSuperfile2 = "分片上传—Superfile2"
	// OperationDownloadFile 下载单个文件
	OperationDownloadFile = "下载单个文件"
	// OperationDownloadStreamFile 下载流式文件
	OperationDownloadStreamFile = "下载流式文件"
	// OperationLocateDownload 获取下载链接
	OperationLocateDownload = "获取下载链接"
	// OperationLocatePanAPIDownload 从百度网盘首页获取下载链接
	OperationLocatePanAPIDownload = "获取下载链接2"
	// OperationCloudDlAddTask 添加离线下载任务
	OperationCloudDlAddTask = "添加离线下载任务"
	// OperationCloudDlQueryTask 精确查询离线下载任务
	OperationCloudDlQueryTask = "精确查询离线下载任务"
	// OperationCloudDlListTask 查询离线下载任务列表
	OperationCloudDlListTask = "查询离线下载任务列表"
	// OperationCloudDlCancelTask 取消离线下载任务
	OperationCloudDlCancelTask = "取消离线下载任务"
	// OperationCloudDlDeleteTask 删除离线下载任务
	OperationCloudDlDeleteTask = "删除离线下载任务"
	// OperationCloudDlClearTask 清空离线下载任务记录
	OperationCloudDlClearTask = "清空离线下载任务记录"
	// OperationShareSet 创建分享链接
	OperationShareSet = "创建分享链接"
	// OperationShareCancel 取消分享
	OperationShareCancel = "取消分享"
	// OperationShareList 列出分享列表
	OperationShareList = "列出分享列表"
	// OperationShareSURLInfo 获取分享详细信息
	OperationShareSURLInfo = "获取分享详细信息"
	// OperationRecycleList 列出回收站文件列表
	OperationRecycleList = "列出回收站文件列表"
	// OperationRecycleRestore 还原回收站文件或目录
	OperationRecycleRestore = "还原回收站文件或目录"
	// OperationRecycleDelete 删除回收站文件或目录
	OperationRecycleDelete = "删除回收站文件或目录"
	// OperationRecycleClear 清空回收站
	OperationRecycleClear = "清空回收站"

	// OperationExportFileInfo 导出文件信息
	OperationExportFileInfo = "导出文件信息"
	// OperationGetRapidUploadInfo 获取文件秒传信息
	OperationGetRapidUploadInfo = "获取文件秒传信息"
	// OperationFixMD5 修复文件md5
	OperationFixMD5 = "修复文件md5"
	// OperrationMatchPathByShellPattern 通配符匹配文件路径
	OperrationMatchPathByShellPattern = "通配符匹配文件路径"

	// PCSBaiduCom pcs api地址
	PCSBaiduCom = "pcs.baidu.com"
	// PanBaiduCom 网盘首页api地址
	PanBaiduCom = "pan.baidu.com"
	// YunBaiduCom 网盘首页api地址2
	YunBaiduCom = "yun.baidu.com"
	// PanAppID 百度网盘appid
	PanAppID = "250528"
	// NetdiskUA 网盘客户端ua
	NetdiskUA = "netdisk;2.2.51.6;netdisk;10.0.63;PC;android-android"
	// DotBaiduCom .baidu.com
	DotBaiduCom = ".baidu.com"
	// PathSeparator 路径分隔符
	PathSeparator = "/"
)

var (
	baiduPCSVerbose = pcsverbose.New("BAIDUPCS")

	baiduComURL = &url.URL{
		Scheme: "http",
		Host:   "baidu.com",
	}

	baiduPcsComURL = &url.URL{
		Scheme: "http",
		Host:   "baidupcs.com",
	}
)

type (
	// BaiduPCS 百度 PCS API 详情
	BaiduPCS struct {
		appID      int                   // app_id
		isHTTPS    bool                  // 是否启用https
		uid        uint64                // 百度uid
		client     *requester.HTTPClient // http 客户端
		pcsUA      string
		panUA      string
		isSetPanUA bool
		ph         *panhome.PanHome
		cacheOpMap cachemap.CacheOpMap
	}

	userInfoJSON struct {
		*pcserror.PanErrorInfo
		Records []struct {
			Uk int64 `json:"uk"`
		} `json:"records"`
	}
)

// NewPCS 提供app_id, 百度BDUSS, 返回 BaiduPCS 对象
func NewPCS(appID int, bduss string) *BaiduPCS {
	client := requester.NewHTTPClient()
	client.ResetCookiejar()
	client.Jar.SetCookies(baiduComURL, []*http.Cookie{
		&http.Cookie{
			Name:   "BDUSS",
			Value:  bduss,
			Domain: DotBaiduCom,
		},
	})

	return &BaiduPCS{
		appID:  appID,
		client: client,
	}
}

// NewPCSWithClient 提供app_id, 自定义客户端, 返回 BaiduPCS 对象
func NewPCSWithClient(appID int, client *requester.HTTPClient) *BaiduPCS {
	pcs := &BaiduPCS{
		appID:  appID,
		client: client,
	}
	return pcs
}

// NewPCSWithCookieStr 提供app_id, cookie 字符串, 返回 BaiduPCS 对象
func NewPCSWithCookieStr(appID int, cookieStr string) *BaiduPCS {
	pcs := &BaiduPCS{
		appID:  appID,
		client: requester.NewHTTPClient(),
	}

	cookies := requester.ParseCookieStr(cookieStr)
	for _, cookie := range cookies {
		cookie.Domain = DotBaiduCom
	}

	jar, _ := cookiejar.New(nil)
	jar.SetCookies(baiduComURL, cookies)
	pcs.client.SetCookiejar(jar)

	return pcs
}

func (pcs *BaiduPCS) lazyInit() {
	if pcs.client == nil {
		pcs.client = requester.NewHTTPClient()
	}
	if pcs.ph == nil {
		pcs.ph = panhome.NewPanHome(pcs.client)
	}
	if !pcs.isSetPanUA {
		pcs.panUA = NetdiskUA
	}
}

// GetClient 获取当前的http client
func (pcs *BaiduPCS) GetClient() *requester.HTTPClient {
	pcs.lazyInit()
	return pcs.client
}

// GetBDUSS 获取BDUSS
func (pcs *BaiduPCS) GetBDUSS() (bduss string) {
	if pcs.client == nil || pcs.client.Jar == nil {
		return ""
	}
	cookies := pcs.client.Jar.Cookies(baiduComURL)
	for _, cookie := range cookies {
		if cookie.Name == "BDUSS" {
			return cookie.Value
		}
	}
	return ""
}

// SetAPPID 设置app_id
func (pcs *BaiduPCS) SetAPPID(appID int) {
	pcs.appID = appID
}

// SetUID 设置百度UID
// 只有locatedownload才需要设置此项
func (pcs *BaiduPCS) SetUID(uid uint64) {
	pcs.uid = uid
}

// SetStoken 设置stoken
func (pcs *BaiduPCS) SetStoken(stoken string) {
	pcs.lazyInit()
	if pcs.client.Jar == nil {
		pcs.client.ResetCookiejar()
	}

	pcs.client.Jar.SetCookies(baiduComURL, []*http.Cookie{
		&http.Cookie{
			Name:   "STOKEN",
			Value:  stoken,
			Domain: DotBaiduCom,
		},
	})
}

// SetPCSUserAgent 设置 PCS User-Agent
func (pcs *BaiduPCS) SetPCSUserAgent(ua string) {
	pcs.pcsUA = ua
}

// SetPanUserAgent 设置 Pan User-Agent
func (pcs *BaiduPCS) SetPanUserAgent(ua string) {
	pcs.panUA = ua
	pcs.isSetPanUA = true
}

// SetHTTPS 是否启用https连接
func (pcs *BaiduPCS) SetHTTPS(https bool) {
	pcs.isHTTPS = https
}

// URL 返回 url
func (pcs *BaiduPCS) URL() *url.URL {
	return &url.URL{
		Scheme: GetHTTPScheme(pcs.isHTTPS),
		Host:   PCSBaiduCom,
	}
}

func (pcs *BaiduPCS) getPanUAHeader() (header map[string]string) {
	return map[string]string{
		"User-Agent": pcs.panUA,
	}
}

func (pcs *BaiduPCS) generatePCSURL(subPath, method string, param ...map[string]string) *url.URL {
	pcsURL := pcs.URL()
	pcsURL.Path = "/rest/2.0/pcs/" + subPath

	uv := pcsURL.Query()
	uv.Set("app_id", strconv.Itoa(pcs.appID))
	uv.Set("method", method)
	for k := range param {
		for k2 := range param[k] {
			uv.Set(k2, param[k][k2])
		}
	}

	pcsURL.RawQuery = uv.Encode()
	return pcsURL
}

func (pcs *BaiduPCS) generatePCSURL2(subPath, method string, param ...map[string]string) *url.URL {
	pcsURL2 := &url.URL{
		Scheme: GetHTTPScheme(pcs.isHTTPS),
		Host:   PanBaiduCom,
		Path:   "/rest/2.0/" + subPath,
	}

	uv := pcsURL2.Query()
	uv.Set("app_id", PanAppID)
	uv.Set("method", method)
	for k := range param {
		for k2 := range param[k] {
			uv.Set(k2, param[k][k2])
		}
	}

	pcsURL2.RawQuery = uv.Encode()
	return pcsURL2
}

func (pcs *BaiduPCS) generatePanURL(subPath string, param map[string]string) *url.URL {
	panURL := url.URL{
		Scheme: GetHTTPScheme(pcs.isHTTPS),
		Host:   PanBaiduCom,
		Path:   "/api/" + subPath,
	}

	if param != nil {
		uv := url.Values{}
		for k := range param {
			uv.Set(k, param[k])
		}
		panURL.RawQuery = uv.Encode()
	}
	return &panURL
}

// UK 获取用户 UK
func (pcs *BaiduPCS) UK() (uk int64, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareUK()
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPanErrorInfo(OperationGetUK)
	jsonData := userInfoJSON{
		PanErrorInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationGetUK, dataReadCloser, &jsonData)
	if pcsError != nil {
		return
	}

	if len(jsonData.Records) != 1 {
		errInfo.ErrType = pcserror.ErrTypeOthers
		errInfo.Err = errors.New("Unknown remote data")
		return 0, errInfo
	}

	return jsonData.Records[0].Uk, nil
}



================================================
FILE: baidupcs/cache.go
================================================
package baidupcs

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"time"
)

// deleteCache 删除含有 dirs 的缓存
func (pcs *BaiduPCS) deleteCache(dirs []string) {
	cache := pcs.cacheOpMap.LazyInitCachePoolOp(OperationFilesDirectoriesList)
	for _, v := range dirs {
		key := v + "_" + defaultOrderOptionsStr
		_, ok := cache.Load(key)
		if ok {
			cache.Delete(key)
		}
	}
}

// CacheFilesDirectoriesList 缓存获取
func (pcs *BaiduPCS) CacheFilesDirectoriesList(path string, options *OrderOptions) (fdl FileDirectoryList, pcsError pcserror.Error) {
	data := pcs.cacheOpMap.CacheOperation(OperationFilesDirectoriesList, path+"_"+fmt.Sprint(options), func() expires.DataExpires {
		fdl, pcsError = pcs.FilesDirectoriesList(path, options)
		if pcsError != nil {
			return nil
		}
		return expires.NewDataExpires(fdl, 1*time.Minute)
	})
	if pcsError != nil {
		return
	}
	return data.Data().(FileDirectoryList), nil
}



================================================
FILE: baidupcs/cloud_dl.go
================================================
package baidupcs

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/pcstime"
	"io"
	"path"
	"strconv"
	"strings"
)

type (
	// CloudDlFileInfo 离线下载的文件信息
	CloudDlFileInfo struct {
		FileName string `json:"file_name"`
		FileSize int64  `json:"file_size"`
	}

	// CloudDlTaskInfo 离线下载的任务信息
	CloudDlTaskInfo struct {
		TaskID       int64
		Status       int // 0下载成功, 1下载进行中, 2系统错误, 3资源不存在, 4下载超时, 5资源存在但下载失败, 6存储空间不足, 7任务取消
		StatusText   string
		FileSize     int64  // 文件大小
		FinishedSize int64  // 文件大小
		CreateTime   int64  // 创建时间
		StartTime    int64  // 开始时间
		FinishTime   int64  // 结束时间
		SavePath     string // 保存的路径
		SourceURL    string // 资源地址
		TaskName     string // 任务名称, 一般为文件名
		OdType       int
		FileList     []*CloudDlFileInfo
		Result       int // 0查询成功，结果有效，1要查询的task_id不存在
	}

	// CloudDlTaskList 离线下载的任务信息列表
	CloudDlTaskList []*CloudDlTaskInfo

	// cloudDlTaskInfo 用于解析远程返回的JSON
	cloudDlTaskInfo struct {
		Status       string `json:"status"`
		FileSize     string `json:"file_size"`
		FinishedSize string `json:"finished_size"`
		CreateTime   string `json:"create_time"`
		StartTime    string `json:"start_time"`
		FinishTime   string `json:"finish_time"`
		SavePath     string `json:"save_path"`
		SourceURL    string `json:"source_url"`
		TaskName     string `json:"task_name"`
		OdType       string `json:"od_type"`
		FileList     []*struct {
			FileName string `json:"file_name"`
			FileSize string `json:"file_size"`
		} `json:"file_list"`
		Result int `json:"result"`
	}

	taskIDJSON struct {
		TaskID string `json:"task_id"`
	}

	taskIDInt64JSON struct {
		TaskID int64 `json:"task_id"`
	}

	cloudDlAddTaskJSON struct {
		*pcserror.PCSErrInfo
		taskIDInt64JSON
	}

	cloudDlQueryTaskJSON struct {
		TaskInfo map[string]*cloudDlTaskInfo `json:"task_info"`
		*pcserror.PCSErrInfo
	}

	cloudDlListTaskJSON struct {
		TaskInfo []*taskIDJSON `json:"task_info"`
		*pcserror.PCSErrInfo
	}

	cloudDlClearJSON struct {
		Total int `json:"total"`
		*pcserror.PCSErrInfo
	}
)

func (ci *cloudDlTaskInfo) convert() *CloudDlTaskInfo {
	ci2 := &CloudDlTaskInfo{
		Status:       converter.MustInt(ci.Status),
		FileSize:     converter.MustInt64(ci.FileSize),
		FinishedSize: converter.MustInt64(ci.FinishedSize),
		CreateTime:   converter.MustInt64(ci.CreateTime),
		StartTime:    converter.MustInt64(ci.StartTime),
		FinishTime:   converter.MustInt64(ci.FinishTime),
		SavePath:     ci.SavePath,
		SourceURL:    ci.SourceURL,
		TaskName:     ci.TaskName,
		OdType:       converter.MustInt(ci.OdType),
		Result:       ci.Result,
	}

	ci2.FileList = make([]*CloudDlFileInfo, 0, len(ci.FileList))
	for _, v := range ci.FileList {
		if v == nil {
			continue
		}

		ci2.FileList = append(ci2.FileList, &CloudDlFileInfo{
			FileName: v.FileName,
			FileSize: converter.MustInt64(v.FileSize),
		})
	}

	return ci2
}

// CloudDlAddTask 添加离线下载任务
func (pcs *BaiduPCS) CloudDlAddTask(sourceURL, savePath string) (taskID int64, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareCloudDlAddTask(sourceURL, savePath)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPCSErrorInfo(OperationCloudDlAddTask)
	taskInfo := cloudDlAddTaskJSON{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationCloudDlAddTask, dataReadCloser, &taskInfo)
	if pcsError != nil {
		return
	}

	return taskInfo.TaskID, nil
}

func (pcs *BaiduPCS) cloudDlQueryTask(op string, taskIDs []int64) (cl CloudDlTaskList, pcsError pcserror.Error) {
	errInfo := pcserror.NewPCSErrorInfo(op)
	if len(taskIDs) == 0 {
		errInfo.ErrType = pcserror.ErrTypeOthers
		errInfo.Err = errors.New("no input any task_ids")
		return nil, errInfo
	}

	// TODO: 支持100条以上的task_id查询
	if len(taskIDs) > 100 {
		taskIDs = taskIDs[:100]
	}

	taskStrIDs := make([]string, len(taskIDs))
	for k := range taskStrIDs {
		taskStrIDs[k] = strconv.FormatInt(taskIDs[k], 10)
	}

	dataReadCloser, pcsError := pcs.PrepareCloudDlQueryTask(strings.Join(taskStrIDs, ","))
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	taskInfo := cloudDlQueryTaskJSON{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationCloudDlQueryTask, dataReadCloser, &taskInfo)
	if pcsError != nil {
		return
	}

	var v2 *CloudDlTaskInfo
	cl = make(CloudDlTaskList, 0, len(taskStrIDs))
	for k := range taskStrIDs {
		var err error
		v := taskInfo.TaskInfo[taskStrIDs[k]]
		if v == nil {
			continue
		}

		v2 = v.convert()

		v2.TaskID, err = strconv.ParseInt(taskStrIDs[k], 10, 64)
		if err != nil {
			continue
		}

		v2.ParseText()
		cl = append(cl, v2)
	}

	return cl, nil
}

// CloudDlQueryTask 精确查询离线下载任务
func (pcs *BaiduPCS) CloudDlQueryTask(taskIDs []int64) (cl CloudDlTaskList, pcsError pcserror.Error) {
	return pcs.cloudDlQueryTask(OperationCloudDlQueryTask, taskIDs)
}

// CloudDlListTask 查询离线下载任务列表
func (pcs *BaiduPCS) CloudDlListTask() (cl CloudDlTaskList, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareCloudDlListTask()
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPCSErrorInfo(OperationCloudDlListTask)
	taskInfo := cloudDlListTaskJSON{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationCloudDlListTask, dataReadCloser, &taskInfo)
	if pcsError != nil {
		return
	}

	// 没有任务
	if len(taskInfo.TaskInfo) <= 0 {
		return CloudDlTaskList{}, nil
	}

	var (
		taskID  int64
		taskIDs = make([]int64, 0, len(taskInfo.TaskInfo))
	)
	for _, v := range taskInfo.TaskInfo {
		if v == nil {
			continue
		}
		var err error
		if taskID, err = strconv.ParseInt(v.TaskID, 10, 64); err == nil {
			taskIDs = append(taskIDs, taskID)
		}
	}

	cl, pcsError = pcs.cloudDlQueryTask(OperationCloudDlListTask, taskIDs)
	if pcsError != nil {
		return nil, pcsError
	}

	return cl, nil
}

func (pcs *BaiduPCS) cloudDlManipTask(op string, taskID int64) (pcsError pcserror.Error) {
	var dataReadCloser io.ReadCloser

	switch op {
	case OperationCloudDlCancelTask:
		dataReadCloser, pcsError = pcs.PrepareCloudDlCancelTask(taskID)
	case OperationCloudDlDeleteTask:
		dataReadCloser, pcsError = pcs.PrepareCloudDlDeleteTask(taskID)
	default:
		panic("unknown op, " + op)
	}
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.DecodePCSJSONError(op, dataReadCloser)
	return errInfo
}

// CloudDlCancelTask 取消离线下载任务
func (pcs *BaiduPCS) CloudDlCancelTask(taskID int64) (pcsError pcserror.Error) {
	return pcs.cloudDlManipTask(OperationCloudDlCancelTask, taskID)
}

// CloudDlDeleteTask 删除离线下载任务
func (pcs *BaiduPCS) CloudDlDeleteTask(taskID int64) (pcsError pcserror.Error) {
	return pcs.cloudDlManipTask(OperationCloudDlDeleteTask, taskID)
}

// CloudDlClearTask 清空离线下载任务记录
func (pcs *BaiduPCS) CloudDlClearTask() (total int, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareCloudDlClearTask()
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPCSErrorInfo(OperationCloudDlClearTask)
	clearInfo := cloudDlClearJSON{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationCloudDlClearTask, dataReadCloser, &clearInfo)
	if pcsError != nil {
		return
	}

	return clearInfo.Total, nil
}

// ParseText 解析状态码
func (ci *CloudDlTaskInfo) ParseText() {
	switch ci.Status {
	case 0:
		ci.StatusText = "下载成功"
	case 1:
		ci.StatusText = "下载进行中"
	case 2:
		ci.StatusText = "系统错误"
	case 3:
		ci.StatusText = "资源不存在"
	case 4:
		ci.StatusText = "下载超时"
	case 5:
		ci.StatusText = "资源存在但下载失败"
	case 6:
		ci.StatusText = "存储空间不足"
	case 7:
		ci.StatusText = "任务取消"
	default:
		ci.StatusText = "未知状态码: " + strconv.Itoa(ci.Status)
	}
}

func (cl CloudDlTaskList) String() string {
	builder := &strings.Builder{}
	tb := pcstable.NewTable(builder)
	tb.SetHeader([]string{"#", "任务ID", "任务名称", "文件大小", "创建日期", "保存路径", "资源地址", "状态"})
	for k, v := range cl {
		tb.Append([]string{strconv.Itoa(k), strconv.FormatInt(v.TaskID, 10), v.TaskName, converter.ConvertFileSize(v.FileSize), pcstime.FormatTime(v.CreateTime), path.Clean(v.SavePath), v.SourceURL, v.StatusText})
	}
	tb.Render()
	return builder.String()
}



================================================
FILE: baidupcs/cp_mv_rename.go
================================================
package baidupcs

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"unsafe"
)

// Rename 重命名文件/目录
func (pcs *BaiduPCS) Rename(from, to string) (pcsError pcserror.Error) {
	return pcs.cpmvOp(OperationRename, &CpMvJSON{
		From: from,
		To:   to,
	})
}

// Copy 批量拷贝文件/目录
func (pcs *BaiduPCS) Copy(cpmvJSON ...*CpMvJSON) (pcsError pcserror.Error) {
	return pcs.cpmvOp(OperationCopy, cpmvJSON...)
}

// Move 批量移动文件/目录
func (pcs *BaiduPCS) Move(cpmvJSON ...*CpMvJSON) (pcsError pcserror.Error) {
	return pcs.cpmvOp(OperationMove, cpmvJSON...)
}

func (pcs *BaiduPCS) cpmvOp(op string, cpmvJSON ...*CpMvJSON) (pcsError pcserror.Error) {
	dataReadCloser, err := pcs.prepareCpMvOp(op, cpmvJSON...)
	if err != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.DecodePCSJSONError(op, dataReadCloser)
	if errInfo != nil {
		return errInfo
	}

	// 更新缓存
	pcs.deleteCache((*CpMvJSONList)(unsafe.Pointer(&cpmvJSON)).AllRelatedDir())
	return nil
}



================================================
FILE: baidupcs/download.go
================================================
package baidupcs

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"net/http"
	"net/url"
)

var (
	// ErrLocateDownloadURLNotFound 未找到下载链接
	ErrLocateDownloadURLNotFound = errors.New("locatedownload url not found")
	// MaxDownloadRangeSize 文件片段最大值
	MaxDownloadRangeSize = 55 * converter.MB
)

type (
	// DownloadFunc 下载文件处理函数
	DownloadFunc func(downloadURL string, jar http.CookieJar) error

	// URLInfo 下载链接详情
	URLInfo struct {
		URLs []struct {
			URL string `json:"url"`
		} `json:"urls"`
	}

	// LocateDownloadInfoV1 locatedownload api v1
	LocateDownloadInfoV1 struct {
		Server []string `json:"server"`
		PathJSON
	}

	locateDownloadJSON struct {
		*pcserror.PCSErrInfo
		URLInfo
	}

	// APIDownloadDlinkInfo 下载信息
	APIDownloadDlinkInfo struct {
		Dlink string `json:"dlink"`
		FsID  string `json:"fs_id"`
	}

	// APIDownloadDlinkInfoList 下载信息列表
	APIDownloadDlinkInfoList []*APIDownloadDlinkInfo

	panAPIDownloadJSON struct {
		*pcserror.PanErrorInfo
		DlinkList APIDownloadDlinkInfoList `json:"dlink"`
	}
)

// URLStrings 返回下载链接数组
func (ui *URLInfo) URLStrings(https bool) (urls []*url.URL) {
	urls = make([]*url.URL, 0, len(ui.URLs))
	for k := range ui.URLs {
		thisURL, err := url.Parse(ui.URLs[k].URL)
		if err != nil {
			continue
		}
		thisURL.Scheme = GetHTTPScheme(https)
		urls = append(urls, thisURL)
	}
	return urls
}

// SingleURL 返回单条下载链接
func (ui *URLInfo) SingleURL(https bool) *url.URL {
	if len(ui.URLs) < 1 {
		return nil
	}

	u, err := url.Parse(ui.URLs[0].URL)
	if err != nil {
		return nil
	}
	u.Scheme = GetHTTPScheme(https)
	return u
}

// LastURL 返回最后一条下载链接
func (ui *URLInfo) LastURL(https bool) *url.URL {
	if len(ui.URLs) < 1 {
		return nil
	}

	u, err := url.Parse(ui.URLs[len(ui.URLs)-1].URL)
	if err != nil {
		return nil
	}
	u.Scheme = GetHTTPScheme(https)
	return u
}

// DownloadFile 下载单个文件
func (pcs *BaiduPCS) DownloadFile(path string, downloadFunc DownloadFunc) (err error) {
	pcs.lazyInit()
	pcsURL := pcs.generatePCSURL("file", "download", map[string]string{
		"path": path,
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationDownloadFile, pcsURL)

	return downloadFunc(pcsURL.String(), pcs.client.Jar)
}

// DownloadStreamFile 下载流式文件
func (pcs *BaiduPCS) DownloadStreamFile(path string, downloadFunc DownloadFunc) (err error) {
	pcs.lazyInit()
	pcsURL := pcs.generatePCSURL("stream", "download", map[string]string{
		"path": path,
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationDownloadStreamFile, pcsURL)

	return downloadFunc(pcsURL.String(), pcs.client.Jar)
}

// LocateDownloadWithUserAgent 获取下载链接
func (pcs *BaiduPCS) LocateDownload(pcspath string) (info *URLInfo, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareLocateDownload(pcspath)
	if dataReadCloser != nil {
		defer dataReadCloser.Close()
	}
	if pcsError != nil {
		return nil, pcsError
	}

	errInfo := pcserror.NewPCSErrorInfo(OperationLocateDownload)
	jsonData := locateDownloadJSON{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationLocateDownload, dataReadCloser, &jsonData)
	if pcsError != nil {
		return
	}

	return &jsonData.URLInfo, nil
}

// LocatePanAPIDownload 从百度网盘首页获取下载链接
func (pcs *BaiduPCS) LocatePanAPIDownload(fidList ...int64) (dlinkInfoList APIDownloadDlinkInfoList, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareLocatePanAPIDownload(fidList...)
	if dataReadCloser != nil {
		defer dataReadCloser.Close()
	}
	if pcsError != nil {
		return nil, pcsError
	}

	jsonData := panAPIDownloadJSON{
		PanErrorInfo: pcserror.NewPanErrorInfo(OperationLocatePanAPIDownload),
	}
	pcsError = pcserror.HandleJSONParse(OperationLocatePanAPIDownload, dataReadCloser, &jsonData)
	if pcsError != nil {
		if pcsError.GetErrType() == pcserror.ErrTypeRemoteError {
			switch pcsError.GetRemoteErrCode() {
			case 112: // 页面已过期
				fallthrough
			case 113: // 签名错误
				pcs.ph.SetSignExpires() // 重置
			}
		}
		return
	}

	return jsonData.DlinkList, nil
}



================================================
FILE: baidupcs/extends.go
================================================
package baidupcs

import (
	"crypto/md5"
	"encoding/hex"
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/escaper"
	"github.com/felixonmars/BaiduPCS-Go/requester/downloader"
	"io"
	"mime"
	"net/http"
	"net/url"
	"path"
	"strconv"
	"strings"
)

const (
	// ShellPatternCharacters 通配符字符串
	ShellPatternCharacters = "*?[]"
)

var (
	// ErrFixMD5Isdir 目录不需要修复md5
	ErrFixMD5Isdir = errors.New("directory not support fix md5")
	// ErrFixMD5Failed 修复MD5失败, 可能服务器未刷新
	ErrFixMD5Failed = errors.New("fix md5 failed")
	// ErrFixMD5FileInfoNil 文件信息对象为空
	ErrFixMD5FileInfoNil = errors.New("file info is nil")
	// ErrMatchPathByShellPatternNotAbsPath 不是绝对路径
	ErrMatchPathByShellPatternNotAbsPath = errors.New("not absolute path")

	ErrContentRangeNotFound               = errors.New("Content-Range not found")
	ErrGetRapidUploadInfoLengthNotFound   = errors.New("Content-Length not found")
	ErrGetRapidUploadInfoMD5NotFound      = errors.New("Content-MD5 not found")
	ErrGetRapidUploadInfoCrc32NotFound    = errors.New("x-bs-meta-crc32 not found")
	ErrGetRapidUploadInfoFilenameNotEqual = errors.New("文件名不匹配")
	ErrGetRapidUploadInfoLengthNotEqual   = errors.New("Content-Length 不匹配")
	ErrGetRapidUploadInfoMD5NotEqual      = errors.New("Content-MD5 不匹配")
	ErrGetRapidUploadInfoCrc32NotEqual    = errors.New("x-bs-meta-crc32 不匹配")
	ErrGetRapidUploadInfoSliceMD5NotEqual = errors.New("slice-md5 不匹配")

	ErrFileTooLarge = errors.New("文件大于20GB, 无法秒传")
)

func (pcs *BaiduPCS) getLocateDownloadLink(pcspath string) (link string, pcsError pcserror.Error) {
	info, pcsError := pcs.LocateDownload(pcspath)
	if pcsError != nil {
		return
	}

	u := info.SingleURL(pcs.isHTTPS)
	if u == nil {
		return "", &pcserror.PCSErrInfo{
			Operation: OperationLocateDownload,
			ErrType:   pcserror.ErrTypeOthers,
			Err:       ErrLocateDownloadURLNotFound,
		}
	}
	return u.String(), nil
}

// ExportByFileInfo 通过文件信息对象, 导出文件信息
func (pcs *BaiduPCS) ExportByFileInfo(finfo *FileDirectory) (rinfo *RapidUploadInfo, pcsError pcserror.Error) {
	errInfo := pcserror.NewPCSErrorInfo(OperationExportFileInfo)
	errInfo.ErrType = pcserror.ErrTypeOthers
	if finfo.Size > MaxRapidUploadSize {
		errInfo.Err = ErrFileTooLarge
		return nil, errInfo
	}

	rinfo, pcsError = pcs.GetRapidUploadInfoByFileInfo(finfo)
	if pcsError != nil {
		return nil, pcsError
	}
	if rinfo.Filename != finfo.Filename {
		baiduPCSVerbose.Infof("%s filename not equal, local: %s, remote link: %s\n", OperationExportFileInfo, finfo.Filename, rinfo.Filename)
		rinfo.Filename = finfo.Filename
	}
	return rinfo, nil
}

// GetRapidUploadInfoByFileInfo 通过文件信息对象, 获取秒传信息
func (pcs *BaiduPCS) GetRapidUploadInfoByFileInfo(finfo *FileDirectory) (rinfo *RapidUploadInfo, pcsError pcserror.Error) {
	if finfo.Size <= SliceMD5Size && len(finfo.BlockList) == 1 && finfo.BlockList[0] == finfo.MD5 {
		// 可直接秒传
		return &RapidUploadInfo{
			Filename:      finfo.Filename,
			ContentLength: finfo.Size,
			ContentMD5:    finfo.MD5,
			SliceMD5:      finfo.MD5,
			ContentCrc32:  "0",
		}, nil
	}

	link, pcsError := pcs.getLocateDownloadLink(finfo.Path)
	if pcsError != nil {
		return nil, pcsError
	}

	// 只有ContentLength可以比较
	// finfo记录的ContentMD5不一定是正确的
	// finfo记录的Filename不一定与获取到的一致
	return pcs.GetRapidUploadInfoByLink(link, &RapidUploadInfo{
		ContentLength: finfo.Size,
	})
}

// GetRapidUploadInfoByLink 通过下载链接, 获取文件秒传信息
func (pcs *BaiduPCS) GetRapidUploadInfoByLink(link string, compareRInfo *RapidUploadInfo) (rinfo *RapidUploadInfo, pcsError pcserror.Error) {
	errInfo := pcserror.NewPCSErrorInfo(OperationGetRapidUploadInfo)
	errInfo.ErrType = pcserror.ErrTypeOthers

	var (
		header     = pcs.getPanUAHeader()
		isSetRange = compareRInfo != nil && compareRInfo.ContentLength > SliceMD5Size // 是否设置Range
	)
	if isSetRange {
		header["Range"] = "bytes=0-" + strconv.FormatInt(SliceMD5Size-1, 10)
	}

	resp, err := pcs.client.Req(http.MethodGet, link, nil, header)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		errInfo.SetNetError(err)
		return nil, errInfo
	}

	// 检测响应状态码
	if resp.StatusCode/100 != 2 {
		errInfo.SetNetError(errors.New(resp.Status))
		return nil, errInfo
	}

	// 检测是否存在MD5
	md5Str := resp.Header.Get("Content-MD5")
	if md5Str == "" { // 未找到md5值, 可能是服务器未刷新
		errInfo.Err = ErrGetRapidUploadInfoMD5NotFound
		return nil, errInfo
	}
	if compareRInfo != nil && compareRInfo.ContentMD5 != "" && compareRInfo.ContentMD5 != md5Str {
		errInfo.Err = ErrGetRapidUploadInfoMD5NotEqual
		return nil, errInfo
	}

	// 获取文件名
	_, params, err := mime.ParseMediaType(resp.Header.Get("Content-Disposition"))
	if err != nil {
		errInfo.Err = err
		return nil, errInfo
	}
	filename, err := url.QueryUnescape(params["filename"])
	if err != nil {
		errInfo.Err = err
		return nil, errInfo
	}
	if compareRInfo != nil && compareRInfo.Filename != "" && compareRInfo.Filename != filename {
		errInfo.Err = ErrGetRapidUploadInfoFilenameNotEqual
		return nil, errInfo
	}

	var (
		contentLength int64
	)
	if isSetRange {
		// 检测Content-Range
		contentRange := resp.Header.Get("Content-Range")
		if contentRange == "" {
			errInfo.Err = ErrContentRangeNotFound
			return nil, errInfo
		}
		contentLength = downloader.ParseContentRange(contentRange)
	} else {
		contentLength = resp.ContentLength
	}

	// 检测Content-Length
	switch contentLength {
	case -1:
		errInfo.Err = ErrGetRapidUploadInfoLengthNotFound
		return nil, errInfo
	case 0:
		return &RapidUploadInfo{
			Filename:      filename,
			ContentLength: contentLength,
			ContentMD5:    EmptyContentMD5,
			SliceMD5:      EmptyContentMD5,
			ContentCrc32:  "0",
		}, nil
	default:
		if compareRInfo != nil && compareRInfo.ContentLength > 0 && compareRInfo.ContentLength != contentLength {
			errInfo.Err = ErrGetRapidUploadInfoLengthNotEqual
			return nil, errInfo
		}
	}

	// 检测是否存在crc32 值, 一般都会存在的
	crc32Str := resp.Header.Get("x-bs-meta-crc32")
	if crc32Str == "" || crc32Str == "0" {
		errInfo.Err = ErrGetRapidUploadInfoCrc32NotFound
		return nil, errInfo
	}
	if compareRInfo != nil && compareRInfo.ContentCrc32 != "" && compareRInfo.ContentCrc32 != crc32Str {
		errInfo.Err = ErrGetRapidUploadInfoCrc32NotEqual
		return nil, errInfo
	}

	// 获取slice-md5
	// 忽略比较slice-md5
	if contentLength <= SliceMD5Size {
		return &RapidUploadInfo{
			Filename:      filename,
			ContentLength: contentLength,
			ContentMD5:    md5Str,
			SliceMD5:      md5Str,
			ContentCrc32:  crc32Str,
		}, nil
	}

	buf := cachepool.RawMallocByteSlice(int(SliceMD5Size))
	_, err = io.ReadFull(resp.Body, buf)
	if err != nil {
		errInfo.SetNetError(err)
		return nil, errInfo
	}

	// 计算slice-md5
	m := md5.New()
	_, err = m.Write(buf)
	if err != nil {
		panic(err)
	}

	sliceMD5Str := hex.EncodeToString(m.Sum(nil))

	// 检测slice-md5, 不必要的
	if compareRInfo != nil && compareRInfo.SliceMD5 != "" && compareRInfo.SliceMD5 != sliceMD5Str {
		errInfo.Err = ErrGetRapidUploadInfoSliceMD5NotEqual
		return nil, errInfo
	}

	return &RapidUploadInfo{
		Filename:      filename,
		ContentLength: contentLength,
		ContentMD5:    md5Str,
		SliceMD5:      sliceMD5Str,
		ContentCrc32:  crc32Str,
	}, nil
}

// FixMD5ByFileInfo 尝试修复文件的md5, 通过文件信息对象
func (pcs *BaiduPCS) FixMD5ByFileInfo(finfo *FileDirectory) (pcsError pcserror.Error) {
	errInfo := pcserror.NewPCSErrorInfo(OperationFixMD5)
	errInfo.ErrType = pcserror.ErrTypeOthers
	if finfo == nil {
		errInfo.Err = ErrFixMD5FileInfoNil
		return errInfo
	}

	if finfo.Size > MaxRapidUploadSize { // 文件大于20GB
		errInfo.Err = ErrFileTooLarge
		return errInfo
	}

	// 忽略目录
	if finfo.Isdir {
		errInfo.Err = ErrFixMD5Isdir
		return errInfo
	}

	if len(finfo.BlockList) == 1 && finfo.BlockList[0] == finfo.MD5 {
		// 不需要修复
		return nil
	}

	link, pcsError := pcs.getLocateDownloadLink(finfo.Path)
	if pcsError != nil {
		return pcsError
	}

	var (
		cmpInfo = &RapidUploadInfo{
			Filename:      finfo.Filename,
			ContentLength: finfo.Size,
		}
	)
	rinfo, pcsError := pcs.GetRapidUploadInfoByLink(link, cmpInfo)
	if pcsError != nil {
		switch pcsError.GetError() {
		case ErrGetRapidUploadInfoMD5NotFound, ErrGetRapidUploadInfoCrc32NotFound:
			errInfo.Err = ErrFixMD5Failed
		default:
			errInfo.Err = pcsError
		}
		return errInfo
	}

	// 开始修复
	return pcs.RapidUploadNoCheckDir(finfo.Path, rinfo.ContentMD5, rinfo.SliceMD5, rinfo.ContentCrc32, rinfo.ContentLength)
}

// FixMD5 尝试修复文件的md5
func (pcs *BaiduPCS) FixMD5(pcspath string) (pcsError pcserror.Error) {
	finfo, pcsError := pcs.FilesDirectoriesMeta(pcspath)
	if pcsError != nil {
		return
	}

	return pcs.FixMD5ByFileInfo(finfo)
}

func (pcs *BaiduPCS) recurseMatchPathByShellPattern(index int, patternSlice *[]string, ps *[]string, pcspaths *[]string) {
	if index == len(*patternSlice) {
		*pcspaths = append(*pcspaths, strings.Join(*ps, PathSeparator))
		return
	}

	if !strings.ContainsAny((*patternSlice)[index], ShellPatternCharacters) {
		(*ps)[index] = (*patternSlice)[index]
		pcs.recurseMatchPathByShellPattern(index+1, patternSlice, ps, pcspaths)
		return
	}

	fds, pcsError := pcs.FilesDirectoriesList(strings.Join((*ps)[:index], PathSeparator), DefaultOrderOptions)
	if pcsError != nil {
		panic(pcsError) // 抛出异常
	}

	for k := range fds {
		if matched, _ := path.Match((*patternSlice)[index], fds[k].Filename); matched {
			(*ps)[index] = fds[k].Filename
			pcs.recurseMatchPathByShellPattern(index+1, patternSlice, ps, pcspaths)
		}
	}
	return
}

// MatchPathByShellPattern 通配符匹配文件路径, pattern 为绝对路径
func (pcs *BaiduPCS) MatchPathByShellPattern(pattern string) (pcspaths []string, pcsError pcserror.Error) {
	errInfo := pcserror.NewPCSErrorInfo(OperrationMatchPathByShellPattern)
	errInfo.ErrType = pcserror.ErrTypeOthers

	patternSlice := strings.Split(escaper.Escape(path.Clean(pattern), []rune{'['}), PathSeparator) // 转义中括号
	if patternSlice[0] != "" {
		errInfo.Err = ErrMatchPathByShellPatternNotAbsPath
		return nil, errInfo
	}

	ps := make([]string, len(patternSlice))
	defer func() { // 捕获异常
		if err := recover(); err != nil {
			pcspaths = nil
			pcsError = err.(pcserror.Error)
		}
	}()
	pcs.recurseMatchPathByShellPattern(1, &patternSlice, &ps, &pcspaths)
	return pcspaths, nil
}



================================================
FILE: baidupcs/file_directory.go
================================================
package baidupcs

import (
	"errors"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/pcstime"
	"github.com/olekukonko/tablewriter"
	"strconv"
	"strings"
	"unsafe"
)

type (
	// OrderBy 排序字段
	OrderBy string
	// Order 升序降序
	Order string
)

const (
	// OrderByName 根据文件名排序
	OrderByName OrderBy = "name"
	// OrderByTime 根据时间排序
	OrderByTime OrderBy = "time"
	// OrderBySize 根据大小排序, 注意目录无大小
	OrderBySize OrderBy = "size"
	// OrderAsc 升序
	OrderAsc Order = "asc"
	// OrderDesc 降序
	OrderDesc Order = "desc"
)

type (
	// HandleFileDirectoryFunc 处理文件或目录的元信息, 返回值控制是否退出递归
	HandleFileDirectoryFunc func(depth int, fdPath string, fd *FileDirectory, pcsError pcserror.Error) bool

	// FileDirectory 文件或目录的元信息
	FileDirectory struct {
		FsID     int64  // fs_id
		AppID    int64  // app_id
		Path     string // 路径
		Filename string // 文件名 或 目录名
		Ctime    int64  // 创建日期
		Mtime    int64  // 修改日期
		MD5      string // md5 值
		BlockListJSON
		Size        int64 // 文件大小 (目录为0)
		Isdir       bool  // 是否为目录
		Ifhassubdir bool  // 是否含有子目录 (只对目录有效)

		Parent   *FileDirectory    // 父目录信息
		Children FileDirectoryList // 子目录信息
	}

	// FileDirectoryList FileDirectory 的 指针数组
	FileDirectoryList []*FileDirectory

	// fdJSON 用于解析远程JSON数据
	fdJSON struct {
		FsID     int64  `json:"fs_id"` // fs_id
		AppID    int64  `json:"app_id"`
		Path     string `json:"path"`            // 路径
		Filename string `json:"server_filename"` // 文件名 或 目录名
		Ctime    int64  `json:"ctime"`           // 创建日期
		Mtime    int64  `json:"mtime"`           // 修改日期
		MD5      string `json:"md5"`             // md5 值
		BlockListJSON
		Size           int64 `json:"size"` // 文件大小 (目录为0)
		IsdirInt       int8  `json:"isdir"`
		IfhassubdirInt int8  `json:"ifhassubdir"`

		// 对齐
		_ *fdJSON
		_ []*fdJSON
	}

	fdData struct {
		*pcserror.PCSErrInfo
		List FileDirectoryList
	}

	fdDataJSONExport struct {
		*pcserror.PCSErrInfo
		List []*fdJSON `json:"list"`
	}

	// OrderOptions 列文件/目录可选项
	OrderOptions struct {
		By    OrderBy
		Order Order
	}
)

var (
	// DefaultOrderOptions 默认的排序
	DefaultOrderOptions = &OrderOptions{
		By:    OrderByName,
		Order: OrderAsc,
	}

	defaultOrderOptionsStr = fmt.Sprint(DefaultOrderOptions)
)

// FilesDirectoriesMeta 获取单个文件/目录的元信息
func (pcs *BaiduPCS) FilesDirectoriesMeta(path string) (data *FileDirectory, pcsError pcserror.Error) {
	if path == "" {
		path = PathSeparator
	}

	fds, err := pcs.FilesDirectoriesBatchMeta(path)
	if err != nil {
		return nil, err
	}

	// 返回了多条元信息
	if len(fds) != 1 {
		return nil, &pcserror.PCSErrInfo{
			Operation: OperationFilesDirectoriesMeta,
			ErrType:   pcserror.ErrTypeOthers,
			Err:       errors.New("未知返回数据"),
		}
	}

	return fds[0], nil
}

// FilesDirectoriesBatchMeta 获取多个文件/目录的元信息
func (pcs *BaiduPCS) FilesDirectoriesBatchMeta(paths ...string) (data FileDirectoryList, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareFilesDirectoriesBatchMeta(paths...)
	if pcsError != nil {
		return nil, pcsError
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPCSErrorInfo(OperationFilesDirectoriesMeta)
	// 服务器返回数据进行处理
	jsonData := fdData{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationFilesDirectoriesMeta, dataReadCloser, (*fdDataJSONExport)(unsafe.Pointer(&jsonData)))
	if pcsError != nil {
		return
	}

	// 修复MD5
	jsonData.List.fixMD5()

	data = jsonData.List
	return
}

// FilesDirectoriesList 获取目录下的文件和目录列表
func (pcs *BaiduPCS) FilesDirectoriesList(path string, options *OrderOptions) (data FileDirectoryList, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareFilesDirectoriesList(path, options)
	if pcsError != nil {
		return nil, pcsError
	}

	defer dataReadCloser.Close()

	jsonData := fdData{
		PCSErrInfo: pcserror.NewPCSErrorInfo(OperationFilesDirectoriesList),
	}

	pcsError = pcserror.HandleJSONParse(OperationFilesDirectoriesList, dataReadCloser, (*fdDataJSONExport)(unsafe.Pointer(&jsonData)))
	if pcsError != nil {
		return nil, pcsError
	}

	// 修复MD5
	jsonData.List.fixMD5()

	data = jsonData.List
	return
}

// Search 按文件名搜索文件, 不支持查找目录
func (pcs *BaiduPCS) Search(targetPath, keyword string, recursive bool) (fdl FileDirectoryList, pcsError pcserror.Error) {
	if targetPath == "" {
		targetPath = PathSeparator
	}

	dataReadCloser, pcsError := pcs.PrepareSearch(targetPath, keyword, recursive)
	if pcsError != nil {
		return nil, pcsError
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPCSErrorInfo(OperationSearch)
	jsonData := fdData{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationSearch, dataReadCloser, (*fdDataJSONExport)(unsafe.Pointer(&jsonData)))
	if pcsError != nil {
		return
	}

	// 修复MD5
	jsonData.List.fixMD5()

	fdl = jsonData.List
	return
}

func (pcs *BaiduPCS) recurseList(path string, depth int, options *OrderOptions, handleFileDirectoryFunc HandleFileDirectoryFunc) (fdl FileDirectoryList, ok bool) {
	fdl, pcsError := pcs.FilesDirectoriesList(path, options)
	if pcsError != nil {
		ok := handleFileDirectoryFunc(depth, path, nil, pcsError) // 传递错误
		return nil, ok
	}

	for k := range fdl {
		ok = handleFileDirectoryFunc(depth+1, fdl[k].Path, fdl[k], nil)
		if !ok {
			return
		}

		if !fdl[k].Isdir {
			continue
		}

		fdl[k].Children, ok = pcs.recurseList(fdl[k].Path, depth+1, options, handleFileDirectoryFunc)
		if !ok {
			return
		}
	}

	return fdl, true
}

// FilesDirectoriesRecurseList 递归获取目录下的文件和目录列表
func (pcs *BaiduPCS) FilesDirectoriesRecurseList(path string, options *OrderOptions, handleFileDirectoryFunc HandleFileDirectoryFunc) (data FileDirectoryList) {
	fd, pcsError := pcs.FilesDirectoriesMeta(path)
	if pcsError != nil {
		handleFileDirectoryFunc(0, path, nil, pcsError) // 传递错误
		return nil
	}

	if !fd.Isdir { // 不是一个目录
		handleFileDirectoryFunc(0, path, fd, nil)
		return FileDirectoryList{fd}
	}

	data, _ = pcs.recurseList(path, 0, options, handleFileDirectoryFunc)
	return data
}

// fixMD5 尝试修复MD5字段
// 服务器返回的MD5字段不一定正确了, 即是BlockList只有一个md5
// MD5字段使用BlockList中的md5
func (f *FileDirectory) fixMD5() {
	if len(f.BlockList) != 1 {
		return
	}
	f.MD5 = f.BlockList[0]
}

func (f *FileDirectory) String() string {
	builder := &strings.Builder{}
	tb := pcstable.NewTable(builder)
	tb.SetColumnAlignment([]int{tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT})

	if f.Isdir {
		tb.AppendBulk([][]string{
			[]string{"类型", "目录"},
			[]string{"目录路径", f.Path},
			[]string{"目录名称", f.Filename},
		})
	} else {
		var md5info string
		if len(f.BlockList) > 1 {
			md5info = "md5 (可能不正确)"
		} else {
			md5info = "md5 (截图请打码)"
		}
		tb.AppendBulk([][]string{
			[]string{"类型", "文件"},
			[]string{"文件路径", f.Path},
			[]string{"文件名称", f.Filename},
			[]string{"文件大小", strconv.FormatInt(f.Size, 10) + ", " + converter.ConvertFileSize(f.Size)},
			[]string{md5info, f.MD5},
		})
	}

	tb.Append([]string{"app_id", strconv.FormatInt(f.AppID, 10)})
	tb.Append([]string{"fs_id", strconv.FormatInt(f.FsID, 10)})
	tb.AppendBulk([][]string{
		[]string{"创建日期", pcstime.FormatTime(f.Ctime)},
		[]string{"修改日期", pcstime.FormatTime(f.Mtime)},
	})

	if f.Ifhassubdir {
		tb.Append([]string{"是否含有子目录", "true"})
	}

	tb.Render()
	return builder.String()
}

func (fl FileDirectoryList) fixMD5() {
	for _, v := range fl {
		v.fixMD5()
	}
}

// TotalSize 获取目录下文件的总大小
func (fl FileDirectoryList) TotalSize() int64 {
	var size int64
	for k := range fl {
		if fl[k] == nil {
			continue
		}

		size += fl[k].Size

		// 递归获取
		if fl[k].Children != nil {
			size += fl[k].Children.TotalSize()
		}
	}
	return size
}

// Count 获取文件总数和目录总数
func (fl FileDirectoryList) Count() (fileN, directoryN int64) {
	for k := range fl {
		if fl[k] == nil {
			continue
		}

		if fl[k].Isdir {
			directoryN++
		} else {
			fileN++
		}

		// 递归获取
		if fl[k].Children != nil {
			fN, dN := fl[k].Children.Count()
			fileN += fN
			directoryN += dN
		}
	}
	return
}

// AllFilePaths 返回所有的网盘路径, 包括子目录
func (fl FileDirectoryList) AllFilePaths() (pcspaths []string) {
	fN, dN := fl.Count()
	pcspaths = make([]string, 0, fN+dN)
	for k := range fl {
		if fl[k] == nil {
			continue
		}

		pcspaths = append(pcspaths, fl[k].Path)

		if fl[k].Children != nil {
			pcspaths = append(pcspaths, fl[k].Children.AllFilePaths()...)
		}
	}
	return
}



================================================
FILE: baidupcs/jsontable.go
================================================
package baidupcs

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/json-iterator/go"
	"path"
	"strconv"
	"strings"
)

type (
	// PathJSON 网盘路径
	PathJSON struct {
		Path string `json:"path"`
	}

	// PathsListJSON 网盘路径列表
	PathsListJSON struct {
		List []*PathJSON `json:"list"`
	}

	// FsIDJSON 文件或目录ID
	FsIDJSON struct {
		FsID int64 `json:"fs_id"` // fs_id
	}

	// FsIDListJSON fs_id 列表
	FsIDListJSON struct {
		List []*FsIDJSON `json:"list"`
	}

	// CpMvJSON 源文件目录的地址和目标文件目录的地址
	CpMvJSON struct {
		From string `json:"from"` // 源文件或目录
		To   string `json:"to"`   // 目标文件或目录
	}

	// CpMvJSONList CpMvJSON 列表
	CpMvJSONList []*CpMvJSON

	// CpMvListJSON []*CpMvJSON 对象数组
	CpMvListJSON struct {
		List CpMvJSONList `json:"list"`
	}

	// BlockListJSON 文件分块信息JSON
	BlockListJSON struct {
		BlockList []string `json:"block_list"`
	}
)

var (
	// ErrNilJSONValue 解析出的json值为空
	ErrNilJSONValue = errors.New("json value is nil")
)

// JSON json 数据构造
func (plj *PathsListJSON) JSON(paths ...string) (data []byte, err error) {
	plj.List = make([]*PathJSON, len(paths))

	for k := range paths {
		plj.List[k] = &PathJSON{
			Path: paths[k],
		}
	}

	data, err = jsoniter.Marshal(plj)
	return
}

// JSON json 数据构造
func (cj *CpMvJSON) JSON() (data []byte, err error) {
	data, err = jsoniter.Marshal(cj)
	return
}

// JSON json 数据构造
func (clj *CpMvListJSON) JSON() (data []byte, err error) {
	data, err = jsoniter.Marshal(clj)
	return
}

func (clj *CpMvListJSON) String() string {
	builder := &strings.Builder{}

	tb := pcstable.NewTable(builder)
	tb.SetHeader([]string{"#", "原路径", "目标路径"})

	for k := range clj.List {
		if clj.List[k] == nil {
			continue
		}
		tb.Append([]string{strconv.Itoa(k), clj.List[k].From, clj.List[k].To})
	}

	tb.Render()
	return builder.String()
}

// AllRelatedDir 获取所有相关的目录
func (cjl *CpMvJSONList) AllRelatedDir() (dirs []string) {
	for _, cj := range *cjl {
		fromDir, toDir := path.Dir(cj.From), path.Dir(cj.To)
		if !pcsutil.ContainsString(dirs, fromDir) {
			dirs = append(dirs, fromDir)
		}
		if !pcsutil.ContainsString(dirs, toDir) {
			dirs = append(dirs, toDir)
		}
	}
	return
}



================================================
FILE: baidupcs/prepare.go
================================================
package baidupcs

import (
	"bytes"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/netdisksign"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/requester/multipartreader"
	"github.com/felixonmars/baidu-tools/tieba"
	"github.com/json-iterator/go"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"unsafe"
)

type (
	reqType int
)

const (
	reqTypePCS = iota
	reqTypePan
)

func handleRespClose(resp *http.Response) error {
	if resp != nil {
		return resp.Body.Close()
	}
	return nil
}

func handleRespStatusError(opreation string, resp *http.Response) pcserror.Error {
	errInfo := pcserror.NewPCSErrorInfo(opreation)
	// http 响应错误处理
	switch resp.StatusCode / 100 {
	case 4, 5:
		resp.Body.Close()
		errInfo.SetNetError(fmt.Errorf("http 响应错误, %s", resp.Status))
		return errInfo
	}

	return nil
}

func (pcs *BaiduPCS) sendReqReturnResp(rt reqType, op, method, urlStr string, post interface{}, header map[string]string) (resp *http.Response, pcsError pcserror.Error) {
	if header == nil {
		header = map[string]string{}
	}

	var (
		_, uaok = header["User-Agent"]
	)

	if !uaok {
		switch rt {
		case reqTypePCS:
			header["User-Agent"] = pcs.pcsUA
		case reqTypePan:
			header["User-Agent"] = pcs.panUA
		}
	}

	resp, err := pcs.client.Req(method, urlStr, post, header)
	if err != nil {
		handleRespClose(resp)
		switch rt {
		case reqTypePCS:
			return nil, &pcserror.PCSErrInfo{
				Operation: op,
				ErrType:   pcserror.ErrTypeNetError,
				Err:       err,
			}
		case reqTypePan:
			return nil, &pcserror.PanErrorInfo{
				Operation: op,
				ErrType:   pcserror.ErrTypeNetError,
				Err:       err,
			}
		}
		panic("unreachable")
	}
	return resp, nil
}

func (pcs *BaiduPCS) sendReqReturnReadCloser(rt reqType, op, method, urlStr string, post interface{}, header map[string]string) (readCloser io.ReadCloser, pcsError pcserror.Error) {
	resp, pcsError := pcs.sendReqReturnResp(rt, op, method, urlStr, post, header)
	if pcsError != nil {
		return
	}
	return resp.Body, nil
}

// PrepareUK 获取用户 UK, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareUK() (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()

	query := url.Values{}
	query.Set("need_selfinfo", "1")

	panURL := &url.URL{
		Scheme:   "https",
		Host:     PanBaiduCom,
		Path:     "api/user/getinfo",
		RawQuery: query.Encode(),
	}

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationGetUK, http.MethodGet, panURL.String(), nil, nil)
	return
}

// PrepareQuotaInfo 获取当前用户空间配额信息, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareQuotaInfo() (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL := pcs.generatePCSURL("quota", "info")
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationQuotaInfo, pcsURL)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationQuotaInfo, http.MethodGet, pcsURL.String(), nil, nil)
	return
}

// PrepareFilesDirectoriesBatchMeta 获取多个文件/目录的元信息, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareFilesDirectoriesBatchMeta(paths ...string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	sendData, err := (&PathsListJSON{}).JSON(paths...)
	if err != nil {
		panic(OperationFilesDirectoriesMeta + ", json 数据构造失败, " + err.Error())
	}

	pcsURL := pcs.generatePCSURL("file", "meta")
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationFilesDirectoriesMeta, pcsURL)

	// 表单上传
	mr := multipartreader.NewMultipartReader()
	mr.AddFormFeild("param", bytes.NewReader(sendData))
	mr.CloseMultipart()

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationFilesDirectoriesMeta, http.MethodPost, pcsURL.String(), mr, nil)
	return
}

// PrepareFilesDirectoriesList 获取目录下的文件和目录列表, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareFilesDirectoriesList(path string, options *OrderOptions) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	if options == nil {
		options = DefaultOrderOptions
	}
	if path == "" {
		path = PathSeparator
	}

	pcsURL := pcs.generatePCSURL("file", "list", map[string]string{
		"path":  path,
		"by":    *(*string)(unsafe.Pointer(&options.By)),
		"order": *(*string)(unsafe.Pointer(&options.Order)),
		"limit": "0-2147483647",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationFilesDirectoriesList, pcsURL)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationFilesDirectoriesList, http.MethodGet, pcsURL.String(), nil, nil)
	return
}

// PrepareSearch 按文件名搜索文件, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareSearch(targetPath, keyword string, recursive bool) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	var re string
	if recursive {
		re = "1"
	} else {
		re = "0"
	}
	pcsURL := pcs.generatePCSURL("file", "search", map[string]string{
		"path": targetPath,
		"wd":   keyword,
		"re":   re,
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationSearch, pcsURL)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationSearch, http.MethodGet, pcsURL.String(), nil, nil)
	return
}

// PrepareRemove 批量删除文件/目录, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareRemove(paths ...string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	sendData, err := (&PathsListJSON{}).JSON(paths...)
	if err != nil {
		panic(OperationMove + ", json 数据构造失败, " + err.Error())
	}

	pcsURL := pcs.generatePCSURL("file", "delete")
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationRemove, pcsURL)

	// 表单上传
	mr := multipartreader.NewMultipartReader()
	mr.AddFormFeild("param", bytes.NewReader(sendData))
	mr.CloseMultipart()

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationRemove, http.MethodPost, pcsURL.String(), mr, nil)
	return
}

// PrepareMkdir 创建目录, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareMkdir(pcspath string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL := pcs.generatePCSURL("file", "mkdir", map[string]string{
		"path": pcspath,
	})
	baiduPCSVerbose.Infof("%s URL: %s", OperationMkdir, pcsURL)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationMkdir, http.MethodPost, pcsURL.String(), nil, nil)
	return
}

func (pcs *BaiduPCS) prepareCpMvOp(op string, cpmvJSON ...*CpMvJSON) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	var method string
	switch op {
	case OperationCopy:
		method = "copy"
	case OperationMove, OperationRename:
		method = "move"
	default:
		panic("Unknown opreation: " + op)
	}

	sendData, err := (&CpMvListJSON{
		List: cpmvJSON,
	}).JSON()
	if err != nil {
		//json 数据生成失败
		panic(err)
	}

	pcsURL := pcs.generatePCSURL("file", method)
	baiduPCSVerbose.Infof("%s URL: %s\n", op, pcsURL)

	// 表单上传
	mr := multipartreader.NewMultipartReader()
	mr.AddFormFeild("param", bytes.NewReader(sendData))
	mr.CloseMultipart()

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, op, http.MethodPost, pcsURL.String(), mr, nil)
	return
}

// PrepareRename 重命名文件/目录, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareRename(from, to string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	return pcs.prepareCpMvOp(OperationRename, &CpMvJSON{
		From: from,
		To:   to,
	})
}

// PrepareCopy 批量拷贝文件/目录, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareCopy(cpmvJSON ...*CpMvJSON) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	return pcs.prepareCpMvOp(OperationCopy, cpmvJSON...)
}

// PrepareMove 批量移动文件/目录, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareMove(cpmvJSON ...*CpMvJSON) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	return pcs.prepareCpMvOp(OperationMove, cpmvJSON...)
}

// prepareRapidUpload 秒传文件, 不进行文件夹检查
func (pcs *BaiduPCS) prepareRapidUpload(targetPath, contentMD5, sliceMD5, crc32 string, length int64) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL := pcs.generatePCSURL("file", "rapidupload", map[string]string{
		"path":           targetPath,                    // 上传文件的全路径名
		"content-length": strconv.FormatInt(length, 10), // 待秒传的文件长度
		"content-md5":    contentMD5,                    // 待秒传的文件的MD5
		"slice-md5":      sliceMD5,                      // 待秒传的文件前256kb的MD5
		"content-crc32":  crc32,                         // 待秒传文件CRC32
		"ondup":          "overwrite",                   // overwrite: 表示覆盖同名文件; newcopy: 表示生成文件副本并进行重命名，命名规则为“文件名_日期.后缀”
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationRapidUpload, pcsURL)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationRapidUpload, http.MethodGet, pcsURL.String(), nil, nil)
	return
}

// PrepareRapidUpload 秒传文件, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareRapidUpload(targetPath, contentMD5, sliceMD5, crc32 string, length int64) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsError = pcs.checkIsdir(OperationRapidUpload, targetPath)
	if pcsError != nil {
		return nil, pcsError
	}

	return pcs.prepareRapidUpload(targetPath, contentMD5, sliceMD5, crc32, length)
}

// PrepareLocateDownload 获取下载链接, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareLocateDownload(pcspath string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	bduss := pcs.GetBDUSS()
	// 检测uid
	if pcs.uid == 0 {
		t, err := tieba.NewUserInfoByBDUSS(bduss)
		if err != nil {
			return nil, &pcserror.PCSErrInfo{
				Operation: OperationLocateDownload,
				ErrType:   pcserror.ErrTypeNetError,
				Err:       err,
			}
		}
		pcs.uid = t.Baidu.UID
	}

	ns := netdisksign.NewLocateDownloadSign(pcs.uid, bduss)
	pcsURL := &url.URL{
		Scheme: GetHTTPScheme(pcs.isHTTPS),
		Host:   PCSBaiduCom,
		Path:   "/rest/2.0/pcs/file",
		RawQuery: (url.Values{
			"app_id": []string{PanAppID},
			"method": []string{"locatedownload"},
			"path":   []string{pcspath},
			"ver":    []string{"2"},
		}).Encode() + "&" + ns.URLParam(),
	}
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationLocateDownload, pcsURL)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationLocateDownload, http.MethodGet, pcsURL.String(), nil, pcs.getPanUAHeader())
	return
}

// PrepareLocatePanAPIDownload 从百度网盘首页获取下载链接, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareLocatePanAPIDownload(fidList ...int64) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()
	// 初始化
	var (
		sign, err = pcs.ph.CacheSignature()
	)
	if err != nil {
		return nil, &pcserror.PanErrorInfo{
			Operation: OperationLocatePanAPIDownload,
			ErrType:   pcserror.ErrTypeOthers,
			Err:       err,
		}
	}

	panURL := pcs.generatePanURL("download", nil)
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationLocatePanAPIDownload, panURL)

	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationLocatePanAPIDownload, http.MethodPost, panURL.String(), map[string]string{
		"sign":      sign.Sign(),
		"timestamp": sign.Timestamp(),
		"fidlist":   mergeInt64List(fidList...),
	}, map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
	})
	return
}

// PrepareUpload 上传单个文件, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareUpload(targetPath string, uploadFunc UploadFunc) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsError = pcs.checkIsdir(OperationUpload, targetPath)
	if pcsError != nil {
		return nil, pcsError
	}

	pcsURL := pcs.generatePCSURL("file", "upload", map[string]string{
		"path":  targetPath,
		"ondup": "overwrite",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationUpload, pcsURL)

	resp, err := uploadFunc(pcsURL.String(), pcs.client.Jar)
	if err != nil {
		handleRespClose(resp)
		return nil, &pcserror.PCSErrInfo{
			Operation: OperationUpload,
			ErrType:   pcserror.ErrTypeNetError,
			Err:       err,
		}
	}

	pcsError = handleRespStatusError(OperationUpload, resp)
	if pcsError != nil {
		return
	}

	return resp.Body, nil
}

// PrepareUploadTmpFile 分片上传—文件分片及上传, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareUploadTmpFile(uploadFunc UploadFunc) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL := pcs.generatePCSURL("file", "upload", map[string]string{
		"type": "tmpfile",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationUploadTmpFile, pcsURL)

	resp, err := uploadFunc(pcsURL.String(), pcs.client.Jar)
	if err != nil {
		handleRespClose(resp)
		return nil, &pcserror.PCSErrInfo{
			Operation: OperationUploadTmpFile,
			ErrType:   pcserror.ErrTypeNetError,
			Err:       err,
		}
	}

	pcsError = handleRespStatusError(OperationUploadTmpFile, resp)
	if pcsError != nil {
		return
	}

	return resp.Body, nil
}

// PrepareUploadCreateSuperFile 分片上传—合并分片文件, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareUploadCreateSuperFile(checkDir bool, targetPath string, blockList ...string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()

	if checkDir {
		// 检查是否为目录
		pcsError = pcs.checkIsdir(OperationUploadCreateSuperFile, targetPath)
		if pcsError != nil {
			return nil, pcsError
		}
	}

	bl := BlockListJSON{
		BlockList: blockList,
	}

	sendData, err := jsoniter.Marshal(&bl)
	if err != nil {
		panic(err)
	}

	pcsURL := pcs.generatePCSURL("file", "createsuperfile", map[string]string{
		"path":  targetPath,
		"ondup": "overwrite",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationUploadCreateSuperFile, pcsURL)

	// 表单上传
	mr := multipartreader.NewMultipartReader()
	mr.AddFormFeild("param", bytes.NewReader(sendData))
	mr.CloseMultipart()

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationUploadCreateSuperFile, http.MethodPost, pcsURL.String(), mr, nil)
	return
}

// PrepareUploadPrecreate 分片上传—Precreate, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareUploadPrecreate(targetPath, contentMD5, sliceMD5, crc32 string, size int64, bolckList ...string) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()
	panURL := &url.URL{
		Scheme: "https",
		Host:   PanBaiduCom,
		Path:   "api/precreate",
	}
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationUploadPrecreate, panURL)

	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationUploadPrecreate, http.MethodPost, panURL.String(), map[string]string{
		"path":         targetPath,
		"size":         strconv.FormatInt(size, 10),
		"isdir":        "0",
		"block_list":   mergeStringList(bolckList...),
		"autoinit":     "1",
		"content-md5":  contentMD5,
		"slice-md5":    sliceMD5,
		"contentCrc32": crc32,
		"rtype":        "2",
	}, map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
	})
	return
}

// PrepareUploadSuperfile2 另一个上传接口
func (pcs *BaiduPCS) PrepareUploadSuperfile2(uploadid, targetPath string, partseq int, partOffset int64, uploadFunc UploadFunc) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL := pcs.generatePCSURL("superfile2", "upload", map[string]string{
		"type":       "tmpfile",
		"path":       targetPath,
		"partseq":    strconv.Itoa(partseq),
		"partoffset": strconv.FormatInt(partOffset, 10),
		"uploadid":   uploadid,
		"vip":        "1",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationUploadSuperfile2, pcsURL)

	resp, err := uploadFunc(pcsURL.String(), pcs.client.Jar)
	if err != nil {
		handleRespClose(resp)
		return nil, &pcserror.PCSErrInfo{
			Operation: OperationUploadSuperfile2,
			ErrType:   pcserror.ErrTypeNetError,
			Err:       err,
		}
	}

	pcsError = handleRespStatusError(OperationUpload, resp)
	if pcsError != nil {
		return
	}
	return resp.Body, nil
}

// PrepareCloudDlAddTask 添加离线下载任务, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareCloudDlAddTask(sourceURL, savePath string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL2 := pcs.generatePCSURL2("services/cloud_dl", "add_task", map[string]string{
		"save_path":  savePath,
		"source_url": sourceURL,
		"timeout":    "2147483647",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationCloudDlAddTask, pcsURL2)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationCloudDlAddTask, http.MethodPost, pcsURL2.String(), nil, nil)
	return
}

// PrepareCloudDlQueryTask 精确查询离线下载任务, 只返回服务器响应数据和错误信息,
// taskids 例子: 12123,234234,2344, 用逗号隔开多个 task_id
func (pcs *BaiduPCS) PrepareCloudDlQueryTask(taskIDs string) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL2 := pcs.generatePCSURL2("services/cloud_dl", "query_task", map[string]string{
		"op_type": "1",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationCloudDlQueryTask, pcsURL2)

	// 表单上传
	mr := multipartreader.NewMultipartReader()
	mr.AddFormFeild("task_ids", strings.NewReader(taskIDs))
	mr.CloseMultipart()

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationCloudDlQueryTask, http.MethodPost, pcsURL2.String(), mr, nil)
	return
}

// PrepareCloudDlListTask 查询离线下载任务列表, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareCloudDlListTask() (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL2 := pcs.generatePCSURL2("services/cloud_dl", "list_task", map[string]string{
		"need_task_info": "1",
		"status":         "255",
		"start":          "0",
		"limit":          "1000",
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationCloudDlListTask, pcsURL2)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationCloudDlListTask, http.MethodPost, pcsURL2.String(), nil, nil)
	return
}

func (pcs *BaiduPCS) prepareCloudDlCDTask(opreation, method string, taskID int64) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL2 := pcs.generatePCSURL2("services/cloud_dl", method, map[string]string{
		"task_id": strconv.FormatInt(taskID, 10),
	})
	baiduPCSVerbose.Infof("%s URL: %s\n", opreation, pcsURL2)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, opreation, http.MethodPost, pcsURL2.String(), nil, nil)
	return
}

// PrepareCloudDlCancelTask 取消离线下载任务, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareCloudDlCancelTask(taskID int64) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	return pcs.prepareCloudDlCDTask(OperationCloudDlCancelTask, "cancel_task", taskID)
}

// PrepareCloudDlDeleteTask 取消离线下载任务, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareCloudDlDeleteTask(taskID int64) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	return pcs.prepareCloudDlCDTask(OperationCloudDlDeleteTask, "delete_task", taskID)
}

// PrepareCloudDlClearTask 清空离线下载任务记录, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareCloudDlClearTask() (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()
	pcsURL2 := pcs.generatePCSURL2("services/cloud_dl", "clear_task")
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationCloudDlClearTask, pcsURL2)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationCloudDlClearTask, http.MethodPost, pcsURL2.String(), nil, nil)
	return
}

// PrepareSharePSet 私密分享文件, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareSharePSet(paths []string, period int) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()
	panURL := &url.URL{
		Scheme: "https",
		Host:   PanBaiduCom,
		Path:   "share/pset",
	}
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationShareSet, panURL)

	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationShareSet, http.MethodPost, panURL.String(), map[string]string{
		"path_list":    mergeStringList(paths...),
		"schannel":     "0",
		"channel_list": "[]",
		"period":       strconv.Itoa(period),
	}, map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
	})
	return
}

// PrepareShareCancel 取消分享, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareShareCancel(shareIDs []int64) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()
	panURL := &url.URL{
		Scheme: "https",
		Host:   PanBaiduCom,
		Path:   "share/cancel",
	}

	baiduPCSVerbose.Infof("%s URL: %s\n", OperationShareCancel, panURL)

	ss := converter.SliceInt64ToString(shareIDs)
	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationShareCancel, http.MethodPost, panURL.String(), map[string]string{
		"shareid_list": "[" + strings.Join(ss, ",") + "]",
	}, map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
	})
	return
}

// PrepareShareList 列出分享列表, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareShareList(page int) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()

	query := url.Values{}
	query.Set("page", strconv.Itoa(page))
	query.Set("desc", "1")
	query.Set("order", "time")

	panURL := &url.URL{
		Scheme:   "https",
		Host:     PanBaiduCom,
		Path:     "share/record",
		RawQuery: query.Encode(),
	}
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationShareList, panURL)

	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationShareList, http.MethodGet, panURL.String(), nil, nil)
	return
}

// PrepareShareSURLInfo 获取分享的详细信息, 包含密码, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareShareSURLInfo(shareID int64) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()

	query := url.Values{}
	query.Set("shareid", strconv.FormatInt(shareID, 10))
	query.Set("sign", converter.ToString(netdisksign.ShareSURLInfoSign(shareID)))

	panURL := &url.URL{
		Scheme:   "https",
		Host:     PanBaiduCom,
		Path:     "share/surlinfoinrecord",
		RawQuery: query.Encode(),
	}
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationShareSURLInfo, panURL)

	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationShareSURLInfo, http.MethodGet, panURL.String(), nil, nil)
	return
}

// PrepareRecycleList 列出回收站文件列表, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareRecycleList(page int) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()

	panURL := pcs.generatePanURL("recycle/list", map[string]string{
		"num":  "100",
		"page": strconv.Itoa(page),
	})

	baiduPCSVerbose.Infof("%s URL: %s\n", OperationRecycleList, panURL)

	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationRecycleList, http.MethodGet, panURL.String(), nil, nil)
	return
}

// PrepareRecycleRestore 还原回收站文件或目录, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareRecycleRestore(fidList ...int64) (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()

	pcsURL := pcs.generatePCSURL("file", "restore")
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationRecycleRestore, pcsURL)

	fsIDList := make([]*FsIDJSON, 0, len(fidList))
	for k := range fidList {
		fsIDList = append(fsIDList, &FsIDJSON{
			FsID: fidList[k],
		})
	}
	fsIDListJSON := FsIDListJSON{
		List: fsIDList,
	}

	sendData, err := jsoniter.Marshal(&fsIDListJSON)
	if err != nil {
		panic(err)
	}

	// 表单上传
	mr := multipartreader.NewMultipartReader()
	mr.AddFormFeild("param", bytes.NewReader(sendData))
	mr.CloseMultipart()

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationRecycleRestore, http.MethodPost, pcsURL.String(), mr, nil)
	return
}

// PrepareRecycleDelete 删除回收站文件或目录, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareRecycleDelete(fidList ...int64) (dataReadCloser io.ReadCloser, panError pcserror.Error) {
	pcs.lazyInit()

	panURL := pcs.generatePanURL("recycle/delete", nil)
	baiduPCSVerbose.Infof("%s URL: %s\n", OperationRecycleDelete, panURL)

	dataReadCloser, panError = pcs.sendReqReturnReadCloser(reqTypePan, OperationRecycleDelete, http.MethodPost, panURL.String(), map[string]string{
		"fidlist": mergeInt64List(fidList...),
	}, map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
	})
	return
}

// PrepareRecycleClear 清空回收站, 只返回服务器响应数据和错误信息
func (pcs *BaiduPCS) PrepareRecycleClear() (dataReadCloser io.ReadCloser, pcsError pcserror.Error) {
	pcs.lazyInit()

	pcsURL := pcs.generatePCSURL("file", "delete", map[string]string{
		"type": "recycle",
	})

	baiduPCSVerbose.Infof("%s URL: %s\n", OperationRecycleClear, pcsURL)

	dataReadCloser, pcsError = pcs.sendReqReturnReadCloser(reqTypePCS, OperationRecycleClear, http.MethodGet, pcsURL.String(), nil, nil)
	return
}



================================================
FILE: baidupcs/publicsuffix.go
================================================
package baidupcs

import (
	"net/http/cookiejar"
	"strings"
)

type list struct{}

// PublicSuffixList baidupcs PublicSuffixList
var PublicSuffixList cookiejar.PublicSuffixList = list{}

func (list) PublicSuffix(domain string) string {
	if strings.HasSuffix(domain, ".baidu.com") {
		return "com"
	}
	return domain
}

func (list) String() string {
	return "baidupcs"
}



================================================
FILE: baidupcs/quota.go
================================================
package baidupcs

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
)

type quotaInfo struct {
	*pcserror.PCSErrInfo
	Quota int64 `json:"quota"`
	Used  int64 `json:"used"`
}

// QuotaInfo 获取当前用户空间配额信息
func (pcs *BaiduPCS) QuotaInfo() (quota, used int64, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareQuotaInfo()
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	quotaInfo := &quotaInfo{
		PCSErrInfo: pcserror.NewPCSErrorInfo(OperationQuotaInfo),
	}

	pcsError = pcserror.HandleJSONParse(OperationQuotaInfo, dataReadCloser, quotaInfo)
	if pcsError != nil {
		return
	}

	return quotaInfo.Quota, quotaInfo.Used, nil
}



================================================
FILE: baidupcs/recycle.go
================================================
package baidupcs

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
)

type (
	// RecycleFDInfo 回收站中文件/目录信息
	RecycleFDInfo struct {
		FsID     int64  `json:"fs_id"` // fs_id
		Isdir    int    `json:"isdir"`
		LeftTime int    `json:"leftTime"`        // 剩余时间
		Path     string `json:"path"`            // 路径
		Filename string `json:"server_filename"` // 文件名 或 目录名
		Ctime    int64  `json:"server_ctime"`    // 创建日期
		Mtime    int64  `json:"server_mtime"`    // 修改日期
		MD5      string `json:"md5"`             // md5 值
		Size     int64  `json:"size"`            // 文件大小 (目录为0)
	}

	// RecycleFDInfoList 回收站中文件/目录列表
	RecycleFDInfoList []*RecycleFDInfo

	recycleListJSON struct {
		*pcserror.PanErrorInfo
		List RecycleFDInfoList `json:"list"`
	}

	recycleRestoreJSON struct {
		*pcserror.PCSErrInfo
		Extra FsIDListJSON `json:"extra"`
	}

	// RecycleClearInfo 清空回收站的信息
	RecycleClearInfo struct {
		List    RecycleFDInfoList `json:"list"`
		SussNum int               `json:"succNum"`
	}

	recycleClearJSON struct {
		*pcserror.PCSErrInfo
		Extra RecycleClearInfo `json:"extra"`
	}
)

// RecycleList 列出回收站文件列表
func (pcs *BaiduPCS) RecycleList(page int) (fdl RecycleFDInfoList, panError pcserror.Error) {
	dataReadCloser, panError := pcs.PrepareRecycleList(page)
	if panError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPanErrorInfo(OperationRecycleList)
	jsonData := recycleListJSON{
		PanErrorInfo: errInfo,
	}

	panError = pcserror.HandleJSONParse(OperationRecycleList, dataReadCloser, &jsonData)
	if panError != nil {
		return
	}

	return jsonData.List, nil
}

// RecycleRestore 还原回收站文件或目录
func (pcs *BaiduPCS) RecycleRestore(fidList ...int64) (sussFsIDList []*FsIDJSON, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareRecycleRestore(fidList...)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPCSErrorInfo(OperationRecycleRestore)
	jsonData := recycleRestoreJSON{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationRecycleRestore, dataReadCloser, &jsonData)
	return jsonData.Extra.List, pcsError
}

// RecycleDelete 删除回收站文件或目录
func (pcs *BaiduPCS) RecycleDelete(fidList ...int64) (panError pcserror.Error) {
	dataReadCloser, panError := pcs.PrepareRecycleDelete(fidList...)
	if panError != nil {
		return
	}

	defer dataReadCloser.Close()

	panError = pcserror.DecodePanJSONError(OperationRecycleDelete, dataReadCloser)
	return
}

// RecycleClear 清空回收站
func (pcs *BaiduPCS) RecycleClear() (sussNum int, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareRecycleClear()
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPCSErrorInfo(OperationRecycleClear)
	jsonData := recycleClearJSON{
		PCSErrInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationRecycleClear, dataReadCloser, &jsonData)
	return jsonData.Extra.SussNum, pcsError
}



================================================
FILE: baidupcs/rm_mkdir.go
================================================
package baidupcs

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"path"
)

// Remove 批量删除文件/目录
func (pcs *BaiduPCS) Remove(paths ...string) (pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareRemove(paths...)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.DecodePCSJSONError(OperationRemove, dataReadCloser)
	if errInfo != nil {
		return errInfo
	}

	// 更新缓存
	pcs.deleteCache(allRelatedDir(paths))
	return nil
}

// Mkdir 创建目录
func (pcs *BaiduPCS) Mkdir(pcspath string) (pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareMkdir(pcspath)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.DecodePCSJSONError(OperationMkdir, dataReadCloser)
	if errInfo != nil {
		return errInfo
	}

	// 更新缓存
	pcs.deleteCache([]string{path.Dir(pcspath)})
	return
}



================================================
FILE: baidupcs/share.go
================================================
package baidupcs

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"strings"
)

type (
	// ShareOption 分享可选项
	ShareOption struct {
		Password string // 密码
		Period   int    // 有效期
	}

	// Shared 分享信息
	Shared struct {
		Link    string `json:"link"`
		ShareID int64  `json:"shareid"`
	}

	// ShareRecordInfo 分享信息
	ShareRecordInfo struct {
		ShareID         int64   `json:"shareId"`
		FsIds           []int64 `json:"fsIds"`
		Passwd          string  `json:"-"` // 这个字段已经没有用了, 需要从ShareSURLInfo中获取
		Shortlink       string  `json:"shortlink"`
		Status          int     `json:"status"`          // 状态
		Public          int     `json:"public"`          // 是否为公开分享
		TypicalCategory int     `json:"typicalCategory"` // 文件类型
		TypicalPath     string  `json:"typicalPath"`
	}

	shareSURLInfo struct {
		*pcserror.PanErrorInfo
		*ShareSURLInfo
	}

	// ShareSURLInfo 分享的子信息
	ShareSURLInfo struct {
		Pwd      string `json:"pwd"` // 新密码
		ShortURL string `json:"shorturl"`
	}

	// ShareRecordInfoList 分享信息列表
	ShareRecordInfoList []*ShareRecordInfo

	sharePSetJSON struct {
		*Shared
		*pcserror.PanErrorInfo
	}

	shareListJSON struct {
		List ShareRecordInfoList `json:"list"`
		*pcserror.PanErrorInfo
	}
)

var (
	// ErrShareLinkNotFound 未找到分享链接
	ErrShareLinkNotFound = errors.New("未找到分享链接")
)

// ShareSet 分享文件
func (pcs *BaiduPCS) ShareSet(paths []string, option *ShareOption) (s *Shared, pcsError pcserror.Error) {
	if option == nil {
		option = &ShareOption{}
	}

	dataReadCloser, pcsError := pcs.PrepareSharePSet(paths, option.Period)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPanErrorInfo(OperationShareSet)
	jsonData := sharePSetJSON{
		Shared:       &Shared{},
		PanErrorInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationShareSet, dataReadCloser, &jsonData)
	if pcsError != nil {
		return
	}

	if jsonData.Link == "" {
		errInfo.ErrType = pcserror.ErrTypeOthers
		errInfo.Err = ErrShareLinkNotFound
		return nil, errInfo
	}

	return jsonData.Shared, nil
}

// ShareCancel 取消分享
func (pcs *BaiduPCS) ShareCancel(shareIDs []int64) (pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareShareCancel(shareIDs)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	pcsError = pcserror.DecodePanJSONError(OperationShareCancel, dataReadCloser)
	return
}

// ShareList 列出分享列表
func (pcs *BaiduPCS) ShareList(page int) (records ShareRecordInfoList, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareShareList(page)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPanErrorInfo(OperationShareList)
	jsonData := shareListJSON{
		List:         records,
		PanErrorInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationShareList, dataReadCloser, &jsonData)
	if pcsError != nil {
		// json解析错误
		if pcsError.GetErrType() == pcserror.ErrTypeJSONParseError {
			// 服务器更改, List为空时变成{}, 导致解析错误
			if strings.Contains(pcsError.GetError().Error(), `"list":{}`) {
				// 返回空列表
				return jsonData.List, nil
			}
		}
		return
	}

	if jsonData.List == nil {
		errInfo.ErrType = pcserror.ErrTypeOthers
		errInfo.Err = errors.New("shared list is nil")
		return nil, errInfo
	}

	return jsonData.List, nil
}

//ShareSURLInfo 获取分享的详细信息, 包含密码
func (pcs *BaiduPCS) ShareSURLInfo(shareID int64) (info *ShareSURLInfo, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareShareSURLInfo(shareID)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPanErrorInfo(OperationShareSURLInfo)

	jsonData := shareSURLInfo{
		PanErrorInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationShareList, dataReadCloser, &jsonData)
	if pcsError != nil {
		// json解析错误
		return
	}

	// 去掉0
	if jsonData.Pwd == "0" {
		jsonData.Pwd = ""
	}

	return jsonData.ShareSURLInfo, nil
}



================================================
FILE: baidupcs/upload.go
================================================
package baidupcs

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"net/http"
	"path"
)

const (
	// MaxUploadBlockSize 最大上传的文件分片大小
	MaxUploadBlockSize = 2 * converter.GB
	// MinUploadBlockSize 最小的上传的文件分片大小
	MinUploadBlockSize = 4 * converter.MB
	// MaxRapidUploadSize 秒传文件支持的最大文件大小
	MaxRapidUploadSize = 20 * converter.GB
	// RecommendUploadBlockSize 推荐的上传的文件分片大小
	RecommendUploadBlockSize = 1 * converter.GB
	// SliceMD5Size 计算 slice-md5 所需的长度
	SliceMD5Size = 256 * converter.KB
	// EmptyContentMD5 空串的md5
	EmptyContentMD5 = "d41d8cd98f00b204e9800998ecf8427e"
)

var (
	// ErrUploadMD5NotFound 未找到md5
	ErrUploadMD5NotFound = errors.New("unknown response data, md5 not found")
	// ErrUploadSavePathFound 未找到保存路径
	ErrUploadSavePathFound = errors.New("unknown response data, file saved path not found")
	// ErrUploadSeqNotMatch 服务器返回的上传队列不匹配
	ErrUploadSeqNotMatch = errors.New("服务器返回的上传队列不匹配")
)

type (
	// UploadFunc 上传文件处理函数
	UploadFunc func(uploadURL string, jar http.CookieJar) (resp *http.Response, err error)

	// RapidUploadInfo 文件秒传信息
	RapidUploadInfo struct {
		Filename      string
		ContentLength int64
		ContentMD5    string
		SliceMD5      string
		ContentCrc32  string
	}

	uploadJSON struct {
		*PathJSON
		*pcserror.PCSErrInfo
	}

	uploadTmpFileJSON struct {
		MD5 string `json:"md5"`
		*pcserror.PCSErrInfo
	}

	uploadPrecreateJSON struct {
		ReturnType int    `json:"return_type"` // 1上传, 2秒传
		UploadID   string `json:"uploadid"`
		BlockList  []int  `json:"block_list"`
		*pcserror.PanErrorInfo
		fdJSON `json:"info"`
	}

	// UploadSeq 分片上传顺序
	UploadSeq struct {
		Seq   int
		Block string
	}

	// PrecreateInfo 预提交文件消息返回数据
	PrecreateInfo struct {
		IsRapidUpload bool
		UploadID      string
		UploadSeqList []*UploadSeq
	}

	uploadSuperfile2JSON struct {
		MD5 string `json:"md5"`
		*pcserror.PCSErrInfo
	}
)

// RapidUpload 秒传文件
func (pcs *BaiduPCS) RapidUpload(targetPath, contentMD5, sliceMD5, crc32 string, length int64) (pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareRapidUpload(targetPath, contentMD5, sliceMD5, crc32, length)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	pcsError = pcserror.DecodePCSJSONError(OperationRapidUpload, dataReadCloser)
	if pcsError != nil {
		return
	}

	// 更新缓存
	pcs.deleteCache([]string{path.Dir(targetPath)})
	return nil
}

// RapidUploadNoCheckDir 秒传文件, 不进行目录检查, 会覆盖掉同名的目录!
func (pcs *BaiduPCS) RapidUploadNoCheckDir(targetPath, contentMD5, sliceMD5, crc32 string, length int64) (pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.prepareRapidUpload(targetPath, contentMD5, sliceMD5, crc32, length)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	pcsError = pcserror.DecodePCSJSONError(OperationRapidUpload, dataReadCloser)
	if pcsError != nil {
		return
	}

	return nil
}

// Upload 上传单个文件
func (pcs *BaiduPCS) Upload(targetPath string, uploadFunc UploadFunc) (pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareUpload(targetPath, uploadFunc)
	if pcsError != nil {
		return pcsError
	}

	defer dataReadCloser.Close()

	// 数据处理
	jsonData := uploadJSON{
		PCSErrInfo: pcserror.NewPCSErrorInfo(OperationUpload),
	}

	pcsError = pcserror.HandleJSONParse(OperationUpload, dataReadCloser, &jsonData)
	if pcsError != nil {
		return
	}

	if jsonData.Path == "" {
		jsonData.PCSErrInfo.ErrType = pcserror.ErrTypeInternalError
		jsonData.PCSErrInfo.Err = ErrUploadSavePathFound
		return jsonData.PCSErrInfo
	}

	// 更新缓存
	pcs.deleteCache([]string{path.Dir(targetPath)})
	return nil
}

// UploadTmpFile 分片上传—文件分片及上传
func (pcs *BaiduPCS) UploadTmpFile(uploadFunc UploadFunc) (md5 string, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareUploadTmpFile(uploadFunc)
	if pcsError != nil {
		return "", pcsError
	}

	defer dataReadCloser.Close()

	// 数据处理
	jsonData := uploadTmpFileJSON{
		PCSErrInfo: pcserror.NewPCSErrorInfo(OperationUploadTmpFile),
	}

	pcsError = pcserror.HandleJSONParse(OperationUploadTmpFile, dataReadCloser, &jsonData)
	if pcsError != nil {
		return
	}

	// 未找到md5
	if jsonData.MD5 == "" {
		jsonData.PCSErrInfo.ErrType = pcserror.ErrTypeInternalError
		jsonData.PCSErrInfo.Err = ErrUploadMD5NotFound
		return "", jsonData.PCSErrInfo
	}

	return jsonData.MD5, nil
}

// UploadCreateSuperFile 分片上传—合并分片文件
func (pcs *BaiduPCS) UploadCreateSuperFile(checkDir bool, targetPath string, blockList ...string) (pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareUploadCreateSuperFile(checkDir, targetPath, blockList...)
	if pcsError != nil {
		return pcsError
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.DecodePCSJSONError(OperationUploadCreateSuperFile, dataReadCloser)
	if errInfo != nil {
		return errInfo
	}

	// 更新缓存
	pcs.deleteCache([]string{path.Dir(targetPath)})
	return nil
}

// UploadPrecreate 分片上传—Precreate,
// 支持检验秒传
func (pcs *BaiduPCS) UploadPrecreate(targetPath, contentMD5, sliceMD5, crc32 string, size int64, bolckList ...string) (precreateInfo *PrecreateInfo, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareUploadPrecreate(targetPath, contentMD5, sliceMD5, crc32, size, bolckList...)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	errInfo := pcserror.NewPanErrorInfo(OperationUploadPrecreate)
	jsonData := uploadPrecreateJSON{
		PanErrorInfo: errInfo,
	}

	pcsError = pcserror.HandleJSONParse(OperationUploadPrecreate, dataReadCloser, &jsonData)
	if pcsError != nil {
		return
	}

	switch jsonData.ReturnType {
	case 1: // 上传
		seqLen := len(jsonData.BlockList)
		if seqLen != len(bolckList) {
			errInfo.ErrType = pcserror.ErrTypeRemoteError
			errInfo.Err = ErrUploadSeqNotMatch
			return nil, errInfo
		}

		seqList := make([]*UploadSeq, 0, seqLen)
		for k, seq := range jsonData.BlockList {
			seqList = append(seqList, &UploadSeq{
				Seq:   seq,
				Block: bolckList[k],
			})
		}
		return &PrecreateInfo{
			UploadID:      jsonData.UploadID,
			UploadSeqList: seqList,
		}, nil

	case 2: // 秒传
		return &PrecreateInfo{
			IsRapidUpload: true,
		}, nil

	default:
		panic("unknown returntype")
	}
}

// UploadSuperfile2 分片上传—Superfile2
func (pcs *BaiduPCS) UploadSuperfile2(uploadid, targetPath string, partseq int, partOffset int64, uploadFunc UploadFunc) (md5sum string, pcsError pcserror.Error) {
	dataReadCloser, pcsError := pcs.PrepareUploadSuperfile2(uploadid, targetPath, partseq, partOffset, uploadFunc)
	if pcsError != nil {
		return
	}

	defer dataReadCloser.Close()

	jsonData := uploadSuperfile2JSON{
		PCSErrInfo: pcserror.NewPCSErrorInfo(OperationUploadSuperfile2),
	}

	pcsError = pcserror.HandleJSONParse(OperationUploadSuperfile2, dataReadCloser, &jsonData)
	if pcsError != nil {
		return
	}

	return jsonData.MD5, nil
}



================================================
FILE: baidupcs/util.go
================================================
package baidupcs

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"path"
	"strings"
)

// Isdir 检查路径在网盘中是否为目录
func (pcs *BaiduPCS) Isdir(pcspath string) (isdir bool, pcsError pcserror.Error) {
	if path.Clean(pcspath) == PathSeparator {
		return true, nil
	}

	f, pcsError := pcs.FilesDirectoriesMeta(pcspath)
	if pcsError != nil {
		return false, pcsError
	}

	return f.Isdir, nil
}

func (pcs *BaiduPCS) checkIsdir(op string, targetPath string) pcserror.Error {
	// 检测文件是否存在于网盘路径
	// 很重要, 如果文件存在会直接覆盖!!! 即使是根目录!
	isdir, pcsError := pcs.Isdir(targetPath)
	if pcsError != nil {
		// 忽略远程服务端返回的错误
		if pcsError.GetErrType() != pcserror.ErrTypeRemoteError {
			return pcsError
		}
	}

	errInfo := pcserror.NewPCSErrorInfo(op)
	if isdir {
		errInfo.ErrType = pcserror.ErrTypeOthers
		errInfo.Err = errors.New("保存路径不可以覆盖目录")
		return errInfo
	}
	return nil
}

func mergeStringList(a ...string) string {
	s := strings.Join(a, `","`)
	return `["` + s + `"]`
}

func mergeInt64List(si ...int64) string {
	i := converter.SliceInt64ToString(si)
	s := strings.Join(i, ",")
	return "[" + s + "]"
}

func allRelatedDir(pcspaths []string) (dirs []string) {
	for _, pcspath := range pcspaths {
		pathDir := path.Dir(pcspath)
		if !pcsutil.ContainsString(dirs, pathDir) {
			dirs = append(dirs, pathDir)
		}
	}
	return
}

// GetHTTPScheme 获取 http 协议, https 或 http
func GetHTTPScheme(https bool) (scheme string) {
	if https {
		return "https"
	}
	return "http"
}



================================================
FILE: baidupcs/expires/dataexpires.go
================================================
package expires

import (
	"time"
)

type (
	DataExpires interface {
		Data() interface{}
		Expires
	}

	dataExpires struct {
		data interface{}
		Expires
	}
)

func NewDataExpires(data interface{}, dur time.Duration) DataExpires {
	return &dataExpires{
		data:    data,
		Expires: NewExpires(dur),
	}
}

func (de *dataExpires) Data() interface{} {
	return de.data
}



================================================
FILE: baidupcs/expires/expires.go
================================================
package expires

import (
	"fmt"
	"time"
	_ "unsafe" // for go:linkname
)

type (
	Expires interface {
		IsExpires() bool
		GetExpires() time.Time
		SetExpires(e bool)
		fmt.Stringer
	}

	expires struct {
		expiresAt time.Time
		abort     bool
	}
)

//go:linkname stripMono time.(*Time).stripMono
func stripMono(t *time.Time)

// StripMono strip monotonic clocks
func StripMono(t *time.Time) {
	stripMono(t)
}

func NewExpires(dur time.Duration) Expires {
	t := time.Now().Add(dur)
	StripMono(&t)
	return &expires{
		expiresAt: t,
	}
}

func NewExpiresAt(at time.Time) Expires {
	StripMono(&at)
	return &expires{
		expiresAt: at,
	}
}

func (ep *expires) GetExpires() time.Time {
	return ep.expiresAt
}

func (ep *expires) SetExpires(e bool) {
	ep.abort = e
}

func (ep *expires) IsExpires() bool {
	return ep.abort || time.Now().After(ep.expiresAt)
}

func (ep *expires) String() string {
	return fmt.Sprintf("expires at: %s, abort: %t", ep.expiresAt, ep.abort)
}



================================================
FILE: baidupcs/expires/expires.s
================================================
[Empty file]


================================================
FILE: baidupcs/expires/cachemap/cachemap.go
================================================
package cachemap

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"sync"
)

var (
	GlobalCacheOpMap = CacheOpMap{}
)

type (
	CacheOpMap struct {
		cachePool sync.Map
	}
)

func (cm *CacheOpMap) LazyInitCachePoolOp(op string) CacheUnit {
	cacheItf, _ := cm.cachePool.LoadOrStore(op, &cacheUnit{})
	return cacheItf.(CacheUnit)
}

func (cm *CacheOpMap) RemoveCachePoolOp(op string) {
	cm.cachePool.Delete(op)
}

// ClearInvalidate 清除已过期的数据(一般用不到)
func (cm *CacheOpMap) ClearInvalidate() {
	cm.cachePool.Range(func(_, cacheItf interface{}) bool {
		cache := cacheItf.(CacheUnit)
		cache.Range(func(key interface{}, exp expires.DataExpires) bool {
			if exp.IsExpires() {
				cache.Delete(key)
			}
			return true
		})
		return true
	})
}

// PrintAll 输出所有缓冲项目
func (cm *CacheOpMap) PrintAll() {
}



================================================
FILE: baidupcs/expires/cachemap/cachemap_test.go
================================================
package cachemap_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires/cachemap"
	"sync"
	"sync/atomic"
	"testing"
	"time"
)

func TestCacheMapDataExpires(t *testing.T) {
	cm := cachemap.CacheOpMap{}
	cache := cm.LazyInitCachePoolOp("op")
	cache.Store("key_1", expires.NewDataExpires("value_1", 1*time.Second))

	time.Sleep(2 * time.Second)
	data, ok := cache.Load("key_1")
	if ok {
		fmt.Printf("data: %s\n", data.Data())
		// 超时仍能读取到数据, 失败
		t.FailNow()
	}
}

func TestCacheOperation(t *testing.T) {
	cm := cachemap.CacheOpMap{}
	data := cm.CacheOperation("op", "key_1", func() expires.DataExpires {
		return expires.NewDataExpires("value_1", 1*time.Second)
	})
	fmt.Printf("data: %s\n", data.Data())

	newData := cm.CacheOperation("op", "key_1", func() expires.DataExpires {
		return expires.NewDataExpires("value_3", 1*time.Second)
	})
	if data != newData {
		t.FailNow()
	}
	fmt.Printf("data: %s\n", data.Data())
}

func TestCacheOperation_LockKey(t *testing.T) {
	cm := cachemap.CacheOpMap{}
	wg := sync.WaitGroup{}
	wg.Add(5000)

	var (
		execTimes1 int32 = 0 // 执行次数1
		execTimes2 int32 = 0 // 执行次数2
	)

	for i := 0; i < 5000; i++ {
		go func(i int) {
			defer wg.Done()
			cm.CacheOperation("op", "key_1", func() expires.DataExpires {
				time.Sleep(50 * time.Microsecond) // 一些耗时的操作
				atomic.AddInt32(&execTimes1, 1)
				return expires.NewDataExpires(fmt.Sprintf("value_1: %d", i), 10*time.Second)
			})

			cm.CacheOperation("op", "key_2", func() expires.DataExpires {
				time.Sleep(50 * time.Microsecond) // 一些耗时的操作
				atomic.AddInt32(&execTimes2, 1)
				return expires.NewDataExpires(fmt.Sprintf("value_2: %d", i), 10*time.Second)
			})
		}(i)
	}
	wg.Wait()

	// 执行次数应为1
	if execTimes1 != 1 {
		fmt.Printf("execTimes1: %d\n", execTimes1)
		t.FailNow()
	}
	if execTimes2 != 1 {
		fmt.Printf("execTimes2: %d\n", execTimes2)
		t.FailNow()
	}
}



================================================
FILE: baidupcs/expires/cachemap/cacheunit.go
================================================
package cachemap

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"sync"
)

type (
	CacheUnit interface {
		Delete(key interface{})
		Load(key interface{}) (value expires.DataExpires, ok bool)
		LoadOrStore(key interface{}, value expires.DataExpires) (actual expires.DataExpires, loaded bool)
		Range(f func(key interface{}, value expires.DataExpires) bool)
		Store(key interface{}, value expires.DataExpires)
		LockKey(key interface{})
		UnlockKey(key interface{})
	}

	cacheUnit struct {
		unit   sync.Map
		keyMap sync.Map
	}
)

func (cu *cacheUnit) Delete(key interface{}) {
	cu.unit.Delete(key)
	cu.keyMap.Delete(key)
}

func (cu *cacheUnit) Load(key interface{}) (value expires.DataExpires, ok bool) {
	val, ok := cu.unit.Load(key)
	if !ok {
		return nil, ok
	}
	exp := val.(expires.DataExpires)
	if exp.IsExpires() {
		cu.unit.Delete(key)
		return nil, false
	}
	return exp, ok
}

func (cu *cacheUnit) Range(f func(key interface{}, value expires.DataExpires) bool) {
	cu.unit.Range(func(k, val interface{}) bool {
		exp := val.(expires.DataExpires)
		if exp.IsExpires() {
			cu.unit.Delete(k)
			return true
		}
		return f(k, val.(expires.DataExpires))
	})
}

func (cu *cacheUnit) LoadOrStore(key interface{}, value expires.DataExpires) (actual expires.DataExpires, loaded bool) {
	ac, loaded := cu.unit.LoadOrStore(key, value)
	exp := ac.(expires.DataExpires)
	if exp.IsExpires() {
		cu.unit.Delete(key)
		return nil, false
	}
	return exp, loaded
}

func (cu *cacheUnit) Store(key interface{}, value expires.DataExpires) {
	if value.IsExpires() {
		return
	}
	cu.unit.Store(key, value)
}

func (cu *cacheUnit) LockKey(key interface{}) {
	muItf, _ := cu.keyMap.LoadOrStore(key, &sync.Mutex{})
	mu := muItf.(*sync.Mutex)
	mu.Lock()
}

func (cu *cacheUnit) UnlockKey(key interface{}) {
	muItf, _ := cu.keyMap.LoadOrStore(key, &sync.Mutex{})
	mu := muItf.(*sync.Mutex)
	mu.Unlock()
}



================================================
FILE: baidupcs/expires/cachemap/utils.go
================================================
package cachemap

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
)

type (
	OpFunc          func() expires.DataExpires
	OpFuncWithError func() (expires.DataExpires, error)
)

func (cm *CacheOpMap) CacheOperation(op string, key interface{}, opFunc OpFunc) (data expires.DataExpires) {
	var (
		cache = cm.LazyInitCachePoolOp(op)
		ok    bool
	)

	cache.LockKey(key)
	defer cache.UnlockKey(key)
	data, ok = cache.Load(key)
	if !ok {
		data = opFunc()
		if data != nil {
			cache.Store(key, data)
		}
		return
	}

	return
}

func (cm *CacheOpMap) CacheOperationWithError(op string, key interface{}, opFunc OpFuncWithError) (data expires.DataExpires, err error) {
	var (
		cache = cm.LazyInitCachePoolOp(op)
		ok    bool
	)

	cache.LockKey(key)
	defer cache.UnlockKey(key)
	data, ok = cache.Load(key)
	if !ok {
		data, err = opFunc()
		if err != nil {
			return
		}
		if data == nil {
			// 数据为空时也不存
			return
		}
		cache.Store(key, data)
	}

	return
}



================================================
FILE: baidupcs/internal/panhome/cache.go
================================================
package panhome

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"time"
)

// SetSignExpires 设置sign过期
func (ph *PanHome) SetSignExpires() {
	if ph.signExpires != nil {
		ph.signExpires.SetExpires(true)
	}
}

// CacheSignature 在有效期内返回缓存结果
func (ph *PanHome) CacheSignature() (sign SignRes, err error) {
	if ph.signExpires == nil || ph.signExpires.IsExpires() {
		// 先签名再设置有效期
		ph.signRes, err = ph.Signature()
		if err != nil { // 空指针与空接口不等价
			return nil, err
		}

		ph.signExpires = expires.NewExpires(1 * time.Hour) // 设置一小时有效期
		return ph.signRes, nil
	}

	return ph.signRes, nil
}



================================================
FILE: baidupcs/internal/panhome/panhome.go
================================================
package panhome

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"net/url"
)

const (
	// OperationSignature signature
	OperationSignature = "signature"
)

var (
	panBaiduComURL = &url.URL{
		Scheme: "https",
		Host:   "pan.baidu.com",
	}
	// PanHomeUserAgent PanHome User-Agent
	PanHomeUserAgent = "Mozilla/5.0"
)

type (
	PanHome struct {
		client *requester.HTTPClient
		ua     string
		bduss  string

		sign1, sign3 []rune
		timestamp    string

		signRes     SignRes
		signExpires expires.Expires
	}
)

func NewPanHome(client *requester.HTTPClient) *PanHome {
	ph := PanHome{}
	if client != nil {
		newC := *client
		ph.client = &newC
	}
	return &ph
}

func (ph *PanHome) lazyInit() {
	if ph.client == nil {
		ph.client = requester.NewHTTPClient()
	}
}



================================================
FILE: baidupcs/internal/panhome/parse.go
================================================
package panhome

import (
	"errors"
	"io/ioutil"
	"net/http"
	"net/url"
	"regexp"
	"unsafe"
)

var (
	signInfoRE         = regexp.MustCompile(`"sign1":"(.*?)"[\s\S]*"sign3":"(.*?)","timestamp":(\d*?),`)
	ErrCookieInvalid   = errors.New("cookie is invalid")
	ErrUnknownLocation = errors.New("unknown location")
	ErrMatchPanHome    = errors.New("网盘首页数据匹配出错")
)

func (ph *PanHome) getSignInfo() error {
	ph.client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		return http.ErrUseLastResponse
	}
	u := *panBaiduComURL
	u.Path = "/disk/home"
	resp, err := ph.client.Req(http.MethodGet, u.String(), nil, map[string]string{
		"User-Agent": PanHomeUserAgent,
	})
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		return err
	}

	loc := resp.Header.Get("Location")
	switch loc {
	case "/":
		return ErrCookieInvalid
	case "":
		//pass
	default:
		locU, err := url.Parse(loc)
		if err != nil {
			return ErrUnknownLocation
		}
		if locU.Host == "passport.baidu.com" {
			return ErrCookieInvalid
		}
		return ErrUnknownLocation
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	matchRes := signInfoRE.FindSubmatch(body)
	if len(matchRes) <= 3 {
		return ErrMatchPanHome
	}

	ph.sign1 = []rune(*(*string)(unsafe.Pointer(&matchRes[1])))
	ph.sign3 = []rune(*(*string)(unsafe.Pointer(&matchRes[2])))
	ph.timestamp = *(*string)(unsafe.Pointer(&matchRes[3]))
	return nil
}



================================================
FILE: baidupcs/internal/panhome/sign.go
================================================
package panhome

import (
	"github.com/felixonmars/Baidu-Login/bdcrypto"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/netdisksign"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
)

type (
	// SignRes 签名结果
	SignRes interface {
		Sign() string
		Timestamp() string
	}

	signRes struct {
		sign      string
		timestamp string
	}
)

func (sr *signRes) Sign() string {
	return sr.sign
}
func (sr *signRes) Timestamp() string {
	return sr.timestamp
}

func (ph *PanHome) Signature() (sign SignRes, err error) {
	err = ph.getSignInfo()
	if err != nil {
		return nil, err
	}

	o := netdisksign.Sign2(ph.sign3, ph.sign1)
	signed := bdcrypto.Base64Encode(o)
	return &signRes{
		sign:      converter.ToString(signed),
		timestamp: ph.timestamp,
	}, nil
}



================================================
FILE: baidupcs/netdisksign/devuid.go
================================================
package netdisksign

import (
	"bytes"
	"crypto/md5"
	"encoding/hex"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
)

func DevUID(feature string) string {
	m := md5.New()
	m.Write(converter.ToBytes(feature))
	res := m.Sum(nil)
	resHex := cachepool.RawMallocByteSlice(34)
	hex.Encode(resHex[2:], res)
	resHex[0] = 'O'
	resHex[1] = '|'
	return converter.ToString(bytes.ToUpper(resHex))
}



================================================
FILE: baidupcs/netdisksign/locatedownloadsign.go
================================================
package netdisksign

import (
	"crypto/sha1"
	"encoding/hex"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"strconv"
	"time"
)

type (
	LocateDownloadSign struct {
		Time   int64
		Rand   string
		DevUID string
	}
)

func NewLocateDownloadSign(uid uint64, bduss string) *LocateDownloadSign {
	return NewLocateDownloadSignWithTimeAndDevUID(time.Now().Unix(), DevUID(bduss), uid, bduss)
}

func NewLocateDownloadSignWithTimeAndDevUID(timeunix int64, devuid string, uid uint64, bduss string) *LocateDownloadSign {
	l := &LocateDownloadSign{
		Time:   timeunix,
		DevUID: devuid,
	}
	l.Sign(uid, bduss)
	return l
}

func (s *LocateDownloadSign) Sign(uid uint64, bduss string) {
	randSha1 := sha1.New()
	bdussSha1 := sha1.New()
	bdussSha1.Write(converter.ToBytes(bduss))
	sha1ResHex := cachepool.RawMallocByteSlice(40)
	hex.Encode(sha1ResHex, bdussSha1.Sum(nil))
	randSha1.Write(sha1ResHex)
	uidStr := strconv.FormatUint(uid, 10)
	randSha1.Write(converter.ToBytes(uidStr))
	randSha1.Write([]byte{'\x65', '\x62', '\x72', '\x63', '\x55', '\x59', '\x69', '\x75', '\x78', '\x61', '\x5a', '\x76', '\x32', '\x58', '\x47', '\x75', '\x37', '\x4b', '\x49', '\x59', '\x4b', '\x78', '\x55', '\x72', '\x71', '\x66', '\x6e', '\x4f', '\x66', '\x70', '\x44', '\x46'})
	timeStr := strconv.FormatInt(s.Time, 10)
	randSha1.Write(converter.ToBytes(timeStr))
	randSha1.Write(converter.ToBytes(s.DevUID))
	hex.Encode(sha1ResHex, randSha1.Sum(nil))
	s.Rand = converter.ToString(sha1ResHex)
}

func (s *LocateDownloadSign) URLParam() string {
	return "time=" + strconv.FormatInt(s.Time, 10) + "&rand=" + s.Rand + "&devuid=" + s.DevUID
}



================================================
FILE: baidupcs/netdisksign/locatedownloadsign_test.go
================================================
package netdisksign_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/netdisksign"
	"testing"
)

func TestLocateDownloadSign(t *testing.T) {
	sign := netdisksign.NewLocateDownloadSignWithTimeAndDevUID(1571140066, "O|1E67351CCE80B2CF48DB511CD77ACD9F", 10086, "test_bduss")
	fmt.Printf("%#v\n", sign.Rand == "b6bb7a6f46899e181baea58798d4fdb889775c2c")
}



================================================
FILE: baidupcs/netdisksign/share_sign.go
================================================
package netdisksign

import (
	"crypto/md5"
	"encoding/hex"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"strconv"
)

func ShareSURLInfoSign(shareID int64) []byte {
	s := strconv.FormatInt(shareID, 10)
	m := md5.New()
	m.Write(converter.ToBytes(s))
	m.Write([]byte("_sharesurlinfo!@#"))
	res := m.Sum(nil)
	resHex := cachepool.RawMallocByteSlice(32)
	hex.Encode(resHex, res)
	return resHex
}



================================================
FILE: baidupcs/netdisksign/sign2.go
================================================
package netdisksign

func Sign2(j, r []rune) []byte {
	var (
		a  = make([]rune, 256)
		p  = make([]rune, 256)
		o  = make([]byte, len(r))
		v  = len(j)
		q  int
		u  rune
		i  int
		k  rune
		dr int
	)
	if v == 0 {
		return o
	}
	for ; q < 256; q++ {
		dr = q % v
		a[q] = j[dr : 1+dr][0]
		p[q] = rune(q)
	}
	for q = 0; q < 256; q++ {
		u = (u + p[q] + a[q]) % 256
		p[q], p[u] = p[u], p[q]
	}
	u = 0
	for q = 0; q < len(r); q++ {
		i = (i + 1) % 256
		u = (u + p[i]) % 256
		p[i], p[u] = p[u], p[i]
		k = p[(p[i]+p[u])%256]
		o[q] = byte(r[q] ^ k)
	}
	return o
}


================================================
FILE: baidupcs/netdisksign/sign2.js
================================================
function s(j, r) {
    var a = [];
    var p = [];
    var o = "";
    var v = j.length;
    for (var q = 0; q < 256; q++) {
        a[q] = j.substr((q % v), 1).charCodeAt(0);
        // console.log(q, q%v);
        p[q] = q;
        // console.log(q, a[q], p[q]);
    }
    for (var u = q = 0; q < 256; q++) {
        u = (u + p[q] + a[q]) % 256;
        var t = p[q];
        p[q] = p[u];
        p[u] = t;
    }
    // console.log(p)
    for (var i = u = q = 0; q < r.length; q++) {
        i = (i + 1) % 256;
        u = (u + p[i]) % 256;
        var t = p[i];
        p[i] = p[u];
        p[u] = t;
        k = p[((p[i] + p[u]) % 256)];
        o += String.fromCharCode(r.charCodeAt(q) ^ k);
    }
    return o;
};

function base64encode(t) {
    var r, e, a, o, n, i, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (a = t.length,
    e = 0,
    r = ""; a > e; ) {
        if (o = 255 & t.charCodeAt(e++),
        e == a) {
            r += s.charAt(o >> 2),
            r += s.charAt((3 & o) << 4),
            r += "==";
            break
        }
        if (n = t.charCodeAt(e++),
        e == a) {
            r += s.charAt(o >> 2),
            r += s.charAt((3 & o) << 4 | (240 & n) >> 4),
            r += s.charAt((15 & n) << 2),
            r += "=";
            break
        }
        i = t.charCodeAt(e++),
        r += s.charAt(o >> 2),
        r += s.charAt((3 & o) << 4 | (240 & n) >> 4),
        r += s.charAt((15 & n) << 2 | (192 & i) >> 6),
        r += s.charAt(63 & i)
    }
    return r
}

var s1 = s("e8c7d729eea7b54551aa594f942decbe", "37dbe07ade9359c1aa70807e847f768c13360ad2");
console.log(s1);
console.log(base64encode(s1));


================================================
FILE: baidupcs/netdisksign/sign2_test.go
================================================
package netdisksign_test

import (
	"fmt"
	"github.com/felixonmars/Baidu-Login/bdcrypto"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/netdisksign"
	"testing"
)

func TestSign2(t *testing.T) {
	standard := bdcrypto.Base64Decode([]byte("8RxCbsVeSzn2UjxJAAiV9QQs/WetOj2FJUGwjsMG6SgxFMWlLS/U1Q=="))
	fmt.Println("standard,", standard)
	fmt.Printf("standard s %s\n", standard)

	res := netdisksign.Sign2([]rune("e8c7d729eea7b54551aa594f942decbe"), []rune("37dbe07ade9359c1aa70807e847f768c13360ad2"))
	fmt.Println(res)
	fmt.Printf("%s\n", string(res))
	fmt.Println([]byte(string(res)))
	fmt.Println(bdcrypto.Base64Encode([]byte(string(res))))
}



================================================
FILE: baidupcs/pcserror/dlinkerrinfo.go
================================================
[Binary file]


================================================
FILE: baidupcs/pcserror/panerrorinfo.go
================================================
package pcserror

import (
	"fmt"
)

type (
	// PanErrorInfo 网盘网页的api错误
	PanErrorInfo struct {
		Operation string
		ErrType   ErrType
		Err       error
		ErrNo     int `json:"errno"`
		// ErrMsg    string `json:"err_msg"`
	}
)

// NewPanErrorInfo 提供operation操作名称, 返回 *PanErrorInfo
func NewPanErrorInfo(operation string) *PanErrorInfo {
	return &PanErrorInfo{
		Operation: operation,
		ErrType:   ErrorTypeNoError,
	}
}

// SetJSONError 设置JSON错误
func (pane *PanErrorInfo) SetJSONError(err error) {
	pane.ErrType = ErrTypeJSONParseError
	pane.Err = err
}

// SetNetError 设置网络错误
func (pane *PanErrorInfo) SetNetError(err error) {
	pane.ErrType = ErrTypeNetError
	pane.Err = err
}

// SetRemoteError 设置远端服务器错误
func (pane *PanErrorInfo) SetRemoteError() {
	pane.ErrType = ErrTypeRemoteError
}

// GetOperation 获取操作
func (pane *PanErrorInfo) GetOperation() string {
	return pane.Operation
}

// GetErrType 获取错误类型
func (pane *PanErrorInfo) GetErrType() ErrType {
	return pane.ErrType
}

// GetRemoteErrCode 获取远端服务器错误代码
func (pane *PanErrorInfo) GetRemoteErrCode() int {
	return pane.ErrNo
}

// GetRemoteErrMsg 获取远端服务器错误消息
func (pane *PanErrorInfo) GetRemoteErrMsg() string {
	return FindPanErr(pane.ErrNo)
}

// GetError 获取原始错误
func (pane *PanErrorInfo) GetError() error {
	return pane.Err
}

func (pane *PanErrorInfo) Error() string {
	if pane.Operation == "" {
		if pane.Err != nil {
			return pane.Err.Error()
		}
		return StrSuccess
	}

	switch pane.ErrType {
	case ErrTypeInternalError:
		return fmt.Sprintf("%s: %s, %s", pane.Operation, StrInternalError, pane.Err)
	case ErrTypeJSONParseError:
		return fmt.Sprintf("%s: %s, %s", pane.Operation, StrJSONParseError, pane.Err)
	case ErrTypeNetError:
		return fmt.Sprintf("%s: %s, %s", pane.Operation, StrNetError, pane.Err)
	case ErrTypeRemoteError:
		if pane.ErrNo == 0 {
			return fmt.Sprintf("%s: %s", pane.Operation, StrSuccess)
		}

		errmsg := FindPanErr(pane.ErrNo)
		return fmt.Sprintf("%s: 遇到错误, %s, 代码: %d, 消息: %s", pane.Operation, StrRemoteError, pane.ErrNo, errmsg)
	case ErrTypeOthers:
		if pane.Err == nil {
			return fmt.Sprintf("%s: %s", pane.Operation, StrSuccess)
		}

		return fmt.Sprintf("%s, 遇到错误, %s", pane.Operation, pane.Err)
	default:
		panic("panerrorinfo: unknown ErrType")
	}
}

// FindPanErr 根据 ErrNo, 解析网盘错误信息
func FindPanErr(errno int) (errmsg string) {
	switch errno {
	case 0:
		return StrSuccess
	case -1:
		return "由于您分享了违反相关法律法规的文件，分享功能已被禁用，之前分享出去的文件不受影响。"
	case -2:
		return "用户不存在,请刷新页面后重试"
	case -3:
		return "文件不存在,请刷新页面后重试"
	case -4:
		return "登录信息有误，请重新登录试试"
	case -5:
		return "host_key和user_key无效"
	case -6:
		return "请重新登录"
	case -7:
		return "该分享已删除或已取消"
	case -8:
		return "该分享已经过期"
	case -9:
		return "文件不存在"
	case -10:
		return "分享外链已经达到最大上限100000条，不能再次分享"
	case -11:
		return "验证cookie无效"
	case -12:
		return "访问密码错误"
	case -14:
		return "对不起，短信分享每天限制20条，你今天已经分享完，请明天再来分享吧！"
	case -15:
		return "对不起，邮件分享每天限制20封，你今天已经分享完，请明天再来分享吧！"
	case -16:
		return "对不起，该文件已经限制分享！"
	case -17:
		return "文件分享超过限制"
	case -19:
		return "需要输入验证码"
	case -21:
		return "分享已取消或分享信息无效"
	case -30:
		return "文件已存在"
	case -31:
		return "文件保存失败"
	case -33:
		return "一次支持操作999个，减点试试吧"
	case -62:
		return "可能需要输入验证码"
	case -70:
		return "你分享的文件中包含病毒或疑似病毒，为了你和他人的数据安全，换个文件分享吧"
	case 2:
		return "参数错误"
	case 3:
		return "未登录或帐号无效"
	case 4:
		return "存储好像出问题了，请稍候再试"
	case 105:
		return "啊哦，链接错误没找到文件，请打开正确的分享链接"
	case 108:
		return "文件名有敏感词，优化一下吧"
	case 110:
		return "分享次数超出限制，可以到“我的分享”中查看已分享的文件链接"
	case 112:
		return "页面已过期，请刷新后重试"
	case 113:
		return "签名错误"
	case 114:
		return "当前任务不存在，保存失败"
	case 115:
		return "该文件禁止分享"
	case 132:
		return "您的帐号可能存在安全风险，为了确保为您本人操作，请先进行安全验证。"
	default:
		return "未知错误"
	}
}



================================================
FILE: baidupcs/pcserror/pcserror.go
================================================
// Package pcserror PCS错误包
package pcserror

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/jsonhelper"
	"io"
)

type (
	// ErrType 错误类型
	ErrType int

	// Error 错误信息接口
	Error interface {
		error
		SetJSONError(err error)
		SetNetError(err error)
		SetRemoteError()
		GetOperation() string
		GetErrType() ErrType
		GetRemoteErrCode() int
		GetRemoteErrMsg() string
		GetError() error
	}
)

const (
	// ErrorTypeNoError 无错误
	ErrorTypeNoError ErrType = iota
	// ErrTypeInternalError 内部错误
	ErrTypeInternalError
	// ErrTypeRemoteError 远端服务器返回错误
	ErrTypeRemoteError
	// ErrTypeNetError 网络错误
	ErrTypeNetError
	// ErrTypeJSONParseError json 数据解析失败
	ErrTypeJSONParseError
	// ErrTypeOthers 其他错误
	ErrTypeOthers
)

const (
	// StrSuccess 操作成功
	StrSuccess = "操作成功"
	// StrInternalError 内部错误
	StrInternalError = "内部错误"
	// StrRemoteError 远端服务器返回错误
	StrRemoteError = "远端服务器返回错误"
	// StrNetError 网络错误
	StrNetError = "网络错误"
	// StrJSONParseError json 数据解析失败
	StrJSONParseError = "json 数据解析失败"
)

// DecodePCSJSONError 解析PCS JSON的错误
func DecodePCSJSONError(opreation string, data io.Reader) Error {
	errInfo := NewPCSErrorInfo(opreation)
	return HandleJSONParse(opreation, data, errInfo)
}

// DecodePanJSONError 解析Pan JSON的错误
func DecodePanJSONError(opreation string, data io.Reader) Error {
	errInfo := NewPanErrorInfo(opreation)
	return HandleJSONParse(opreation, data, errInfo)
}

// HandleJSONParse 处理解析json
func HandleJSONParse(op string, data io.Reader, info interface{}) (pcsError Error) {
	var (
		err     = jsonhelper.UnmarshalData(data, info)
		errInfo = info.(Error)
	)

	if errInfo == nil {
		errInfo = NewPCSErrorInfo(op)
	}

	if err != nil {
		errInfo.SetJSONError(err)
		return errInfo
	}

	// 设置出错类型为远程错误
	if errInfo.GetRemoteErrCode() != 0 {
		errInfo.SetRemoteError()
		return errInfo
	}

	return nil
}



================================================
FILE: baidupcs/pcserror/pcserrorinfo.go
================================================
[Binary file]


================================================
FILE: cmd/AndroidNDKBuild/main.go
================================================
// AndroidNDKBuild
// go build -ldflags "-X main.APILevel=15 -X main.Arch=x86_64"
// env ANDROID_API_LEVEL NDK ANDROID_NDK_ROOT GOARCH

package main

import (
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"syscall"
)

var (
	// NDKPath path to Android NDK
	NDKPath string
	// APILevel Android api level
	APILevel string
	// Arch arch
	Arch string
)

func getNDKPath() string {
	ndkPath, ok := os.LookupEnv("NDK")
	if ok {
		return ndkPath
	}
	ndkPath, ok = os.LookupEnv("ANDROID_NDK_ROOT")
	if ok {
		return ndkPath
	}
	ndkPath, ok = os.LookupEnv("ANDROID_NDK_DIR")
	if ok {
		return ndkPath
	}
	return ""
}

func getAPILevel() string {
	apiLevelStr, ok := os.LookupEnv("ANDROID_API_LEVEL")
	if ok {
		return apiLevelStr
	}
	return "21"
}

func getGoarch() string {
	arch, ok := os.LookupEnv("GOARCH")
	if ok {
		return arch
	}

	return runtime.GOARCH
}

func getArch() string {
	if Arch != "" {
		return Arch
	}
	goarch := getGoarch()
	switch goarch {
	case "386":
		return "x86"
	case "amd64":
		return "x86_64"
	case "arm64":
		return "aarch64"
	}
	return goarch
}

func getPlatformsArch() string {
	arch := getArch()
	switch arch {
	case "aarch64":
		return "arm64"
	}
	return arch
}

func main() {
	if NDKPath == "" {
		NDKPath = getNDKPath()
	}
	if APILevel == "" {
		APILevel = getAPILevel()
	}
	if Arch == "" {
		Arch = getArch()
	}

	lastPattern := "*-gcc"
	if runtime.GOOS == "windows" {
		lastPattern += ".exe"
	}

	gccPaths, err := filepath.Glob(filepath.Join(NDKPath, "toolchains", getArch()+"-*", "prebuilt", runtime.GOOS+"-*", "bin", lastPattern))
	checkErr(err)
	if len(gccPaths) == 0 {
		panic("no match gcc")
	}

	args := make([]string, len(os.Args))
	copy(args[1:], os.Args[1:])
	args[0] = "--sysroot=" + filepath.Join(NDKPath, "platforms", "android-"+APILevel, "arch-"+getPlatformsArch())

	gccExec := exec.Command(gccPaths[0], args...)
	gccExec.Stdout = os.Stdout
	gccExec.Stderr = os.Stderr

	err = gccExec.Run()
	exitError, ok := err.(*exec.ExitError)
	if ok {
		status := exitError.ProcessState.Sys().(syscall.WaitStatus)
		os.Exit(status.ExitStatus())
	}

	if err != nil {
		println(err.Error())
	}

	return
}

func checkErr(err error) {
	if err != nil {
		panic(err)
	}
}



================================================
FILE: debian/copyright
================================================
Format-Specification: http://svn.debian.org/wsvn/dep/web/deps/dep5.mdwn?op=file&rev=135
Name: BaiduPCS-Go
Maintainer: iikira <i@mail.iikira.com>
Source: https://github.com/iikira/BaiduPCS-Go

Copyright: 2016-2019 iikira <i@mail.iikira.com>
License: Apache-2.0+
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright iikira.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.




================================================
FILE: debian/Packages.sh
================================================
dpkg-scanpackages . | gzip > Packages.gz


================================================
FILE: debian/iphoneos-arm/control
================================================
Package: BaiduPCS-Go
Version: 3.6
Homepage: https://github.com/iikira/BaiduPCS-Go
Section: 实用工具
Priority: optional
Architecture: iphoneos-arm
Installed-Size: 4096
Maintainer: iikira <i@mail.iikira.com>
Description: BaiduPCS-Go 使用Go语言编写的百度网盘命令行客户端, 为操作百度网盘, 提供实用功能.


================================================
FILE: debian/linux-amd64/control
================================================
Package: BaiduPCS-Go
Version: 3.6
Homepage: https://github.com/iikira/BaiduPCS-Go
Section: utils
Priority: optional
Architecture: amd64
Installed-Size: 4096
Maintainer: iikira <i@mail.iikira.com>
Description: BaiduPCS-Go 使用Go语言编写的百度网盘命令行客户端, 为操作百度网盘, 提供实用功能.


================================================
FILE: docs/README.md
================================================
# 文档目录

## 百度PCS文档

### 文件API

[综述](https://github.com/iikira/BaiduPCS-Go/blob/master/docs/overview.md)

[文件API列表](https://github.com/iikira/BaiduPCS-Go/blob/master/docs/file_data_apis_list.md)

[文件API错误码列表](https://github.com/iikira/BaiduPCS-Go/blob/master/docs/file_data_apis_error.md)

### 结构化数据API

[综述](https://github.com/iikira/BaiduPCS-Go/blob/master/docs/structured_data_apis_overview.md)

[结构化数据API列表](https://github.com/iikira/BaiduPCS-Go/blob/master/docs/structured_data_api_list.md)

[结构化数据API错误码](https://github.com/iikira/BaiduPCS-Go/blob/master/docs/structured_data_apis_error.md)



================================================
FILE: docs/file_data_apis_error.md
================================================
[Binary file]


================================================
FILE: docs/overview.md
================================================
# 概述

百度开放云平台为广大开发者提供了访问PCS资源的系列接口，目前开放的接口主要分两个部分：

* 文件API:

    主要提供文件上传、下载、拷贝、删除、搜索、断点续传及缩略图等功能。

* 结构化数据API:

    主要提供结构数据存储、查询、删除及同步等功能。

通过对这些API的组合调用，开发者可以实现基本的用户文件操作以及结构数据存储和管理功能，也能够支持用户数据在多种不同终端上的同步，以提供更优质的用户体验。

除了原生的REST（Representational State Transfer，即“表述性状态转移”） API之外，百度开放云平台还提供了多种平台的SDK来帮助开发者缩短开发周期，具体请参考“SDK”部分相关内容。

## PCS REST API使用说明

### 开通PCS API权限

PCS所有REST API都必须经过开通权限才能正常使用。申请的方法请参考“开通PCS API权限”部分相关内容。

注意：PCS未提供分享接口，download等接口仅供个人获取数据使用。 access_token不能泄露，否则会直接封禁应用。

### API请求方式说明

目前所有的提交类接口仅支持POST方式，查询类接口同时支持POST方式和GET方式。

PCS REST API的所有参数在传入时应当使用：UTF-8编码。

#### HTTP 请求方式

    GET | POST

#### URL

    https://pcs.baidu.com/rest/2.0/pcs/{object_name}?{query_string}

#### 参数说明

| 参数名称 | 描述 |
| :- | :- |
| object_name | PCS REST API操作实体名称，如：quota、file、thumbnail。 |
| query_string | 放在HTTP头部传入的参数，必须经过UrlEncode编码。 |

#### HTTP GET和POST方式使用说明

<table width="600" border="1" cellpadding="1" cellspacing="1">
    <tbody>
        <tr>
            <th scope="row" width="80">请求方式
            </th>
            <th scope="col">GET
            </th>
            <th scope="col">POST
            </th>
        </tr>
        <tr>
            <th scope="row">URL
            </th>
            <td colspan="2">https://pcs.baidu.com/rest/2.0/pcs/{object_name}?{query_string}
            </td>
        </tr>
        <tr>
            <th scope="row">请求参数
            </th>
            <td> 全部携带在 HTTPS 请求头部的 query_string 中。
            </td>
            <td> 既可携带在 query_string 中，也可携带在 HTTP Body 中。
                <dl>
                    <dd>
                        <ul>
                            <li> method 及 access token 等参数必须携带在 query_string 中进行传输，请参考各个API的具体说明；
                            </li>
                            <li> 携带在 query_string 中的参数的值，必须进行 UrlEncode 编码；
                            </li>
                            <li> 携带在 HTTP Body 中的参数，则不需要进行 UrlEncode 编码。
                            </li>
                        </ul>
                    </dd>
                </dl>
                <div style="border:solid 1px #d7d7d7;padding:10px 16px 2px 16px; background-color:#fbfafb;">
                    <div>注</div>
                    HTTP URL 长度有限，若参数值长度过长，建议将参数放在 HTTP Body 中进行传输。</div>
            </td>
        </tr>
        <tr>
            <th scope="row"> HTTP BODY
            </th>
            <td> 不携带HTTP Body
            </td>
            <td> multipart/form-data
            </td>
        </tr>
        <tr>
            <th scope="row">注意
            </th>
            <td colspan="2">如果 HTTP Body 和 query_string 存在相同的参数，则以 query_string 中的参数为准。
            </td>
        </tr>
    </tbody>
</table>

#### 使用示例

1. GET请求：

    用HTTP GET请求方式发送两个参数：key1=value1和key2=value2。

    https://pcs.baidu.com/rest/2.0/pcs/quota?key1=UrlEncode(value1)&key2=UrlEncode(value2)

2. POST请求：

    分别用两种方式使用POST方式发送三个参数：key1=value1、key2=value2和key3=value3；方式一与方式二效果等同。

##### 方式一：

    POST /rest/2.0/pcs/quota?key2=value2&key3=value3 HTTP/1.1

    User-Agent: curl/7.12.1 (x86_64-redhat-linux-gnu) libcurl/7.12.1 OpenSSL/0.9.7a zlib/1.2.1.2 libidn/0.5.6
    Pragma: no-cache
    Accept: */*
    Host:pcs.baidu.com
    Content-Length:123
    Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryS0JIa4uHF7yHd8xJ
    ------WebKitFormBoundaryS0JIa4uHF7yHd8xJ
    Content-Disposition: form-data; name="key1"
    value1
    ------WebKitFormBoundaryS0JIa4uHF7yHd8xJ—

##### 方式二：

    POST /rest/2.0/pcs/quota HTTP/1.1
    User-Agent: curl/7.12.1 (x86_64-redhat-linux-gnu) libcurl/7.12.1 OpenSSL/0.9.7a zlib/1.2.1.2 libidn/0.5.6
    Pragma: no-cache
    Accept: */*
    Host:pcs.baidu.com
    Content-Length:123
    Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryS0JIa4uHF7yHd8xJ
    ------WebKitFormBoundaryS0JIa4uHF7yHd8xJ
    Content-Disposition: form-data; name="key1"

    value1
    ------WebKitFormBoundaryS0JIa4uHF7yHd8xJ
    Content-Disposition: form-data; name="key2"

    value2
    ------WebKitFormBoundaryS0JIa4uHF7yHd8xJ
    Content-Disposition: form-data; name="key3"

    value3
    ------WebKitFormBoundaryS0JIa4uHF7yHd8xJ--

### API响应格式说明

<table>
    <tbody>
        <tr>
            <th scope="col">
            </th>
            <th scope="col">正常请求
            </th>
            <th scope="col">异常请求
            </th>
        </tr>
        <tr>
            <th scope="row">HTTP状态码
            </th>
            <td> 200 OK
            </td>
            <td> 4**&nbsp;: 用户请求错误。<br>5** ：server服务失败。
            </td>
        </tr>
        <tr>
            <th scope="row">HTTP BODY
            </th>
            <td> API响应内容
            </td>
            <td> 异常请求的返回值为JSON字符串。<br>例如：<br>{<br>"error_code":110,<br>"error_msg":"Access token invalid or no longer valid",<br>"request_id":729562373<br>}<br>说明：<br>
                <dl>
                    <dd>- error_code：错误码；<br>
                    </dd>
                    <dd>- error_msg: 错误描述信息；<br>
                    </dd>
                    <dd>- request_id: 请求ID。由server生成，用于追查和定位请求日志。<br>
                    </dd>
                </dl>
            </td>
        </tr>
    </tbody>
</table>



================================================
FILE: docs/structured_data_apis_error.md
================================================
[Binary file]


================================================
FILE: docs/structured_data_apis_overview.md
================================================
[Binary file]


================================================
FILE: internal/pcscommand/cd.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
)

// RunChangeDirectory 执行更改工作目录
func RunChangeDirectory(targetPath string, isList bool) {
	pcs := GetBaiduPCS()
	err := matchPathByShellPatternOnce(&targetPath)
	if err != nil {
		fmt.Println(err)
		return
	}

	data, err := pcs.FilesDirectoriesMeta(targetPath)
	if err != nil {
		fmt.Println(err)
		return
	}

	if !data.Isdir {
		fmt.Printf("错误: %s 不是一个目录 (文件夹)\n", targetPath)
		return
	}

	GetActiveUser().Workdir = targetPath
	pcsconfig.Config.Save()

	fmt.Printf("改变工作目录: %s\n", targetPath)

	if isList {
		RunLs(".", nil, baidupcs.DefaultOrderOptions)
	}
}



================================================
FILE: internal/pcscommand/cloud_dl.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
)

// RunCloudDlAddTask 执行添加离线下载任务
func RunCloudDlAddTask(sourceURLs []string, savePath string) {
	var (
		err error
		pcs = GetBaiduPCS()
	)
	err = matchPathByShellPatternOnce(&savePath)
	if err != nil {
		fmt.Println(err)
		return
	}

	var taskid int64
	for k := range sourceURLs {
		taskid, err = pcs.CloudDlAddTask(sourceURLs[k], savePath+baidupcs.PathSeparator)
		if err != nil {
			fmt.Printf("[%d] %s, 地址: %s\n", k+1, err, sourceURLs[k])
			continue
		}

		fmt.Printf("[%d] 添加离线任务成功, 任务ID(task_id): %d, 源地址: %s, 保存路径: %s\n", k+1, taskid, sourceURLs[k], savePath)
	}
}

// RunCloudDlQueryTask 精确查询离线下载任务
func RunCloudDlQueryTask(taskIDs []int64) {
	cl, err := GetBaiduPCS().CloudDlQueryTask(taskIDs)
	if err != nil {
		fmt.Printf("%s\n", err)
		return
	}

	fmt.Println(cl)
}

// RunCloudDlListTask 查询离线下载任务列表
func RunCloudDlListTask() {
	cl, err := GetBaiduPCS().CloudDlListTask()
	if err != nil {
		fmt.Printf("%s\n", err)
		return
	}

	fmt.Println(cl)
}

// RunCloudDlCancelTask 取消离线下载任务
func RunCloudDlCancelTask(taskIDs []int64) {
	for _, id := range taskIDs {
		err := GetBaiduPCS().CloudDlCancelTask(id)
		if err != nil {
			fmt.Printf("[%d] %s\n", id, err)
			continue
		}

		fmt.Printf("[%d] 取消成功\n", id)
	}
}

// RunCloudDlDeleteTask 删除离线下载任务
func RunCloudDlDeleteTask(taskIDs []int64) {
	for _, id := range taskIDs {
		err := GetBaiduPCS().CloudDlDeleteTask(id)
		if err != nil {
			fmt.Printf("[%d] %s\n", id, err)
			continue
		}

		fmt.Printf("[%d] 删除成功\n", id)
	}
}

// RunCloudDlClearTask 清空离线下载任务记录
func RunCloudDlClearTask() {
	total, err := GetBaiduPCS().CloudDlClearTask()
	if err != nil {
		fmt.Printf("%s\n", err)
		return
	}

	fmt.Printf("%s成功, 共清除 %d 条记录\n", baidupcs.OperationCloudDlClearTask, total)
	return
}



================================================
FILE: internal/pcscommand/cp_mv.go
================================================
[Binary file]


================================================
FILE: internal/pcscommand/download.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsfunctions/pcsdownload"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/taskframework"
	"github.com/felixonmars/BaiduPCS-Go/requester/downloader"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"os"
	"path/filepath"
	"runtime"
)

type (
	//DownloadOptions 下载可选参数
	DownloadOptions struct {
		IsTest               bool
		IsPrintStatus        bool
		IsExecutedPermission bool
		IsOverwrite          bool
		DownloadMode         pcsdownload.DownloadMode
		SaveTo               string
		Parallel             int
		Load                 int
		MaxRetry             int
		NoCheck              bool
	}

	// LocateDownloadOption 获取下载链接可选参数
	LocateDownloadOption struct {
		FromPan bool
	}
)

func downloadPrintFormat(load int) string {
	if load <= 1 {
		return pcsdownload.DefaultPrintFormat
	}
	return "[%d] ↓ %s/%s %s/s in %s, left %s ...\n"
}

// RunDownload 执行下载网盘内文件
func RunDownload(paths []string, options *DownloadOptions) {
	if options == nil {
		options = &DownloadOptions{}
	}

	if options.Load <= 0 {
		options.Load = pcsconfig.Config.MaxDownloadLoad
	}

	if options.MaxRetry < 0 {
		options.MaxRetry = pcsdownload.DefaultDownloadMaxRetry
	}

	if runtime.GOOS == "windows" {
		// windows下不加执行权限
		options.IsExecutedPermission = false
	}

	// 设置下载配置
	cfg := &downloader.Config{
		Mode:                       transfer.RangeGenMode_BlockSize,
		CacheSize:                  pcsconfig.Config.CacheSize,
		BlockSize:                  baidupcs.MaxDownloadRangeSize,
		MaxRate:                    pcsconfig.Config.MaxDownloadRate,
		InstanceStateStorageFormat: downloader.InstanceStateStorageFormatProto3,
		IsTest:                     options.IsTest,
		TryHTTP:                    !pcsconfig.Config.EnableHTTPS,
	}

	// 设置下载最大并发量
	if options.Parallel < 1 {
		options.Parallel = pcsconfig.Config.MaxParallel
	}

	paths, err := matchPathByShellPattern(paths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Print("\n")
	fmt.Printf("[0] 提示: 当前下载最大并发量为: %d, 下载缓存为: %d\n", options.Parallel, cfg.CacheSize)

	var (
		pcs       = GetBaiduPCS()
		loadCount = 0
	)

	// 预测要下载的文件数量
	// TODO: pcscache
	for k := range paths {
		pcs.FilesDirectoriesRecurseList(paths[k], baidupcs.DefaultOrderOptions, func(depth int, _ string, fd *baidupcs.FileDirectory, pcsError pcserror.Error) bool {
			if pcsError != nil {
				pcsCommandVerbose.Warnf("%s\n", pcsError)
				return true
			}

			// 忽略统计文件夹数量
			if !fd.Isdir {
				loadCount++
				if loadCount >= options.Load {
					return false
				}
			}
			return true
		})

		if loadCount >= options.Load {
			break
		}
	}

	// 修改Load, 设置MaxParallel
	if loadCount > 0 {
		options.Load = loadCount
		// 取平均值
		cfg.MaxParallel = pcsconfig.AverageParallel(options.Parallel, loadCount)
	} else {
		cfg.MaxParallel = options.Parallel
	}

	var (
		executor = taskframework.TaskExecutor{
			IsFailedDeque: true, // 统计失败的列表
		}
		statistic = &pcsdownload.DownloadStatistic{}
	)
	// 处理队列
	for k := range paths {
		newCfg := *cfg
		unit := pcsdownload.DownloadTaskUnit{
			Cfg:                  &newCfg, // 复制一份新的cfg
			PCS:                  pcs,
			VerbosePrinter:       pcsCommandVerbose,
			PrintFormat:          downloadPrintFormat(options.Load),
			ParentTaskExecutor:   &executor,
			DownloadStatistic:    statistic,
			IsPrintStatus:        options.IsPrintStatus,
			IsExecutedPermission: options.IsExecutedPermission,
			IsOverwrite:          options.IsOverwrite,
			NoCheck:              options.NoCheck,
			DownloadMode:         options.DownloadMode,
			PcsPath:              paths[k],
		}

		// 设置储存的路径
		if options.SaveTo != "" {
			unit.SavePath = filepath.Join(options.SaveTo, filepath.Base(paths[k]))
		} else {
			// 使用默认的保存路径
			unit.SavePath = GetActiveUser().GetSavePath(paths[k])
		}
		info := executor.Append(&unit, options.MaxRetry)
		fmt.Printf("[%s] 加入下载队列: %s\n", info.Id(), paths[k])
	}

	// 开始计时
	statistic.StartTimer()

	// 开始执行
	executor.Execute()

	fmt.Printf("\n下载结束, 时间: %s, 数据总量: %s\n", statistic.Elapsed()/1e6*1e6, converter.ConvertFileSize(statistic.TotalSize()))

	// 输出失败的文件列表
	failedList := executor.FailedDeque()
	if failedList.Size() != 0 {
		fmt.Printf("以下文件下载失败: \n")
		tb := pcstable.NewTable(os.Stdout)
		for e := failedList.Shift(); e != nil; e = failedList.Shift() {
			item := e.(*taskframework.TaskInfoItem)
			tb.Append([]string{item.Info.Id(), item.Unit.(*pcsdownload.DownloadTaskUnit).PcsPath})
		}
		tb.Render()
	}
}



================================================
FILE: internal/pcscommand/export.go
================================================
package pcscommand

import (
	"container/list"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/pcstime"
	"os"
	"path"
	"strings"
	"time"
)

type (
	etask struct {
		*ListTask
		path     string
		rootPath string
		fd       *baidupcs.FileDirectory
		err      pcserror.Error
	}

	// ExportOptions 导出可选项
	ExportOptions struct {
		RootPath  string // 根路径
		SavePath  string // 输出路径
		MaxRetry  int
		Recursive bool
	}
)

func (task *etask) handleExportTaskError(l *list.List, failedList *list.List) {
	if task.err == nil {
		return
	}

	// 不重试
	switch task.err.GetError() {
	case baidupcs.ErrGetRapidUploadInfoMD5NotFound, baidupcs.ErrGetRapidUploadInfoCrc32NotFound:
		fmt.Printf("[%d] - [%s] 导出失败, 可能是服务器未刷新文件的md5, 请过一段时间再试一试\n", task.ID, task.path)
		failedList.PushBack(task)
		return
	case baidupcs.ErrFileTooLarge:
		fmt.Printf("[%d] - [%s] 导出失败, 文件大于20GB, 无法导出\n", task.ID, task.path)
		failedList.PushBack(task)
		return
	}

	// 未达到失败重试最大次数, 将任务推送到队列末尾
	if task.retry < task.MaxRetry {
		task.retry++
		fmt.Printf("[%d] - [%s] 导出错误, %s, 重试 %d/%d\n", task.ID, task.path, task.err, task.retry, task.MaxRetry)
		l.PushBack(task)
		time.Sleep(3 * time.Duration(task.retry) * time.Second)
	} else {
		fmt.Printf("[%d] - [%s] 导出错误, %s\n", task.ID, task.path, task.err)
		failedList.PushBack(task)
	}
}

func changeRootPath(dstRootPath, dstPath, srcRootPath string) string {
	if srcRootPath == "" {
		return dstPath
	}
	return path.Join(srcRootPath, strings.TrimPrefix(dstPath, dstRootPath))
}

// GetExportFilename 获取导出路径
func GetExportFilename() string {
	return "BaiduPCS-Go_export_" + pcstime.BeijingTimeOption("") + ".txt"
}

// RunExport 执行导出文件和目录
func RunExport(pcspaths []string, opt *ExportOptions) {
	if opt == nil {
		opt = &ExportOptions{}
	}

	if opt.SavePath == "" {
		opt.SavePath = GetExportFilename()
	}

	pcspaths, err := matchPathByShellPattern(pcspaths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	saveFile, err := os.OpenFile(opt.SavePath, os.O_CREATE|os.O_RDWR|os.O_APPEND, 0644)
	if err != nil { // 不可写
		fmt.Printf("%s\n", err)
		return
	}
	defer saveFile.Close()
	fmt.Printf("导出的信息将保存在: %s\n", opt.SavePath)

	var (
		au         = GetActiveUser()
		pcs        = GetBaiduPCS()
		l          = list.New()
		failedList = list.New()
		writeErr   error
		id         int
	)

	for id = range pcspaths {
		var rootPath string
		if pcspaths[id] == au.Workdir {
			rootPath = pcspaths[id]
		} else {
			rootPath = path.Dir(pcspaths[id])
		}
		// 加入队列
		l.PushBack(&etask{
			ListTask: &ListTask{
				ID:       id,
				MaxRetry: opt.MaxRetry,
			},
			path:     pcspaths[id],
			rootPath: rootPath,
		})
	}

	for {
		e := l.Front()
		if e == nil { // 结束
			break
		}

		l.Remove(e) // 载入任务后, 移除队列

		task := e.Value.(*etask)
		root := task.fd == nil

		// 获取文件信息
		if task.fd == nil { // 第一次初始化
			fd, pcsError := pcs.FilesDirectoriesMeta(task.path)
			if pcsError != nil {
				task.err = pcsError
				task.handleExportTaskError(l, failedList)
				continue
			}
			task.fd = fd
		}

		if task.fd.Isdir { // 导出目录
			if !root && !opt.Recursive { // 非递归
				continue
			}

			fds, pcsError := pcs.FilesDirectoriesList(task.path, baidupcs.DefaultOrderOptions)
			if pcsError != nil {
				task.err = pcsError
				task.handleExportTaskError(l, failedList)
				continue
			}

			if len(fds) == 0 {
				_, writeErr = saveFile.Write(converter.ToBytes(fmt.Sprintf("BaiduPCS-Go mkdir \"%s\"\n", changeRootPath(task.rootPath, task.path, opt.RootPath))))
				if writeErr != nil {
					fmt.Printf("写入文件失败: %s\n", writeErr)
					return // 直接返回
				}
				fmt.Printf("[%d] - [%s] 导出成功\n", task.ID, task.path)
				continue
			}

			// 加入队列
			for _, fd := range fds {
				// 加入队列
				id++
				l.PushBack(&etask{
					ListTask: &ListTask{
						ID:       id,
						MaxRetry: opt.MaxRetry,
					},
					path:     fd.Path,
					fd:       fd,
					rootPath: task.rootPath,
				})
			}
			continue
		}

		rinfo, pcsError := pcs.ExportByFileInfo(task.fd)
		if pcsError != nil {
			task.err = pcsError
			task.handleExportTaskError(l, failedList)
			continue
		}

		_, writeErr = saveFile.Write(converter.ToBytes(fmt.Sprintf("BaiduPCS-Go rapidupload -length=%d -md5=%s -slicemd5=%s -crc32=%s \"%s\"\n", rinfo.ContentLength, rinfo.ContentMD5, rinfo.SliceMD5, rinfo.ContentCrc32, changeRootPath(task.rootPath, task.path, opt.RootPath))))
		if writeErr != nil {
			fmt.Printf("写入文件失败: %s\n", writeErr)
			return // 直接返回
		}

		fmt.Printf("[%d] - [%s] 导出成功\n", task.ID, task.path)
	}

	if failedList.Len() > 0 {
		fmt.Printf("\n以下目录导出失败: \n")
		fmt.Printf("%s\n", strings.Repeat("-", 100))
		for e := failedList.Front(); e != nil; e = e.Next() {
			et := e.Value.(*etask)
			fmt.Printf("[%d] %s\n", et.ID, et.path)
		}
	}
}



================================================
FILE: internal/pcscommand/fixmd5.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
)

// RunFixMD5 执行修复md5
func RunFixMD5(pcspaths ...string) {
	absPaths, err := matchPathByShellPattern(pcspaths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	pcs := GetBaiduPCS()
	finfoList, err := pcs.FilesDirectoriesBatchMeta(absPaths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	for k, finfo := range finfoList {
		err := pcs.FixMD5ByFileInfo(finfo)
		if err == nil {
			fmt.Printf("[%d] - [%s] 修复md5成功\n", k, finfo.Path)
			continue
		}

		if err.GetError() == baidupcs.ErrFixMD5Failed {
			fmt.Printf("[%d] - [%s] 修复md5失败, 可能是服务器未刷新\n", k, finfo.Path)
			continue
		}
		fmt.Printf("[%d] - [%s] 修复md5失败, 错误信息: %s\n", k, finfo.Path, err)
	}
}



================================================
FILE: internal/pcscommand/locatedonwload.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"os"
	"strconv"
)

// RunLocateDownload 执行获取直链
func RunLocateDownload(pcspaths []string, opt *LocateDownloadOption) {
	if opt == nil {
		opt = &LocateDownloadOption{}
	}

	absPaths, err := matchPathByShellPattern(pcspaths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	pcs := GetBaiduPCS()

	if opt.FromPan {
		fds, err := pcs.FilesDirectoriesBatchMeta(absPaths...)
		if err != nil {
			fmt.Printf("%s\n", err)
			return
		}

		fidList := make([]int64, 0, len(fds))
		for i := range fds {
			fidList = append(fidList, fds[i].FsID)
		}

		list, err := pcs.LocatePanAPIDownload(fidList...)
		if err != nil {
			fmt.Printf("%s\n", err)
			return
		}

		tb := pcstable.NewTable(os.Stdout)
		tb.SetHeader([]string{"#", "fs_id", "路径", "链接"})

		var (
			i          int
			fidStrList = converter.SliceInt64ToString(fidList)
		)
		for k := range fidStrList {
			for i = range list {
				if fidStrList[k] == list[i].FsID {
					tb.Append([]string{strconv.Itoa(k), list[i].FsID, fds[k].Path, list[i].Dlink})
					list = append(list[:i], list[i+1:]...)
					break
				}
			}
		}
		tb.Render()
		fmt.Printf("\n注意: 以上链接不能直接访问, 需要登录百度帐号才可以下载\n")
		return
	}

	for i, pcspath := range absPaths {
		info, err := pcs.LocateDownload(pcspath)
		if err != nil {
			fmt.Printf("[%d] %s, 路径: %s\n", i, err, pcspath)
			continue
		}

		fmt.Printf("[%d] %s: \n", i, pcspath)
		tb := pcstable.NewTable(os.Stdout)
		tb.SetHeader([]string{"#", "链接"})
		for k, u := range info.URLStrings(pcsconfig.Config.EnableHTTPS) {
			tb.Append([]string{strconv.Itoa(k), u.String()})
		}
		tb.Render()
		fmt.Println()
	}
	fmt.Printf("提示: 访问下载链接, 需将下载器的 User-Agent 设置为: %s\n", pcsconfig.Config.PanUA)
}



================================================
FILE: internal/pcscommand/login.go
================================================
package pcscommand

import (
	"bytes"
	"fmt"
	"github.com/felixonmars/Baidu-Login"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsfunctions/pcscaptcha"
	"github.com/felixonmars/BaiduPCS-Go/pcsliner"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"image/png"
	"io/ioutil"
)

// handleVerifyImg 处理验证码, 下载到本地
func handleVerifyImg(imgURL string) (savePath string, err error) {
	imgContents, err := requester.Fetch("GET", imgURL, nil, nil)
	if err != nil {
		return "", fmt.Errorf("获取验证码失败, 错误: %s", err)
	}

	_, err = png.Decode(bytes.NewReader(imgContents))
	if err != nil {
		return "", fmt.Errorf("验证码解析错误: %s", err)
	}

	savePath = pcscaptcha.CaptchaPath()

	return savePath, ioutil.WriteFile(savePath, imgContents, 0777)
}

// RunLogin 登录百度帐号
func RunLogin(username, password string) (bduss, ptoken, stoken string, err error) {
	line := pcsliner.NewLiner()
	defer line.Close()

	bc := baidulogin.NewBaiduClinet()

	if username == "" {
		username, err = line.State.Prompt("请输入百度用户名(手机号/邮箱/用户名), 回车键提交 > ")
		if err != nil {
			return
		}
	}

	if password == "" {
		// liner 的 PasswordPrompt 不安全, 拆行之后密码就会显示出来了
		fmt.Printf("请输入密码(输入的密码无回显, 确认输入完成, 回车提交即可) > ")
		password, err = line.State.PasswordPrompt("")
		if err != nil {
			return
		}
	}

	var vcode, vcodestr string
	// 移除验证码文件
	defer func() {
		pcscaptcha.RemoveCaptchaPath()
		pcscaptcha.RemoveOldCaptchaPath()
	}()

for_1:
	for i := 0; i < 10; i++ {
		lj := bc.BaiduLogin(username, password, vcode, vcodestr)

		switch lj.ErrInfo.No {
		case "0": // 登录成功, 退出循环
			return lj.Data.BDUSS, lj.Data.PToken, lj.Data.SToken, nil
		case "400023", "400101": // 需要验证手机或邮箱
			fmt.Printf("\n需要验证手机或邮箱才能登录\n选择一种验证方式\n")
			fmt.Printf("1: 手机: %s\n", lj.Data.Phone)
			fmt.Printf("2: 邮箱: %s\n", lj.Data.Email)
			fmt.Printf("\n")

			var verifyType string
			for et := 0; et < 3; et++ {
				verifyType, err = line.State.Prompt("请输入验证方式 (1 或 2) > ")
				if err != nil {
					return
				}

				switch verifyType {
				case "1":
					verifyType = "mobile"
				case "2":
					verifyType = "email"
				default:
					fmt.Printf("[%d/3] 验证方式不合法\n", et+1)
					continue
				}
				break
			}
			if verifyType != "mobile" && verifyType != "email" {
				err = fmt.Errorf("验证方式不合法")
				return
			}

			msg := bc.SendCodeToUser(verifyType, lj.Data.Token) // 发送验证码
			fmt.Printf("消息: %s\n\n", msg)

			for et := 0; et < 5; et++ {
				vcode, err = line.State.Prompt("请输入接收到的验证码 > ")
				if err != nil {
					return
				}

				nlj := bc.VerifyCode(verifyType, lj.Data.Token, vcode, lj.Data.U)
				if nlj.ErrInfo.No != "0" {
					fmt.Printf("[%d/5] 错误消息: %s\n\n", et+1, nlj.ErrInfo.Msg)
					continue
				}
				// 登录成功
				return nlj.Data.BDUSS, nlj.Data.PToken, nlj.Data.SToken, nil
			}
			break for_1
		case "500001", "500002": // 验证码
			fmt.Printf("\n%s\n", lj.ErrInfo.Msg)
			vcodestr = lj.Data.CodeString
			if vcodestr == "" {
				err = fmt.Errorf("未找到codeString")
				return
			}

			// 图片验证码
			var (
				verifyImgURL = "https://wappass.baidu.com/cgi-bin/genimage?" + vcodestr
				savePath     string
			)

			savePath, err = handleVerifyImg(verifyImgURL)
			if err != nil {
				fmt.Println(err)
			} else {
				fmt.Printf("打开以下路径, 以查看验证码\n%s\n\n", savePath)
			}

			fmt.Printf("或者打开以下的网址, 以查看验证码\n")
			fmt.Printf("%s\n\n", verifyImgURL)

			vcode, err = line.State.Prompt("请输入验证码 > ")
			if err != nil {
				return
			}
			continue
		default:
			err = fmt.Errorf("错误代码: %s, 消息: %s", lj.ErrInfo.No, lj.ErrInfo.Msg)
			return
		}
	}
	return
}



================================================
FILE: internal/pcscommand/ls_search.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/pcstime"
	"github.com/olekukonko/tablewriter"
	"os"
	"strconv"
)

type (
	// LsOptions 列目录可选项
	LsOptions struct {
		Total bool
	}

	// SearchOptions 搜索可选项
	SearchOptions struct {
		Total   bool
		Recurse bool
	}
)

const (
	opLs int = iota
	opSearch
)

// RunLs 执行列目录
func RunLs(pcspath string, lsOptions *LsOptions, orderOptions *baidupcs.OrderOptions) {
	err := matchPathByShellPatternOnce(&pcspath)
	if err != nil {
		fmt.Println(err)
		return
	}

	files, err := GetBaiduPCS().FilesDirectoriesList(pcspath, orderOptions)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Printf("\n当前目录: %s\n----\n", pcspath)

	if lsOptions == nil {
		lsOptions = &LsOptions{}
	}

	renderTable(opLs, lsOptions.Total, pcspath, files)
	return
}

// RunSearch 执行搜索
func RunSearch(targetPath, keyword string, opt *SearchOptions) {
	err := matchPathByShellPatternOnce(&targetPath)
	if err != nil {
		fmt.Println(err)
		return
	}

	if opt == nil {
		opt = &SearchOptions{}
	}

	files, err := GetBaiduPCS().Search(targetPath, keyword, opt.Recurse)
	if err != nil {
		fmt.Println(err)
		return
	}

	renderTable(opSearch, opt.Total, targetPath, files)
	return
}

func renderTable(op int, isTotal bool, path string, files baidupcs.FileDirectoryList) {
	tb := pcstable.NewTable(os.Stdout)
	var (
		fN, dN   int64
		showPath string
	)

	switch op {
	case opLs:
		showPath = "文件(目录)"
	case opSearch:
		showPath = "路径"
	}

	if isTotal {
		tb.SetHeader([]string{"#", "fs_id", "app_id", "文件大小", "创建日期", "修改日期", "md5(截图请打码)", showPath})
		tb.SetColumnAlignment([]int{tablewriter.ALIGN_DEFAULT, tablewriter.ALIGN_RIGHT, tablewriter.ALIGN_RIGHT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT})
		for k, file := range files {
			if file.Isdir {
				tb.Append([]string{strconv.Itoa(k), strconv.FormatInt(file.FsID, 10), strconv.FormatInt(file.AppID, 10), "-", pcstime.FormatTime(file.Ctime), pcstime.FormatTime(file.Mtime), file.MD5, file.Filename + baidupcs.PathSeparator})
				continue
			}

			var md5 string
			if len(file.BlockList) > 1 {
				md5 = "(可能不正确)" + file.MD5
			} else {
				md5 = file.MD5
			}

			switch op {
			case opLs:
				tb.Append([]string{strconv.Itoa(k), strconv.FormatInt(file.FsID, 10), strconv.FormatInt(file.AppID, 10), converter.ConvertFileSize(file.Size, 2), pcstime.FormatTime(file.Ctime), pcstime.FormatTime(file.Mtime), md5, file.Filename})
			case opSearch:
				tb.Append([]string{strconv.Itoa(k), strconv.FormatInt(file.FsID, 10), strconv.FormatInt(file.AppID, 10), converter.ConvertFileSize(file.Size, 2), pcstime.FormatTime(file.Ctime), pcstime.FormatTime(file.Mtime), md5, file.Path})
			}
		}
		fN, dN = files.Count()
		tb.Append([]string{"", "", "总: " + converter.ConvertFileSize(files.TotalSize(), 2), "", "", "", fmt.Sprintf("文件总数: %d, 目录总数: %d", fN, dN)})
	} else {
		tb.SetHeader([]string{"#", "文件大小", "修改日期", showPath})
		tb.SetColumnAlignment([]int{tablewriter.ALIGN_DEFAULT, tablewriter.ALIGN_RIGHT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT})
		for k, file := range files {
			if file.Isdir {
				tb.Append([]string{strconv.Itoa(k), "-", pcstime.FormatTime(file.Mtime), file.Filename + baidupcs.PathSeparator})
				continue
			}

			switch op {
			case opLs:
				tb.Append([]string{strconv.Itoa(k), converter.ConvertFileSize(file.Size, 2), pcstime.FormatTime(file.Mtime), file.Filename})
			case opSearch:
				tb.Append([]string{strconv.Itoa(k), converter.ConvertFileSize(file.Size, 2), pcstime.FormatTime(file.Mtime), file.Path})
			}
		}
		fN, dN = files.Count()
		tb.Append([]string{"", "总: " + converter.ConvertFileSize(files.TotalSize(), 2), "", fmt.Sprintf("文件总数: %d, 目录总数: %d", fN, dN)})
	}

	tb.Render()

	if fN+dN >= 50 {
		fmt.Printf("\n当前目录: %s\n", path)
	}

	fmt.Printf("----\n")
}



================================================
FILE: internal/pcscommand/meta.go
================================================
package pcscommand

import (
	"fmt"
)

// RunGetMeta 执行 获取文件/目录的元信息
func RunGetMeta(targetPaths ...string) {
	targetPaths, err := matchPathByShellPattern(targetPaths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	for k, targetPath := range targetPaths {
		fmt.Printf("[%d] - [%s] --------------\n", k, targetPath)
		data, err := GetBaiduPCS().FilesDirectoriesMeta(targetPath)
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Println()
		fmt.Println(data)
	}
}



================================================
FILE: internal/pcscommand/pcscommand.go
================================================
// Package pcscommand 命令包
package pcscommand

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
)

var (
	pcsCommandVerbose = pcsverbose.New("PCSCOMMAND")
)

// GetActiveUser 获取当前登录的百度帐号
func GetActiveUser() *pcsconfig.Baidu {
	return pcsconfig.Config.ActiveUser()
}

// GetBaiduPCS 从配置读取BaiduPCS
func GetBaiduPCS() *baidupcs.BaiduPCS {
	return pcsconfig.Config.ActiveUserBaiduPCS()
}



================================================
FILE: internal/pcscommand/quota.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
)

// RunGetQuota 执行 获取当前用户空间配额信息, 并输出
func RunGetQuota() {
	quota, used, err := GetBaiduPCS().QuotaInfo()
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("用户名: %s, 总空间: %s, 已用空间: %s, 比率: %f%%\n",
		GetActiveUser().Name,
		converter.ConvertFileSize(quota),
		converter.ConvertFileSize(used),
		100*float64(used)/float64(quota),
	)
}



================================================
FILE: internal/pcscommand/recycle.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/pcstime"
	"github.com/olekukonko/tablewriter"
	"os"
	"strconv"
)

// RunRecycleList 执行列出回收站文件列表
func RunRecycleList(page int) {
	if page < 1 {
		page = 1
	}

	pcs := GetBaiduPCS()
	fdl, err := pcs.RecycleList(page)
	if err != nil {
		fmt.Println(err)
		return
	}

	tb := pcstable.NewTable(os.Stdout)
	tb.SetHeader([]string{"#", "fs_id", "文件大小", "创建日期", "修改日期", "md5(截图请打码)", "剩余时间", "路径"})
	tb.SetColumnAlignment([]int{tablewriter.ALIGN_DEFAULT, tablewriter.ALIGN_RIGHT, tablewriter.ALIGN_RIGHT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_DEFAULT, tablewriter.ALIGN_LEFT})
	for k, file := range fdl {
		if file.Isdir == 1 {
			tb.Append([]string{strconv.Itoa(k), strconv.FormatInt(file.FsID, 10), "-", pcstime.FormatTime(file.Ctime), pcstime.FormatTime(file.Mtime), file.MD5, strconv.Itoa(file.LeftTime), file.Path + baidupcs.PathSeparator})
			continue
		}
		tb.Append([]string{strconv.Itoa(k), strconv.FormatInt(file.FsID, 10), converter.ConvertFileSize(file.Size, 2), pcstime.FormatTime(file.Ctime), pcstime.FormatTime(file.Mtime), file.MD5, strconv.Itoa(file.LeftTime), file.Path})
	}

	tb.Render()
}

// RunRecycleRestore 执行还原回收站文件或目录
func RunRecycleRestore(fidStrList ...string) {
	var (
		fidList = converter.SliceStringToInt64(fidStrList)
		pcs     = GetBaiduPCS()
		ex, err = pcs.RecycleRestore(fidList...)
	)
	if err != nil {
		fmt.Println(err)
		if len(ex) > 0 {
			fmt.Printf("\n以下的 fs_id 还原成功, 数量: %d\n", len(ex))
			for k := range ex {
				fmt.Println(ex[k].FsID)
			}
		}
		return
	}

	fmt.Printf("还原成功, 数量: %d\n", len(ex))
}

// RunRecycleDelete 执行删除回收站文件或目录
func RunRecycleDelete(fidStrList ...string) {
	var (
		fidList = converter.SliceStringToInt64(fidStrList)
		pcs     = GetBaiduPCS()
		err     = pcs.RecycleDelete(fidList...)
	)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Printf("删除成功\n")
}

// RunRecycleClear 清空回收站
func RunRecycleClear() {
	pcs := GetBaiduPCS()
	sussNum, err := pcs.RecycleClear()
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("清空回收站成功, 数量: %d\n", sussNum)
}



================================================
FILE: internal/pcscommand/rm_mkdir.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"os"
	"strconv"
)

// RunRemove 执行 批量删除文件/目录
func RunRemove(paths ...string) {
	paths, err := matchPathByShellPattern(paths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	pnt := func() {
		tb := pcstable.NewTable(os.Stdout)
		tb.SetHeader([]string{"#", "文件/目录"})
		for k := range paths {
			tb.Append([]string{strconv.Itoa(k), paths[k]})
		}
		tb.Render()
	}

	err = GetBaiduPCS().Remove(paths...)
	if err != nil {
		fmt.Println(err)
		fmt.Println("操作失败, 以下文件/目录删除失败: ")
		pnt()
		return
	}

	fmt.Println("操作成功, 以下文件/目录已删除, 可在网盘文件回收站找回: ")
	pnt()
}

// RunMkdir 执行 创建目录
func RunMkdir(path string) {
	activeUser := GetActiveUser()
	err := GetBaiduPCS().Mkdir(activeUser.PathJoin(path))
	if err != nil {
		fmt.Printf("创建目录 %s 失败, %s\n", path, err)
		return
	}

	fmt.Println("创建目录成功:", path)
}



================================================
FILE: internal/pcscommand/runner.go
================================================
package pcscommand

import (
	"io"
	"os"
)

var (
	// DefaultRunner 默认 Runner
	DefaultRunner = Runner{
		Output: os.Stdout,
	}
)

type (
	// Runner 执行器
	Runner struct {
		Output       io.Writer
		IsBackground bool
	}
)



================================================
FILE: internal/pcscommand/share.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"os"
	"path"
	"strconv"
)

// RunShareSet 执行分享
func RunShareSet(paths []string, option *baidupcs.ShareOption) {
	pcspaths, err := matchPathByShellPattern(paths...)
	if err != nil {
		fmt.Println(err)
		return
	}

	shared, err := GetBaiduPCS().ShareSet(pcspaths, option)
	if err != nil {
		fmt.Printf("%s失败: %s\n", baidupcs.OperationShareSet, err)
		return
	}

	fmt.Printf("shareID: %d, 链接: %s\n", shared.ShareID, shared.Link)
}

// RunShareCancel 执行取消分享
func RunShareCancel(shareIDs []int64) {
	if len(shareIDs) == 0 {
		fmt.Printf("%s失败, 没有任何 shareid\n", baidupcs.OperationShareCancel)
		return
	}

	err := GetBaiduPCS().ShareCancel(shareIDs)
	if err != nil {
		fmt.Printf("%s失败: %s\n", baidupcs.OperationShareCancel, err)
		return
	}

	fmt.Printf("%s成功\n", baidupcs.OperationShareCancel)
}

// RunShareList 执行列出分享列表
func RunShareList(page int) {
	if page < 1 {
		page = 1
	}

	pcs := GetBaiduPCS()
	records, err := pcs.ShareList(page)
	if err != nil {
		fmt.Printf("%s失败: %s\n", baidupcs.OperationShareList, err)
		return
	}

	tb := pcstable.NewTable(os.Stdout)
	tb.SetHeader([]string{"#", "ShareID", "分享链接", "提取密码", "特征目录", "特征路径"})
	for k, record := range records {
		// 获取Passwd
		if record.Public == 0 {
			// 私密分享
			info, pcsError := pcs.ShareSURLInfo(record.ShareID)
			if pcsError != nil {
				// 获取错误
				fmt.Printf("[%d] 获取分享密码错误: %s\n", k, pcsError)
			} else {
				record.Passwd = info.Pwd
			}
		}

		tb.Append([]string{strconv.Itoa(k), strconv.FormatInt(record.ShareID, 10), record.Shortlink, record.Passwd, path.Clean(path.Dir(record.TypicalPath)), record.TypicalPath})
	}
	tb.Render()
}



================================================
FILE: internal/pcscommand/tree.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"strings"
)

const (
	indentPrefix   = "│   "
	pathPrefix     = "├──"
	lastFilePrefix = "└──"
)

func getTree(pcspath string, depth int) {
	var (
		err   error
		files baidupcs.FileDirectoryList
	)
	if depth == 0 {
		err := matchPathByShellPatternOnce(&pcspath)
		if err != nil {
			fmt.Println(err)
			return
		}
	}

	files, err = GetBaiduPCS().FilesDirectoriesList(pcspath, baidupcs.DefaultOrderOptions)
	if err != nil {
		fmt.Println(err)
		return
	}

	var (
		prefix          = pathPrefix
		fN              = len(files)
		indentPrefixStr = strings.Repeat(indentPrefix, depth)
	)
	for i, file := range files {
		if file.Isdir {
			fmt.Printf("%v%v %v/\n", indentPrefixStr, pathPrefix, file.Filename)
			getTree(file.Path, depth+1)
			continue
		}

		if i+1 == fN {
			prefix = lastFilePrefix
		}

		fmt.Printf("%v%v %v\n", indentPrefixStr, prefix, file.Filename)
	}

	return
}

// RunTree 列出树形图
func RunTree(path string) {
	getTree(path, 0)
}



================================================
FILE: internal/pcscommand/upload.go
================================================
package pcscommand

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsfunctions/pcsupload"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/checksum"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/taskframework"
	"os"
	"path"
	"path/filepath"
	"strings"
)

const (
	// DefaultUploadMaxRetry 默认上传失败最大重试次数
	DefaultUploadMaxRetry = 3
)

type (
	// UploadOptions 上传可选项
	UploadOptions struct {
		Parallel      int
		MaxRetry      int
		NoRapidUpload bool
		NoSplitFile   bool // 禁用分片上传
	}
)

// RunRapidUpload 执行秒传文件, 前提是知道文件的大小, md5, 前256KB切片的 md5, crc32
func RunRapidUpload(targetPath, contentMD5, sliceMD5, crc32 string, length int64) {
	err := matchPathByShellPatternOnce(&targetPath)
	if err != nil {
		fmt.Printf("警告: %s, 获取网盘路径 %s 错误, %s\n", baidupcs.OperationRapidUpload, targetPath, err)
	}

	err = GetBaiduPCS().RapidUpload(targetPath, contentMD5, sliceMD5, crc32, length)
	if err != nil {
		fmt.Printf("%s失败, 消息: %s\n", baidupcs.OperationRapidUpload, err)
		return
	}

	fmt.Printf("%s成功, 保存到网盘路径: %s\n", baidupcs.OperationRapidUpload, targetPath)
	return
}

// RunCreateSuperFile 执行分片上传—合并分片文件
func RunCreateSuperFile(targetPath string, blockList ...string) {
	err := matchPathByShellPatternOnce(&targetPath)
	if err != nil {
		fmt.Printf("警告: %s, 获取网盘路径 %s 错误, %s\n", baidupcs.OperationUploadCreateSuperFile, targetPath, err)
	}

	err = GetBaiduPCS().UploadCreateSuperFile(true, targetPath, blockList...)
	if err != nil {
		fmt.Printf("%s失败, 消息: %s\n", baidupcs.OperationUploadCreateSuperFile, err)
		return
	}

	fmt.Printf("%s成功, 保存到网盘路径: %s\n", baidupcs.OperationUploadCreateSuperFile, targetPath)
	return
}

// RunUpload 执行文件上传
func RunUpload(localPaths []string, savePath string, opt *UploadOptions) {
	if opt == nil {
		opt = &UploadOptions{}
	}

	// 检测opt
	if opt.Parallel <= 0 {
		opt.Parallel = pcsconfig.Config.MaxUploadParallel
	}

	if opt.MaxRetry < 0 {
		opt.MaxRetry = DefaultUploadMaxRetry
	}

	err := matchPathByShellPatternOnce(&savePath)
	if err != nil {
		fmt.Printf("警告: 上传文件, 获取网盘路径 %s 错误, %s\n", savePath, err)
	}

	switch len(localPaths) {
	case 0:
		fmt.Printf("本地路径为空\n")
		return
	}

	// 打开上传状态
	uploadDatabase, err := pcsupload.NewUploadingDatabase()
	if err != nil {
		fmt.Printf("打开上传未完成数据库错误: %s\n", err)
		return
	}
	defer uploadDatabase.Close()

	var (
		pcs = GetBaiduPCS()
		// 使用 task framework
		executor = &taskframework.TaskExecutor{
			IsFailedDeque: true, // 失败统计
		}
		subSavePath string
		// 统计
		statistic = &pcsupload.UploadStatistic{}
	)

	statistic.StartTimer() // 开始计时

	for k := range localPaths {
		walkedFiles, err := pcsutil.WalkDir(localPaths[k], "")
		if err != nil {
			fmt.Printf("警告: 遍历错误: %s\n", err)
			continue
		}

		for k3 := range walkedFiles {
			var localPathDir string
			// 针对 windows 的目录处理
			if os.PathSeparator == '\\' {
				walkedFiles[k3] = pcsutil.ConvertToUnixPathSeparator(walkedFiles[k3])
				localPathDir = pcsutil.ConvertToUnixPathSeparator(filepath.Dir(localPaths[k]))
			} else {
				localPathDir = filepath.Dir(localPaths[k])
			}

			// 避免去除文件名开头的"."
			if localPathDir == "." {
				localPathDir = ""
			}

			subSavePath = strings.TrimPrefix(walkedFiles[k3], localPathDir)

			info := executor.Append(&pcsupload.UploadTaskUnit{
				LocalFileChecksum: checksum.NewLocalFileChecksum(walkedFiles[k3], int(baidupcs.SliceMD5Size)),
				SavePath:          path.Clean(savePath + baidupcs.PathSeparator + subSavePath),
				PCS:               pcs,
				UploadingDatabase: uploadDatabase,
				Parallel:          opt.Parallel,
				NoRapidUpload:     opt.NoRapidUpload,
				NoSplitFile:       opt.NoSplitFile,
				UploadStatistic:   statistic,
			}, opt.MaxRetry)
			fmt.Printf("[%s] 加入上传队列: %s\n", info.Id(), walkedFiles[k3])
		}
	}

	// 没有添加任何任务
	if executor.Count() == 0 {
		fmt.Printf("未检测到上传的文件.\n")
		return
	}

	// 执行上传任务
	executor.Execute()

	fmt.Printf("\n")
	fmt.Printf("上传结束, 时间: %s, 总大小: %s\n", statistic.Elapsed()/1e6*1e6, converter.ConvertFileSize(statistic.TotalSize()))

	// 输出上传失败的文件列表
	failedList := executor.FailedDeque()
	if failedList.Size() != 0 {
		fmt.Printf("以下文件上传失败: \n")
		tb := pcstable.NewTable(os.Stdout)
		for e := failedList.Shift(); e != nil; e = failedList.Shift() {
			item := e.(*taskframework.TaskInfoItem)
			tb.Append([]string{item.Info.Id(), item.Unit.(*pcsupload.UploadTaskUnit).LocalFileChecksum.Path})
		}
		tb.Render()
	}
}



================================================
FILE: internal/pcscommand/util.go
================================================
package pcscommand

import (
	"errors"
	"fmt"
)

var (
	// ErrShellPatternMultiRes 多条通配符匹配结果
	ErrShellPatternMultiRes = errors.New("多条通配符匹配结果")
	// ErrShellPatternNoHit 未匹配到路径
	ErrShellPatternNoHit = errors.New("未匹配到路径, 请检测通配符")
)

// ListTask 队列状态 (基类)
type ListTask struct {
	ID       int // 任务id
	MaxRetry int // 最大重试次数
	retry    int // 任务失败的重试次数
}

// RunTestShellPattern 执行测试通配符
func RunTestShellPattern(pattern string) {
	pcs := GetBaiduPCS()
	paths, err := pcs.MatchPathByShellPattern(GetActiveUser().PathJoin(pattern))
	if err != nil {
		fmt.Println(err)
		return
	}
	for k := range paths {
		fmt.Printf("%s\n", paths[k])
	}
	return
}

func matchPathByShellPatternOnce(pattern *string) error {
	paths, err := GetBaiduPCS().MatchPathByShellPattern(GetActiveUser().PathJoin(*pattern))
	if err != nil {
		return err
	}
	switch len(paths) {
	case 0:
		return ErrShellPatternNoHit
	case 1:
		*pattern = paths[0]
	default:
		return ErrShellPatternMultiRes
	}

	return nil
}

func matchPathByShellPattern(patterns ...string) (pcspaths []string, err error) {
	acUser, pcs := GetActiveUser(), GetBaiduPCS()
	for k := range patterns {
		ps, err := pcs.MatchPathByShellPattern(acUser.PathJoin(patterns[k]))
		if err != nil {
			return nil, err
		}

		pcspaths = append(pcspaths, ps...)
	}
	return pcspaths, nil
}



================================================
FILE: internal/pcsconfig/baidu.go
================================================
package pcsconfig

import (
	"errors"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/baidu-tools/tieba"
	"github.com/olekukonko/tablewriter"
	"path"
	"path/filepath"
	"strconv"
	"strings"
)

var (
	//ErrNoSuchBaiduUser 未登录任何百度帐号
	ErrNoSuchBaiduUser = errors.New("no such baidu user")
	//ErrBaiduUserNotFound 未找到百度帐号
	ErrBaiduUserNotFound = errors.New("baidu user not found")
)

//BaiduBase Baidu基
type BaiduBase struct {
	UID  uint64 `json:"uid"`  // 百度ID对应的uid
	Name string `json:"name"` // 真实ID
}

// Baidu 百度帐号对象
type Baidu struct {
	BaiduBase
	Sex string  `json:"sex"` // 性别
	Age float64 `json:"age"` // 帐号年龄

	BDUSS  string `json:"bduss"`
	PTOKEN string `json:"ptoken"`
	STOKEN string `json:"stoken"`

	Workdir string `json:"workdir"` // 工作目录
}

// BaiduPCS 初始化*baidupcs.BaiduPCS
func (baidu *Baidu) BaiduPCS() *baidupcs.BaiduPCS {
	pcs := baidupcs.NewPCS(Config.AppID, baidu.BDUSS)
	pcs.SetStoken(baidu.STOKEN)
	pcs.SetHTTPS(Config.EnableHTTPS)
	pcs.SetPCSUserAgent(Config.PCSUA)
	pcs.SetPanUserAgent(Config.PanUA)
	pcs.SetUID(baidu.UID)
	return pcs
}

// GetSavePath 根据提供的网盘文件路径 pcspath, 返回本地储存路径,
// 返回绝对路径, 获取绝对路径出错时才返回相对路径...
func (baidu *Baidu) GetSavePath(pcspath string) string {
	dirStr := filepath.Join(Config.SaveDir, fmt.Sprintf("%d_%s", baidu.UID, converter.TrimPathInvalidChars(baidu.Name)), pcspath)
	dir, err := filepath.Abs(dirStr)
	if err != nil {
		dir = filepath.Clean(dirStr)
	}
	return dir
}

// PathJoin 合并工作目录和相对路径p, 若p为绝对路径则忽略
func (baidu *Baidu) PathJoin(p string) string {
	if path.IsAbs(p) {
		return p
	}
	return path.Join(baidu.Workdir, p)
}

// BaiduUserList 百度帐号列表
type BaiduUserList []*Baidu

// NewUserInfoByBDUSS 检测BDUSS有效性, 同时获取百度详细信息 (无法获取 ptoken 和 stoken)
func NewUserInfoByBDUSS(bduss string) (b *Baidu, err error) {
	t, err := tieba.NewUserInfoByBDUSS(bduss)
	if err != nil {
		return nil, err
	}

	b = &Baidu{
		BaiduBase: BaiduBase{
			UID:  t.Baidu.UID,
			Name: t.Baidu.Name,
		},
		Sex:     t.Baidu.Sex,
		Age:     t.Baidu.Age,
		BDUSS:   bduss,
		Workdir: "/",
	}
	return b, nil
}

// String 格式输出百度帐号列表
func (bl *BaiduUserList) String() string {
	builder := &strings.Builder{}

	tb := pcstable.NewTable(builder)
	tb.SetColumnAlignment([]int{tablewriter.ALIGN_DEFAULT, tablewriter.ALIGN_RIGHT, tablewriter.ALIGN_CENTER, tablewriter.ALIGN_CENTER, tablewriter.ALIGN_CENTER})
	tb.SetHeader([]string{"#", "uid", "用户名", "性别", "age"})

	for k, baiduInfo := range *bl {
		tb.Append([]string{strconv.Itoa(k), strconv.FormatUint(baiduInfo.UID, 10), baiduInfo.Name, baiduInfo.Sex, fmt.Sprint(baiduInfo.Age)})
	}

	tb.Render()

	return builder.String()
}



================================================
FILE: internal/pcsconfig/errors.go
================================================
package pcsconfig

import (
	"errors"
)

var (
	//ErrNotLogin 未登录帐号错误
	ErrNotLogin = errors.New("baidu user not login")
	//ErrConfigFilePathNotSet 未设置配置文件
	ErrConfigFilePathNotSet = errors.New("config file not set")
	//ErrConfigFileNotExist 未设置Config, 未初始化
	ErrConfigFileNotExist = errors.New("config file not exist")
	//ErrConfigFileNoPermission Config文件无权限访问
	ErrConfigFileNoPermission = errors.New("config file permission denied")
	//ErrConfigContentsParseError 解析Config数据错误
	ErrConfigContentsParseError = errors.New("config contents parse error")
)



================================================
FILE: internal/pcsconfig/export.go
================================================
package pcsconfig

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/olekukonko/tablewriter"
	"os"
	"strconv"
)

// ActiveUser 获取当前登录的用户
func (c *PCSConfig) ActiveUser() *Baidu {
	if c.activeUser == nil {
		return &Baidu{}
	}
	return c.activeUser
}

// ActiveUserBaiduPCS 获取当前登录的用户的baidupcs.BaiduPCS
func (c *PCSConfig) ActiveUserBaiduPCS() *baidupcs.BaiduPCS {
	if c.pcs == nil {
		c.pcs = c.ActiveUser().BaiduPCS()
	}
	return c.pcs
}

func (c *PCSConfig) httpClientWithUA(ua string) *requester.HTTPClient {
	client := requester.NewHTTPClient()
	client.SetHTTPSecure(c.EnableHTTPS)
	client.SetUserAgent(ua)
	return client
}

// HTTPClient 返回设置好的 HTTPClient
func (c *PCSConfig) HTTPClient() *requester.HTTPClient {
	return c.httpClientWithUA(c.UserAgent)
}

// PCSHTTPClient 返回设置好的 PCS HTTPClient
func (c *PCSConfig) PCSHTTPClient() *requester.HTTPClient {
	return c.httpClientWithUA(c.PCSUA)
}

// PanHTTPClient 返回设置好的 Pan HTTPClient
func (c *PCSConfig) PanHTTPClient() *requester.HTTPClient {
	return c.httpClientWithUA(c.PanUA)
}

// NumLogins 获取登录的用户数量
func (c *PCSConfig) NumLogins() int {
	return len(c.BaiduUserList)
}

// AverageParallel 返回平均的下载最大并发量
func (c *PCSConfig) AverageParallel() int {
	return AverageParallel(c.MaxParallel, c.MaxDownloadLoad)
}

// PrintTable 输出表格
func (c *PCSConfig) PrintTable() {
	tb := pcstable.NewTable(os.Stdout)
	tb.SetHeader([]string{"名称", "值", "建议值", "描述"})
	tb.SetHeaderAlignment(tablewriter.ALIGN_LEFT)
	tb.SetColumnAlignment([]int{tablewriter.ALIGN_DEFAULT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT, tablewriter.ALIGN_LEFT})
	tb.AppendBulk([][]string{
		[]string{"appid", fmt.Sprint(c.AppID), "", "百度 PCS 应用ID"},
		[]string{"cache_size", converter.ConvertFileSize(int64(c.CacheSize), 2), "1KB ~ 256KB", "下载缓存, 如果硬盘占用高或下载速度慢, 请尝试调大此值"},
		[]string{"max_parallel", strconv.Itoa(c.MaxParallel), "1 ~ 64", "下载最大并发量"},
		[]string{"max_upload_parallel", strconv.Itoa(c.MaxUploadParallel), "1 ~ 100", "上传最大并发量"},
		[]string{"max_download_load", strconv.Itoa(c.MaxDownloadLoad), "1 ~ 5", "同时进行下载文件的最大数量"},
		[]string{"max_download_rate", showMaxRate(c.MaxDownloadRate), "", "限制最大下载速度, 0代表不限制"},
		[]string{"max_upload_rate", showMaxRate(c.MaxUploadRate), "", "限制最大上传速度, 0代表不限制"},
		[]string{"savedir", c.SaveDir, "", "下载文件的储存目录"},
		[]string{"enable_https", fmt.Sprint(c.EnableHTTPS), "true", "启用 https"},
		[]string{"user_agent", c.UserAgent, requester.DefaultUserAgent, "浏览器标识"},
		[]string{"pcs_ua", c.PCSUA, "", "PCS 浏览器标识"},
		[]string{"pan_ua", c.PanUA, baidupcs.NetdiskUA, "Pan 浏览器标识"},
		[]string{"proxy", c.Proxy, "", "设置代理, 支持 http/socks5 代理"},
		[]string{"local_addrs", c.LocalAddrs, "", "设置本地网卡地址, 多个地址用逗号隔开"},
	})
	tb.Render()
}



================================================
FILE: internal/pcsconfig/maniper.go
================================================
package pcsconfig

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"strings"
)

const (
	opDelete = "delete"
	opSwitch = "switch"
	opGet    = "get"
)

func (c *PCSConfig) manipUser(op string, baiduBase *BaiduBase) (*Baidu, error) {
	// empty baiduBase
	if baiduBase == nil || (baiduBase.UID == 0 && baiduBase.Name == "") {
		switch op {
		case opGet:
			return &Baidu{}, nil
		default:
			return nil, ErrBaiduUserNotFound
		}
	}
	if len(c.BaiduUserList) == 0 {
		return nil, ErrNoSuchBaiduUser
	}

	for k, user := range c.BaiduUserList {
		if user == nil {
			continue
		}

		switch {
		case baiduBase.UID != 0 && baiduBase.Name != "":
			// 不区分大小写
			if user.UID == baiduBase.UID && strings.EqualFold(user.Name, baiduBase.Name) {
				goto handle
			}
			continue
		case baiduBase.UID == 0 && baiduBase.Name != "":
			// 不区分大小写
			if strings.EqualFold(user.Name, baiduBase.Name) {
				goto handle
			}
			continue
		case baiduBase.UID != 0 && baiduBase.Name == "":
			if user.UID == baiduBase.UID {
				goto handle
			}
			continue
		default:
			continue
		}
		// unreachable zone

	handle:
		switch op {
		case opSwitch:
			c.setupNewUser(user)
		case opDelete:
			c.BaiduUserList = append(c.BaiduUserList[:k], c.BaiduUserList[k+1:]...)

			// 修改 正在使用的 百度帐号
			// 如果要删除的帐号为当前登录的帐号, 则设置当前登录帐号为列表中第一个帐号
			if c.BaiduActiveUID == user.UID {
				if len(c.BaiduUserList) != 0 {
					c.setupNewUser(c.BaiduUserList[0])
				} else {
					c.BaiduActiveUID = 0
				}
			}
		case opGet:
			// do nothing
		default:
			// do nothing
		}
		return user, nil
	}

	return nil, ErrBaiduUserNotFound
}

//setupNewUser 从已有用户中, 设置新的当前登录用户
func (c *PCSConfig) setupNewUser(user *Baidu) {
	if user == nil {
		return
	}
	c.BaiduActiveUID = user.UID
	c.activeUser = user
	c.pcs = user.BaiduPCS()
}

// SwitchUser 切换用户, 返回切换成功的用户
func (c *PCSConfig) SwitchUser(baiduBase *BaiduBase) (*Baidu, error) {
	return c.manipUser(opSwitch, baiduBase)
}

// DeleteUser 删除用户, 返回删除成功的用户
func (c *PCSConfig) DeleteUser(baiduBase *BaiduBase) (*Baidu, error) {
	return c.manipUser(opDelete, baiduBase)
}

// GetBaiduUser 获取百度用户信息
func (c *PCSConfig) GetBaiduUser(baidubase *BaiduBase) (*Baidu, error) {
	return c.manipUser(opGet, baidubase)
}

// CheckBaiduUserExist 检查百度用户是否存在于已登录列表
func (c *PCSConfig) CheckBaiduUserExist(baidubase *BaiduBase) bool {
	_, err := c.manipUser("", baidubase)
	return err == nil
}

// SetupUserByBDUSS 设置百度 bduss, ptoken, stoken 并保存
func (c *PCSConfig) SetupUserByBDUSS(bduss, ptoken, stoken string) (baidu *Baidu, err error) {
	b, err := NewUserInfoByBDUSS(bduss)
	if err != nil {
		return nil, err
	}

	c.DeleteUser(&BaiduBase{
		UID: b.UID,
	}) // 删除旧的信息

	b.PTOKEN = ptoken
	b.STOKEN = stoken

	c.BaiduUserList = append(c.BaiduUserList, b)

	// 自动切换用户
	c.setupNewUser(b)
	return b, nil
}

// SetAppID 设置app_id
func (c *PCSConfig) SetAppID(appID int) {
	c.AppID = appID
	if c.pcs != nil {
		c.pcs.SetAPPID(appID)
	}
}

// SetCacheSizeByStr 设置cache_size
func (c *PCSConfig) SetCacheSizeByStr(sizeStr string) error {
	size, err := converter.ParseFileSizeStr(sizeStr)
	if err != nil {
		return err
	}
	c.CacheSize = int(size)
	return nil
}

// SetMaxDownloadRateByStr 设置 max_download_rate
func (c *PCSConfig) SetMaxDownloadRateByStr(sizeStr string) error {
	size, err := converter.ParseFileSizeStr(stripPerSecond(sizeStr))
	if err != nil {
		return err
	}
	c.MaxDownloadRate = size
	return nil
}

// SetMaxUploadRateByStr 设置 max_upload_rate
func (c *PCSConfig) SetMaxUploadRateByStr(sizeStr string) error {
	size, err := converter.ParseFileSizeStr(stripPerSecond(sizeStr))
	if err != nil {
		return err
	}
	c.MaxUploadRate = size
	return nil
}

// SetUserAgent 设置User-Agent
func (c *PCSConfig) SetUserAgent(userAgent string) {
	c.UserAgent = userAgent
	requester.UserAgent = userAgent
}

// SetPCSUA 设置 PCS User-Agent
func (c *PCSConfig) SetPCSUA(pcsUA string) {
	c.PCSUA = pcsUA
	if c.pcs != nil {
		c.pcs.SetPCSUserAgent(pcsUA)
	}
}

// SetPanUA 设置 Pan User-Agent
func (c *PCSConfig) SetPanUA(panUA string) {
	c.PanUA = panUA
	if c.pcs != nil {
		c.pcs.SetPanUserAgent(panUA)
	}
}

// SetEnableHTTPS 设置是否启用https
func (c *PCSConfig) SetEnableHTTPS(https bool) {
	c.EnableHTTPS = https
	if c.pcs != nil {
		c.pcs.SetHTTPS(https)
	}
}

// SetProxy 设置代理
func (c *PCSConfig) SetProxy(proxy string) {
	c.Proxy = proxy
	requester.SetGlobalProxy(proxy)
}

// SetLocalAddrs 设置localAddrs
func (c *PCSConfig) SetLocalAddrs(localAddrs string) {
	c.LocalAddrs = localAddrs
	requester.SetLocalTCPAddrList(strings.Split(localAddrs, ",")...)
}



================================================
FILE: internal/pcsconfig/pcsconfig.go
================================================
// Package pcsconfig 配置包
package pcsconfig

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/jsonhelper"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/json-iterator/go"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
)

const (
	// EnvConfigDir 配置路径环境变量
	EnvConfigDir = "BAIDUPCS_GO_CONFIG_DIR"
	// ConfigName 配置文件名
	ConfigName = "pcs_config.json"
)

var (
	pcsConfigVerbose = pcsverbose.New("PCSCONFIG")
	configFilePath   = filepath.Join(GetConfigDir(), ConfigName)

	// Config 配置信息, 由外部调用
	Config = NewConfig(configFilePath)
)

// PCSConfig 配置详情
type PCSConfig struct {
	BaiduActiveUID uint64        `json:"baidu_active_uid"`
	BaiduUserList  BaiduUserList `json:"baidu_user_list"`

	AppID int `json:"appid"` // appid

	CacheSize         int `json:"cache_size"`          // 下载缓存
	MaxParallel       int `json:"max_parallel"`        // 最大下载并发量
	MaxUploadParallel int `json:"max_upload_parallel"` // 最大上传并发量
	MaxDownloadLoad   int `json:"max_download_load"`   // 同时进行下载文件的最大数量

	MaxDownloadRate int64 `json:"max_download_rate"` // 限制最大下载速度
	MaxUploadRate   int64 `json:"max_upload_rate"`   // 限制最大上传速度

	UserAgent   string `json:"user_agent"`   // 浏览器标识
	PCSUA       string `json:"pcs_ua"`       // PCS浏览器标识
	PanUA       string `json:"pan_ua"`       // PAN浏览器标识
	SaveDir     string `json:"savedir"`      // 下载储存路径
	EnableHTTPS bool   `json:"enable_https"` // 启用https
	Proxy       string `json:"proxy"`        // 代理
	LocalAddrs  string `json:"local_addrs"`  // 本地网卡地址

	configFilePath string
	configFile     *os.File
	fileMu         sync.Mutex
	activeUser     *Baidu
	pcs            *baidupcs.BaiduPCS
}

// NewConfig 返回 PCSConfig 指针对象
func NewConfig(configFilePath string) *PCSConfig {
	c := &PCSConfig{
		configFilePath: configFilePath,
	}
	return c
}

// Init 初始化配置
func (c *PCSConfig) Init() error {
	return c.init()
}

// Reload 从文件重载配置
func (c *PCSConfig) Reload() error {
	return c.init()
}

// Close 关闭配置文件
func (c *PCSConfig) Close() error {
	if c.configFile != nil {
		err := c.configFile.Close()
		c.configFile = nil
		return err
	}
	return nil
}

// Save 保存配置信息到配置文件
func (c *PCSConfig) Save() error {
	// 检测配置项是否合法, 不合法则自动修复
	c.fix()

	err := c.lazyOpenConfigFile()
	if err != nil {
		return err
	}

	c.fileMu.Lock()
	defer c.fileMu.Unlock()

	data, err := jsoniter.MarshalIndent(c, "", " ")
	if err != nil {
		// json数据生成失败
		panic(err)
	}

	// 减掉多余的部分
	err = c.configFile.Truncate(int64(len(data)))
	if err != nil {
		return err
	}

	_, err = c.configFile.Seek(0, os.SEEK_SET)
	if err != nil {
		return err
	}

	_, err = c.configFile.Write(data)
	if err != nil {
		return err
	}

	return nil
}

func (c *PCSConfig) init() error {
	if c.configFilePath == "" {
		return ErrConfigFileNotExist
	}

	c.initDefaultConfig()
	err := c.loadConfigFromFile()
	if err != nil {
		return err
	}

	// 载入配置
	// 如果 activeUser 已初始化, 则跳过
	if c.activeUser != nil && c.activeUser.UID == c.BaiduActiveUID {
		return nil
	}

	c.activeUser, err = c.GetBaiduUser(&BaiduBase{
		UID: c.BaiduActiveUID,
	})
	if err != nil {
		return err
	}
	c.pcs = c.activeUser.BaiduPCS()

	// 设置全局User-Agent
	requester.UserAgent = c.UserAgent
	// 设置全局代理
	requester.SetGlobalProxy(c.Proxy)
	// 设置本地网卡地址
	requester.SetLocalTCPAddrList(strings.Split(c.LocalAddrs, ",")...)

	return nil
}

// lazyOpenConfigFile 打开配置文件
func (c *PCSConfig) lazyOpenConfigFile() (err error) {
	if c.configFile != nil {
		return nil
	}

	c.fileMu.Lock()
	os.MkdirAll(filepath.Dir(c.configFilePath), 0700)
	c.configFile, err = os.OpenFile(c.configFilePath, os.O_CREATE|os.O_RDWR, 0600)
	c.fileMu.Unlock()

	if err != nil {
		if os.IsPermission(err) {
			return ErrConfigFileNoPermission
		}
		if os.IsExist(err) {
			return ErrConfigFileNotExist
		}
		return err
	}
	return nil
}

// loadConfigFromFile 载入配置
func (c *PCSConfig) loadConfigFromFile() (err error) {
	err = c.lazyOpenConfigFile()
	if err != nil {
		return err
	}

	// 未初始化
	info, err := c.configFile.Stat()
	if err != nil {
		return err
	}

	if info.Size() == 0 {
		err = c.Save()
		return err
	}

	c.fileMu.Lock()
	defer c.fileMu.Unlock()

	_, err = c.configFile.Seek(0, os.SEEK_SET)
	if err != nil {
		return err
	}

	err = jsonhelper.UnmarshalData(c.configFile, c)
	if err != nil {
		return ErrConfigContentsParseError
	}
	return nil
}

func (c *PCSConfig) initDefaultConfig() {
	c.AppID = 266719
	c.CacheSize = 65536
	c.MaxParallel = 1
	c.MaxUploadParallel = 8
	c.MaxDownloadLoad = 1
	c.UserAgent = requester.UserAgent
	c.PCSUA = ""
	c.PanUA = baidupcs.NetdiskUA
	c.EnableHTTPS = true

	// 设置默认的下载路径
	switch runtime.GOOS {
	case "windows":
		c.SaveDir = pcsutil.ExecutablePathJoin("Downloads")
	case "android":
		// TODO: 获取完整的的下载路径
		c.SaveDir = "/sdcard/Download"
	default:
		dataPath, ok := os.LookupEnv("HOME")
		if !ok {
			pcsConfigVerbose.Warn("Environment HOME not set")
			c.SaveDir = pcsutil.ExecutablePathJoin("Downloads")
		} else {
			c.SaveDir = filepath.Join(dataPath, "Downloads")
		}
	}
}

// GetConfigDir 获取配置路径
func GetConfigDir() string {
	// 从环境变量读取
	configDir, ok := os.LookupEnv(EnvConfigDir)
	if ok {
		if filepath.IsAbs(configDir) {
			return configDir
		}
		// 如果不是绝对路径, 从程序目录寻找
		return pcsutil.ExecutablePathJoin(configDir)
	}

	// 使用旧版
	// 如果旧版的配置文件存在, 则使用旧版
	oldConfigDir := pcsutil.ExecutablePath()
	_, err := os.Stat(filepath.Join(oldConfigDir, ConfigName))
	if err == nil {
		return oldConfigDir
	}

	switch runtime.GOOS {
	case "windows":
		dataPath, ok := os.LookupEnv("APPDATA")
		if !ok {
			pcsConfigVerbose.Warn("Environment APPDATA not set")
			return oldConfigDir
		}
		return filepath.Join(dataPath, "BaiduPCS-Go")
	default:
		dataPath, ok := os.LookupEnv("HOME")
		if !ok {
			pcsConfigVerbose.Warn("Environment HOME not set")
			return oldConfigDir
		}
		configDir = filepath.Join(dataPath, ".config", "BaiduPCS-Go")

		// 检测是否可写
		err = os.MkdirAll(configDir, 0700)
		if err != nil {
			pcsConfigVerbose.Warnf("check config dir error: %s\n", err)
			return oldConfigDir
		}
		return configDir
	}
}

func (c *PCSConfig) fix() {
	if c.CacheSize < 1024 {
		c.CacheSize = 1024
	}
	if c.MaxParallel < 1 {
		c.MaxParallel = 1
	}
	if c.MaxUploadParallel < 1 {
		c.MaxUploadParallel = 1
	}
	if c.MaxDownloadLoad < 1 {
		c.MaxDownloadLoad = 1
	}
}



================================================
FILE: internal/pcsconfig/util.go
================================================
package pcsconfig

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"strings"
)

// AverageParallel 返回平均的下载最大并发量
func AverageParallel(parallel, downloadLoad int) int {
	if downloadLoad < 1 {
		return 1
	}

	p := parallel / downloadLoad
	if p < 1 {
		return 1
	}
	return p
}

func stripPerSecond(sizeStr string) string {
	i := strings.LastIndex(sizeStr, "/")
	if i < 0 {
		return sizeStr
	}
	return sizeStr[:i]
}

func showMaxRate(size int64) string {
	if size <= 0 {
		return "不限制"
	}
	return converter.ConvertFileSize(size, 2) + "/s"
}



================================================
FILE: internal/pcsfunctions/common.go
================================================
package pcsfunctions

import "time"

// RetryWait 失败重试等待事件
func RetryWait(retry int) time.Duration {
	if retry < 3 {
		return 2 * time.Duration(retry) * time.Second
	}
	return 6 * time.Second
}



================================================
FILE: internal/pcsfunctions/statistic.go
================================================
package pcsfunctions

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"sync/atomic"
	"time"
)

type (
	Statistic struct {
		totalSize int64
		startTime time.Time
	}
)

func (s *Statistic) AddTotalSize(size int64) int64 {
	return atomic.AddInt64(&s.totalSize, size)
}

func (s *Statistic) TotalSize() int64 {
	return s.totalSize
}

func (s *Statistic) StartTimer() {
	s.startTime = time.Now()
	expires.StripMono(&s.startTime)
}

func (s *Statistic) Elapsed() time.Duration {
	return time.Now().Sub(s.startTime)
}


================================================
FILE: internal/pcsfunctions/pcscaptcha/captchapath.go
================================================
package pcscaptcha

import (
	"os"
	"path/filepath"
)

// CaptchaPath 返回验证码存放路径
func CaptchaPath() string {
	return filepath.Join(os.TempDir(), CaptchaName)
}



================================================
FILE: internal/pcsfunctions/pcscaptcha/pcscaptcha.go
================================================
// Package pcscaptcha 验证码处理包
// TODO: 直接打开验证码
package pcscaptcha

import (
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"os"
	"path/filepath"
)

const (
	// CaptchaName 验证码文件名称
	CaptchaName = "captcha.png"
)

// RemoveOldCaptchaPath 移除旧的验证码路径
func RemoveOldCaptchaPath() error {
	return os.Remove(filepath.Join(pcsconfig.GetConfigDir(), CaptchaName))
}

// RemoveCaptchaPath 移除验证码路径
func RemoveCaptchaPath() error {
	return os.Remove(CaptchaPath())
}



================================================
FILE: internal/pcsfunctions/pcsdownload/download_link.go
================================================
package pcsdownload

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"net/url"
)

func GetLocateDownloadLinks(pcs *baidupcs.BaiduPCS, pcspath string) (dlinks []*url.URL, err error) {
	dInfo, pcsError := pcs.LocateDownload(pcspath)
	if pcsError != nil {
		return nil, pcsError
	}

	us := dInfo.URLStrings(pcsconfig.Config.EnableHTTPS)
	if len(us) == 0 {
		return nil, ErrDlinkNotFound
	}

	return us, nil
}



================================================
FILE: internal/pcsfunctions/pcsdownload/download_statistic.go
================================================
package pcsdownload

import (
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsfunctions"
)

type (
	DownloadStatistic struct {
		pcsfunctions.Statistic
	}
)



================================================
FILE: internal/pcsfunctions/pcsdownload/download_task_unit.go
================================================
package pcsdownload

import (
	"errors"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsfunctions"
	"github.com/felixonmars/BaiduPCS-Go/pcstable"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/taskframework"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/felixonmars/BaiduPCS-Go/requester/downloader"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

type (
	// DownloadMode 下载模式
	DownloadMode int

	// DownloadTaskUnit 下载的任务单元
	DownloadTaskUnit struct {
		taskInfo *taskframework.TaskInfo // 任务信息

		Cfg                *downloader.Config
		PCS                *baidupcs.BaiduPCS
		ParentTaskExecutor *taskframework.TaskExecutor

		DownloadStatistic *DownloadStatistic // 下载统计

		// 可选项
		VerbosePrinter       *pcsverbose.PCSVerbose
		PrintFormat          string
		IsPrintStatus        bool // 是否输出各个下载线程的详细信息
		IsExecutedPermission bool // 下载成功后是否加上执行权限
		IsOverwrite          bool // 是否覆盖已存在的文件
		NoCheck              bool // 不校验文件

		DownloadMode DownloadMode // 下载模式

		PcsPath  string // 要下载的网盘文件路径
		SavePath string // 保存的路径

		fileInfo *baidupcs.FileDirectory // 文件或目录详情
	}
)

const (
	// DefaultPrintFormat 默认的下载进度输出格式
	DefaultPrintFormat = "\r[%s] ↓ %s/%s %s/s in %s, left %s ............"
	//DownloadSuffix 文件下载后缀
	DownloadSuffix = ".BaiduPCS-Go-downloading"
	//StrDownloadInitError 初始化下载发生错误
	StrDownloadInitError = "初始化下载发生错误"
	// StrDownloadFailed 下载文件失败
	StrDownloadFailed = "下载文件失败"
	// StrDownloadGetDlinkFailed 获取下载链接失败
	StrDownloadGetDlinkFailed = "获取下载链接失败"
	// StrDownloadChecksumFailed 检测文件有效性失败
	StrDownloadChecksumFailed = "检测文件有效性失败"
	// DefaultDownloadMaxRetry 默认下载失败最大重试次数
	DefaultDownloadMaxRetry = 3
)

const (
	DownloadModeLocate DownloadMode = iota
	DownloadModePCS
	DownloadModeStreaming
)

func (dtu *DownloadTaskUnit) SetTaskInfo(info *taskframework.TaskInfo) {
	dtu.taskInfo = info
}

func (dtu *DownloadTaskUnit) verboseInfof(format string, a ...interface{}) {
	if dtu.VerbosePrinter != nil {
		dtu.VerbosePrinter.Infof(format, a...)
	}
}

// download 执行下载
func (dtu *DownloadTaskUnit) download(downloadURL string, client *requester.HTTPClient) (err error) {
	var (
		writer downloader.Writer
		file   *os.File
	)

	if !dtu.Cfg.IsTest {
		// 非测试下载
		dtu.Cfg.InstanceStatePath = dtu.SavePath + DownloadSuffix

		// 创建下载的目录
		// 获取SavePath所在的目录
		dir := filepath.Dir(dtu.SavePath)
		fileInfo, err := os.Stat(dir)
		if err != nil {
			// 目录不存在, 创建
			err = os.MkdirAll(dir, 0777)
			if err != nil {
				return err
			}
		} else if !fileInfo.IsDir() {
			// SavePath所在的目录不是目录
			return fmt.Errorf("%s, path %s: not a directory", StrDownloadInitError, dir)
		}

		// 打开文件
		writer, file, err = downloader.NewDownloaderWriterByFilename(dtu.SavePath, os.O_CREATE|os.O_WRONLY, 0666)
		if err != nil {
			return fmt.Errorf("%s, %s", StrDownloadInitError, err)
		}
		defer file.Close()
	}

	der := downloader.NewDownloader(downloadURL, writer, dtu.Cfg)
	der.SetClient(client)
	der.SetDURLCheckFunc(BaiduPCSURLCheckFunc)
	der.SetStatusCodeBodyCheckFunc(func(respBody io.Reader) error {
		// 返回的错误可能是pcs的json
		// 解析错误
		return pcserror.DecodePCSJSONError(baidupcs.OperationDownloadFile, respBody)
	})

	// 检查输出格式
	if dtu.PrintFormat == "" {
		dtu.PrintFormat = DefaultPrintFormat
	}

	// 这里用共享变量的方式
	isComplete := false
	der.OnDownloadStatusEvent(func(status transfer.DownloadStatuser, workersCallback func(downloader.RangeWorkerFunc)) {
		// 这里可能会下载结束了, 还会输出内容
		builder := &strings.Builder{}
		if dtu.IsPrintStatus {
			// 输出所有的worker状态
			var (
				tb      = pcstable.NewTable(builder)
			)
			tb.SetHeader([]string{"#", "status", "range", "left", "speeds", "error"})
			workersCallback(func(key int, worker *downloader.Worker) bool {
				wrange := worker.GetRange()
				tb.Append([]string{fmt.Sprint(worker.ID()), worker.GetStatus().StatusText(), wrange.ShowDetails(), strconv.FormatInt(wrange.Len(), 10), strconv.FormatInt(worker.GetSpeedsPerSecond(), 10), fmt.Sprint(worker.Err())})
				return true
			})

			// 先空两行
			builder.WriteString("\n\n")
			tb.Render()
		}

		// 如果下载速度为0, 剩余下载时间未知, 则用 - 代替
		var leftStr string
		left := status.TimeLeft()
		if left < 0 {
			leftStr = "-"
		} else {
			leftStr = left.String()
		}

		fmt.Fprintf(builder,dtu.PrintFormat, dtu.taskInfo.Id(),
			converter.ConvertFileSize(status.Downloaded(), 2),
			converter.ConvertFileSize(status.TotalSize(), 2),
			converter.ConvertFileSize(status.SpeedsPerSecond(), 2),
			status.TimeElapsed()/1e7*1e7, leftStr,
		)

		if !isComplete {
			// 如果未完成下载, 就输出
			fmt.Print(builder.String())
		}
	})

	der.OnExecute(func() {
		if dtu.Cfg.IsTest {
			fmt.Printf("[%s] 测试下载开始\n\n", dtu.taskInfo.Id())
		}
	})

	err = der.Execute()
	isComplete = true
	fmt.Print("\n")

	if err != nil {
		// 下载发生错误
		if !dtu.Cfg.IsTest {
			// 下载失败, 删去空文件
			if info, infoErr := file.Stat(); infoErr == nil {
				if info.Size() == 0 {
					// 空文件, 应该删除
					dtu.verboseInfof("[%s] remove empty file: %s\n", dtu.taskInfo.Id(), dtu.SavePath)
					removeErr := os.Remove(dtu.SavePath)
					if removeErr != nil {
						dtu.verboseInfof("[%s] remove file error: %s\n", dtu.taskInfo.Id(), removeErr)
					}
				}
			}
		}
		return err
	}

	// 下载成功
	if !dtu.Cfg.IsTest {
		if dtu.IsExecutedPermission {
			err = file.Chmod(0766)
			if err != nil {
				fmt.Printf("[%s] 警告, 加执行权限错误: %s\n", dtu.taskInfo.Id(), err)
			}
		}

		fmt.Printf("[%s] 下载完成, 保存位置: %s\n", dtu.taskInfo.Id(), dtu.SavePath)
	} else {
		fmt.Printf("[%s] 测试下载结束\n", dtu.taskInfo.Id())
	}

	return nil
}

//panHTTPClient 获取包含特定User-Agent的HTTPClient
func (dtu *DownloadTaskUnit) panHTTPClient() (client *requester.HTTPClient) {
	client = pcsconfig.Config.PanHTTPClient()
	client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		// 去掉 Referer
		if !pcsconfig.Config.EnableHTTPS {
			req.Header.Del("Referer")
		}
		if len(via) >= 10 {
			return errors.New("stopped after 10 redirects")
		}
		return nil
	}
	client.SetTimeout(20 * time.Minute)
	client.SetKeepAlive(true)
	return client
}

func (dtu *DownloadTaskUnit) handleError(result *taskframework.TaskUnitRunResult) {
	switch value := result.Err.(type) {
	case pcserror.Error: // pcserror 接口
		switch value.GetErrType() {
		case pcserror.ErrTypeRemoteError:
		// 远程服务器错误
		case 31045: // user not exists
			fallthrough
		case 31066: // file does not exist
			result.NeedRetry = false
		case 31626: // user is not authorized
			//可能是User-Agent不对
			//重试
			fallthrough
		default:
			result.NeedRetry = true
		}
	case *os.PathError:
		// 系统级别的错误, 可能是权限问题
		result.NeedRetry = false
	default:
		// 其他错误, 需要重试
		result.NeedRetry = true
	}
}

func (dtu *DownloadTaskUnit) execPanDownload(dlink string, result *taskframework.TaskUnitRunResult, okPtr *bool) {
	dtu.verboseInfof("[%s] 获取到下载链接: %s\n", dtu.taskInfo.Id(), dlink)

	client := dtu.panHTTPClient()
	err := dtu.download(dlink, client)
	if err != nil {
		result.ResultMessage = StrDownloadFailed
		result.Err = err
		dtu.handleError(result)
		return
	}
	*okPtr = true
}

func (dtu *DownloadTaskUnit) locateDownload(result *taskframework.TaskUnitRunResult) (ok bool) {
	rawDlinks, err := GetLocateDownloadLinks(dtu.PCS, dtu.PcsPath)
	if err != nil {
		result.ResultMessage = StrDownloadGetDlinkFailed
		result.Err = err
		dtu.handleError(result)
		return
	}

	// 更新链接的协议
	FixHTTPLinkURL(rawDlinks[0])
	dlink := rawDlinks[0].String()

	dtu.execPanDownload(dlink, result, &ok)
	return
}

func (dtu *DownloadTaskUnit) pcsOrStreamingDownload(mode DownloadMode, result *taskframework.TaskUnitRunResult) (ok bool) {
	dfunc := func(downloadURL string, jar http.CookieJar) error {
		client := pcsconfig.Config.PCSHTTPClient()
		client.SetCookiejar(jar)
		client.SetKeepAlive(true)
		client.SetTimeout(10 * time.Minute)

		return dtu.download(downloadURL, client)
	}

	var err error
	switch mode {
	case DownloadModePCS:
		err = dtu.PCS.DownloadFile(dtu.PcsPath, dfunc)
	case DownloadModeStreaming:
		err = dtu.PCS.DownloadStreamFile(dtu.PcsPath, dfunc)
	default:
		panic("unreachable")
	}

	if err != nil {
		result.ResultMessage = StrDownloadFailed
		result.Err = err
		dtu.handleError(result)
		return
	}
	return true // 下载成功
}

//checkFileValid 检测文件有效性
func (dtu *DownloadTaskUnit) checkFileValid(result *taskframework.TaskUnitRunResult) (ok bool) {
	if dtu.Cfg.IsTest || dtu.NoCheck {
		// 不检测文件有效性
		return
	}

	if dtu.fileInfo.Size >= 128*converter.MB {
		// 大文件, 输出一句提示消息
		fmt.Printf("[%s] 开始检验文件有效性, 请稍候...\n", dtu.taskInfo.Id())
	}

	// 就在这里处理校验出错
	err := CheckFileValid(dtu.SavePath, dtu.fileInfo)
	if err != nil {
		result.ResultMessage = StrDownloadChecksumFailed
		result.Err = err
		switch err {
		case ErrDownloadNotSupportChecksum:
			// 文件不支持校验
			result.ResultMessage = "检验文件有效性"
			result.Err = err
			fmt.Printf("[%s] 检验文件有效性: %s\n", dtu.taskInfo.Id(), err)
			return true
		case ErrDownloadFileBanned:
			// 违规文件
			result.NeedRetry = false
			return
		case ErrDownloadChecksumFailed:
			// 校验失败, 需要重新下载
			result.NeedRetry = true
			// 设置允许覆盖
			dtu.IsOverwrite = true
			return
		default:
			result.NeedRetry = false
			return
		}
	}

	fmt.Printf("[%s] 检验文件有效性成功: %s\n", dtu.taskInfo.Id(), dtu.SavePath)
	return true
}

func (dtu *DownloadTaskUnit) OnRetry(lastRunResult *taskframework.TaskUnitRunResult) {
	// 输出错误信息
	if lastRunResult.Err == nil {
		// result中不包含Err, 忽略输出
		fmt.Printf("[%s] %s, 重试 %d/%d\n", dtu.taskInfo.Id(), lastRunResult.ResultMessage, dtu.taskInfo.Retry(), dtu.taskInfo.MaxRetry())
		return
	}
	fmt.Printf("[%s] %s, %s, 重试 %d/%d\n", dtu.taskInfo.Id(), lastRunResult.ResultMessage, lastRunResult.Err, dtu.taskInfo.Retry(), dtu.taskInfo.MaxRetry())
}

func (dtu *DownloadTaskUnit) OnSuccess(lastRunResult *taskframework.TaskUnitRunResult) {
}

func (dtu *DownloadTaskUnit) OnFailed(lastRunResult *taskframework.TaskUnitRunResult) {
	// 失败
	if lastRunResult.Err == nil {
		// result中不包含Err, 忽略输出
		fmt.Printf("[%s] %s\n", dtu.taskInfo.Id(), lastRunResult.ResultMessage)
		return
	}
	fmt.Printf("[%s] %s, %s\n", dtu.taskInfo.Id(), lastRunResult.ResultMessage, lastRunResult.Err)
}

func (dtu *DownloadTaskUnit) OnComplete(lastRunResult *taskframework.TaskUnitRunResult) {
}

func (dtu *DownloadTaskUnit) RetryWait() time.Duration {
	return pcsfunctions.RetryWait(dtu.taskInfo.Retry())
}

func (dtu *DownloadTaskUnit) Run() (result *taskframework.TaskUnitRunResult) {
	result = &taskframework.TaskUnitRunResult{}
	// 获取文件信息
	var err error
	if dtu.fileInfo == nil || dtu.taskInfo.Retry() > 0 {
		// 没有获取文件信息
		// 如果是动态添加的下载任务, 是会写入文件信息的
		// 如果该任务重试过, 则应该再获取一次文件信息
		dtu.fileInfo, err = dtu.PCS.FilesDirectoriesMeta(dtu.PcsPath)
		if err != nil {
			// 如果不是未登录或文件不存在, 则不重试
			result.ResultMessage = "获取下载路径信息错误"
			result.Err = err
			dtu.handleError(result)
			return
		}
	}

	// 输出文件信息
	fmt.Print("\n")
	fmt.Printf("[%s] ----\n%s\n", dtu.taskInfo.Id(), dtu.fileInfo.String())

	// 如果是一个目录, 将子文件和子目录加入队列
	if dtu.fileInfo.Isdir {
		if !dtu.Cfg.IsTest { // 测试下载, 不建立空目录
			os.MkdirAll(dtu.SavePath, 0777) // 首先在本地创建目录, 保证空目录也能被保存
		}

		// 获取该目录下的文件列表
		fileList, err := dtu.PCS.FilesDirectoriesList(dtu.PcsPath, baidupcs.DefaultOrderOptions)
		if err != nil {
			result.ResultMessage = "获取目录信息错误"
			result.Err = err
			result.NeedRetry = true
			return
		}

		for k := range fileList {
			// 添加子任务
			subUnit := *dtu
			newCfg := *dtu.Cfg
			subUnit.Cfg = &newCfg
			subUnit.fileInfo = fileList[k] // 保存文件信息
			subUnit.PcsPath = fileList[k].Path
			subUnit.SavePath = filepath.Join(dtu.SavePath, fileList[k].Filename) // 保存位置

			// 加入父队列
			info := dtu.ParentTaskExecutor.Append(&subUnit, dtu.taskInfo.MaxRetry())
			fmt.Printf("[%s] 加入下载队列: %s\n", info.Id(), fileList[k].Path)
		}

		result.Succeed = true // 执行成功
		return
	}

	fmt.Printf("[%s] 准备下载: %s\n", dtu.taskInfo.Id(), dtu.PcsPath)

	if !dtu.Cfg.IsTest && !dtu.IsOverwrite && FileExist(dtu.SavePath) {
		fmt.Printf("[%s] 文件已经存在: %s, 跳过...\n", dtu.taskInfo.Id(), dtu.SavePath)
		result.Succeed = true // 执行成功
		return
	}

	if !dtu.Cfg.IsTest {
		// 不是测试下载, 输出下载路径
		fmt.Printf("[%s] 将会下载到路径: %s\n\n", dtu.taskInfo.Id(), dtu.SavePath)
	}

	var ok bool
	// 获取下载链接
	switch dtu.DownloadMode {
	case DownloadModeLocate:
		ok = dtu.locateDownload(result)
	case DownloadModePCS, DownloadModeStreaming:
		ok = dtu.pcsOrStreamingDownload(dtu.DownloadMode, result)
	}

	if !ok {
		// 以上执行不成功, 返回
		return result
	}

	// 检测文件有效性
	ok = dtu.checkFileValid(result)
	if !ok {
		// 校验不成功, 返回结果
		return result
	}

	// 统计下载
	dtu.DownloadStatistic.AddTotalSize(dtu.fileInfo.Size)
	// 下载成功
	result.Succeed = true
	return
}



================================================
FILE: internal/pcsfunctions/pcsdownload/errors.go
================================================
package pcsdownload

import "errors"

var (
	// ErrDownloadNotSupportChecksum 文件不支持校验
	ErrDownloadNotSupportChecksum = errors.New("该文件不支持校验")
	// ErrDownloadChecksumFailed 文件校验失败
	ErrDownloadChecksumFailed = errors.New("该文件校验失败, 文件md5值与服务器记录的不匹配")
	// ErrDownloadFileBanned 违规文件
	ErrDownloadFileBanned = errors.New("该文件可能是违规文件, 不支持校验")
	// ErrDlinkNotFound 未取得下载链接
	ErrDlinkNotFound = errors.New("未取得下载链接")
	// ErrShareInfoNotFound 未在已分享列表中找到分享信息
	ErrShareInfoNotFound = errors.New("未在已分享列表中找到分享信息")
)



================================================
FILE: internal/pcsfunctions/pcsdownload/pcsdownload.go
================================================
package pcsdownload

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"net/http"
	"strconv"
)

// IsSkipMd5Checksum 是否忽略某些校验
func IsSkipMd5Checksum(size int64, md5Str string) bool {
	switch {
	case size == 1749504 && md5Str == "48bb9b0361dc9c672f3dc7b3ffcfde97": //8秒温馨提示
		fallthrough
	case size == 120 && md5Str == "6c1b84914588d09a6e5ec43605557457": //温馨提示文字版
		return true
	}
	return false
}

// BaiduPCSURLCheckFunc downloader 首次检查下载地址要执行的函数
func BaiduPCSURLCheckFunc(client *requester.HTTPClient, durl string) (contentLength int64, resp *http.Response, err error) {
	resp, err = client.Req(http.MethodGet, durl, nil, map[string]string{
		"Range": "bytes=0-" + strconv.FormatInt(baidupcs.MaxDownloadRangeSize-1, 10),
	})
	if err != nil {
		if resp != nil {
			resp.Body.Close()
		}
		return 0, nil, err
	}

	contentLengthStr := resp.Header.Get("x-bs-file-size")
	contentLength, _ = strconv.ParseInt(contentLengthStr, 10, 64)
	return contentLength, resp, nil
}



================================================
FILE: internal/pcsfunctions/pcsdownload/utils.go
================================================
package pcsdownload

import (
	"encoding/hex"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/checksum"
	"net/url"
	"os"
)

// CheckFileValid 检测文件有效性
func CheckFileValid(filePath string, fileInfo *baidupcs.FileDirectory) error {
	if len(fileInfo.BlockList) != 1 {
		return ErrDownloadNotSupportChecksum
	}

	f := checksum.NewLocalFileChecksum(filePath, int(baidupcs.SliceMD5Size))
	err := f.OpenPath()
	if err != nil {
		return err
	}
	defer f.Close()

	err = f.Sum(checksum.CHECKSUM_MD5)
	if err != nil {
		return err
	}
	md5Str := hex.EncodeToString(f.MD5)

	if md5Str != fileInfo.MD5 { // md5不一致
		// 检测是否为违规文件
		if IsSkipMd5Checksum(f.Length, md5Str) {
			return ErrDownloadFileBanned
		}
		return ErrDownloadChecksumFailed
	}
	return nil
}

// FileExist 检查文件是否存在,
// 只有当文件存在, 文件大小不为0或断点续传文件不存在时, 才判断为存在
func FileExist(path string) bool {
	if info, err := os.Stat(path); err == nil {
		if info.Size() == 0 {
			return false
		}
		if _, err = os.Stat(path + DownloadSuffix); err != nil {
			return true
		}
	}

	return false
}

//FixHTTPLinkURL 通过配置, 确定链接使用的协议(http,https)
func FixHTTPLinkURL(linkURL *url.URL) {
	if pcsconfig.Config.EnableHTTPS {
		if linkURL.Scheme == "http" {
			linkURL.Scheme = "https"
		}
	}
}



================================================
FILE: internal/pcsfunctions/pcsupload/pcsupload.go
================================================
// Package pcsupload 上传包
package pcsupload

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
)

const (
	UploadingFileName = "pcs_uploading.json"
)

var (
	pcsUploadVerbose = pcsverbose.New("PCSUPLOAD")
)



================================================
FILE: internal/pcsfunctions/pcsupload/upload.go
================================================
package pcsupload

import (
	"context"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/felixonmars/BaiduPCS-Go/requester/multipartreader"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"github.com/felixonmars/BaiduPCS-Go/requester/uploader"
	"io"
	"net/http"
)

type (
	PCSUpload struct {
		pcs        *baidupcs.BaiduPCS
		targetPath string
	}

	EmptyReaderLen64 struct {
	}
)

func (e EmptyReaderLen64) Read(p []byte) (n int, err error) {
	return 0, io.EOF
}

func (e EmptyReaderLen64) Len() int64 {
	return 0
}

func NewPCSUpload(pcs *baidupcs.BaiduPCS, targetPath string) uploader.MultiUpload {
	return &PCSUpload{
		pcs:        pcs,
		targetPath: targetPath,
	}
}

func (pu *PCSUpload) lazyInit() {
	if pu.pcs == nil {
		pu.pcs = &baidupcs.BaiduPCS{}
	}
}

// Precreate do nothing
func (pu *PCSUpload) Precreate() (err error) {
	return nil
}

func (pu *PCSUpload) TmpFile(ctx context.Context, partseq int, partOffset int64, r rio.ReaderLen64) (checksum string, uperr error) {
	pu.lazyInit()

	var respErr *uploader.MultiError
	checksum, pcsError := pu.pcs.UploadTmpFile(func(uploadURL string, jar http.CookieJar) (resp *http.Response, err error) {
		client := pcsconfig.Config.PCSHTTPClient()
		client.SetCookiejar(jar)
		client.SetTimeout(0)

		mr := multipartreader.NewMultipartReader()
		mr.AddFormFile("uploadedfile", "", r)
		mr.CloseMultipart()

		doneChan := make(chan struct{}, 1)
		go func() {
			resp, err = client.Req(http.MethodPost, uploadURL, mr, nil)
			doneChan <- struct{}{}

			if resp != nil {
				// 不可恢复的错误
				switch resp.StatusCode {
				case 400, 401, 403, 413:
					respErr = &uploader.MultiError{
						Terminated: true,
					}
				}
			}
		}()
		select {
		case <-ctx.Done(): // 取消
			// 返回, 让那边关闭连接
			return resp, ctx.Err()
		case <-doneChan:
			// return
		}
		return
	})

	if respErr != nil {
		respErr.Err = pcsError
		return checksum, respErr
	}

	return checksum, pcsError
}

func (pu *PCSUpload) CreateSuperFile(checksumList ...string) (err error) {
	pu.lazyInit()

	// 先在网盘目标位置, 上传一个空文件
	// 防止出现file does not exist
	pcsError := pu.pcs.Upload(pu.targetPath, func(uploadURL string, jar http.CookieJar) (resp *http.Response, err error) {
		mr := multipartreader.NewMultipartReader()
		mr.AddFormFile("file", "file", &EmptyReaderLen64{})
		mr.CloseMultipart()

		c := requester.NewHTTPClient()
		c.SetCookiejar(jar)
		return c.Req(http.MethodPost, uploadURL, mr, nil)
	})
	if pcsError != nil {
		// 修改操作
		pcsError.(*pcserror.PCSErrInfo).Operation = baidupcs.OperationUploadCreateSuperFile
		return pcsError
	}

	return pu.pcs.UploadCreateSuperFile(false, pu.targetPath, checksumList...)
}



================================================
FILE: internal/pcsfunctions/pcsupload/upload2.go
================================================
package pcsupload

/*
import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
)

type (
	// PCSUpload2 新的上传方式
	// TODO
	PCSUpload2 struct {
		pcs        *baidupcs.BaiduPCS
		targetPath string
		uploadid   string
	}
)

func NewPCSUpload2(pcs *baidupcs.BaiduPCS, targetPath string) uploader.MultiUpload {
	return &PCSUpload{
		pcs:        pcs,
		targetPath: targetPath,
	}
}

func (pu2 *PCSUpload2) lazyInit() {
	if pu2.pcs == nil {
		pu2.pcs = &baidupcs.BaiduPCS{}
	}
}

// Precreate
func (pu2 *PCSUpload2) Precreate() (err error) {
	return nil
}

func (pu2 *PCSUpload2) TmpFile(ctx context.Context, partseq int, partOffset int64, r rio.ReaderLen64) (checksum string, uperr error) {
	pu2.lazyInit()
	return pu.pcs.UploadTmpFile(func(uploadURL string, jar http.CookieJar) (resp *http.Response, err error) {
		client := pcsconfig.Config.HTTPClient()
		client.SetCookiejar(jar)
		client.SetTimeout(0)

		mr := multipartreader.NewMultipartReader()
		mr.AddFormFile("uploadedfile", "", r)
		mr.CloseMultipart()

		doneChan := make(chan struct{}, 1)
		go func() {
			resp, err = client.Req("POST", uploadURL, mr, nil)
			doneChan <- struct{}{}
		}()
		select {
		case <-ctx.Done():
			return resp, ctx.Err()
		case <-doneChan:
			// return
		}
		return
	})
}

func (pu2 *PCSUpload2) CreateSuperFile(checksumList ...string) (err error) {
	return nil
}
*/



================================================
FILE: internal/pcsfunctions/pcsupload/upload_database.go
================================================
package pcsupload

import (
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/checksum"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/jsonhelper"
	"github.com/felixonmars/BaiduPCS-Go/requester/uploader"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type (
	// Uploading 未完成上传的信息
	Uploading struct {
		*checksum.LocalFileMeta
		State *uploader.InstanceState `json:"state"`
	}

	// UploadingDatabase 未完成上传的数据库
	UploadingDatabase struct {
		UploadingList []*Uploading `json:"upload_state"`
		Timestamp     int64        `json:"timestamp"`

		dataFile *os.File
	}
)

// NewUploadingDatabase 初始化未完成上传的数据库, 从库中读取内容
func NewUploadingDatabase() (ud *UploadingDatabase, err error) {
	file, err := os.OpenFile(filepath.Join(pcsconfig.GetConfigDir(), UploadingFileName), os.O_CREATE|os.O_RDWR, 0777)
	if err != nil {
		return nil, err
	}

	ud = &UploadingDatabase{
		dataFile: file,
	}
	info, err := file.Stat()
	if err != nil {
		return nil, err
	}

	if info.Size() <= 0 {
		return ud, nil
	}

	err = jsonhelper.UnmarshalData(file, ud)
	if err != nil {
		return nil, err
	}

	return ud, nil
}

// Save 保存内容
func (ud *UploadingDatabase) Save() error {
	if ud.dataFile == nil {
		return errors.New("dataFile is nil")
	}

	ud.Timestamp = time.Now().Unix()

	var (
		builder = &strings.Builder{}
		err     = jsonhelper.MarshalData(builder, ud)
	)
	if err != nil {
		panic(err)
	}

	err = ud.dataFile.Truncate(int64(builder.Len()))
	if err != nil {
		return err
	}

	str := builder.String()
	_, err = ud.dataFile.WriteAt(converter.ToBytes(str), 0)
	if err != nil {
		return err
	}

	return nil
}

// UpdateUploading 更新正在上传
func (ud *UploadingDatabase) UpdateUploading(meta *checksum.LocalFileMeta, state *uploader.InstanceState) {
	if meta == nil {
		return
	}

	meta.CompleteAbsPath()
	for k, uploading := range ud.UploadingList {
		if uploading.LocalFileMeta == nil {
			continue
		}
		if uploading.LocalFileMeta.EqualLengthMD5(meta) || uploading.LocalFileMeta.Path == meta.Path {
			ud.UploadingList[k].State = state
			return
		}
	}

	ud.UploadingList = append(ud.UploadingList, &Uploading{
		LocalFileMeta: meta,
		State:         state,
	})
}

func (ud *UploadingDatabase) deleteIndex(k int) {
	ud.UploadingList = append(ud.UploadingList[:k], ud.UploadingList[k+1:]...)
}

// Delete 删除
func (ud *UploadingDatabase) Delete(meta *checksum.LocalFileMeta) bool {
	if meta == nil {
		return false
	}

	meta.CompleteAbsPath()
	for k, uploading := range ud.UploadingList {
		if uploading.LocalFileMeta == nil {
			continue
		}
		if uploading.LocalFileMeta.EqualLengthMD5(meta) || uploading.LocalFileMeta.Path == meta.Path {
			ud.deleteIndex(k)
			return true
		}
	}
	return false
}

// Search 搜索
func (ud *UploadingDatabase) Search(meta *checksum.LocalFileMeta) *uploader.InstanceState {
	if meta == nil {
		return nil
	}

	meta.CompleteAbsPath()
	ud.clearModTimeChange()
	for _, uploading := range ud.UploadingList {
		if uploading.LocalFileMeta == nil {
			continue
		}
		if uploading.LocalFileMeta.EqualLengthMD5(meta) {
			return uploading.State
		}
		if uploading.LocalFileMeta.Path == meta.Path {
			// 移除旧的信息
			// 目前只是比较了文件大小
			if meta.Length != uploading.LocalFileMeta.Length {
				ud.Delete(meta)
				return nil
			}

			// 覆盖数据
			meta.MD5 = uploading.LocalFileMeta.MD5
			meta.SliceMD5 = uploading.LocalFileMeta.SliceMD5
			return uploading.State
		}
	}
	return nil
}

func (ud *UploadingDatabase) clearModTimeChange() {
	for i := 0; i < len(ud.UploadingList); i++ {
		uploading := ud.UploadingList[i]
		if uploading.LocalFileMeta == nil {
			continue
		}

		if uploading.ModTime == -1 { // 忽略
			continue
		}

		info, err := os.Stat(uploading.LocalFileMeta.Path)
		if err != nil {
			ud.deleteIndex(i)
			i--
			pcsUploadVerbose.Warnf("clear invalid file path: %s, err: %s\n", uploading.LocalFileMeta.Path, err)
			continue
		}

		if uploading.LocalFileMeta.ModTime != info.ModTime().Unix() {
			ud.deleteIndex(i)
			i--
			pcsUploadVerbose.Infof("clear modified file path: %s\n", uploading.LocalFileMeta.Path)
			continue
		}
	}
}

// Close 关闭数据库
func (ud *UploadingDatabase) Close() error {
	return ud.dataFile.Close()
}



================================================
FILE: internal/pcsfunctions/pcsupload/upload_statistic.go
================================================
package pcsupload

import (
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsfunctions"
)

type (
	UploadStatistic struct {
		pcsfunctions.Statistic
	}
)



================================================
FILE: internal/pcsfunctions/pcsupload/upload_task_unit.go
================================================
package pcsupload

import (
	"bytes"
	"encoding/hex"
	"errors"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/pcserror"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsfunctions"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/checksum"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/taskframework"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"github.com/felixonmars/BaiduPCS-Go/requester/uploader"
	"path"
	"strings"
	"time"
)

type (
	// StepUpload 上传步骤
	StepUpload int

	// UploadTaskUnit 上传的任务单元
	UploadTaskUnit struct {
		LocalFileChecksum *checksum.LocalFileChecksum // 要上传的本地文件详情
		Step              StepUpload
		SavePath          string // 保存路径

		PCS               *baidupcs.BaiduPCS
		UploadingDatabase *UploadingDatabase // 数据库
		Parallel          int
		NoRapidUpload     bool // 禁用秒传
		NoSplitFile       bool // 禁用分片上传

		UploadStatistic *UploadStatistic

		taskInfo *taskframework.TaskInfo
		panDir   string
		panFile  string
		state    *uploader.InstanceState
	}
)

const (
	// StepUploadInit 初始化步骤
	StepUploadInit StepUpload = iota
	// StepUploadRapidUpload 秒传步骤
	StepUploadRapidUpload
	// StepUploadUpload 正常上传步骤
	StepUploadUpload
)

const (
	StrUploadFailed = "上传文件失败"
)

func (utu *UploadTaskUnit) SetTaskInfo(taskInfo *taskframework.TaskInfo) {
	utu.taskInfo = taskInfo
}

// prepareFile 解析文件阶段
func (utu *UploadTaskUnit) prepareFile() {
	// 解析文件保存路径
	var (
		panDir, panFile = path.Split(utu.SavePath)
	)
	utu.panDir = path.Clean(panDir)
	utu.panFile = panFile

	// 检测断点续传
	utu.state = utu.UploadingDatabase.Search(&utu.LocalFileChecksum.LocalFileMeta)
	if utu.state != nil || utu.LocalFileChecksum.LocalFileMeta.MD5 != nil { // 读取到了md5
		utu.Step = StepUploadUpload
		return
	}

	if utu.NoRapidUpload {
		utu.Step = StepUploadUpload
		return
	}

	if utu.LocalFileChecksum.Length > baidupcs.MaxRapidUploadSize {
		fmt.Printf("[%s] 文件超过20GB, 无法使用秒传功能, 跳过秒传...\n", utu.taskInfo.Id())
		utu.Step = StepUploadUpload
		return
	}
	// 下一步: 秒传
	utu.Step = StepUploadRapidUpload
}

// rapidUpload 执行秒传
func (utu *UploadTaskUnit) rapidUpload() (isContinue bool, result *taskframework.TaskUnitRunResult) {
	utu.Step = StepUploadRapidUpload

	// TODO: 建立一个通过百度错误码判断重试的函数
	result = &taskframework.TaskUnitRunResult{}

	fdl, pcsError := utu.PCS.CacheFilesDirectoriesList(utu.panDir, baidupcs.DefaultOrderOptions)
	if pcsError != nil {
		switch pcsError.GetErrType() {
		case pcserror.ErrTypeRemoteError:
			switch pcsError.GetRemoteErrCode() {
			case 31066:
			// file does not exist
			// 不缓存文件夹
			default:
				// 其他百度服务器错误, 不重试
				result.ResultMessage = "获取文件列表错误"
				result.Err = pcsError
				return
			}
		default:
			// 未知错误, 重试
			result.ResultMessage = "获取文件列表错误"
			result.NeedRetry = true
			result.Err = pcsError
			return
		}
	}

	// 文件大于128MB, 输出提示信息
	if utu.LocalFileChecksum.Length >= 128*converter.MB {
		fmt.Printf("[%s] 检测秒传中, 请稍候...\n", utu.taskInfo.Id())
	}

	// 经测试, 文件的 crc32 值并非秒传文件所必需
	err := utu.LocalFileChecksum.Sum(checksum.CHECKSUM_MD5 | checksum.CHECKSUM_SLICE_MD5)
	if err != nil {
		// 不重试
		result.ResultMessage = "计算文件秒传信息错误"
		result.Err = err
		return
	}

	// 检测缓存, 通过文件的md5值判断本地文件和网盘文件是否一样
	if fdl != nil {
		for _, fd := range fdl {
			if fd.Filename == utu.panFile {
				// TODO: fd.MD5 有可能是错误的
				decodedMD5, _ := hex.DecodeString(fd.MD5)
				if bytes.Compare(decodedMD5, utu.LocalFileChecksum.MD5) == 0 {
					fmt.Printf("[%s] 目标文件, %s, 已存在, 跳过...\n", utu.taskInfo.Id(), utu.SavePath)
					result.Succeed = true // 成功
					return
				}
			}
		}
	}

	pcsError = utu.PCS.RapidUpload(utu.SavePath, hex.EncodeToString(utu.LocalFileChecksum.MD5), hex.EncodeToString(utu.LocalFileChecksum.SliceMD5), fmt.Sprint(utu.LocalFileChecksum.CRC32), utu.LocalFileChecksum.Length)
	if pcsError == nil {
		fmt.Printf("[%s] 秒传成功, 保存到网盘路径: %s\n\n", utu.taskInfo.Id(), utu.SavePath)
		// 统计
		utu.UploadStatistic.AddTotalSize(utu.LocalFileChecksum.Length)
		result.Succeed = true // 成功
		return
	}

	// 判断配额是否已满
	switch pcsError.GetErrType() {
	// 远程服务器错误
	case pcserror.ErrTypeRemoteError:
		switch pcsError.GetRemoteErrCode() {
		case 31112: //exceed quota
			result.ResultMessage = "秒传失败, 超出配额, 网盘容量已满"
			return
		}
	}

	fmt.Printf("[%s] 秒传失败, 开始上传文件...\n\n", utu.taskInfo.Id())

	// 保存秒传信息
	utu.UploadingDatabase.UpdateUploading(&utu.LocalFileChecksum.LocalFileMeta, nil)
	utu.UploadingDatabase.Save()
	isContinue = true
	return
}

// upload 上传文件
func (utu *UploadTaskUnit) upload() (result *taskframework.TaskUnitRunResult) {
	utu.Step = StepUploadUpload

	var blockSize int64
	if utu.NoSplitFile {
		// 不分片上传
		blockSize = utu.LocalFileChecksum.Length
	} else {
		blockSize = getBlockSize(utu.LocalFileChecksum.Length)
	}

	muer := uploader.NewMultiUploader(NewPCSUpload(utu.PCS, utu.SavePath), rio.NewFileReaderAtLen64(utu.LocalFileChecksum.GetFile()), &uploader.MultiUploaderConfig{
		Parallel:  utu.Parallel,
		BlockSize: blockSize,
		MaxRate:   pcsconfig.Config.MaxUploadRate,
	})

	// 设置断点续传
	if utu.state != nil {
		muer.SetInstanceState(utu.state)
	}

	muer.OnUploadStatusEvent(func(status uploader.Status, updateChan <-chan struct{}) {
		select {
		case <-updateChan:
			utu.UploadingDatabase.UpdateUploading(&utu.LocalFileChecksum.LocalFileMeta, muer.InstanceState())
			utu.UploadingDatabase.Save()
		default:
		}

		fmt.Printf("\r[%s] ↑ %s/%s %s/s in %s ............", utu.taskInfo.Id(),
			converter.ConvertFileSize(status.Uploaded(), 2),
			converter.ConvertFileSize(status.TotalSize(), 2),
			converter.ConvertFileSize(status.SpeedsPerSecond(), 2),
			status.TimeElapsed(),
		)
	})

	// result
	result = &taskframework.TaskUnitRunResult{}
	muer.OnSuccess(func() {
		fmt.Printf("\n")
		fmt.Printf("[%s] 上传文件成功, 保存到网盘路径: %s\n", utu.taskInfo.Id(), utu.SavePath)
		// 统计
		utu.UploadStatistic.AddTotalSize(utu.LocalFileChecksum.Length)
		utu.UploadingDatabase.Delete(&utu.LocalFileChecksum.LocalFileMeta) // 删除
		utu.UploadingDatabase.Save()
		result.Succeed = true
	})
	muer.OnError(func(err error) {
		pcsError, ok := err.(pcserror.Error)
		if !ok {
			// 未知错误类型 (非预期的)
			// 不重试
			result.ResultMessage = "上传文件错误"
			result.Err = err
			return
		}

		// 默认需要重试
		result.NeedRetry = true

		switch pcsError.GetErrType() {
		case pcserror.ErrTypeRemoteError:
			// 远程百度服务器的错误
			switch pcsError.GetRemoteErrCode() {
			case 31363:
				// block miss in superfile2, 上传状态过期
				// 需要重试的
				utu.UploadingDatabase.Delete(&utu.LocalFileChecksum.LocalFileMeta)
				utu.UploadingDatabase.Save()

				result.ResultMessage = StrUploadFailed
				result.Err = errors.New("上传状态过期, 重新上传")
			case 31200:
				//服务器错误
				//[Method:Insert][Error:Insert Request Forbid]
				// do nothing
			default:
				result.ResultMessage = StrUploadFailed
				result.Err = pcsError
			}
		case pcserror.ErrTypeNetError:
			// 网络错误
			result.ResultMessage = StrUploadFailed
			result.Err = pcsError
			if strings.Contains(pcsError.GetError().Error(), "413 Request Entity Too Large") {
				// 请求实体过大
				// 不重试
				result.NeedRetry = false
				return
			}
		default:
			result.ResultMessage = StrUploadFailed
			result.NeedRetry = false
			result.Err = pcsError
		}
		return
	})
	muer.Execute()

	return
}

func (utu *UploadTaskUnit) OnRetry(lastRunResult *taskframework.TaskUnitRunResult) {
	// 输出错误信息
	if lastRunResult.Err == nil {
		// result中不包含Err, 忽略输出
		fmt.Printf("[%s] %s, 重试 %d/%d\n", utu.taskInfo.Id(), lastRunResult.ResultMessage, utu.taskInfo.Retry(), utu.taskInfo.MaxRetry())
		return
	}
	fmt.Printf("[%s] %s, %s, 重试 %d/%d\n", utu.taskInfo.Id(), lastRunResult.ResultMessage, lastRunResult.Err, utu.taskInfo.Retry(), utu.taskInfo.MaxRetry())
}

func (utu *UploadTaskUnit) OnSuccess(lastRunResult *taskframework.TaskUnitRunResult) {
}

func (utu *UploadTaskUnit) OnFailed(lastRunResult *taskframework.TaskUnitRunResult) {
	// 失败
	if lastRunResult.Err == nil {
		// result中不包含Err, 忽略输出
		fmt.Printf("[%s] %s\n", utu.taskInfo.Id(), lastRunResult.ResultMessage)
		return
	}
	fmt.Printf("[%s] %s, %s\n", utu.taskInfo.Id(), lastRunResult.ResultMessage, lastRunResult.Err)
}

func (utu *UploadTaskUnit) OnComplete(lastRunResult *taskframework.TaskUnitRunResult) {
}

func (utu *UploadTaskUnit) RetryWait() time.Duration {
	return pcsfunctions.RetryWait(utu.taskInfo.Retry())
}

func (utu *UploadTaskUnit) Run() (result *taskframework.TaskUnitRunResult) {
	fmt.Printf("[%s] 准备上传: %s\n", utu.taskInfo.Id(), utu.LocalFileChecksum.Path)

	err := utu.LocalFileChecksum.OpenPath()
	if err != nil {
		fmt.Printf("[%s] 文件不可读, 错误信息: %s, 跳过...\n", utu.taskInfo.Id(), err)
		return
	}
	defer utu.LocalFileChecksum.Close() // 关闭文件

	// 准备文件
	utu.prepareFile()

	switch utu.Step {
	case StepUploadRapidUpload:
		goto stepUploadRapidUpload
	case StepUploadUpload:
		goto stepUploadUpload
	}

stepUploadRapidUpload:
	// 秒传
	{
		isContinue, rapidUploadResult := utu.rapidUpload()
		if !isContinue {
			// 不继续, 返回秒传的结果
			return rapidUploadResult
		}
	}

stepUploadUpload:
	// 正常上传流程
	uploadResult := utu.upload()

	return uploadResult
}



================================================
FILE: internal/pcsfunctions/pcsupload/utils.go
================================================
package pcsupload

import "github.com/felixonmars/BaiduPCS-Go/baidupcs"

func getBlockSize(fileSize int64) int64 {
	blockNum := fileSize / baidupcs.MinUploadBlockSize
	if blockNum > 999 {
		return fileSize/999 + 1
	}
	return baidupcs.MinUploadBlockSize
}



================================================
FILE: internal/pcsinit/pcsinit.go
================================================
// Package pcsinit 初始化配置包
package pcsinit

import (
	"fmt"
	"github.com/urfave/cli"
	_ "unsafe" // for go:linkname
)

//go:linkname helpCommand1 github.com/felixonmars/BaiduPCS-Go/vendor/github.com/urfave/cli.helpCommand
//go:linkname helpCommand2 github.com/urfave/cli.helpCommand
var (
	helpCommand1 cli.Command
	helpCommand2 cli.Command
)

func init() {
	cli.AppHelpTemplate = `----
	{{.Name}}{{if .Usage}} - {{.Usage}}{{end}}

USAGE:
	{{if .UsageText}}{{.UsageText}}{{else}}{{.HelpName}} {{if .VisibleFlags}}[global options]{{end}}{{if .Commands}} command [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}}{{end}}{{if .Version}}{{if not .HideVersion}}

VERSION:
	{{.Version}}{{end}}{{end}}{{if .Description}}

DESCRIPTION:
	{{.Description}}{{end}}{{if len .Authors}}

AUTHOR{{with $length := len .Authors}}{{if ne 1 $length}}S{{end}}{{end}}:
	{{range $index, $author := .Authors}}{{if $index}}
	{{end}}{{$author}}{{end}}{{end}}{{if .VisibleCommands}}

COMMANDS:{{range .VisibleCategories}}{{if .Name}}
	{{.Name}}:{{end}}{{range .VisibleCommands}}
		{{join .Names ", "}}{{"\t"}}{{.Usage}}{{end}}{{end}}{{end}}{{if .VisibleFlags}}

GLOBAL OPTIONS:
	{{range $index, $option := .VisibleFlags}}{{if $index}}
	{{end}}{{$option}}{{end}}{{end}}{{if .Copyright}}

COPYRIGHT:
	{{.Copyright}}{{end}}
`

	cli.CommandHelpTemplate = `----
	{{.HelpName}} - {{.Usage}}

USAGE:
	{{if .UsageText}}{{.UsageText}}{{else}}{{.HelpName}}{{if .VisibleFlags}} [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}}{{end}}{{if .Category}}

CATEGORY:
	{{.Category}}{{end}}{{if .Description}}

DESCRIPTION:
	{{.Description}}{{end}}{{if .VisibleFlags}}

OPTIONS:
	{{range .VisibleFlags}}{{.}}
	{{end}}{{end}}
`

	cli.SubcommandHelpTemplate = `----
	{{.HelpName}} - {{.Usage}}

USAGE:
	{{if .UsageText}}{{.UsageText}}{{else}}{{.HelpName}} command{{if .VisibleFlags}} [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}}{{end}}{{if .Description}}

DESCRIPTION:
	{{.Description}}{{end}}

COMMANDS:{{range .VisibleCategories}}{{if .Name}}
	{{.Name}}:{{end}}{{range .VisibleCommands}}
		{{join .Names ", "}}{{"\t"}}{{.Usage}}{{end}}
{{end}}{{if .VisibleFlags}}
OPTIONS:
	{{range .VisibleFlags}}{{.}}
	{{end}}{{end}}
`

	helpCommand1.Aliases = append(helpCommand1.Aliases, "?", "？")
	helpCommand1.Action = func(c *cli.Context) error {
		args := c.Args()
		if args.Present() {
			err := cli.ShowCommandHelp(c, args.First())
			if err != nil {
				fmt.Printf("%s\n", err)
			}
			return nil
		}

		cli.ShowAppHelp(c)
		return nil
	}

	helpCommand2.Aliases = helpCommand1.Aliases
	helpCommand2.Action = helpCommand1.Action
}



================================================
FILE: internal/pcsinit/pcsinit.s
================================================
[Empty file]


================================================
FILE: internal/pcsupdate/github.go
================================================
package pcsupdate

type (
	// AssetInfo asset 信息
	AssetInfo struct {
		Name               string `json:"name"`
		ContentType        string `json:"content_type"`
		State              string `json:"state"`
		Size               int64  `json:"size"`
		BrowserDownloadURL string `json:"browser_download_url"`
	}

	// ReleaseInfo 发布信息
	ReleaseInfo struct {
		TagName string       `json:"tag_name"`
		Assets  []*AssetInfo `json:"assets"`
	}
)



================================================
FILE: internal/pcsupdate/pcsupdate.go
================================================
// Package pcsupdate 更新包
package pcsupdate

import (
	"archive/zip"
	"bytes"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/internal/pcsconfig"
	"github.com/felixonmars/BaiduPCS-Go/pcsliner"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/checkaccess"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/jsonhelper"
	"github.com/felixonmars/BaiduPCS-Go/requester/downloader"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"net/http"
	"path/filepath"
	"regexp"
	"runtime"
	"strconv"
	"strings"
)

const (
	// ReleaseName 分享根目录名称
	ReleaseName = "BaiduPCS-Go-releases"
)

type info struct {
	filename    string
	size        int64
	downloadURL string
}

// CheckUpdate 检测更新
func CheckUpdate(version string, yes bool) {
	if !checkaccess.AccessRDWR(pcsutil.ExecutablePath()) {
		fmt.Printf("程序目录不可写, 无法更新.\n")
		return
	}
	fmt.Println("检测更新中, 稍候...")
	c := pcsconfig.Config.HTTPClient()
	resp, err := c.Req(http.MethodGet, "https://api.github.com/repos/iikira/BaiduPCS-Go/releases/latest", nil, nil)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		fmt.Printf("获取数据错误: %s\n", err)
		return
	}

	releaseInfo := ReleaseInfo{}
	err = jsonhelper.UnmarshalData(resp.Body, &releaseInfo)
	if err != nil {
		fmt.Printf("json数据解析失败: %s\n", err)
		return
	}

	// 没有更新, 或忽略 Beta 版本, 和版本前缀不符的
	if strings.Contains(releaseInfo.TagName, "Beta") || !strings.HasPrefix(releaseInfo.TagName, "v") || version >= releaseInfo.TagName {
		fmt.Printf("未检测到更新!\n")
		return
	}

	fmt.Printf("检测到新版本: %s\n", releaseInfo.TagName)

	line := pcsliner.NewLiner()
	defer line.Close()

	if !yes {
		y, err := line.State.Prompt("是否进行更新 (y/n): ")
		if err != nil {
			fmt.Printf("输入错误: %s\n", err)
			return
		}

		if y != "y" && y != "Y" {
			fmt.Printf("更新取消.\n")
			return
		}
	}

	builder := &strings.Builder{}
	builder.WriteString("BaiduPCS-Go-" + releaseInfo.TagName + "-" + runtime.GOOS + "-.*?")
	if runtime.GOOS == "darwin" && (runtime.GOARCH == "arm" || runtime.GOARCH == "arm64") {
		builder.WriteString("arm")
	} else {
		switch runtime.GOARCH {
		case "amd64":
			builder.WriteString("(amd64|x86_64|x64)")
		case "386":
			builder.WriteString("(386|x86)")
		case "arm":
			builder.WriteString("(armv5|armv7|arm)")
		case "arm64":
			builder.WriteString("arm64")
		case "mips":
			builder.WriteString("mips")
		case "mips64":
			builder.WriteString("mips64")
		case "mipsle":
			builder.WriteString("(mipsle|mipsel)")
		case "mips64le":
			builder.WriteString("(mips64le|mips64el)")
		default:
			builder.WriteString(runtime.GOARCH)
		}
	}
	builder.WriteString("\\.zip")

	exp := regexp.MustCompile(builder.String())

	var targetList []*info
	for _, asset := range releaseInfo.Assets {
		if asset == nil || asset.State != "uploaded" {
			continue
		}

		if exp.MatchString(asset.Name) {
			targetList = append(targetList, &info{
				filename:    asset.Name,
				size:        asset.Size,
				downloadURL: asset.BrowserDownloadURL,
			})
		}
	}

	var target info
	switch len(targetList) {
	case 0:
		fmt.Printf("未匹配到当前系统的程序更新文件, GOOS: %s, GOARCH: %s\n", runtime.GOOS, runtime.GOARCH)
		return
	case 1:
		target = *targetList[0]
	default:
		fmt.Println()
		for k := range targetList {
			fmt.Printf("%d: %s\n", k, targetList[k].filename)
		}

		fmt.Println()
		t, err := line.State.Prompt("输入序号以下载更新: ")
		if err != nil {
			fmt.Printf("%s\n", err)
			return
		}

		i, err := strconv.Atoi(t)
		if err != nil {
			fmt.Printf("输入错误: %s\n", err)
			return
		}

		if i < 0 || i >= len(targetList) {
			fmt.Printf("输入错误: 序号不在范围内\n")
			return
		}

		target = *targetList[i]
	}

	if target.size > 0x7fffffff {
		fmt.Printf("file size too large: %d\n", target.size)
		return
	}

	fmt.Printf("准备下载更新: %s\n", target.filename)

	// 开始下载
	buf := rio.NewBuffer(cachepool.RawMallocByteSlice(int(target.size)))
	der := downloader.NewDownloader(target.downloadURL, buf, &downloader.Config{
		MaxParallel: 20,
		CacheSize:   10000,
	})
	der.SetClient(c)

	der.OnDownloadStatusEvent(func(status transfer.DownloadStatuser, workersCallback func(downloader.RangeWorkerFunc)) {
		var leftStr string
		left := status.TimeLeft()
		if left < 0 {
			leftStr = "-"
		} else {
			leftStr = left.String()
		}

		fmt.Printf("\r ↓ %s/%s %s/s in %s, left %s ............",
			converter.ConvertFileSize(status.Downloaded(), 2),
			converter.ConvertFileSize(status.TotalSize(), 2),
			converter.ConvertFileSize(status.SpeedsPerSecond(), 2),
			status.TimeElapsed()/1e7*1e7, leftStr,
		)
	})
	der.OnFinish(func() {
		fmt.Println()
	})
	der.OnSuccess(func() {
		fmt.Printf("下载完毕\n")
	})

	err = der.Execute()
	if err != nil {
		fmt.Printf("下载发生错误: %s\n", err)
		return
	}

	// 读取文件
	reader, err := zip.NewReader(bytes.NewReader(buf.Bytes()), target.size)
	if err != nil {
		fmt.Printf("读取更新文件发生错误: %s\n", err)
		return
	}

	execPath := pcsutil.ExecutablePath()

	var fileNum, errTimes int
	for _, zipFile := range reader.File {
		if zipFile == nil {
			continue
		}

		info := zipFile.FileInfo()

		if info.IsDir() {
			continue
		}

		rc, err := zipFile.Open()
		if err != nil {
			fmt.Printf("解析 zip 文件错误: %s\n", err)
			continue
		}

		fileNum++

		name := zipFile.Name[strings.Index(zipFile.Name, "/")+1:]
		if name == "BaiduPCS-Go" {
			err = update(pcsutil.Executable(), rc)
		} else {
			err = update(filepath.Join(execPath, name), rc)
		}

		if err != nil {
			errTimes++
			fmt.Printf("发生错误, zip 路径: %s, 错误: %s\n", zipFile.Name, err)
			continue
		}
	}

	if errTimes == fileNum {
		fmt.Printf("更新失败\n")
		return
	}

	fmt.Printf("更新完毕, 请重启程序\n")
}



================================================
FILE: internal/pcsupdate/updatefile.go
================================================
package pcsupdate

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
)

func update(targetPath string, src io.Reader) error {
	info, err := os.Stat(targetPath)
	if err != nil {
		fmt.Printf("Warning: %s\n", err)
		return nil
	}

	privMode := info.Mode()

	oldPath := filepath.Join(filepath.Dir(targetPath), "old"+filepath.Base(targetPath))

	err = os.Rename(targetPath, oldPath)
	if err != nil {
		return err
	}

	newFile, err := os.OpenFile(targetPath, os.O_CREATE|os.O_WRONLY, privMode)
	if err != nil {
		return err
	}

	_, err = io.Copy(newFile, src)
	if err != nil {
		return err
	}

	err = newFile.Close()
	if err != nil {
		fmt.Printf("Warning: 关闭文件发生错误: %s\n", err)
	}

	err = os.Remove(oldPath)
	if err != nil {
		fmt.Printf("Warning: 移除旧文件发生错误: %s\n", err)
	}
	return nil
}



================================================
FILE: pcsliner/clear.go
================================================
// +build !windows

package pcsliner

import (
	"fmt"
)

// ClearScreen 清空屏幕
func (pl *PCSLiner) ClearScreen() {
	ClearScreen()
}

// ClearScreen 清空屏幕
func ClearScreen() {
	fmt.Print("\x1b[H\x1b[2J")
}



================================================
FILE: pcsliner/clear.s
================================================
[Empty file]


================================================
FILE: pcsliner/clear_windows.go
================================================
package pcsliner

import (
	"syscall"
	"unsafe"
)

const (
	std_output_handle = uint32(-11 & 0xFFFFFFFF)
)

var (
	kernel32 = syscall.NewLazyDLL("kernel32.dll")

	procGetStdHandle               = kernel32.NewProc("GetStdHandle")
	procSetConsoleCursorPosition   = kernel32.NewProc("SetConsoleCursorPosition")
	procGetConsoleScreenBufferInfo = kernel32.NewProc("GetConsoleScreenBufferInfo")
	procFillConsoleOutputCharacter = kernel32.NewProc("FillConsoleOutputCharacterW")
)

type (
	coord struct {
		x, y int16
	}
	smallRect struct {
		left, top, right, bottom int16
	}
	consoleScreenBufferInfo struct {
		dwSize              coord
		dwCursorPosition    coord
		wAttributes         int16
		srWindow            smallRect
		dwMaximumWindowSize coord
	}
)

// ClearScreen 清空屏幕
func (pl *PCSLiner) ClearScreen() {
	ClearScreen()
}

// ClearScreen 清空屏幕
func ClearScreen() {
	out, _, _ := procGetStdHandle.Call(uintptr(std_output_handle))
	hOut := syscall.Handle(out)

	var sbi consoleScreenBufferInfo
	procGetConsoleScreenBufferInfo.Call(uintptr(hOut), uintptr(unsafe.Pointer(&sbi)))

	var numWritten uint32
	procFillConsoleOutputCharacter.Call(uintptr(hOut), uintptr(' '),
		uintptr(sbi.dwSize.x)*uintptr(sbi.dwSize.y),
		0,
		uintptr(unsafe.Pointer(&numWritten)))
	procSetConsoleCursorPosition.Call(uintptr(hOut), 0)
}



================================================
FILE: pcsliner/linehistory.go
================================================
package pcsliner

import (
	"fmt"
	"os"
)

// LineHistory 命令行历史
type LineHistory struct {
	historyFilePath string
	historyFile     *os.File
}

// NewLineHistory 设置历史
func NewLineHistory(filePath string) (lh *LineHistory, err error) {
	lh = &LineHistory{
		historyFilePath: filePath,
	}

	lh.historyFile, err = os.OpenFile(filePath, os.O_RDWR|os.O_CREATE, 0644)
	if err != nil {
		return nil, err
	}

	return lh, nil
}

// DoWriteHistory 执行写入历史
func (pl *PCSLiner) DoWriteHistory() (err error) {
	if pl.History == nil {
		return fmt.Errorf("history not set")
	}

	pl.History.historyFile, err = os.Create(pl.History.historyFilePath)
	if err != nil {
		return fmt.Errorf("写入历史错误, %s", err)
	}

	_, err = pl.State.WriteHistory(pl.History.historyFile)
	if err != nil {
		return fmt.Errorf("写入历史错误: %s", err)
	}

	return nil
}

// ReadHistory 读取历史
func (pl *PCSLiner) ReadHistory() (err error) {
	if pl.History == nil {
		return fmt.Errorf("history not set")
	}

	_, err = pl.State.ReadHistory(pl.History.historyFile)
	return err
}



================================================
FILE: pcsliner/pcsliner.go
================================================
// Package pcsliner 命令行 readline 工具包
package pcsliner

import (
	"github.com/peterh/liner"
)

// PCSLiner 封装 *liner.State, 提供更简便的操作
type PCSLiner struct {
	State   *liner.State
	History *LineHistory

	tmode liner.ModeApplier
	lmode liner.ModeApplier

	paused bool
}

// NewLiner 返回 *PCSLiner, 默认设置允许 Ctrl+C 结束
func NewLiner() *PCSLiner {
	pl := &PCSLiner{}
	pl.tmode, _ = liner.TerminalMode()

	line := liner.NewLiner()
	pl.lmode, _ = liner.TerminalMode()

	line.SetMultiLineMode(true)
	line.SetCtrlCAborts(true)

	pl.State = line

	return pl
}

// Pause 暂停服务
func (pl *PCSLiner) Pause() error {
	if pl.paused {
		panic("PCSLiner already paused")
	}

	pl.paused = true
	pl.DoWriteHistory()

	return pl.tmode.ApplyMode()
}

// Resume 恢复服务
func (pl *PCSLiner) Resume() error {
	if !pl.paused {
		panic("PCSLiner is not paused")
	}

	pl.paused = false

	return pl.lmode.ApplyMode()
}

// Close 关闭服务
func (pl *PCSLiner) Close() (err error) {
	err = pl.State.Close()
	if err != nil {
		return err
	}

	if pl.History != nil && pl.History.historyFile != nil {
		return pl.History.historyFile.Close()
	}

	return nil
}



================================================
FILE: pcsliner/args/args.go
================================================
package args

import (
	"strings"
	"unicode"
)

const (
	CharEscape      = '\\'
	CharSingleQuote = '\''
	CharDoubleQuote = '"'
	CharBackQuote   = '`'
)

// IsQuote 是否为引号
func IsQuote(r rune) bool {
	return r == CharSingleQuote || r == CharDoubleQuote || r == CharBackQuote
}

// Parse 解析line, 忽略括号
func Parse(line string) (lineArgs []string) {
	var (
		rl        = []rune(line + " ")
		buf       = strings.Builder{}
		quoteChar rune
		nextChar  rune
		escaped   bool
		in        bool
	)

	var (
		isSpace bool
	)

	for k, r := range rl {
		isSpace = unicode.IsSpace(r)
		if !isSpace && !in {
			in = true
		}

		switch {
		case escaped: // 已转义, 跳过
			escaped = false
			//pass
		case r == CharEscape: // 转义模式
			if k+1+1 < len(rl) { // 不是最后一个字符, 多+1是因为最后一个空格
				nextChar = rl[k+1]
				// 仅支持转义这些字符, 否则原样输出反斜杠
				if unicode.IsSpace(nextChar) || IsQuote(nextChar) || nextChar == CharEscape {
					escaped = true
					continue
				}
			}
			// pass
		case IsQuote(r):
			if quoteChar == 0 { //未引
				quoteChar = r
				continue
			}

			if quoteChar == r { //取消引
				quoteChar = 0
				continue
			}
		case isSpace:
			if !in { // 忽略多余的空格
				continue
			}
			if quoteChar == 0 { // 未在引号内
				lineArgs = append(lineArgs, buf.String())
				buf.Reset()
				in = false
				continue
			}
		}

		buf.WriteRune(r)
	}

	return
}



================================================
FILE: pcsliner/args/args_test.go
================================================
package args_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsliner/args"
	"testing"
)

func TestParseArgs(t *testing.T) {
	as := args.Parse(`  one two three "double quotes" 'single quotes'  ""   arg\ with\ spaces "\"quotes\" in 'quotes'" '"quotes" in \'quotes'"  "   `)
	for k := range as {
		fmt.Printf("%d: %s|\n", k, as[k])
	}

	as = args.Parse(` cd  英语_800个有趣句子帮你记忆7000个单词_42页.doc`)
	for k := range as {
		fmt.Printf("%d: %s|\n", k, as[k])
	}
}



================================================
FILE: pcstable/pcstable.go
================================================
// Package pcstable 格式化表格包
package pcstable

import (
	"github.com/olekukonko/tablewriter"
	"io"
)

// PCSTable 封装 tablewriter.Table
type PCSTable struct {
	*tablewriter.Table
}

// NewTable 预设了一些配置
func NewTable(wt io.Writer) PCSTable {
	tb := tablewriter.NewWriter(wt)
	tb.SetAutoWrapText(false)
	tb.SetBorder(false)
	tb.SetHeaderLine(false)
	tb.SetColumnSeparator("")
	return PCSTable{tb}
}



================================================
FILE: pcsutil/addr.go
================================================
package pcsutil

import (
	"net"
)

// ListAddresses 列出本地可用的 IP 地址
func ListAddresses() (addresses []string) {
	iFaces, _ := net.Interfaces()
	addresses = make([]string, 0, len(iFaces))
	for k := range iFaces {
		iFaceAddrs, _ := iFaces[k].Addrs()
		for l := range iFaceAddrs {
			switch v := iFaceAddrs[l].(type) {
			case *net.IPNet:
				addresses = append(addresses, v.IP.String())
			case *net.IPAddr:
				addresses = append(addresses, v.IP.String())
			}
		}
	}
	return
}

// ParseHost 解析地址中的host
func ParseHost(address string) string {
	h, _, err := net.SplitHostPort(address)
	if err != nil {
		return address
	}
	return h
}



================================================
FILE: pcsutil/crypto.go
================================================
package pcsutil

import (
	"fmt"
	"github.com/felixonmars/Baidu-Login/bdcrypto"
	"io"
	"os"
	"strings"
)

// CryptoMethodSupport 检测是否支持加密解密方法
func CryptoMethodSupport(method string) bool {
	switch method {
	case "aes-128-ctr", "aes-192-ctr", "aes-256-ctr", "aes-128-cfb", "aes-192-cfb", "aes-256-cfb", "aes-128-ofb", "aes-192-ofb", "aes-256-ofb":
		return true
	}

	return false
}

// EncryptFile 加密本地文件
func EncryptFile(method string, key []byte, filePath string, isGzip bool) (encryptedFilePath string, err error) {
	if !CryptoMethodSupport(method) {
		return "", fmt.Errorf("unknown encrypt method: %s", method)
	}

	if isGzip {
		err = bdcrypto.GZIPCompressFile(filePath)
		if err != nil {
			return
		}
	}

	plainFile, err := os.OpenFile(filePath, os.O_RDONLY, 0)
	if err != nil {
		return
	}

	defer plainFile.Close()

	var cipherReader io.Reader
	switch method {
	case "aes-128-ctr":
		cipherReader, err = bdcrypto.Aes128CTREncrypt(bdcrypto.Convert16bytes(key), plainFile)
	case "aes-192-ctr":
		cipherReader, err = bdcrypto.Aes192CTREncrypt(bdcrypto.Convert24bytes(key), plainFile)
	case "aes-256-ctr":
		cipherReader, err = bdcrypto.Aes256CTREncrypt(bdcrypto.Convert32bytes(key), plainFile)
	case "aes-128-cfb":
		cipherReader, err = bdcrypto.Aes128CFBEncrypt(bdcrypto.Convert16bytes(key), plainFile)
	case "aes-192-cfb":
		cipherReader, err = bdcrypto.Aes192CFBEncrypt(bdcrypto.Convert24bytes(key), plainFile)
	case "aes-256-cfb":
		cipherReader, err = bdcrypto.Aes256CFBEncrypt(bdcrypto.Convert32bytes(key), plainFile)
	case "aes-128-ofb":
		cipherReader, err = bdcrypto.Aes128OFBEncrypt(bdcrypto.Convert16bytes(key), plainFile)
	case "aes-192-ofb":
		cipherReader, err = bdcrypto.Aes192OFBEncrypt(bdcrypto.Convert24bytes(key), plainFile)
	case "aes-256-ofb":
		cipherReader, err = bdcrypto.Aes256OFBEncrypt(bdcrypto.Convert32bytes(key), plainFile)
	default:
		return "", fmt.Errorf("unknown encrypt method: %s", method)
	}

	if err != nil {
		return
	}

	plainFileInfo, err := plainFile.Stat()
	if err != nil {
		return
	}

	encryptedFilePath = filePath + ".encrypt"
	encryptedFile, err := os.OpenFile(encryptedFilePath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, plainFileInfo.Mode())
	if err != nil {
		return
	}

	defer encryptedFile.Close()

	_, err = io.Copy(encryptedFile, cipherReader)
	if err != nil {
		return
	}

	os.Remove(filePath)

	return encryptedFilePath, nil
}

// DecryptFile 加密本地文件
func DecryptFile(method string, key []byte, filePath string, isGzip bool) (decryptedFilePath string, err error) {
	if !CryptoMethodSupport(method) {
		return "", fmt.Errorf("unknown decrypt method: %s", method)
	}

	cipherFile, err := os.OpenFile(filePath, os.O_RDONLY, 0644)
	if err != nil {
		return
	}

	defer cipherFile.Close()

	var plainReader io.Reader
	switch method {
	case "aes-128-ctr":
		plainReader, err = bdcrypto.Aes128CTRDecrypt(bdcrypto.Convert16bytes(key), cipherFile)
	case "aes-192-ctr":
		plainReader, err = bdcrypto.Aes192CTRDecrypt(bdcrypto.Convert24bytes(key), cipherFile)
	case "aes-256-ctr":
		plainReader, err = bdcrypto.Aes256CTRDecrypt(bdcrypto.Convert32bytes(key), cipherFile)
	case "aes-128-cfb":
		plainReader, err = bdcrypto.Aes128CFBDecrypt(bdcrypto.Convert16bytes(key), cipherFile)
	case "aes-192-cfb":
		plainReader, err = bdcrypto.Aes192CFBDecrypt(bdcrypto.Convert24bytes(key), cipherFile)
	case "aes-256-cfb":
		plainReader, err = bdcrypto.Aes256CFBDecrypt(bdcrypto.Convert32bytes(key), cipherFile)
	case "aes-128-ofb":
		plainReader, err = bdcrypto.Aes128OFBDecrypt(bdcrypto.Convert16bytes(key), cipherFile)
	case "aes-192-ofb":
		plainReader, err = bdcrypto.Aes192OFBDecrypt(bdcrypto.Convert24bytes(key), cipherFile)
	case "aes-256-ofb":
		plainReader, err = bdcrypto.Aes256OFBDecrypt(bdcrypto.Convert32bytes(key), cipherFile)
	default:
		return "", fmt.Errorf("unknown decrypt method: %s", method)
	}

	if err != nil {
		return
	}

	cipherFileInfo, err := cipherFile.Stat()
	if err != nil {
		return
	}

	decryptedFilePath = strings.TrimSuffix(filePath, ".encrypt")
	decryptedTmpFilePath := decryptedFilePath + ".decrypted"
	decryptedTmpFile, err := os.OpenFile(decryptedTmpFilePath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, cipherFileInfo.Mode())
	if err != nil {
		return
	}

	_, err = io.Copy(decryptedTmpFile, plainReader)
	if err != nil {
		return
	}

	defer decryptedTmpFile.Close()

	if isGzip {
		err = bdcrypto.GZIPUnompressFile(decryptedTmpFilePath)
		if err != nil {
			os.Remove(decryptedTmpFilePath)
			return
		}

		// 删除已加密的文件
		os.Remove(filePath)
	}

	if filePath != decryptedFilePath {
		os.Rename(decryptedTmpFilePath, decryptedFilePath)
	} else {
		decryptedFilePath = decryptedTmpFilePath
	}

	return decryptedFilePath, nil
}



================================================
FILE: pcsutil/error.go
================================================
package pcsutil

import (
	"log"
	"os"
)

// PrintErrIfExist 简易错误处理, 如果 err 存在, 就只向屏幕输出 err 。
func PrintErrIfExist(err error) {
	if err != nil {
		log.Println(err)
	}
}

// PrintErrAndExit 简易错误处理, 如果 err 存在, 向屏幕输出 err 并退出, annotate 是加在 err 之前的注释信息。
func PrintErrAndExit(annotate string, err error) {
	if err != nil {
		log.Println(annotate, err)
		os.Exit(1)
	}
}



================================================
FILE: pcsutil/file.go
================================================
package pcsutil

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/kardianos/osext"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"strings"
)

func IsPipeInput() bool {
	fileInfo, err := os.Stdin.Stat()
	if err != nil {
		return false
	}
	return (fileInfo.Mode() & os.ModeNamedPipe) == os.ModeNamedPipe
}

// IsIPhoneOS 是否为苹果移动设备
func IsIPhoneOS() bool {
	if runtime.GOOS == "darwin" && (runtime.GOARCH == "arm" || runtime.GOARCH == "arm64") {
		_, err := os.Stat("Info.plist")
		return err == nil
	}
	return false
}

// ChWorkDir 切换回工作目录
func ChWorkDir() {
	if !IsIPhoneOS() {
		return
	}

	dir, err := filepath.Abs("")
	if err != nil {
		return
	}

	subPath := filepath.Dir(os.Args[0])
	os.Chdir(strings.TrimSuffix(dir, subPath))
}

// Executable 获取程序所在的真实目录或真实相对路径
func Executable() string {
	executablePath, err := osext.Executable()
	if err != nil {
		pcsverbose.Verbosef("DEBUG: osext.Executable: %s\n", err)
		executablePath, err = filepath.Abs(filepath.Dir(os.Args[0]))
		if err != nil {
			pcsverbose.Verbosef("DEBUG: filepath.Abs: %s\n", err)
			executablePath = filepath.Dir(os.Args[0])
		}
	}

	if IsIPhoneOS() {
		executablePath = filepath.Join(strings.TrimSuffix(executablePath, os.Args[0]), filepath.Base(os.Args[0]))
	}

	// 读取链接
	linkedExecutablePath, err := filepath.EvalSymlinks(executablePath)
	if err != nil {
		pcsverbose.Verbosef("DEBUG: filepath.EvalSymlinks: %s\n", err)
		return executablePath
	}
	return linkedExecutablePath
}

// ExecutablePath 获取程序所在目录
func ExecutablePath() string {
	return filepath.Dir(Executable())
}

// ExecutablePathJoin 返回程序所在目录的子目录
func ExecutablePathJoin(subPath string) string {
	return filepath.Join(ExecutablePath(), subPath)
}

// WalkDir 获取指定目录及所有子目录下的所有文件，可以匹配后缀过滤。
// 支持 Linux/macOS 软链接
func WalkDir(dirPth, suffix string) (files []string, err error) {
	files = make([]string, 0, 32)
	suffix = strings.ToUpper(suffix) //忽略后缀匹配的大小写

	var walkFunc filepath.WalkFunc
	walkFunc = func(filename string, fi os.FileInfo, err error) error { //遍历目录
		if err != nil {
			return err
		}
		if fi.IsDir() { // 忽略目录
			return nil
		}
		if fi.Mode()&os.ModeSymlink != 0 { // 读取 symbol link
			err = filepath.Walk(filename+string(os.PathSeparator), walkFunc)
			return err
		}

		if strings.HasSuffix(strings.ToUpper(fi.Name()), suffix) {
			files = append(files, path.Clean(filename))
		}
		return nil
	}

	err = filepath.Walk(dirPth, walkFunc)
	return files, err
}

// ConvertToUnixPathSeparator 将 windows 目录分隔符转换为 Unix 的
func ConvertToUnixPathSeparator(p string) string {
	return strings.Replace(p, "\\", "/", -1)
}



================================================
FILE: pcsutil/file_test.go
================================================
package pcsutil_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"testing"
)

func TestWalkDir(t *testing.T) {
	files, err := pcsutil.WalkDir("/Users/syy/tmp", "")
	if err != nil {
		t.Fatal(err)
	}
	for _, file := range files {
		fmt.Println(file)
	}
}



================================================
FILE: pcsutil/log_colorable_prefix.go
================================================
package pcsutil

import (
	"fmt"
	"github.com/fatih/color"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/pcstime"
	"log"
)

var (
	// ErrorColor 设置输出错误的颜色
	ErrorColor = color.New(color.FgRed).SprintFunc()
)

// 自定义log writer
type logWriter struct{}

func (logWriter) Write(bytes []byte) (int, error) {
	return fmt.Fprint(color.Output, "["+pcstime.BeijingTimeOption("Refer")+"] "+string(bytes))
}

// SetLogPrefix 设置日志输出的时间前缀
func SetLogPrefix() {
	log.SetFlags(0)
	log.SetOutput(new(logWriter))
}



================================================
FILE: pcsutil/pcsutil.go
================================================
// Package pcsutil 工具包
package pcsutil

import (
	"compress/gzip"
	"flag"
	"io"
	"io/ioutil"
	"net/http/cookiejar"
	"net/url"
	"strings"
)

// TrimPathPrefix 去除目录的前缀
func TrimPathPrefix(path, prefixPath string) string {
	if prefixPath == "/" {
		return path
	}
	return strings.TrimPrefix(path, prefixPath)
}

// ContainsString 检测字符串是否在字符串数组里
func ContainsString(ss []string, s string) bool {
	for k := range ss {
		if ss[k] == s {
			return true
		}
	}
	return false
}

// GetURLCookieString 返回cookie字串
func GetURLCookieString(urlString string, jar *cookiejar.Jar) string {
	u, _ := url.Parse(urlString)
	cookies := jar.Cookies(u)
	cookieString := ""
	for _, v := range cookies {
		cookieString += v.String() + "; "
	}
	cookieString = strings.TrimRight(cookieString, "; ")
	return cookieString
}

// DecompressGZIP 对 io.Reader 数据, 进行 gzip 解压
func DecompressGZIP(r io.Reader) ([]byte, error) {
	gzipReader, err := gzip.NewReader(r)
	if err != nil {
		return nil, err
	}
	gzipReader.Close()
	return ioutil.ReadAll(gzipReader)
}

// FlagProvided 检测命令行是否提供名为 name 的 flag, 支持多个name(names)
func FlagProvided(names ...string) bool {
	if len(names) == 0 {
		return false
	}
	var targetFlag *flag.Flag
	for _, name := range names {
		targetFlag = flag.Lookup(name)
		if targetFlag == nil {
			return false
		}
		if targetFlag.DefValue == targetFlag.Value.String() {
			return false
		}
	}
	return true
}

// Trigger 用于触发事件
func Trigger(f func()) {
	if f == nil {
		return
	}
	go f()
}

// TriggerOnSync 用于触发事件, 同步触发
func TriggerOnSync(f func()) {
	if f == nil {
		return
	}
	f()
}



================================================
FILE: pcsutil/regexp_pre.go
================================================
package pcsutil

import (
	"regexp"
)

var (
	// HTTPSRE https regexp
	HTTPSRE = regexp.MustCompile("^https")
	// ChinaPhoneRE https regexp
	ChinaPhoneRE = regexp.MustCompile(`^(\+86)?1[3-9][0-9]\d{8}$`)
)



================================================
FILE: pcsutil/cachepool/cachepool.go
================================================
package cachepool

import (
	"sync"
)

var (
	//CachePool []byte 缓存池 2
	CachePool = cachePool2{}
)

//Cache cache
type Cache interface {
	Bytes() []byte
	Free()
}

type cache struct {
	isUsed bool
	b      []byte
}

func (c *cache) Bytes() []byte {
	if !c.isUsed {
		return nil
	}
	return c.b
}

func (c *cache) Free() {
	c.isUsed = false
}

type cachePool2 struct {
	pool []*cache
	mu   sync.Mutex
}

func (cp2 *cachePool2) Require(size int) Cache {
	cp2.mu.Lock()
	defer cp2.mu.Unlock()
	for k := range cp2.pool {
		if cp2.pool[k] == nil || cp2.pool[k].isUsed || len(cp2.pool[k].b) < size {
			continue
		}

		cp2.pool[k].isUsed = true
		return cp2.pool[k]
	}
	newCache := &cache{
		isUsed: true,
		b:      RawMallocByteSlice(size),
	}
	cp2.addCache(newCache)
	return newCache
}

func (cp2 *cachePool2) addCache(newCache *cache) {
	for k := range cp2.pool {
		if cp2.pool[k] == nil {
			cp2.pool[k] = newCache
			return
		}
	}
	cp2.pool = append(cp2.pool, newCache)
}

func (cp2 *cachePool2) DeleteNotUsed() {
	cp2.mu.Lock()
	defer cp2.mu.Unlock()
	for k := range cp2.pool {
		if cp2.pool[k] == nil {
			continue
		}

		if !cp2.pool[k].isUsed {
			cp2.pool[k] = nil
		}
	}
}

func (cp2 *cachePool2) DeleteAll() {
	cp2.mu.Lock()
	defer cp2.mu.Unlock()
	for k := range cp2.pool {
		cp2.pool[k] = nil
	}
}

//Require 申请Cache
func Require(size int) Cache {
	return CachePool.Require(size)
}



================================================
FILE: pcsutil/cachepool/idcachepool.go
================================================
// Package cachepool []byte缓存池
package cachepool

import (
	"sync"
	"sync/atomic"
)

var (
	// IDCachePool []byte 缓存池
	IDCachePool = cachePool{
		cachepool: sync.Map{},
	}
)

type cachePool struct {
	lastID    int32
	cachepool sync.Map
}

func (cp *cachePool) Apply(size int) (id int32) {
	for {
		_, ok := cp.cachepool.Load(cp.lastID)
		atomic.AddInt32(&cp.lastID, 1)
		if ok {
			continue
		}
		break
	}

	cp.Set(cp.lastID, size)
	return cp.lastID
}

func (cp *cachePool) Existed(id int32) (existed bool) {
	_, existed = cp.cachepool.Load(id)
	return
}

func (cp *cachePool) Get(id int32) []byte {
	cache, ok := cp.cachepool.Load(id)
	if !ok {
		return nil
	}
	return cache.([]byte)
}

func (cp *cachePool) Set(id int32, size int) []byte {
	cache := RawMallocByteSlice(size)
	cp.cachepool.Store(id, cache)
	return cp.Get(id)
}

func (cp *cachePool) SetIfNotExist(id int32, size int) []byte {
	ok := cp.Existed(id)
	cache := cp.Get(id)
	if !ok || len(cache) < size {
		cache = nil
		cp.Delete(id)
		cp.Set(id, size)
	}
	return cp.Get(id)
}

func (cp *cachePool) Delete(id int32) {
	cp.cachepool.Store(id, nil)
	cp.cachepool.Delete(id)
}

func (cp *cachePool) DeleteAll() {
	cp.cachepool.Range(func(k interface{}, _ interface{}) bool {
		cp.Delete(k.(int32))
		return true
	})
}

// Apply 申请缓存, 返回缓存id
func Apply(size int) (id int32) {
	return IDCachePool.Apply(size)
}

// Existed 通过缓存id检测是否存在缓存
func Existed(id int32) bool {
	return IDCachePool.Existed(id)
}

// Get 通过缓存id获取缓存[]byte
func Get(id int32) []byte {
	return IDCachePool.Get(id)
}

// Set 设置缓存, 通过给定的缓存id
func Set(id int32, size int) []byte {
	return IDCachePool.Set(id, size)
}

// SetIfNotExist 如果缓存不存在, 则设置缓存池
func SetIfNotExist(id int32, size int) []byte {
	return IDCachePool.SetIfNotExist(id, size)
}

// Delete 通过缓存id删除缓存
func Delete(id int32) {
	IDCachePool.Delete(id)
}

// DeleteAll 清空缓存池
func DeleteAll() {
	IDCachePool.DeleteAll()
}



================================================
FILE: pcsutil/cachepool/malloc.go
================================================
package cachepool

import (
	"reflect"
	"unsafe"
)

//go:linkname mallocgc runtime.mallocgc
func mallocgc(size uintptr, typ uintptr, needzero bool) unsafe.Pointer

//go:linkname rawbyteslice runtime.rawbyteslice
func rawbyteslice(size int) (b []byte)

// RawByteSlice point to runtime.rawbyteslice
func RawByteSlice(size int) (b []byte) {
	return rawbyteslice(size)
}

// RawMalloc allocates a new slice. The slice is not zeroed.
func RawMalloc(size int) unsafe.Pointer {
	return mallocgc(uintptr(size), 0, false)
}

// RawMallocByteSlice allocates a new byte slice. The slice is not zeroed.
func RawMallocByteSlice(size int) []byte {
	p := mallocgc(uintptr(size), 0, false)
	b := *(*[]byte)(unsafe.Pointer(&reflect.SliceHeader{
		Data: uintptr(p),
		Len:  size,
		Cap:  size,
	}))
	return b
}



================================================
FILE: pcsutil/cachepool/malloc.s
================================================
[Empty file]


================================================
FILE: pcsutil/cachepool/malloc_test.go
================================================
package cachepool_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"reflect"
	"runtime"
	"testing"
	"unsafe"
)

func TestMalloc(t *testing.T) {
	b := cachepool.RawMallocByteSlice(128)
	for k := range b {
		b[k] = byte(k)
	}
	fmt.Println(b)
	runtime.GC()

	b = cachepool.RawMallocByteSlice(128)
	fmt.Printf("---%s---\n", b)
	runtime.GC()

	b = cachepool.RawByteSlice(128)
	fmt.Println(b)
	runtime.GC()

	b = cachepool.RawByteSlice(127)
	bH := (*reflect.SliceHeader)(unsafe.Pointer(&b))
	fmt.Printf("%#v\n", bH)
}



================================================
FILE: pcsutil/cachepool/syncpool.go
================================================
package cachepool

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"runtime"
	"sync"
)

var (
	syncPoolSize     = int(64 * converter.KB)
	syncPoolFirstNew = false
	SyncPool         = sync.Pool{
		New: func() interface{} {
			syncPoolFirstNew = true
			return RawMallocByteSlice(syncPoolSize)
		},
	}
)

func SetSyncPoolSize(size int) {
	if syncPoolFirstNew && size != syncPoolSize {
		runtime.GC()
	}
	syncPoolSize = size
}



================================================
FILE: pcsutil/checkaccess/check_others.go
================================================
//+build aix plan9

package checkaccess

func AccessRDWR(path string) bool {
	return true
}



================================================
FILE: pcsutil/checkaccess/check_unix.go
================================================
// +build !windows,!plan9,!aix

package checkaccess

import (
	"syscall"
)

func AccessRDWR(path string) bool {
	return syscall.Access(path, syscall.O_RDWR) == nil
}



================================================
FILE: pcsutil/checkaccess/check_windows.go
================================================
package checkaccess

// TODO: check writable

func AccessRDWR(path string) bool {
	return true
}



================================================
FILE: pcsutil/checkaccess/checkaccess.go
================================================
package checkaccess



================================================
FILE: pcsutil/checksum/checksum.go
================================================
// Package checksum 校验本地文件包
package checksum

import (
	"crypto/md5"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"hash/crc32"
	"io"
	"os"
)

const (
	// DefaultBufSize 默认的bufSize
	DefaultBufSize = int(256 * converter.KB)
)

const (
	// CHECKSUM_MD5 获取文件的 md5 值
	CHECKSUM_MD5 int = 1 << iota
	// CHECKSUM_SLICE_MD5 获取文件前 sliceSize 切片的 md5 值
	CHECKSUM_SLICE_MD5
	// CHECKSUM_CRC32 获取文件的 crc32 值
	CHECKSUM_CRC32
)

type (
	// LocalFileMeta 本地文件元信息
	LocalFileMeta struct {
		Path     string `json:"path"`     // 本地路径
		Length   int64  `json:"length"`   // 文件大小
		SliceMD5 []byte `json:"slicemd5"` // 文件前 requiredSliceLen (256KB) 切片的 md5 值
		MD5      []byte `json:"md5"`      // 文件的 md5
		CRC32    uint32 `json:"crc32"`    // 文件的 crc32
		ModTime  int64  `json:"modtime"`  // 修改日期
	}

	// LocalFileChecksum 校验本地文件
	LocalFileChecksum struct {
		LocalFileMeta
		bufSize   int
		sliceSize int
		buf       []byte
		file      *os.File // 文件
	}
)

func NewLocalFileChecksum(localPath string, sliceSize int) *LocalFileChecksum {
	return NewLocalFileChecksumWithBufSize(localPath, DefaultBufSize, sliceSize)
}

func NewLocalFileChecksumWithBufSize(localPath string, bufSize, sliceSize int) *LocalFileChecksum {
	return &LocalFileChecksum{
		LocalFileMeta: LocalFileMeta{
			Path: localPath,
		},
		bufSize:   bufSize,
		sliceSize: sliceSize,
	}
}

// OpenPath 检查文件状态并获取文件的大小 (Length)
func (lfc *LocalFileChecksum) OpenPath() error {
	if lfc.file != nil {
		lfc.file.Close()
	}

	var err error
	lfc.file, err = os.Open(lfc.Path)
	if err != nil {
		return err
	}

	info, err := lfc.file.Stat()
	if err != nil {
		return err
	}

	lfc.Length = info.Size()
	lfc.ModTime = info.ModTime().Unix()
	return nil
}

// GetFile 获取文件
func (lfc *LocalFileChecksum) GetFile() *os.File {
	return lfc.file
}

// Close 关闭文件
func (lfc *LocalFileChecksum) Close() error {
	if lfc.file == nil {
		return ErrFileIsNil
	}

	return lfc.file.Close()
}

func (lfc *LocalFileChecksum) initBuf() {
	if lfc.buf == nil {
		lfc.buf = cachepool.RawMallocByteSlice(lfc.bufSize)
	}
}

func (lfc *LocalFileChecksum) writeChecksum(data []byte, wus ...*ChecksumWriteUnit) (err error) {
	doneCount := 0
	for _, wu := range wus {
		_, err := wu.Write(data)
		switch err {
		case ErrChecksumWriteStop:
			doneCount++
			continue
		case nil:
		default:
			return err
		}
	}
	if doneCount == len(wus) {
		return ErrChecksumWriteAllStop
	}
	return nil
}

func (lfc *LocalFileChecksum) repeatRead(wus ...*ChecksumWriteUnit) (err error) {
	if lfc.file == nil {
		return ErrFileIsNil
	}

	lfc.initBuf()

	defer func() {
		_, err = lfc.file.Seek(0, os.SEEK_SET) // 恢复文件指针
		if err != nil {
			return
		}
	}()

	// 读文件
	var (
		n int
	)
read:
	for {
		n, err = lfc.file.Read(lfc.buf)
		switch err {
		case io.EOF:
			err = lfc.writeChecksum(lfc.buf[:n], wus...)
			break read
		case nil:
			err = lfc.writeChecksum(lfc.buf[:n], wus...)
		default:
			return
		}
	}
	switch err {
	case ErrChecksumWriteAllStop: // 全部结束
		err = nil
	}
	return
}

func (lfc *LocalFileChecksum) createChecksumWriteUnit(cw ChecksumWriter, isAll, isSlice bool, getSumFunc func(sliceSum interface{}, sum interface{})) (wu *ChecksumWriteUnit, deferFunc func(err error)) {
	wu = &ChecksumWriteUnit{
		ChecksumWriter: cw,
		End:            lfc.LocalFileMeta.Length,
		OnlySliceSum:   !isAll,
	}

	if isSlice {
		wu.SliceEnd = int64(lfc.sliceSize)
	}

	return wu, func(err error) {
		if err != nil {
			return
		}
		getSumFunc(wu.SliceSum, wu.Sum)
	}
}

// Sum 计算文件摘要值
func (lfc *LocalFileChecksum) Sum(checkSumFlag int) (err error) {
	lfc.fix()
	wus := make([]*ChecksumWriteUnit, 0, 2)
	if (checkSumFlag & (CHECKSUM_MD5 | CHECKSUM_SLICE_MD5)) != 0 {
		md5w := md5.New()
		wu, d := lfc.createChecksumWriteUnit(
			NewHashChecksumWriter(md5w),
			(checkSumFlag&CHECKSUM_MD5) != 0,
			(checkSumFlag&CHECKSUM_SLICE_MD5) != 0,
			func(sliceSum interface{}, sum interface{}) {
				if sliceSum != nil {
					lfc.SliceMD5 = sliceSum.([]byte)
				}
				if sum != nil {
					lfc.MD5 = sum.([]byte)
				}
			},
		)

		wus = append(wus, wu)
		defer d(err)
	}
	if (checkSumFlag & CHECKSUM_CRC32) != 0 {
		crc32w := crc32.NewIEEE()
		wu, d := lfc.createChecksumWriteUnit(
			NewHash32ChecksumWriter(crc32w),
			true,
			false,
			func(sliceSum interface{}, sum interface{}) {
				if sum != nil {
					lfc.CRC32 = sum.(uint32)
				}
			},
		)

		wus = append(wus, wu)
		defer d(err)
	}

	err = lfc.repeatRead(wus...)
	return
}

func (lfc *LocalFileChecksum) fix() {
	if lfc.sliceSize <= 0 {
		lfc.sliceSize = DefaultBufSize
	}
	if lfc.bufSize < DefaultBufSize {
		lfc.bufSize = DefaultBufSize
	}
}



================================================
FILE: pcsutil/checksum/checksum_test.go
================================================
package checksum_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/checksum"
	"testing"
)

var (
	flagList = []int{
		checksum.CHECKSUM_MD5 | 000000000000000000000000000 | 00000000000000000000000,
		000000000000000000000 | checksum.CHECKSUM_SLICE_MD5 | 00000000000000000000000,
		000000000000000000000 | 000000000000000000000000000 | checksum.CHECKSUM_CRC32,
		checksum.CHECKSUM_MD5 | checksum.CHECKSUM_SLICE_MD5 | 00000000000000000000000,
		000000000000000000000 | checksum.CHECKSUM_SLICE_MD5 | checksum.CHECKSUM_CRC32,
		checksum.CHECKSUM_MD5 | 000000000000000000000000000 | checksum.CHECKSUM_CRC32,
		checksum.CHECKSUM_MD5 | checksum.CHECKSUM_SLICE_MD5 | checksum.CHECKSUM_CRC32,
	}
)

func printFileMeta(meta *checksum.LocalFileMeta) {
	fmt.Printf("slicemd5: %x, md5: %x, crc32: %x %d\n", meta.SliceMD5, meta.MD5, meta.CRC32, meta.CRC32)
}

func TestChecksum(t *testing.T) {
	fmt.Println("--- file.go")
	for _, flag := range flagList {
		lf, err := checksum.GetFileSum("file.go", flag)
		if err != nil {
			t.Fatal(err)
		}
		printFileMeta(&lf.LocalFileMeta)
	}

	fmt.Println("--- /Users/syy/go/src/github.com/felixonmars/BaiduPCS-Go/BaiduPCS-Go")
	for _, flag := range flagList {
		lf := checksum.NewLocalFileChecksumWithBufSize("/Users/syy/go/src/github.com/felixonmars/BaiduPCS-Go/BaiduPCS-Go", checksum.DefaultBufSize-3, checksum.DefaultBufSize)
		err := lf.OpenPath()
		if err != nil {
			t.Fatal(err)
		}
		lf.Sum(flag)
		printFileMeta(&lf.LocalFileMeta)
	}
}



================================================
FILE: pcsutil/checksum/checksum_write.go
================================================
package checksum

import (
	"hash"
	"io"
)

type (
	ChecksumWriter interface {
		io.Writer
		Sum() interface{}
	}

	ChecksumWriteUnit struct {
		SliceEnd       int64
		End            int64
		SliceSum       interface{}
		Sum            interface{}
		OnlySliceSum   bool
		ChecksumWriter ChecksumWriter

		ptr int64
	}

	hashChecksumWriter struct {
		h hash.Hash
	}

	hash32ChecksumWriter struct {
		h hash.Hash32
	}
)

func (wi *ChecksumWriteUnit) handleEnd() error {
	if wi.ptr >= wi.End {
		// 已写完
		if !wi.OnlySliceSum {
			wi.Sum = wi.ChecksumWriter.Sum()
		}
		return ErrChecksumWriteStop
	}
	return nil
}

func (wi *ChecksumWriteUnit) write(p []byte) (n int, err error) {
	if wi.End <= 0 {
		// do nothing
		err = ErrChecksumWriteStop
		return
	}
	err = wi.handleEnd()
	if err != nil {
		return
	}

	var (
		i    int
		left = wi.End - wi.ptr
		lenP = len(p)
	)
	if left < int64(lenP) {
		// 读取即将完毕
		i = int(left)
	} else {
		i = lenP
	}
	n, err = wi.ChecksumWriter.Write(p[:i])
	if err != nil {
		return
	}
	wi.ptr += int64(n)
	if left < int64(lenP) {
		err = wi.handleEnd()
		return
	}
	return
}

func (wi *ChecksumWriteUnit) Write(p []byte) (n int, err error) {
	if wi.SliceEnd <= 0 { // 忽略Slice
		// 读取全部
		n, err = wi.write(p)
		return
	}

	// 要计算Slice的情况
	// 调整slice
	if wi.SliceEnd > wi.End {
		wi.SliceEnd = wi.End
	}

	// 计算剩余Slice
	var (
		sliceLeft = wi.SliceEnd - wi.ptr
	)
	if sliceLeft <= 0 {
		// 已处理完Slice
		if wi.OnlySliceSum {
			err = ErrChecksumWriteStop
			return
		}

		// 继续处理
		n, err = wi.write(p)
		return
	}

	var (
		lenP = len(p)
	)
	if sliceLeft <= int64(lenP) {
		var n1, n2 int
		n1, err = wi.write(p[:sliceLeft])
		n += n1
		if err != nil {
			return
		}
		wi.SliceSum = wi.ChecksumWriter.Sum().([]byte)
		n2, err = wi.write(p[sliceLeft:])
		n += n2
		if err != nil {
			return
		}
		return
	}
	n, err = wi.write(p)
	return
}

func NewHashChecksumWriter(h hash.Hash) ChecksumWriter {
	return &hashChecksumWriter{
		h: h,
	}
}

func (hc *hashChecksumWriter) Write(p []byte) (n int, err error) {
	return hc.h.Write(p)
}

func (hc *hashChecksumWriter) Sum() interface{} {
	return hc.h.Sum(nil)
}

func NewHash32ChecksumWriter(h32 hash.Hash32) ChecksumWriter {
	return &hash32ChecksumWriter{
		h: h32,
	}
}

func (hc *hash32ChecksumWriter) Write(p []byte) (n int, err error) {
	return hc.h.Write(p)
}

func (hc *hash32ChecksumWriter) Sum() interface{} {
	return hc.h.Sum32()
}



================================================
FILE: pcsutil/checksum/errors.go
================================================
package checksum

import (
	"errors"
)

var (
	ErrFileIsNil            = errors.New("file is nil")
	ErrChecksumWriteStop    = errors.New("checksum write stop")
	ErrChecksumWriteAllStop = errors.New("checksum write all stop")
)



================================================
FILE: pcsutil/checksum/file.go
================================================
package checksum

import (
	"bytes"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs"
	"path/filepath"
)

// EqualLengthMD5 检测md5和大小是否相同
func (lfm *LocalFileMeta) EqualLengthMD5(m *LocalFileMeta) bool {
	if lfm.Length != m.Length {
		return false
	}
	if bytes.Compare(lfm.MD5, m.MD5) != 0 {
		return false
	}
	return true
}

// CompleteAbsPath 补齐绝对路径
func (lfm *LocalFileMeta) CompleteAbsPath() {
	if filepath.IsAbs(lfm.Path) {
		return
	}

	absPath, err := filepath.Abs(lfm.Path)
	if err != nil {
		return
	}

	lfm.Path = absPath
}

// GetFileSum 获取文件的大小, md5, 前256KB切片的 md5, crc32
func GetFileSum(localPath string, flag int) (lfc *LocalFileChecksum, err error) {
	lfc = NewLocalFileChecksum(localPath, int(baidupcs.SliceMD5Size))
	defer lfc.Close()

	err = lfc.OpenPath()
	if err != nil {
		return nil, err
	}

	err = lfc.Sum(flag)
	if err != nil {
		return nil, err
	}
	return lfc, nil
}



================================================
FILE: pcsutil/converter/converter.go
================================================
// Package converter 格式, 类型转换包
package converter

import (
	"github.com/mattn/go-runewidth"
	"reflect"
	"strconv"
	"strings"
	"unicode"
	"unsafe"
)

const (
	// InvalidChars 文件名中的非法字符
	InvalidChars = `\/:*?"<>|`
)

// ToString unsafe 转换, 将 []byte 转换为 string
func ToString(p []byte) string {
	return *(*string)(unsafe.Pointer(&p))
}

// ToBytes unsafe 转换, 将 string 转换为 []byte
func ToBytes(str string) []byte {
	strHeader := (*reflect.StringHeader)(unsafe.Pointer(&str))
	return *(*[]byte)(unsafe.Pointer(&reflect.SliceHeader{
		Data: strHeader.Data,
		Len:  strHeader.Len,
		Cap:  strHeader.Len,
	}))
}

// ToBytesUnsafe unsafe 转换, 请确保转换后的 []byte 不涉及 cap() 操作, 将 string 转换为 []byte
func ToBytesUnsafe(str string) []byte {
	return *(*[]byte)(unsafe.Pointer(&str))
}

// IntToBool int 类型转换为 bool
func IntToBool(i int) bool {
	return i != 0
}

// SliceInt64ToString []int64 转换为 []string
func SliceInt64ToString(si []int64) (ss []string) {
	ss = make([]string, 0, len(si))
	for k := range si {
		ss = append(ss, strconv.FormatInt(si[k], 10))
	}
	return ss
}

// SliceStringToInt64 []string 转换为 []int64
func SliceStringToInt64(ss []string) (si []int64) {
	si = make([]int64, 0, len(ss))
	var (
		i   int64
		err error
	)
	for k := range ss {
		i, err = strconv.ParseInt(ss[k], 10, 64)
		if err != nil {
			continue
		}
		si = append(si, i)
	}
	return
}

// SliceStringToInt []string 转换为 []int
func SliceStringToInt(ss []string) (si []int) {
	si = make([]int, 0, len(ss))
	var (
		i   int
		err error
	)
	for k := range ss {
		i, err = strconv.Atoi(ss[k])
		if err != nil {
			continue
		}
		si = append(si, i)
	}
	return
}

// MustInt 将string转换为int, 忽略错误
func MustInt(s string) (n int) {
	n, _ = strconv.Atoi(s)
	return
}

// MustInt64 将string转换为int64, 忽略错误
func MustInt64(s string) (i int64) {
	i, _ = strconv.ParseInt(s, 10, 64)
	return
}

// ShortDisplay 缩略显示字符串s, 显示长度为num, 缩略的内容用"..."填充
func ShortDisplay(s string, num int) string {
	var (
		sb = strings.Builder{}
		n  int
	)
	for _, v := range s {
		if unicode.Is(unicode.C, v) { // 去除无效字符
			continue
		}
		n += runewidth.RuneWidth(v)
		if n > num {
			sb.WriteString("...")
			break
		}
		sb.WriteRune(v)
	}

	return sb.String()
}

// TrimPathInvalidChars 清除文件名中的非法字符
func TrimPathInvalidChars(fpath string) string {
	buf := make([]byte, 0, len(fpath))

	for _, c := range ToBytesUnsafe(fpath) {
		if strings.ContainsRune(InvalidChars, rune(c)) {
			continue
		}

		buf = append(buf, c)
	}

	return ToString(buf)
}



================================================
FILE: pcsutil/converter/converter_test.go
================================================
package converter_test

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"strings"
	"testing"
)

func TestTrimPathInvalidChars(t *testing.T) {
	trimed := converter.TrimPathInvalidChars("ksjadfi*/?adf")
	if strings.Compare(trimed, "ksjadfiadf") != 0 {
		t.Fatalf("trimed: %s\n", trimed)
	}
	return
}



================================================
FILE: pcsutil/converter/short_display_test.go
================================================
package converter_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"testing"
)

func TestShortDisplay(t *testing.T) {
	for i := 0; i < 20; i++ {
		fmt.Println([]byte(converter.ShortDisplay("\u0000我我\u0000我我我我", i)))
	}
}



================================================
FILE: pcsutil/converter/size.go
================================================
package converter

import (
	"errors"
	"fmt"
	"strconv"
	"strings"
)

const (
	// B byte
	B = (int64)(1 << (10 * iota))
	// KB kilobyte
	KB
	// MB megabyte
	MB
	// GB gigabyte
	GB
	// TB terabyte
	TB
	// PB petabyte
	PB
)

// ConvertFileSize 文件大小格式化输出
func ConvertFileSize(size int64, precision ...int) string {
	pint := "6"
	if len(precision) == 1 {
		pint = fmt.Sprint(precision[0])
	}
	if size < 0 {
		return "0B"
	}
	if size < KB {
		return fmt.Sprintf("%dB", size)
	}
	if size < MB {
		return fmt.Sprintf("%."+pint+"fKB", float64(size)/float64(KB))
	}
	if size < GB {
		return fmt.Sprintf("%."+pint+"fMB", float64(size)/float64(MB))
	}
	if size < TB {
		return fmt.Sprintf("%."+pint+"fGB", float64(size)/float64(GB))
	}
	if size < PB {
		return fmt.Sprintf("%."+pint+"fTB", float64(size)/float64(TB))
	}
	return fmt.Sprintf("%."+pint+"fPB", float64(size)/float64(PB))
}

// ParseFileSizeStr 将文件大小字符串转换成字节数
func ParseFileSizeStr(ss string) (size int64, err error) {
	if ss == "" {
		err = errors.New("converter: size is empty")
		return
	}
	if !(ss[0] == '.' || '0' <= ss[0] && ss[0] <= '9') {
		err = errors.New("converter: invalid size: " + ss)
		return
	}

	var i int
	for i = range ss[1:] {
		i++
		if ss[i] == '.' || ('0' <= ss[i] && ss[i] <= '9') {
			// 属于数字
			continue
		}
		break
	}
	if ss[i] == '.' || ('0' <= ss[i] && ss[i] <= '9') { // 最后一个分隔符是否为数字
		i++
	}

	var (
		sizeStr      = ss[:i] // 数字部分
		unitStr      = ss[i:] // 单位部分
		sizeFloat, _ = strconv.ParseFloat(sizeStr, 10)
	)
	switch strings.ToUpper(unitStr) {
	case "", "B":
		size = int64(sizeFloat)
	case "K", "KB":
		size = int64(sizeFloat * float64(KB))
	case "M", "MB":
		size = int64(sizeFloat * float64(MB))
	case "G", "GB":
		size = int64(sizeFloat * float64(GB))
	case "T", "TB":
		size = int64(sizeFloat * float64(TB))
	case "P", "PB":
		size = int64(sizeFloat * float64(PB))
	default:
		err = errors.New("converter: invalid unit " + unitStr)
	}
	return
}



================================================
FILE: pcsutil/converter/size_test.go
================================================
package converter_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"testing"
)

func TestParseFileSizeStr(t *testing.T) {
	for _, v := range []string{"1k", "3.86mb", "4.001Gb", "32"} {
		size, err := converter.ParseFileSizeStr(v)
		if err != nil {
			t.Fatalf("%s\n", err)
		}
		fmt.Println(v, size)
	}
}



================================================
FILE: pcsutil/delay/delay.go
================================================
package delay

import (
	"time"
)

// NewDelayChan 发送延时信号
func NewDelayChan(t time.Duration) <-chan struct{} {
	c := make(chan struct{})
	go func() {
		time.Sleep(t)
		close(c)
	}()
	return c
}



================================================
FILE: pcsutil/escaper/escaper.go
================================================
package escaper

import (
	"strings"
)

type (
	// RuneFunc 判断指定rune
	RuneFunc func(r rune) bool
)

// EscapeByRuneFunc 通过runeFunc转义, runeFunc返回真, 则转义
func EscapeByRuneFunc(s string, runeFunc RuneFunc) string {
	if runeFunc == nil {
		return s
	}

	var (
		builder = &strings.Builder{}
		rs      = []rune(s)
	)

	for k := range rs {
		if !runeFunc(rs[k]) {
			builder.WriteRune(rs[k])
			continue
		}

		if k >= 1 && rs[k-1] == '\\' {
			builder.WriteRune(rs[k])
			continue
		}
		builder.WriteString(`\`)
		builder.WriteRune(rs[k])
	}
	return builder.String()
}

// Escape 转义指定的escapeRunes, 在escapeRunes的前面加上一个反斜杠
func Escape(s string, escapeRunes []rune) string {
	return EscapeByRuneFunc(s, func(r rune) bool {
		for k := range escapeRunes {
			if escapeRunes[k] == r {
				return true
			}
		}
		return false
	})
}

// EscapeStrings 转义字符串数组
func EscapeStrings(ss []string, escapeRunes []rune) {
	for k := range ss {
		ss[k] = Escape(ss[k], escapeRunes)
	}
}

// EscapeStringsByRuneFunc 转义字符串数组, 通过runeFunc
func EscapeStringsByRuneFunc(ss []string, runeFunc RuneFunc) {
	for k := range ss {
		ss[k] = EscapeByRuneFunc(ss[k], runeFunc)
	}
}



================================================
FILE: pcsutil/escaper/escaper_test.go
================================================
package escaper_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/escaper"
	"testing"
)

func TestEscape(t *testing.T) {
	fmt.Println(escaper.Escape(`asdf'asdfasd[]a[\[][sdf\[d]`, []rune{'[', '\''}))
}



================================================
FILE: pcsutil/getip/errors.go
================================================
package getip

import (
	"errors"
)

var (
	// ErrParseIP 解析ip地址错误
	ErrParseIP = errors.New("parse ip error")
)



================================================
FILE: pcsutil/getip/getip.go
================================================
// Package getip 获取 ip 信息包
package getip

import (
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"net"
	"net/http"
	"unsafe"
)

// IPInfoByClient 给定client获取ip地址
func IPInfoByClient(c *requester.HTTPClient) (ipAddr string, err error) {
	if c == nil {
		c = requester.NewHTTPClient()
	}

	body, err := c.Fetch(http.MethodGet, "https://api.ipify.org", nil, nil)
	if err != nil {
		return
	}

	ipAddr = *(*string)(unsafe.Pointer(&body))
	ip := net.ParseIP(ipAddr)
	if ip == nil {
		return "", ErrParseIP
	}
	return
}

//IPInfo 从ipify获取IP地址
func IPInfo(https bool) (ipAddr string, err error) {
	c := requester.NewHTTPClient()
	c.SetHTTPSecure(https)
	return IPInfoByClient(c)
}



================================================
FILE: pcsutil/getip/getip_netease.go
================================================
package getip

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/jsonhelper"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"net"
	"net/http"
)

type (
	// IPResNetease 网易服务器获取ip返回的结果
	IPResNetease struct {
		Result  string `json:"result"`
		Code    int    `json:"code"`
		Message string `json:"message"`
	}
)

func IPInfoFromNeteaseByClient(c *requester.HTTPClient) (ipAddr string, err error) {
	resp, err := c.Req(http.MethodGet, "http://mam.netease.com/api/config/getClientIp", nil, nil)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		return
	}

	res := &IPResNetease{}
	err = jsonhelper.UnmarshalData(resp.Body, res)
	if err != nil {
		return
	}

	ip := net.ParseIP(res.Result)
	if ip == nil {
		err = ErrParseIP
		return
	}

	ipAddr = res.Result
	return
}

// IPInfoFromNetease 从网易服务器获取ip
func IPInfoFromNetease() (ipAddr string, err error) {
	c := requester.NewHTTPClient()
	return IPInfoFromNeteaseByClient(c)
}



================================================
FILE: pcsutil/getip/getip_techain.go
================================================
package getip

import (
	"bytes"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"net/http"
)

func IPInfoFromTechainBaiduByClient(c *requester.HTTPClient) (ipAddr string, err error) {
	body, err := c.Fetch(http.MethodGet, "https://techain.baidu.com/srcmon", nil, map[string]string{
		"User-Agent":      "x18/600000101/10.0.63/4.1.3",
		"Pragma":          "no-cache",
		"Accept":          "*/*",
		"Content-Type":    "application/x-www-form-urlencoded",
		"x-auth-ver":      "1",
		"Accept-Language": "zh-CN",
		"x-device-id":     "00000000000000000000000000000000",
	})
	if err != nil {
		return
	}
	return converter.ToString(bytes.TrimSpace(body)), nil
}

// IPInfoFromTechainBaidu 从 techain.baidu.com 获取ip
func IPInfoFromTechainBaidu() (ipAddr string, err error) {
	c := requester.NewHTTPClient()
	return IPInfoFromNeteaseByClient(c)
}



================================================
FILE: pcsutil/getip/getip_test.go
================================================
package getip

import (
	"testing"
)

func TestGetIP(t *testing.T) {
	ipAddr, err := IPInfo(false)
	if err != nil {
		t.Errorf("err: %s\n", err)
		return
	}

	t.Logf("from ipify: %s\n", ipAddr)

	ipAddr, err = IPInfoFromNetease()
	if err != nil {
		t.Errorf("err: %s\n", err)
		return
	}

	t.Logf("from netease: %s\n", ipAddr)
}



================================================
FILE: pcsutil/jsonhelper/jsonhelper.go
================================================
package jsonhelper

import (
	"github.com/json-iterator/go"
	"io"
)

// UnmarshalData 将 r 中的 json 格式的数据, 解析到 data
func UnmarshalData(r io.Reader, data interface{}) error {
	d := jsoniter.NewDecoder(r)
	return d.Decode(data)
}

// MarshalData 将 data, 生成 json 格式的数据, 写入 w 中
func MarshalData(w io.Writer, data interface{}) error {
	e := jsoniter.NewEncoder(w)
	return e.Encode(data)
}



================================================
FILE: pcsutil/jwted25519/jwted25519.go
================================================
package jwted25519

import (
	"github.com/dgrijalva/jwt-go"
	"golang.org/x/crypto/ed25519"
	"unsafe"
)

type (
	SigningMethodEd25519 struct{}
)

var (
	SigningMethodED25519 *SigningMethodEd25519
)

func init() {
	// ED25519
	SigningMethodED25519 = &SigningMethodEd25519{}
	jwt.RegisterSigningMethod(SigningMethodED25519.Alg(), func() jwt.SigningMethod {
		return SigningMethodED25519
	})
}

func (m *SigningMethodEd25519) Alg() string {
	return "ED25519"
}

func (m *SigningMethodEd25519) Sign(signingString string, key interface{}) (string, error) {
	if privkey, ok := key.(ed25519.PrivateKey); ok {
		if len(privkey) != ed25519.PrivateKeySize {
			return "", jwt.ErrInvalidKey
		}

		signature := ed25519.Sign(privkey, *(*[]byte)(unsafe.Pointer(&signingString)))
		return jwt.EncodeSegment(signature), nil
	}

	return "", jwt.ErrInvalidKeyType
}

func (m *SigningMethodEd25519) Verify(signingString, signature string, key interface{}) error {
	pubkey, ok := key.(ed25519.PublicKey)
	if !ok {
		return jwt.ErrInvalidKeyType
	}

	if len(pubkey) != ed25519.PublicKeySize {
		return jwt.ErrInvalidKey
	}

	message, err := jwt.DecodeSegment(signature)
	if err != nil {
		return err
	}

	ok = ed25519.Verify(pubkey, *(*[]byte)(unsafe.Pointer(&signingString)), message)
	if !ok {
		return jwt.ErrSignatureInvalid
	}

	return nil
}



================================================
FILE: pcsutil/pcstime/time.go
================================================
// Package pcstime 时间工具包
package pcstime

import (
	"fmt"
	"time"
)

var (
	// CSTLocation 东八区时区
	CSTLocation = time.FixedZone("CST", 8*3600)
)

/*
BeijingTimeOption 根据给定的 get 返回时间格式.

	get:        时间格式

	"Refer":    2017-7-21 12:02:32.000
	"printLog": 2017-7-21_12:02:32
	"day":      21
	"ymd":      2017-7-21
	"hour":     12
	默认时间戳:   1500609752
*/
func BeijingTimeOption(get string) string {
	//获取北京（东八区）时间
	now := time.Now().In(CSTLocation)
	year, mon, day := now.Date()
	hour, min, sec := now.Clock()
	millisecond := now.Nanosecond() / 1e6
	switch get {
	case "Refer":
		return fmt.Sprintf("%d-%d-%d %02d:%02d:%02d.%03d", year, mon, day, hour, min, sec, millisecond)
	case "printLog":
		return fmt.Sprintf("%d-%d-%d_%02dh%02dm%02ds", year, mon, day, hour, min, sec)
	case "day":
		return fmt.Sprint(day)
	case "ymd":
		return fmt.Sprintf("%d-%d-%d", year, mon, day)
	case "hour":
		return fmt.Sprint(hour)
	default:
		return fmt.Sprint(time.Now().Unix())
	}
}

// FormatTime 将 Unix 时间戳, 转换为字符串
func FormatTime(t int64) string {
	tt := time.Unix(t, 0).In(CSTLocation)
	year, mon, day := tt.Date()
	hour, min, sec := tt.Clock()
	return fmt.Sprintf("%d-%02d-%02d %02d:%02d:%02d", year, mon, day, hour, min, sec)
}



================================================
FILE: pcsutil/prealloc/errors.go
================================================
package prealloc

import (
	"fmt"
)

type (
	PreAllocError struct {
		ProcName string
		Err      error
	}
)

func (pe *PreAllocError) Error() string {
	if pe.Err == nil {
		return "<nil>"
	}
	return fmt.Sprintf("%s error: %s\n", pe.ProcName, pe.Err)
}



================================================
FILE: pcsutil/prealloc/prealloc.go
================================================
//+build !windows,!plan9

// Package prealloc 初始化分配文件包
package prealloc

import (
	"syscall"
)

// PreAlloc 预分配文件空间
func PreAlloc(fd uintptr, length int64) error {
	err := syscall.Ftruncate(int(fd), length)
	if err != nil {
		return &PreAllocError{
			ProcName: "Ftruncate",
			Err:      err,
		}
	}
	return nil
}



================================================
FILE: pcsutil/prealloc/prealloc_plan9.go
================================================
//+build plan9

package prealloc

func PreAlloc(fd uintptr, length int64) error {
	return nil
}



================================================
FILE: pcsutil/prealloc/prealloc_windows.go
================================================
package prealloc

import (
	"golang.org/x/sys/windows"
	"log"
	"syscall"
)

var (
	kernel32             = syscall.NewLazyDLL("kernel32.dll")
	procSetFileValidData = kernel32.NewProc("SetFileValidData")
)

func initPrivilege() error {
	current, err := windows.GetCurrentProcess()
	if err != nil {
		return &PreAllocError{
			ProcName: "GetCurrentProcess",
			Err:      err,
		}
	}

	var hToken windows.Token
	err = windows.OpenProcessToken(current, windows.TOKEN_ADJUST_PRIVILEGES|windows.TOKEN_QUERY, &hToken)
	if err != nil {
		return &PreAllocError{
			ProcName: "OpenProcessToken",
			Err:      err,
		}
	}

	var (
		seManageVolumeName, _ = windows.UTF16PtrFromString("SeManageVolumePrivilege")
		tp                    = windows.Tokenprivileges{
			PrivilegeCount: 1,
			Privileges: [1]windows.LUIDAndAttributes{
				windows.LUIDAndAttributes{
					Luid:       windows.LUID{},
					Attributes: windows.SE_PRIVILEGE_ENABLED,
				},
			},
		}
	)
	err = windows.LookupPrivilegeValue(nil, seManageVolumeName, &tp.Privileges[0].Luid)
	if err != nil {
		return &PreAllocError{
			ProcName: "LookupPrivilegeValue",
			Err:      err,
		}
	}

	err = windows.AdjustTokenPrivileges(hToken, false, &tp, 0, nil, nil)
	if err != nil {
		return &PreAllocError{
			ProcName: "AdjustTokenPrivileges",
			Err:      err,
		}
	}

	return nil
}

// 初始化权限
func init() {
	err := initPrivilege()
	if err != nil {
		log.Printf("prealloc: init privileges error: %s\n", err) // 打印警告
	}
}

// PreAlloc 预分配文件空间
func PreAlloc(fd uintptr, length int64) error {
	err := syscall.Ftruncate(syscall.Handle(fd), length)
	if err != nil {
		return &PreAllocError{
			ProcName: "Ftruncate",
			Err:      err,
		}
	}

	r1, _, err := procSetFileValidData.Call(fd, uintptr(length))
	if r1 == 0 {
		return &PreAllocError{
			ProcName: "SetFileValidData",
			Err:      err,
		}
	}

	return nil
}



================================================
FILE: pcsutil/taskframework/executor.go
================================================
package taskframework

import (
	"github.com/GeertJohan/go.incremental"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/waitgroup"
	"github.com/oleiade/lane"
	"strconv"
	"time"
)

type (
	TaskExecutor struct {
		incr     *incremental.Int // 任务id生成
		deque    *lane.Deque      // 队列
		parallel int              // 任务的最大并发量

		// 是否统计失败队列
		IsFailedDeque bool
		failedDeque   *lane.Deque
	}
)

func NewTaskExecutor() *TaskExecutor {
	return &TaskExecutor{}
}

func (te *TaskExecutor) lazyInit() {
	if te.deque == nil {
		te.deque = lane.NewDeque()
	}
	if te.incr == nil {
		te.incr = &incremental.Int{}
	}
	if te.parallel < 1 {
		te.parallel = 1
	}
	if te.IsFailedDeque {
		te.failedDeque = lane.NewDeque()
	}
}

// 设置任务的最大并发量
func (te *TaskExecutor) SetParallel(parallel int) {
	te.parallel = parallel
}

//Append 将任务加到任务队列末尾
func (te *TaskExecutor) Append(unit TaskUnit, maxRetry int) *TaskInfo {
	te.lazyInit()
	taskInfo := &TaskInfo{
		id:       strconv.Itoa(te.incr.Next()),
		maxRetry: maxRetry,
	}
	unit.SetTaskInfo(taskInfo)
	te.deque.Append(&TaskInfoItem{
		Info: taskInfo,
		Unit: unit,
	})
	return taskInfo
}

//AppendNoRetry 将任务加到任务队列末尾, 不重试
func (te *TaskExecutor) AppendNoRetry(unit TaskUnit) {
	te.Append(unit, 0)
}

//Count 返回任务数量
func (te *TaskExecutor) Count() int {
	if te.deque == nil {
		return 0
	}
	return te.deque.Size()
}

//Execute 执行任务
func (te *TaskExecutor) Execute() {
	te.lazyInit()

	for {
		wg := waitgroup.NewWaitGroup(te.parallel)
		for {
			e := te.deque.Shift()
			if e == nil { // 任务为空
				break
			}

			// 获取任务
			task := e.(*TaskInfoItem)
			wg.AddDelta()

			go func(task *TaskInfoItem) {
				defer wg.Done()

				result := task.Unit.Run()

				// 返回结果为空
				if result == nil {
					task.Unit.OnComplete(result)
					return
				}

				if result.Succeed {
					task.Unit.OnSuccess(result)
					task.Unit.OnComplete(result)
					return
				}

				// 需要进行重试
				if result.NeedRetry {
					// 重试次数超出限制
					// 执行失败
					if task.Info.IsExceedRetry() {
						task.Unit.OnFailed(result)
						if te.IsFailedDeque {
							// 加入失败队列
							te.failedDeque.Append(task)
						}
						task.Unit.OnComplete(result)
						return
					}

					task.Info.retry++         // 增加重试次数
					task.Unit.OnRetry(result) // 调用重试
					task.Unit.OnComplete(result)

					time.Sleep(task.Unit.RetryWait()) // 等待
					te.deque.Append(task)             // 重新加入队列末尾
					return
				}

				// 执行失败
				task.Unit.OnFailed(result)
				if te.IsFailedDeque {
					// 加入失败队列
					te.failedDeque.Append(task)
				}
				task.Unit.OnComplete(result)
			}(task)
		}

		wg.Wait()

		// 没有任务了
		if te.deque.Size() == 0 {
			break
		}
	}
}

//FailedDeque 获取失败队列
func (te *TaskExecutor) FailedDeque() *lane.Deque {
	return te.failedDeque
}

//Stop 停止执行
func (te *TaskExecutor) Stop() {

}

//Pause 暂停执行
func (te *TaskExecutor) Pause() {

}

//Resume 恢复执行
func (te *TaskExecutor) Resume() {
}



================================================
FILE: pcsutil/taskframework/task_unit.go
================================================
[Binary file]


================================================
FILE: pcsutil/taskframework/taskframework_test.go
================================================
package taskframework_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/taskframework"
	"testing"
	"time"
)

type (
	TestUnit struct {
		retry    bool
		taskInfo *taskframework.TaskInfo
	}
)

func (tu *TestUnit) SetTaskInfo(taskInfo *taskframework.TaskInfo) {
	tu.taskInfo = taskInfo
}

func (tu *TestUnit) OnFailed(lastRunResult *taskframework.TaskUnitRunResult) {
	fmt.Printf("[%s] error: %s, failed\n", tu.taskInfo.Id(), lastRunResult.Err)
}

func (tu *TestUnit) OnSuccess(lastRunResult *taskframework.TaskUnitRunResult) {
	fmt.Printf("[%s] success\n", tu.taskInfo.Id())
}

func (tu *TestUnit) OnComplete(lastRunResult *taskframework.TaskUnitRunResult) {
	fmt.Printf("[%s] complete\n", tu.taskInfo.Id())
}

func (tu *TestUnit) Run() (result *taskframework.TaskUnitRunResult) {
	fmt.Printf("[%s] running...\n", tu.taskInfo.Id())
	return &taskframework.TaskUnitRunResult{
		//Succeed:   true,
		NeedRetry: true,
	}
}

func (tu *TestUnit) OnRetry(lastRunResult *taskframework.TaskUnitRunResult) {
	fmt.Printf("[%s] prepare retry, times [%d/%d]...\n", tu.taskInfo.Id(), tu.taskInfo.Retry(), tu.taskInfo.MaxRetry())
}

func (tu *TestUnit) RetryWait() time.Duration {
	return 1 * time.Second
}

func TestTaskExecutor(t *testing.T) {
	te := taskframework.NewTaskExecutor()
	te.SetParallel(2)
	for i := 0; i < 3; i++ {
		tu := TestUnit{
			retry: false,
		}
		te.Append(&tu, 2)
	}
	te.Execute()
}



================================================
FILE: pcsutil/taskframework/taskinfo.go
================================================
package taskframework

type (
	TaskInfo struct {
		id       string
		maxRetry int
		retry    int
	}

	TaskInfoItem struct {
		Info *TaskInfo
		Unit TaskUnit
	}
)

// IsExceedRetry 重试次数达到限制
func (t *TaskInfo) IsExceedRetry() bool {
	return t.retry >= t.maxRetry
}

func (t *TaskInfo) Id() string {
	return t.id
}

func (t *TaskInfo) MaxRetry() int {
	return t.maxRetry
}

func (t *TaskInfo) SetMaxRetry(maxRetry int) {
	t.maxRetry = maxRetry
}

func (t *TaskInfo) Retry() int {
	return t.retry
}



================================================
FILE: pcsutil/waitgroup/wait_group.go
================================================
// Package waitgroup sync.WaitGroup extension
package waitgroup

import "sync"

// WaitGroup 在 sync.WaitGroup 的基础上, 新增线程控制功能
type WaitGroup struct {
	wg sync.WaitGroup
	p  chan struct{}

	sync.RWMutex
}

// NewWaitGroup returns a pointer to a new `WaitGroup` object.
// parallel 为最大并发数, 0 代表无限制
func NewWaitGroup(parallel int) (w *WaitGroup) {
	w = &WaitGroup{
		wg: sync.WaitGroup{},
	}

	if parallel <= 0 {
		return
	}

	w.p = make(chan struct{}, parallel)
	return
}

// AddDelta sync.WaitGroup.Add(1)
func (w *WaitGroup) AddDelta() {
	if w.p != nil {
		w.p <- struct{}{}
	}

	w.wg.Add(1)
}

// Done sync.WaitGroup.Done()
func (w *WaitGroup) Done() {
	w.wg.Done()

	if w.p != nil {
		<-w.p
	}
}

// Wait 参照 sync.WaitGroup 的 Wait 方法
func (w *WaitGroup) Wait() {
	w.wg.Wait()
	if w.p != nil {
		close(w.p)
	}
}

// Parallel 返回当前正在进行的任务数量
func (w *WaitGroup) Parallel() int {
	return len(w.p)
}



================================================
FILE: pcsutil/waitgroup/wait_group_test.go
================================================
package waitgroup

import (
	"fmt"
	"testing"
	"time"
)

func TestWg(t *testing.T) {
	wg := NewWaitGroup(2)
	for i := 0; i < 60; i++ {
		wg.AddDelta()
		go func(i int) {
			fmt.Println(i, wg.Parallel())
			time.Sleep(1e9)
			wg.Done()
		}(i)
	}
	wg.Wait()
}



================================================
FILE: pcsverbose/pcsverbose.go
================================================
// Package pcsverbose 调试包
package pcsverbose

import (
	"fmt"
	"io"
	"os"
)

const (
	// EnvVerbose 启用调试环境变量
	EnvVerbose = "BAIDUPCS_GO_VERBOSE"
)

var (
	// IsVerbose 是否调试
	IsVerbose = os.Getenv(EnvVerbose) == "1"

	// Outputs 输出
	Outputs = []io.Writer{os.Stderr}
)

// PCSVerbose 调试
type PCSVerbose struct {
	Module string
}

// New 根据module, 初始化PCSVerbose
func New(module string) *PCSVerbose {
	return &PCSVerbose{
		Module: module,
	}
}

// Info 提示
func (pv *PCSVerbose) Info(l string) {
	Verbosef("DEBUG: %s INFO: %s\n", pv.Module, l)
}

// Infof 提示, 格式输出
func (pv *PCSVerbose) Infof(format string, a ...interface{}) {
	Verbosef("DEBUG: %s INFO: %s", pv.Module, fmt.Sprintf(format, a...))
}

// Warn 警告
func (pv *PCSVerbose) Warn(l string) {
	Verbosef("DEBUG: %s WARN: %s\n", pv.Module, l)
}

// Warnf 警告, 格式输出
func (pv *PCSVerbose) Warnf(format string, a ...interface{}) {
	Verbosef("DEBUG: %s WARN: %s", pv.Module, fmt.Sprintf(format, a...))
}

// Verbosef 调试格式输出
func Verbosef(format string, a ...interface{}) (n int, err error) {
	if IsVerbose {
		for _, Output := range Outputs {
			n1, err := fmt.Fprintf(Output, TimePrefix()+" "+format, a...)
			n += n1
			if err != nil {
				return n, err
			}
		}
	}
	return
}

// Verboseln 调试输出一行
func Verboseln(a ...interface{}) (n int, err error) {
	if IsVerbose {
		for _, Output := range Outputs {
			n1, err := fmt.Fprint(Output, TimePrefix()+" ")
			n += n1
			if err != nil {
				return n, err
			}
			n2, err := fmt.Fprintln(Output, a...)
			n += n2
			if err != nil {
				return n, err
			}
		}
	}
	return
}



================================================
FILE: pcsverbose/utils.go
================================================
package pcsverbose

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/pcstime"
	"io"
	"io/ioutil"
)

//PrintReader 输出Reader
func PrintReader(r io.Reader) {
	b, _ := ioutil.ReadAll(r)
	fmt.Printf("%s\n", b)
}

// PrintArgs 输出字符串数组
func PrintArgs(w io.Writer, args ...string) {
	for k, arg := range args {
		io.WriteString(w, fmt.Sprintf("args[%d] = `%s`, ", k, arg))
	}
	w.Write([]byte{'\n'})
}

func TimePrefix() string {
	return "[" + pcstime.BeijingTimeOption("Refer") + "]"
}



================================================
FILE: pcsverbose/pcsdebug/cpu.go
================================================
// Package pcsdebug 调试包
package pcsdebug

import (
	"context"
	"fmt"
	"os"
	"runtime/pprof"
)

//StartCPUProfile 收集cpu信息
func StartCPUProfile(ctx context.Context, cpuProfile string) {
	if cpuProfile != "" {
		f, err := os.Create(cpuProfile)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Can not create cpu profile output file: %s", err)
			return
		}
		if err := pprof.StartCPUProfile(f); err != nil {
			fmt.Fprintf(os.Stderr, "Can not start cpu profile: %s", err)
			f.Close()
			return
		}
		defer pprof.StopCPUProfile()
	}
	select {
	case <-ctx.Done():
		return
	}
}



================================================
FILE: pcsverbose/pcsdebug/pprof.go
================================================
package pcsdebug

import (
	"net/http"
	_ "net/http/pprof"
)

func StartPprofListen() {
	http.ListenAndServe("0.0.0.0:6060", nil)
}



================================================
FILE: requester/dial.go
================================================
package requester

import (
	"context"
	"crypto/tls"
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires/cachemap"
	mathrand "math/rand"
	"net"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

const (
	// MaxDuration 最大的Duration
	MaxDuration = 1<<63 - 1
)

var (
	localTCPAddrList = []*net.TCPAddr{}

	// ProxyAddr 代理地址
	ProxyAddr string

	// ErrProxyAddrEmpty 代理地址为空
	ErrProxyAddrEmpty = errors.New("proxy addr is empty")

	tcpCache = cachemap.GlobalCacheOpMap.LazyInitCachePoolOp("requester/tcp")
)

// SetLocalTCPAddrList 设置网卡地址
func SetLocalTCPAddrList(ips ...string) {
	list := make([]*net.TCPAddr, 0, len(ips))
	for k := range ips {
		p := net.ParseIP(ips[k])
		if p == nil {
			continue
		}

		list = append(list, &net.TCPAddr{
			IP: p,
		})
	}
	localTCPAddrList = list
}

func proxyFunc(req *http.Request) (*url.URL, error) {
	u, err := checkProxyAddr(ProxyAddr)
	if err != nil {
		return http.ProxyFromEnvironment(req)
	}

	return u, err
}

func getLocalTCPAddr() *net.TCPAddr {
	if len(localTCPAddrList) == 0 {
		return nil
	}
	i := mathrand.Intn(len(localTCPAddrList))
	return localTCPAddrList[i]
}

func getDialer() *net.Dialer {
	return &net.Dialer{
		Timeout:   30 * time.Second,
		KeepAlive: 30 * time.Second,
		LocalAddr: getLocalTCPAddr(),
		DualStack: true,
	}
}

func checkProxyAddr(proxyAddr string) (u *url.URL, err error) {
	if proxyAddr == "" {
		return nil, ErrProxyAddrEmpty
	}

	host, port, err := net.SplitHostPort(proxyAddr)
	if err == nil {
		u = &url.URL{
			Host: net.JoinHostPort(host, port),
		}
		return
	}

	u, err = url.Parse(proxyAddr)
	if err == nil {
		return
	}

	return
}

// SetGlobalProxy 设置代理
func SetGlobalProxy(proxyAddr string) {
	ProxyAddr = proxyAddr
}

// SetTCPHostBind 设置host绑定ip
func SetTCPHostBind(host, ip string) {
	tcpCache.Store(host, expires.NewDataExpires(net.ParseIP(ip), MaxDuration))
	return
}

func getServerName(address string) string {
	host, _, err := net.SplitHostPort(address)
	if err != nil {
		return address
	}
	return host
}

// resolveTCPHost
// 解析的tcpaddr没有port!!!
func resolveTCPHost(ctx context.Context, host string) (ip net.IP, err error) {
	addrs, err := net.DefaultResolver.LookupIPAddr(ctx, host)
	if err != nil {
		return
	}

	return addrs[0].IP, nil
}

func dialContext(ctx context.Context, network, address string) (conn net.Conn, err error) {
	switch network {
	case "tcp", "tcp4", "tcp6":
		host, portStr, err := net.SplitHostPort(address)
		if err != nil {
			return nil, err
		}
		data, err := cachemap.GlobalCacheOpMap.CacheOperationWithError("requester/tcp", host, func() (expires.DataExpires, error) {
			ip, err := resolveTCPHost(ctx, host)
			if err != nil {
				return nil, err
			}
			return expires.NewDataExpires(ip, 10*time.Minute), nil // 传值
		})
		if err != nil {
			return nil, err
		}

		port, err := strconv.Atoi(portStr)
		if err != nil {
			return nil, err
		}

		return net.DialTCP(network, getLocalTCPAddr(), &net.TCPAddr{
			IP:   data.Data().(net.IP),
			Port: port, // 设置端口
		})
	}

	// 非 tcp 请求
	conn, err = getDialer().DialContext(ctx, network, address)
	return
}

func dial(network, address string) (conn net.Conn, err error) {
	return dialContext(context.Background(), network, address)
}

func (h *HTTPClient) dialTLSFunc() func(network, address string) (tlsConn net.Conn, err error) {
	return func(network, address string) (tlsConn net.Conn, err error) {
		conn, err := dialContext(context.Background(), network, address)
		if err != nil {
			return nil, err
		}

		return tls.Client(conn, &tls.Config{
			ServerName:         getServerName(address),
			InsecureSkipVerify: !h.https,
		}), nil
	}
}



================================================
FILE: requester/fetch.go
================================================
package requester

import (
	"bytes"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// HTTPGet 简单实现 http 访问 GET 请求
func HTTPGet(urlStr string) (body []byte, err error) {
	resp, err := DefaultClient.Get(urlStr)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		return nil, err
	}
	return ioutil.ReadAll(resp.Body)
}

// Req 参见 *HTTPClient.Req, 使用默认 http 客户端
func Req(method string, urlStr string, post interface{}, header map[string]string) (resp *http.Response, err error) {
	return DefaultClient.Req(method, urlStr, post, header)
}

// Fetch 参见 *HTTPClient.Fetch, 使用默认 http 客户端
func Fetch(method string, urlStr string, post interface{}, header map[string]string) (body []byte, err error) {
	return DefaultClient.Fetch(method, urlStr, post, header)
}

// Req 实现 http／https 访问，
// 根据给定的 method (GET, POST, HEAD, PUT 等等), urlStr (网址),
// post (post 数据), header (header 请求头数据), 进行网站访问。
// 返回值分别为 *http.Response, 错误信息
func (h *HTTPClient) Req(method string, urlStr string, post interface{}, header map[string]string) (resp *http.Response, err error) {
	h.lazyInit()
	var (
		req           *http.Request
		obody         io.Reader
		contentLength int64
		contentType   string
	)

	if post != nil {
		switch value := post.(type) {
		case io.Reader:
			obody = value
		case map[string]string:
			query := url.Values{}
			for k := range value {
				query.Set(k, value[k])
			}
			obody = strings.NewReader(query.Encode())
		case map[string]interface{}:
			query := url.Values{}
			for k := range value {
				query.Set(k, fmt.Sprint(value[k]))
			}
			obody = strings.NewReader(query.Encode())
		case map[interface{}]interface{}:
			query := url.Values{}
			for k := range value {
				query.Set(fmt.Sprint(k), fmt.Sprint(value[k]))
			}
			obody = strings.NewReader(query.Encode())
		case string:
			obody = strings.NewReader(value)
		case []byte:
			obody = bytes.NewReader(value[:])
		default:
			return nil, fmt.Errorf("requester.Req: unknown post type: %s", value)
		}

		switch value := post.(type) {
		case ContentLengther:
			contentLength = value.ContentLength()
		case rio.Lener:
			contentLength = int64(value.Len())
		case rio.Lener64:
			contentLength = value.Len()
		}

		switch value := post.(type) {
		case ContentTyper:
			contentType = value.ContentType()
		}
	}
	req, err = http.NewRequest(method, urlStr, obody)
	if err != nil {
		return nil, err
	}

	if req.ContentLength <= 0 && contentLength != 0 {
		req.ContentLength = contentLength
	}

	// 设置浏览器标识
	req.Header.Set("User-Agent", h.UserAgent)

	// 设置Content-Type
	if contentType != "" {
		req.Header.Set("Content-Type", contentType)
	}

	if header != nil {
		// 处理Host
		if host, ok := header["Host"]; ok {
			req.Host = host
		}

		for key := range header {
			req.Header.Set(key, header[key])
		}
	}

	return h.Client.Do(req)
}

// Fetch 实现 http／https 访问，
// 根据给定的 method (GET, POST, HEAD, PUT 等等), urlStr (网址),
// post (post 数据), header (header 请求头数据), 进行网站访问。
// 返回值分别为 网站主体, 错误信息
func (h *HTTPClient) Fetch(method string, urlStr string, post interface{}, header map[string]string) (body []byte, err error) {
	h.lazyInit()
	resp, err := h.Req(method, urlStr, post, header)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		return nil, err
	}

	return ioutil.ReadAll(resp.Body)
}



================================================
FILE: requester/http_client.go
================================================
package requester

import (
	"crypto/tls"
	"net/http"
	"net/http/cookiejar"
	"time"
)

// HTTPClient http client
type HTTPClient struct {
	http.Client
	transport *http.Transport
	https     bool
	UserAgent string
}

// NewHTTPClient 返回 HTTPClient 的指针,
// 预设了一些配置
func NewHTTPClient() *HTTPClient {
	h := &HTTPClient{
		Client: http.Client{
			Timeout: 30 * time.Second,
		},
		UserAgent: UserAgent,
	}
	h.Client.Jar, _ = cookiejar.New(nil)
	return h
}

func (h *HTTPClient) lazyInit() {
	if h.transport == nil {
		h.transport = &http.Transport{
			Proxy:       proxyFunc,
			DialContext: dialContext,
			Dial:        dial,
			// DialTLS:     h.dialTLSFunc(),
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: !h.https,
			},
			TLSHandshakeTimeout:   10 * time.Second,
			DisableKeepAlives:     false,
			DisableCompression:    false, // gzip
			MaxIdleConns:          100,
			IdleConnTimeout:       90 * time.Second,
			ResponseHeaderTimeout: 10 * time.Second,
			ExpectContinueTimeout: 10 * time.Second,
		}
		h.Client.Transport = h.transport
	}
}

// SetUserAgent 设置 UserAgent 浏览器标识
func (h *HTTPClient) SetUserAgent(ua string) {
	h.UserAgent = ua
}

// SetProxy 设置代理
func (h *HTTPClient) SetProxy(proxyAddr string) {
	h.lazyInit()
	u, err := checkProxyAddr(proxyAddr)
	if err != nil {
		h.transport.Proxy = http.ProxyFromEnvironment
		return
	}

	h.transport.Proxy = http.ProxyURL(u)
}

// SetCookiejar 设置 cookie
func (h *HTTPClient) SetCookiejar(jar http.CookieJar) {
	h.Client.Jar = jar
}

// ResetCookiejar 清空 cookie
func (h *HTTPClient) ResetCookiejar() {
	h.Jar, _ = cookiejar.New(nil)
}

// SetHTTPSecure 是否启用 https 安全检查, 默认不检查
func (h *HTTPClient) SetHTTPSecure(b bool) {
	h.https = b
	h.lazyInit()
	if b {
		h.transport.TLSClientConfig = nil
	} else {
		h.transport.TLSClientConfig = &tls.Config{
			InsecureSkipVerify: !b,
		}
	}
}

// SetKeepAlive 设置 Keep-Alive
func (h *HTTPClient) SetKeepAlive(b bool) {
	h.lazyInit()
	h.transport.DisableKeepAlives = !b
}

// SetGzip 是否启用Gzip
func (h *HTTPClient) SetGzip(b bool) {
	h.lazyInit()
	h.transport.DisableCompression = !b
}

// SetResponseHeaderTimeout 设置目标服务器响应超时时间
func (h *HTTPClient) SetResponseHeaderTimeout(t time.Duration) {
	h.lazyInit()
	h.transport.ResponseHeaderTimeout = t
}

// SetTLSHandshakeTimeout 设置tls握手超时时间
func (h *HTTPClient) SetTLSHandshakeTimeout(t time.Duration) {
	h.lazyInit()
	h.transport.TLSHandshakeTimeout = t
}

// SetTimeout 设置 http 请求超时时间, 默认30s
func (h *HTTPClient) SetTimeout(t time.Duration) {
	h.Client.Timeout = t
}



================================================
FILE: requester/requester.go
================================================
// Package requester 提供网络请求简便操作
package requester

const (
	// DefaultUserAgent 默认浏览器标识
	DefaultUserAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"
)

var (
	// UserAgent 浏览器标识
	UserAgent = DefaultUserAgent
	// DefaultClient 默认 http 客户端
	DefaultClient = NewHTTPClient()
)

type (
	// ContentTyper Content-Type 接口
	ContentTyper interface {
		ContentType() string
	}

	// ContentLengther Content-Length 接口
	ContentLengther interface {
		ContentLength() int64
	}

	// Event 下载/上传任务运行时事件
	Event func()

	// EventOnError 任务出错运行时事件
	EventOnError func(err error)
)



================================================
FILE: requester/tcpaddr_cache.go
================================================
package requester



================================================
FILE: requester/util.go
================================================
package requester

import (
	"fmt"
	"net/http"
	"strings"
)

// ParseCookieStr 解析 Cookie 字符串
func ParseCookieStr(cookieStr string) []*http.Cookie {
	rawCookies := strings.SplitN(cookieStr, ";", -1)
	cookies := make([]*http.Cookie, 0, len(rawCookies))

	for _, rawCookie := range rawCookies {
		s2 := strings.SplitN(rawCookie, "=", 2)
		if len(s2) < 2 {
			fmt.Println(s2)
			continue
		}

		s2[0] = strings.TrimSpace(s2[0])
		s2[1] = strings.TrimSpace(s2[1])

		cookies = append(cookies, &http.Cookie{
			Name:  s2[0],
			Value: s2[1],
		})
	}
	return cookies
}



================================================
FILE: requester/downloader/config.go
================================================
package downloader

import (
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
)

const (
	//CacheSize 默认的下载缓存
	CacheSize = 8192
)

var (
	// MinParallelSize 单个线程最小的数据量
	MinParallelSize int64 = 128 * 1024 // 128kb
)

//Config 下载配置
type Config struct {
	Mode                       transfer.RangeGenMode      // 下载Range分配模式
	MaxParallel                int                        // 最大下载并发量
	CacheSize                  int                        // 下载缓冲
	BlockSize                  int64                      // 每个Range区块的大小, RangeGenMode 为 RangeGenMode2 时才有效
	MaxRate                    int64                      // 限制最大下载速度
	InstanceStateStorageFormat InstanceStateStorageFormat // 断点续传储存类型
	InstanceStatePath          string                     // 断点续传信息路径
	IsTest                     bool                       // 是否测试下载
	TryHTTP                    bool                       // 是否尝试使用 http 连接
}

//NewConfig 返回默认配置
func NewConfig() *Config {
	return &Config{
		MaxParallel: 5,
		CacheSize:   CacheSize,
		IsTest:      false,
	}
}

//Fix 修复配置信息, 使其合法
func (cfg *Config) Fix() {
	fixCacheSize(&cfg.CacheSize)
	if cfg.MaxParallel < 1 {
		cfg.MaxParallel = 1
	}
}

//Copy 拷贝新的配置
func (cfg *Config) Copy() *Config {
	newCfg := *cfg
	return &newCfg
}



================================================
FILE: requester/downloader/download_firstinfo.go
================================================
package downloader

import (
	"fmt"
	"net/http"
	"reflect"
)

type (
	DownloadFirstInfo struct {
		ContentLength int64
		ContentMD5    string
		ContentCRC32  string
		AcceptRanges  string
		Referer       string
	}
)

func NewDownloadFirstInfoByResp(contentLength int64, resp *http.Response) (dfi *DownloadFirstInfo) {
	dfi = &DownloadFirstInfo{}
	if resp == nil {
		dfi.ContentLength = contentLength
		return
	}
	if contentLength != resp.ContentLength {
		dfi.ContentLength = contentLength
	}
	dfi.AcceptRanges = resp.Header.Get("Accept-Ranges")
	dfi.Referer = resp.Header.Get("Referer")
	return
}

func (dfi *DownloadFirstInfo) Compare(n *DownloadFirstInfo) bool {
	if n == nil {
		return false
	}
	if dfi.ContentLength != n.ContentLength {
		return false
	}
	if dfi.AcceptRanges != n.AcceptRanges {
		return false
	}
	if dfi.Referer != n.Referer {
		return false
	}
	return true
}

// ToMap 转换为map
func (dfi *DownloadFirstInfo) ToMap() map[string]string {
	m := map[string]string{
		"Content-MD5":     dfi.ContentMD5,
		"x-bs-meta-crc32": dfi.ContentCRC32,
		"Accept-Ranges":   dfi.AcceptRanges,
		"Referer":         dfi.Referer,
	}
	return m
}

// ToMapByReflect 用reflect转换为map
func (dfi *DownloadFirstInfo) ToMapByReflect() map[string]string {
	te := reflect.TypeOf(dfi).Elem()
	ve := reflect.ValueOf(dfi).Elem()
	n := te.NumField()
	m := map[string]string{}
	for i := 0; i < n; i++ {
		f := te.Field(i)
		m[f.Name] = fmt.Sprint(ve.Field(i).Interface())
	}
	return m
}



================================================
FILE: requester/downloader/download_test.go
================================================
package downloader

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"os"
	"testing"
	"time"
)

var (
	url1 = "https://dldir1.qq.com/qqfile/qq/TIM2.1.8/23475/TIM2.1.8.exe"
	url2 = "https://git.oschina.net/lufenping/pixabay_img/raw/master/tiny-20170712/lizard-2427248_1920.jpg"
)

func TestRandomNumber(t *testing.T) {
	for i := 0; i < 10; i++ {
		fmt.Println(RandomNumber(0, 5))
	}
}

func TestExample(t *testing.T) {
	DoDownload(url2, "lizard-2427248_1920.jpg", nil)
}

func TestDownloadTIM(t *testing.T) {
	pcsverbose.IsVerbose = true

	file, _ := os.OpenFile("tim.exe", os.O_CREATE|os.O_WRONLY, 0777)
	d := NewDownloader(url1, file, &Config{
		MaxParallel:       10,
		CacheSize:         8192,
		InstanceStatePath: "tmp.txt",
	})

	client := requester.NewHTTPClient()
	client.SetTimeout(10 * time.Second)
	d.SetClient(client)

	go func() {
		for {
			if d.monitor != nil {
				fmt.Println(d.monitor.ShowWorkers())
			}
			time.Sleep(1e9)
		}
	}()
	go func() {
		time.Sleep(3e9)
		d.Pause()
		time.Sleep(5e9)
		d.Resume()
		time.Sleep(9e9)
		d.Pause()
		time.Sleep(5e9)
		d.Resume()
		time.Sleep(3e9)
		d.Cancel()
		fmt.Println("canceled")
		time.Sleep(3e9)
	}()
	err := d.Execute()
	if err != nil {
		fmt.Println(err)
	}
}

func newSlice() [][]byte {
	s := make([][]byte, 20)
	s[0] = []byte("kjashdfiuqwheirhwuq")
	s[9] = []byte("kjashdfiuqwheirhwuq")
	return s
}

func rangeSlice(f func(key int, by []byte) bool) {
	s := newSlice()
	for k := range s {
		if s[k] == nil {
			continue
		}
		if !f(k, s[k]) {
			break
		}
	}
}

func BenchmarkRange1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		var a = 0
		rangeSlice(func(key int, s []byte) bool {
			a++
			return true
		})
	}
}

func BenchmarkRange2(b *testing.B) {
	for i := 0; i < b.N; i++ {
		s := newSlice()
		a := 0
		for k := range s {
			if s[k] == nil {
				continue
			}
			a++
		}
	}
}



================================================
FILE: requester/downloader/downloader.go
================================================
// Package downloader 多线程下载器, 重构版
package downloader

import (
	"context"
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/prealloc"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/waitgroup"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio/speeds"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"io"
	"net/http"
	"sync"
	"time"
)

const (
	// DefaultAcceptRanges 默认的 Accept-Ranges
	DefaultAcceptRanges = "bytes"
)

type (
	// Downloader 下载
	Downloader struct {
		onExecuteEvent        requester.Event    //开始下载事件
		onSuccessEvent        requester.Event    //成功下载事件
		onFinishEvent         requester.Event    //结束下载事件
		onPauseEvent          requester.Event    //暂停下载事件
		onResumeEvent         requester.Event    //恢复下载事件
		onCancelEvent         requester.Event    //取消下载事件
		onDownloadStatusEvent DownloadStatusFunc //状态处理事件

		monitorCancelFunc context.CancelFunc

		firstInfo               *DownloadFirstInfo      // 初始信息
		loadBalancerCompareFunc LoadBalancerCompareFunc // 负载均衡检测函数
		durlCheckFunc           DURLCheckFunc           // 下载url检测函数
		statusCodeBodyCheckFunc StatusCodeBodyCheckFunc
		executeTime             time.Time
		durl                    string
		loadBalansers           []string
		writer                  io.WriterAt
		client                  *requester.HTTPClient
		config                  *Config
		monitor                 *Monitor
		instanceState           *InstanceState
	}

	// DURLCheckFunc 下载URL检测函数
	DURLCheckFunc func(client *requester.HTTPClient, durl string) (contentLength int64, resp *http.Response, err error)
	// StatusCodeBodyCheckFunc 响应状态码出错的检查函数
	StatusCodeBodyCheckFunc func(respBody io.Reader) error
)

//NewDownloader 初始化Downloader
func NewDownloader(durl string, writer io.WriterAt, config *Config) (der *Downloader) {
	der = &Downloader{
		durl:   durl,
		config: config,
		writer: writer,
	}

	return
}

// SetFirstInfo 设置初始信息
// 如果设置了此值, 将忽略检测url
func (der *Downloader) SetFirstInfo(i *DownloadFirstInfo) {
	der.firstInfo = i
}

//SetClient 设置http客户端
func (der *Downloader) SetClient(client *requester.HTTPClient) {
	der.client = client
}

// SetDURLCheckFunc 设置下载URL检测函数
func (der *Downloader) SetDURLCheckFunc(f DURLCheckFunc) {
	der.durlCheckFunc = f
}

// SetLoadBalancerCompareFunc 设置负载均衡检测函数
func (der *Downloader) SetLoadBalancerCompareFunc(f LoadBalancerCompareFunc) {
	der.loadBalancerCompareFunc = f
}

//SetStatusCodeBodyCheckFunc 设置响应状态码出错的检查函数, 当FirstCheckMethod不为HEAD时才有效
func (der *Downloader) SetStatusCodeBodyCheckFunc(f StatusCodeBodyCheckFunc) {
	der.statusCodeBodyCheckFunc = f
}

func (der *Downloader) lazyInit() {
	if der.config == nil {
		der.config = NewConfig()
	}
	if der.client == nil {
		der.client = requester.NewHTTPClient()
		der.client.SetTimeout(20 * time.Minute)
	}
	if der.monitor == nil {
		der.monitor = NewMonitor()
	}
	if der.durlCheckFunc == nil {
		der.durlCheckFunc = DefaultDURLCheckFunc
	}
	if der.loadBalancerCompareFunc == nil {
		der.loadBalancerCompareFunc = DefaultLoadBalancerCompareFunc
	}
}

// SelectParallel 获取合适的 parallel
func (der *Downloader) SelectParallel(single bool, maxParallel int, totalSize int64, instanceRangeList transfer.RangeList) (parallel int) {
	isRange := instanceRangeList != nil && len(instanceRangeList) > 0
	if single { //不支持多线程
		parallel = 1
	} else if isRange {
		parallel = len(instanceRangeList)
	} else {
		parallel = der.config.MaxParallel
		if int64(parallel) > totalSize/int64(MinParallelSize) {
			parallel = int(totalSize/int64(MinParallelSize)) + 1
		}
	}

	if parallel < 1 {
		parallel = 1
	}
	return
}

// SelectBlockSizeAndInitRangeGen 获取合适的 BlockSize, 和初始化 RangeGen
func (der *Downloader) SelectBlockSizeAndInitRangeGen(single bool, status *transfer.DownloadStatus, parallel int) (blockSize int64, initErr error) {
	// Range 生成器
	if single { // 单线程
		blockSize = -1
		return
	}
	gen := status.RangeListGen()
	if gen == nil {
		switch der.config.Mode {
		case transfer.RangeGenMode_Default:
			gen = transfer.NewRangeListGenDefault(status.TotalSize(), 0, 0, parallel)
			blockSize = gen.LoadBlockSize()
		case transfer.RangeGenMode_BlockSize:
			b2 := status.TotalSize()/int64(parallel) + 1
			if b2 > der.config.BlockSize { // 选小的BlockSize, 以更高并发
				blockSize = der.config.BlockSize
			} else {
				blockSize = b2
			}

			gen = transfer.NewRangeListGenBlockSize(status.TotalSize(), 0, blockSize)
		default:
			initErr = transfer.ErrUnknownRangeGenMode
			return
		}
	} else {
		blockSize = gen.LoadBlockSize()
	}
	status.SetRangeListGen(gen)
	return
}

// SelectCacheSize 获取合适的 cacheSize
func (der *Downloader) SelectCacheSize(confCacheSize int, blockSize int64) (cacheSize int) {
	if blockSize > 0 && int64(confCacheSize) > blockSize {
		// 如果 cache size 过高, 则调低
		cacheSize = int(blockSize)
	} else {
		cacheSize = confCacheSize
	}
	return
}

// DefaultDURLCheckFunc 默认的 DURLCheckFunc
func DefaultDURLCheckFunc(client *requester.HTTPClient, durl string) (contentLength int64, resp *http.Response, err error) {
	resp, err = client.Req(http.MethodGet, durl, nil, nil)
	if err != nil {
		if resp != nil {
			resp.Body.Close()
		}
		return 0, nil, err
	}
	return resp.ContentLength, resp, nil
}

func (der *Downloader) checkLoadBalancers() *LoadBalancerResponseList {
	var (
		loadBalancerResponses = make([]*LoadBalancerResponse, 0, len(der.loadBalansers)+1)
		handleLoadBalancer    = func(req *http.Request) {
			if req == nil {
				return
			}

			if der.config.TryHTTP {
				req.URL.Scheme = "http"
			}

			loadBalancer := &LoadBalancerResponse{
				URL:     req.URL.String(),
				Referer: req.Referer(),
			}

			loadBalancerResponses = append(loadBalancerResponses, loadBalancer)
			pcsverbose.Verbosef("DEBUG: load balance task: URL: %s, Referer: %s\n", loadBalancer.URL, loadBalancer.Referer)
		}
	)

	// 加入第一个
	loadBalancerResponses = append(loadBalancerResponses, &LoadBalancerResponse{
		URL: der.durl,
	})

	// 负载均衡
	wg := waitgroup.NewWaitGroup(10)
	privTimeout := der.client.Client.Timeout
	der.client.SetTimeout(5 * time.Second)
	for _, loadBalanser := range der.loadBalansers {
		wg.AddDelta()
		go func(loadBalanser string) {
			defer wg.Done()

			subContentLength, subResp, subErr := der.durlCheckFunc(der.client, loadBalanser)
			if subResp != nil {
				subResp.Body.Close() // 不读Body, 马上关闭连接
			}
			if subErr != nil {
				pcsverbose.Verbosef("DEBUG: loadBalanser Error: %s\n", subErr)
				return
			}

			// 检测状态码
			switch subResp.StatusCode / 100 {
			case 2: // succeed
			case 4, 5: // error
				var err error
				if der.statusCodeBodyCheckFunc != nil {
					err = der.statusCodeBodyCheckFunc(subResp.Body)
				} else {
					err = errors.New(subResp.Status)
				}
				pcsverbose.Verbosef("DEBUG: loadBalanser Status Error: %s\n", err)
				return
			}

			// 检测长度
			if der.firstInfo.ContentLength != subContentLength {
				pcsverbose.Verbosef("DEBUG: loadBalanser Content-Length not equal to main server\n")
				return
			}

			if !der.loadBalancerCompareFunc(der.firstInfo.ToMap(), subResp) {
				pcsverbose.Verbosef("DEBUG: loadBalanser not equal to main server\n")
				return
			}

			handleLoadBalancer(subResp.Request)
		}(loadBalanser)
	}
	wg.Wait()
	der.client.SetTimeout(privTimeout)

	loadBalancerResponseList := NewLoadBalancerResponseList(loadBalancerResponses)
	return loadBalancerResponseList
}

//Execute 开始任务
func (der *Downloader) Execute() error {
	der.lazyInit()

	var (
		resp *http.Response
	)
	if der.firstInfo == nil {
		// 检测
		contentLength, resp, err := der.durlCheckFunc(der.client, der.durl)
		if err != nil {
			return err
		}

		// 检测网络错误
		switch resp.StatusCode / 100 {
		case 2: // succeed
		case 4, 5: // error
			if der.statusCodeBodyCheckFunc != nil {
				err = der.statusCodeBodyCheckFunc(resp.Body)
				resp.Body.Close() // 关闭连接
				if err != nil {
					return err
				}
			}
			return errors.New(resp.Status)
		}

		acceptRanges := resp.Header.Get("Accept-Ranges")
		if contentLength < 0 {
			acceptRanges = ""
		} else {
			acceptRanges = DefaultAcceptRanges
		}

		// 初始化firstInfo
		der.firstInfo = &DownloadFirstInfo{
			ContentLength: contentLength,
			ContentMD5:    resp.Header.Get("Content-MD5"),
			ContentCRC32:  resp.Header.Get("x-bs-meta-crc32"),
			AcceptRanges:  acceptRanges,
			Referer:       resp.Header.Get("Referer"),
		}
		pcsverbose.Verbosef("DEBUG: download task: URL: %s, Referer: %s\n", resp.Request.URL, resp.Request.Referer())
	} else {
		if der.firstInfo.AcceptRanges == "" {
			der.firstInfo.AcceptRanges = DefaultAcceptRanges
		}
	}

	var (
		loadBalancerResponseList = der.checkLoadBalancers()
		single                   = der.firstInfo.AcceptRanges == ""
		bii                      *transfer.DownloadInstanceInfo
	)

	if !single {
		//load breakpoint
		//服务端不支持多线程时, 不记录断点
		err := der.initInstanceState(der.config.InstanceStateStorageFormat)
		if err != nil {
			return err
		}
		bii = der.instanceState.Get()
	}

	var (
		isInstance = bii != nil // 是否存在断点信息
		status     *transfer.DownloadStatus
	)
	if !isInstance {
		bii = &transfer.DownloadInstanceInfo{}
	}

	if bii.DownloadStatus != nil {
		// 使用断点信息的状态
		status = bii.DownloadStatus
	} else {
		// 新建状态
		status = transfer.NewDownloadStatus()
		status.SetTotalSize(der.firstInfo.ContentLength)
	}

	// 设置限速
	if der.config.MaxRate > 0 {
		rl := speeds.NewRateLimit(der.config.MaxRate)
		status.SetRateLimit(rl)
		defer rl.Stop()
	}

	// 数据处理
	parallel := der.SelectParallel(single, der.config.MaxParallel, status.TotalSize(), bii.Ranges) // 实际的下载并行量
	blockSize, err := der.SelectBlockSizeAndInitRangeGen(single, status, parallel)                 // 实际的BlockSize
	if err != nil {
		return err
	}

	cacheSize := der.SelectCacheSize(der.config.CacheSize, blockSize) // 实际下载缓存
	cachepool.SetSyncPoolSize(cacheSize)                              // 调整pool大小

	pcsverbose.Verbosef("DEBUG: download task CREATED: parallel: %d, cache size: %d\n", parallel, cacheSize)

	der.monitor.InitMonitorCapacity(parallel)

	var writer Writer
	if !der.config.IsTest {
		// 尝试修剪文件
		if fder, ok := der.writer.(Fder); ok {
			err = prealloc.PreAlloc(fder.Fd(), status.TotalSize())
			if err != nil {
				pcsverbose.Verbosef("DEBUG: truncate file error: %s\n", err)
			}
		}
		writer = der.writer // 非测试模式, 赋值writer
	}

	// 数据平均分配给各个线程
	isRange := bii.Ranges != nil && len(bii.Ranges) > 0
	if !isRange {
		// 没有使用断点续传
		// 分配线程
		bii.Ranges = make(transfer.RangeList, 0, parallel)
		if single { // 单线程
			bii.Ranges = append(bii.Ranges, &transfer.Range{})
		} else {
			gen := status.RangeListGen()
			for i := 0; i < cap(bii.Ranges); i++ {
				_, r := gen.GenRange()
				if r == nil { // 没有了（不正常）
					break
				}
				bii.Ranges = append(bii.Ranges, r)
			}
		}
	}

	var (
		writeMu = &sync.Mutex{}
	)
	for k, r := range bii.Ranges {
		loadBalancer := loadBalancerResponseList.SequentialGet()
		if loadBalancer == nil {
			continue
		}

		worker := NewWorker(k, loadBalancer.URL, writer)
		worker.SetClient(der.client)
		worker.SetWriteMutex(writeMu)
		worker.SetReferer(loadBalancer.Referer)
		worker.SetTotalSize(der.firstInfo.ContentLength)

		// 使用第一个连接
		// 断点续传时不使用
		if k == 0 && !isInstance {
			worker.firstResp = resp
		}

		worker.SetAcceptRange(der.firstInfo.AcceptRanges)
		worker.SetRange(r) // 分配Range
		der.monitor.Append(worker)
	}

	der.monitor.SetStatus(status)

	// 服务器不支持断点续传, 或者单线程下载, 都不重载worker
	der.monitor.SetReloadWorker(parallel > 1)

	moniterCtx, moniterCancelFunc := context.WithCancel(context.Background())
	der.monitorCancelFunc = moniterCancelFunc

	der.monitor.SetInstanceState(der.instanceState)

	// 开始执行
	der.executeTime = time.Now()
	pcsutil.Trigger(der.onExecuteEvent)
	der.downloadStatusEvent() // 启动执行状态处理事件
	der.monitor.Execute(moniterCtx)

	// 检查错误
	err = der.monitor.Err()
	if err == nil { // 成功
		pcsutil.Trigger(der.onSuccessEvent)
		if !single {
			der.removeInstanceState() // 移除断点续传文件
		}
	}

	// 执行结束
	pcsutil.Trigger(der.onFinishEvent)
	return err
}

//downloadStatusEvent 执行状态处理事件
func (der *Downloader) downloadStatusEvent() {
	if der.onDownloadStatusEvent == nil {
		return
	}

	status := der.monitor.Status()
	go func() {
		ticker := time.NewTicker(1 * time.Second)
		defer ticker.Stop()
		for {
			select {
			case <-der.monitor.completed:
				return
			case <-ticker.C:
				der.onDownloadStatusEvent(status, der.monitor.RangeWorker)
			}
		}
	}()
}

//Pause 暂停
func (der *Downloader) Pause() {
	if der.monitor == nil {
		return
	}
	pcsutil.Trigger(der.onPauseEvent)
	der.monitor.Pause()
}

//Resume 恢复
func (der *Downloader) Resume() {
	if der.monitor == nil {
		return
	}
	pcsutil.Trigger(der.onResumeEvent)
	der.monitor.Resume()
}

//Cancel 取消
func (der *Downloader) Cancel() {
	if der.monitor == nil {
		return
	}
	pcsutil.Trigger(der.onCancelEvent)
	pcsutil.Trigger(der.monitorCancelFunc)
}

//OnExecute 设置开始下载事件
func (der *Downloader) OnExecute(onExecuteEvent requester.Event) {
	der.onExecuteEvent = onExecuteEvent
}

//OnSuccess 设置成功下载事件
func (der *Downloader) OnSuccess(onSuccessEvent requester.Event) {
	der.onSuccessEvent = onSuccessEvent
}

//OnFinish 设置结束下载事件
func (der *Downloader) OnFinish(onFinishEvent requester.Event) {
	der.onFinishEvent = onFinishEvent
}

//OnPause 设置暂停下载事件
func (der *Downloader) OnPause(onPauseEvent requester.Event) {
	der.onPauseEvent = onPauseEvent
}

//OnResume 设置恢复下载事件
func (der *Downloader) OnResume(onResumeEvent requester.Event) {
	der.onResumeEvent = onResumeEvent
}

//OnCancel 设置取消下载事件
func (der *Downloader) OnCancel(onCancelEvent requester.Event) {
	der.onCancelEvent = onCancelEvent
}

//OnDownloadStatusEvent 设置状态处理函数
func (der *Downloader) OnDownloadStatusEvent(f DownloadStatusFunc) {
	der.onDownloadStatusEvent = f
}



================================================
FILE: requester/downloader/example.go
================================================
package downloader

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"io"
	"os"
)

// DoDownload 执行下载
func DoDownload(durl string, savePath string, cfg *Config) {
	var (
		file   *os.File
		writer io.WriterAt
		err    error
	)

	if savePath != "" {
		writer, file, err = NewDownloaderWriterByFilename(savePath, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0666)
		if err != nil {
			fmt.Println(err)
			return
		}
		defer file.Close()
	}

	download := NewDownloader(durl, writer, cfg)

	exitDownloadFunc := make(chan struct{})

	download.OnDownloadStatusEvent(func(status transfer.DownloadStatuser, workersCallback func(RangeWorkerFunc)) {
		var ts string
		if status.TotalSize() <= 0 {
			ts = converter.ConvertFileSize(status.Downloaded(), 2)
		} else {
			ts = converter.ConvertFileSize(status.TotalSize(), 2)
		}

		fmt.Printf("\r ↓ %s/%s %s/s in %s ............",
			converter.ConvertFileSize(status.Downloaded(), 2),
			ts,
			converter.ConvertFileSize(status.SpeedsPerSecond(), 2),
			status.TimeElapsed(),
		)
	})

	err = download.Execute()
	close(exitDownloadFunc)
	if err != nil {
		fmt.Printf("err: %s\n", err)
	}
}



================================================
FILE: requester/downloader/instance_state.go
================================================
package downloader

import (
	"errors"
	"github.com/golang/protobuf/proto"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"github.com/json-iterator/go"
	"os"
	"sync"
)

type (
	//InstanceState 状态, 断点续传信息
	InstanceState struct {
		saveFile *os.File
		format   InstanceStateStorageFormat
		ii       transfer.DownloadInstanceInfoExporter
		mu       sync.Mutex
	}

	// InstanceStateStorageFormat 断点续传储存类型
	InstanceStateStorageFormat int
)

const (
	// InstanceStateStorageFormatJSON json 格式
	InstanceStateStorageFormatJSON = iota
	// InstanceStateStorageFormatProto3 protobuf 格式
	InstanceStateStorageFormatProto3
)

//NewInstanceState 初始化InstanceState
func NewInstanceState(saveFile *os.File, format InstanceStateStorageFormat) *InstanceState {
	return &InstanceState{
		saveFile: saveFile,
		format:   format,
	}
}

func (is *InstanceState) checkSaveFile() bool {
	return is.saveFile != nil
}

func (is *InstanceState) getSaveFileContents() []byte {
	if !is.checkSaveFile() {
		return nil
	}

	finfo, err := is.saveFile.Stat()
	if err != nil {
		panic(err)
	}

	size := finfo.Size()
	if size > 0xffffffff {
		panic("savePath too large")
	}
	intSize := int(size)

	buf := cachepool.RawMallocByteSlice(intSize)

	n, _ := is.saveFile.ReadAt(buf, 0)
	return buf[:n]
}

//Get 获取断点续传信息
func (is *InstanceState) Get() (eii *transfer.DownloadInstanceInfo) {
	if !is.checkSaveFile() {
		return nil
	}

	is.mu.Lock()
	defer is.mu.Unlock()

	contents := is.getSaveFileContents()
	if len(contents) <= 0 {
		return
	}

	is.ii = &transfer.DownloadInstanceInfoExport{}
	var err error
	switch is.format {
	case InstanceStateStorageFormatProto3:
		err = proto.Unmarshal(contents, is.ii.(*transfer.DownloadInstanceInfoExport))
	default:
		err = jsoniter.Unmarshal(contents, is.ii)
	}

	if err != nil {
		pcsverbose.Verbosef("DEBUG: InstanceInfo unmarshal error: %s\n", err)
		return
	}

	eii = is.ii.GetInstanceInfo()
	return
}

//Put 提交断点续传信息
func (is *InstanceState) Put(eii *transfer.DownloadInstanceInfo) {
	if !is.checkSaveFile() {
		return
	}

	is.mu.Lock()
	defer is.mu.Unlock()

	if is.ii == nil {
		is.ii = &transfer.DownloadInstanceInfoExport{}
	}
	is.ii.SetInstanceInfo(eii)
	var (
		data []byte
		err  error
	)
	switch is.format {
	case InstanceStateStorageFormatProto3:
		data, err = proto.Marshal(is.ii.(*transfer.DownloadInstanceInfoExport))
	default:
		data, err = jsoniter.Marshal(is.ii)
	}
	if err != nil {
		panic(err)
	}

	err = is.saveFile.Truncate(int64(len(data)))
	if err != nil {
		pcsverbose.Verbosef("DEBUG: truncate file error: %s\n", err)
	}

	_, err = is.saveFile.WriteAt(data, 0)
	if err != nil {
		pcsverbose.Verbosef("DEBUG: write instance state error: %s\n", err)
	}
}

//Close 关闭
func (is *InstanceState) Close() error {
	if !is.checkSaveFile() {
		return nil
	}

	return is.saveFile.Close()
}

func (der *Downloader) initInstanceState(format InstanceStateStorageFormat) (err error) {
	if der.instanceState != nil {
		return errors.New("already initInstanceState")
	}

	var saveFile *os.File
	if !der.config.IsTest && der.config.InstanceStatePath != "" {
		saveFile, err = os.OpenFile(der.config.InstanceStatePath, os.O_RDWR|os.O_CREATE, 0777)
		if err != nil {
			return err
		}
	}

	der.instanceState = NewInstanceState(saveFile, format)
	return nil
}

func (der *Downloader) removeInstanceState() error {
	der.instanceState.Close()
	if !der.config.IsTest && der.config.InstanceStatePath != "" {
		return os.Remove(der.config.InstanceStatePath)
	}
	return nil
}



================================================
FILE: requester/downloader/loadbalance.go
================================================
package downloader

import (
	"net/http"
	"sync/atomic"
)

type (
	// LoadBalancerResponse 负载均衡响应状态
	LoadBalancerResponse struct {
		URL     string
		Referer string
	}

	// LoadBalancerResponseList 负载均衡列表
	LoadBalancerResponseList struct {
		lbr    []*LoadBalancerResponse
		cursor int32
	}

	LoadBalancerCompareFunc func(info map[string]string, subResp *http.Response) bool
)

// NewLoadBalancerResponseList 初始化负载均衡列表
func NewLoadBalancerResponseList(lbr []*LoadBalancerResponse) *LoadBalancerResponseList {
	return &LoadBalancerResponseList{
		lbr: lbr,
	}
}

// SequentialGet 顺序获取
func (lbrl *LoadBalancerResponseList) SequentialGet() *LoadBalancerResponse {
	if len(lbrl.lbr) == 0 {
		return nil
	}

	if int(lbrl.cursor) >= len(lbrl.lbr) {
		lbrl.cursor = 0
	}

	lbr := lbrl.lbr[int(lbrl.cursor)]
	atomic.AddInt32(&lbrl.cursor, 1)
	return lbr
}

// RandomGet 随机获取
func (lbrl *LoadBalancerResponseList) RandomGet() *LoadBalancerResponse {
	return lbrl.lbr[RandomNumber(0, len(lbrl.lbr))]
}

// AddLoadBalanceServer 增加负载均衡服务器
func (der *Downloader) AddLoadBalanceServer(urls ...string) {
	der.loadBalansers = append(der.loadBalansers, urls...)
}

// DefaultLoadBalancerCompareFunc 检测负载均衡的服务器是否一致
func DefaultLoadBalancerCompareFunc(info map[string]string, subResp *http.Response) bool {
	if info == nil || subResp == nil {
		return false
	}

	for headerKey, value := range info {
		if value != subResp.Header.Get(headerKey) {
			return false
		}
	}

	return true
}



================================================
FILE: requester/downloader/monitor.go
================================================
package downloader

import (
	"context"
	"errors"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"sort"
	"time"
)

var (
	//ErrNoWokers no workers
	ErrNoWokers = errors.New("no workers")
)

type (
	//Monitor 线程监控器
	Monitor struct {
		workers         WorkerList
		status          *transfer.DownloadStatus
		instanceState   *InstanceState
		completed       chan struct{}
		err             error
		resetController *ResetController
		isReloadWorker  bool //是否重载worker, 单线程模式不重载

		// 临时变量
		lastAvaliableIndex int
	}

	// RangeWorkerFunc 遍历workers的函数
	RangeWorkerFunc func(key int, worker *Worker) bool
)

//NewMonitor 初始化Monitor
func NewMonitor() *Monitor {
	monitor := &Monitor{}
	return monitor
}

func (mt *Monitor) lazyInit() {
	if mt.workers == nil {
		mt.workers = make(WorkerList, 0, 100)
	}
	if mt.status == nil {
		mt.status = transfer.NewDownloadStatus()
	}
	if mt.resetController == nil {
		mt.resetController = NewResetController(80)
	}
}

//InitMonitorCapacity 初始化workers, 用于Append
func (mt *Monitor) InitMonitorCapacity(capacity int) {
	mt.workers = make(WorkerList, 0, capacity)
}

//Append 增加Worker
func (mt *Monitor) Append(worker *Worker) {
	if worker == nil {
		return
	}
	mt.workers = append(mt.workers, worker)
}

//SetWorkers 设置workers, 此操作会覆盖原有的workers
func (mt *Monitor) SetWorkers(workers WorkerList) {
	mt.workers = workers
}

//SetStatus 设置DownloadStatus
func (mt *Monitor) SetStatus(status *transfer.DownloadStatus) {
	mt.status = status
}

//SetInstanceState 设置状态
func (mt *Monitor) SetInstanceState(instanceState *InstanceState) {
	mt.instanceState = instanceState
}

//Status 返回DownloadStatus
func (mt *Monitor) Status() *transfer.DownloadStatus {
	return mt.status
}

//Err 返回遇到的错误
func (mt *Monitor) Err() error {
	return mt.err
}

//CompletedChan 获取completed chan
func (mt *Monitor) CompletedChan() <-chan struct{} {
	return mt.completed
}

//GetAvailableWorker 获取空闲的worker
func (mt *Monitor) GetAvailableWorker() *Worker {
	workerCount := len(mt.workers)
	for i := mt.lastAvaliableIndex; i < mt.lastAvaliableIndex+workerCount; i++ {
		index := i % workerCount
		worker := mt.workers[index]
		if worker.Completed() {
			mt.lastAvaliableIndex = index
			return worker
		}
	}
	return nil
}

//GetAllWorkersRange 获取所有worker的范围
func (mt *Monitor) GetAllWorkersRange() transfer.RangeList {
	allWorkerRanges := make(transfer.RangeList, 0, len(mt.workers))
	for _, worker := range mt.workers {
		allWorkerRanges = append(allWorkerRanges, worker.GetRange())
	}
	return allWorkerRanges
}

//NumLeftWorkers 剩余的worker数量
func (mt *Monitor) NumLeftWorkers() (num int) {
	for _, worker := range mt.workers {
		if !worker.Completed() {
			num++
		}
	}
	return
}

//SetReloadWorker 是否重载worker
func (mt *Monitor) SetReloadWorker(b bool) {
	mt.isReloadWorker = b
}

//IsLeftWorkersAllFailed 剩下的线程是否全部失败
func (mt *Monitor) IsLeftWorkersAllFailed() bool {
	failedNum := 0
	for _, worker := range mt.workers {
		if worker.Completed() {
			continue
		}

		if !worker.Failed() {
			failedNum++
			return false
		}
	}
	return failedNum != 0
}

//registerAllCompleted 全部完成则发送消息
func (mt *Monitor) registerAllCompleted() {
	mt.completed = make(chan struct{}, 0)
	var (
		workerNum   = len(mt.workers)
		completeNum = 0
	)

	go func() {
		for {
			time.Sleep(1 * time.Second)

			completeNum = 0
			for _, worker := range mt.workers {
				switch worker.GetStatus().StatusCode() {
				case StatusCodeInternalError:
					// 检测到内部错误
					// 马上停止执行
					mt.err = worker.Err()
					close(mt.completed)
					return
				case StatusCodeSuccessed, StatusCodeCanceled:
					completeNum++
				}
			}
			// status 在 lazyInit 之后, 不可能为空
			// 完成条件: 所有worker 都已经完成, 且 rangeGen 已生成完毕
			gen := mt.status.RangeListGen()
			if completeNum >= workerNum && (gen == nil || gen.IsDone()) { // 已完成
				close(mt.completed)
				return
			}
		}
	}()
}

//ResetFailedAndNetErrorWorkers 重设部分网络错误的worker
func (mt *Monitor) ResetFailedAndNetErrorWorkers() {
	for k := range mt.workers {
		if !mt.resetController.CanReset() {
			continue
		}

		switch mt.workers[k].GetStatus().StatusCode() {
		case StatusCodeNetError:
			pcsverbose.Verbosef("DEBUG: monitor: ResetFailedAndNetErrorWorkers: reset StatusCodeNetError worker, id: %d\n", mt.workers[k].id)
			goto reset
		case StatusCodeFailed:
			pcsverbose.Verbosef("DEBUG: monitor: ResetFailedAndNetErrorWorkers: reset StatusCodeFailed worker, id: %d\n", mt.workers[k].id)
			goto reset
		default:
			continue
		}

	reset:
		mt.workers[k].Reset()
		mt.resetController.AddResetNum()
	}
}

//RangeWorker 遍历worker
func (mt *Monitor) RangeWorker(f RangeWorkerFunc) {
	for k := range mt.workers {
		if !f(k, mt.workers[k]) {
			break
		}
	}
}

//Pause 暂停所有的下载
func (mt *Monitor) Pause() {
	for k := range mt.workers {
		mt.workers[k].Pause()
	}
}

//Resume 恢复所有的下载
func (mt *Monitor) Resume() {
	for k := range mt.workers {
		mt.workers[k].Resume()
	}
}

// TryAddNewWork 尝试加入新range
func (mt *Monitor) TryAddNewWork() {
	if mt.status == nil {
		return
	}
	gen := mt.status.RangeListGen()
	if gen == nil || gen.IsDone() {
		return
	}

	if !mt.resetController.CanReset() { //能否建立新连接
		return
	}

	availableWorker := mt.GetAvailableWorker()
	if availableWorker == nil {
		return
	}

	// 有空闲的range, 执行
	_, r := gen.GenRange()
	if r == nil {
		// 没有range了
		return
	}

	availableWorker.SetRange(r)
	availableWorker.ClearStatus()

	mt.resetController.AddResetNum()
	pcsverbose.Verbosef("MONITER: worker[%d] add new range: %s\n", availableWorker.ID(), r.ShowDetails())
	go availableWorker.Execute()
}

// DynamicSplitWorker 动态分配线程
func (mt *Monitor) DynamicSplitWorker(worker *Worker) {
	if !mt.resetController.CanReset() {
		return
	}

	switch worker.status.statusCode {
	case StatusCodeDownloading, StatusCodeFailed, StatusCodeNetError:
	//pass
	default:
		return
	}

	// 筛选空闲的Worker
	availableWorker := mt.GetAvailableWorker()
	if availableWorker == nil || worker == availableWorker { // 没有空的
		return
	}

	workerRange := worker.GetRange()

	end := workerRange.LoadEnd()
	middle := (workerRange.LoadBegin() + end) / 2

	if end-middle < MinParallelSize/5 { // 如果线程剩余的下载量太少, 不分配空闲线程
		return
	}

	// 折半
	availableWorkerRange := availableWorker.GetRange()
	availableWorkerRange.StoreBegin(middle) // middle不能加1
	availableWorkerRange.StoreEnd(end)
	availableWorker.ClearStatus()

	workerRange.StoreEnd(middle)

	mt.resetController.AddResetNum()
	pcsverbose.Verbosef("MONITOR: worker duplicated: %d <- %d\n", availableWorker.ID(), worker.ID())
	go availableWorker.Execute()
}

// ResetWorker 重设长时间无响应, 和下载速度为 0 的 Worker
func (mt *Monitor) ResetWorker(worker *Worker) {
	if !mt.resetController.CanReset() { //达到最大重载次数
		return
	}

	if worker.Completed() {
		return
	}

	// 忽略正在写入数据到硬盘的
	// 过滤速度有变化的线程
	status := worker.GetStatus()
	speeds := worker.GetSpeedsPerSecond()
	if speeds != 0 {
		return
	}

	switch status.StatusCode() {
	case StatusCodePending, StatusCodeReseted:
		fallthrough
	case StatusCodeWaitToWrite: // 正在写入数据
		fallthrough
	case StatusCodePaused: // 已暂停
		// 忽略, 返回
		return
	}

	mt.resetController.AddResetNum()

	// 重设连接
	pcsverbose.Verbosef("MONITOR: worker[%d] reload\n", worker.ID())
	worker.Reset()
}

//Execute 执行任务
func (mt *Monitor) Execute(cancelCtx context.Context) {
	if len(mt.workers) == 0 {
		mt.err = ErrNoWokers
		return
	}

	mt.lazyInit()
	for _, worker := range mt.workers {
		worker.SetDownloadStatus(mt.status)
		go worker.Execute()
	}

	mt.registerAllCompleted() // 注册completed
	ticker := time.NewTicker(990 * time.Millisecond)
	defer ticker.Stop()

	//开始监控
	for {
		select {
		case <-cancelCtx.Done():
			for _, worker := range mt.workers {
				err := worker.Cancel()
				if err != nil {
					pcsverbose.Verbosef("DEBUG: cancel failed, worker id: %d, err: %s\n", worker.ID(), err)
				}
			}
			return
		case <-mt.completed:
			return
		case <-ticker.C:
			// 初始化监控工作
			mt.ResetFailedAndNetErrorWorkers()

			mt.status.UpdateSpeeds() // 更新速度

			// 保存断点信息到文件
			if mt.instanceState != nil {
				mt.instanceState.Put(&transfer.DownloadInstanceInfo{
					DownloadStatus: mt.status,
					Ranges:         mt.GetAllWorkersRange(),
				})
			}

			// 加入新range
			mt.TryAddNewWork()

			// 不重载worker
			if !mt.isReloadWorker {
				continue
			}

			// 更新maxSpeeds
			mt.status.SetMaxSpeeds(mt.status.SpeedsPerSecond())

			// 速度减慢或者全部失败, 开始监控
			// 只有一个worker时不重设连接
			isLeftWorkersAllFailed := mt.IsLeftWorkersAllFailed()
			if mt.status.SpeedsPerSecond() < mt.status.MaxSpeeds()/6 || isLeftWorkersAllFailed {
				if isLeftWorkersAllFailed {
					pcsverbose.Verbosef("DEBUG: monitor: All workers failed\n")
				}
				mt.status.ClearMaxSpeeds() //清空最大速度的统计

				// 先进行动态分配线程
				pcsverbose.Verbosef("DEBUG: monitor: start duplicate.\n")
				sort.Sort(ByLeftDesc{mt.workers})
				for _, worker := range mt.workers {
					//动态分配线程
					mt.DynamicSplitWorker(worker)
				}

				// 重设长时间无响应, 和下载速度为 0 的线程
				pcsverbose.Verbosef("DEBUG: monitor: start reload.\n")
				for _, worker := range mt.workers {
					mt.ResetWorker(worker)
				}
			} // end if 2
		} //end select
	} //end for
}



================================================
FILE: requester/downloader/range_test.go
================================================
package downloader_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/requester/downloader"
	"testing"
)

func TestRangeListGen(t *testing.T) {
	gen1 := downloader.NewRangeListGenDefault(1024, 0, 0, 10)
	gen2 := downloader.NewRangeListGenBlockSize(1024, 0, 53)

	for mode, gen := range []*downloader.RangeListGen{gen1, gen2} {
		fmt.Printf("[%d] ----\n", mode+1)
		for i, r := gen.GenRange(); r != nil; i, r = gen.GenRange() {
			fmt.Printf("%d: %s\n", i, r.ShowDetails())
		}
		fmt.Println()
	}
}



================================================
FILE: requester/downloader/resetcontroler.go
================================================
package downloader

import (
	"github.com/felixonmars/BaiduPCS-Go/baidupcs/expires"
	"sync"
	"time"
)

// ResetController 网络连接控制器
type ResetController struct {
	mu          sync.Mutex
	currentTime time.Time
	maxResetNum int
	resetEntity map[expires.Expires]struct{}
}

// NewResetController 初始化*ResetController
func NewResetController(maxResetNum int) *ResetController {
	return &ResetController{
		currentTime: time.Now(),
		maxResetNum: maxResetNum,
		resetEntity: map[expires.Expires]struct{}{},
	}
}

func (rc *ResetController) update() {
	for k := range rc.resetEntity {
		if k.IsExpires() {
			delete(rc.resetEntity, k)
		}
	}
}

// AddResetNum 增加连接
func (rc *ResetController) AddResetNum() {
	rc.mu.Lock()
	defer rc.mu.Unlock()
	rc.update()
	rc.resetEntity[expires.NewExpires(9*time.Second)] = struct{}{}
}

// CanReset 是否可以建立连接
func (rc *ResetController) CanReset() bool {
	rc.mu.Lock()
	defer rc.mu.Unlock()
	rc.update()
	return len(rc.resetEntity) < rc.maxResetNum
}



================================================
FILE: requester/downloader/sort.go
================================================
package downloader

type (
	// ByLeftDesc 根据剩余下载量倒序排序
	ByLeftDesc struct {
		WorkerList
	}
)

// Len 返回长度
func (wl WorkerList) Len() int {
	return len(wl)
}

// Swap 交换
func (wl WorkerList) Swap(i, j int) {
	wl[i], wl[j] = wl[j], wl[i]
}

// Less 实现倒序
func (wl ByLeftDesc) Less(i, j int) bool {
	return wl.WorkerList[i].wrange.Len() > wl.WorkerList[j].wrange.Len()
}



================================================
FILE: requester/downloader/status.go
================================================
package downloader

import (
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
)

type (
	//WorkerStatuser 状态
	WorkerStatuser interface {
		StatusCode() StatusCode //状态码
		StatusText() string
	}

	//StatusCode 状态码
	StatusCode int

	//WorkerStatus worker状态
	WorkerStatus struct {
		statusCode StatusCode
	}

	// DownloadStatusFunc 下载状态处理函数
	DownloadStatusFunc func(status transfer.DownloadStatuser, workersCallback func(RangeWorkerFunc))
)

const (
	//StatusCodeInit 初始化
	StatusCodeInit StatusCode = iota
	//StatusCodeSuccessed 成功
	StatusCodeSuccessed
	//StatusCodePending 等待响应
	StatusCodePending
	//StatusCodeDownloading 下载中
	StatusCodeDownloading
	//StatusCodeWaitToWrite 等待写入数据
	StatusCodeWaitToWrite
	//StatusCodeInternalError 内部错误
	StatusCodeInternalError
	//StatusCodeTooManyConnections 连接数太多
	StatusCodeTooManyConnections
	//StatusCodeNetError 网络错误
	StatusCodeNetError
	//StatusCodeFailed 下载失败
	StatusCodeFailed
	//StatusCodePaused 已暂停
	StatusCodePaused
	//StatusCodeReseted 已重设连接
	StatusCodeReseted
	//StatusCodeCanceled 已取消
	StatusCodeCanceled
)

//GetStatusText 根据状态码获取状态信息
func GetStatusText(sc StatusCode) string {
	switch sc {
	case StatusCodeInit:
		return "初始化"
	case StatusCodeSuccessed:
		return "成功"
	case StatusCodePending:
		return "等待响应"
	case StatusCodeDownloading:
		return "下载中"
	case StatusCodeWaitToWrite:
		return "等待写入数据"
	case StatusCodeInternalError:
		return "内部错误"
	case StatusCodeTooManyConnections:
		return "连接数太多"
	case StatusCodeNetError:
		return "网络错误"
	case StatusCodeFailed:
		return "下载失败"
	case StatusCodePaused:
		return "已暂停"
	case StatusCodeReseted:
		return "已重设连接"
	case StatusCodeCanceled:
		return "已取消"
	default:
		return "未知状态码"
	}
}

//NewWorkerStatus 初始化WorkerStatus
func NewWorkerStatus() *WorkerStatus {
	return &WorkerStatus{
		statusCode: StatusCodeInit,
	}
}

//SetStatusCode 设置worker状态码
func (ws *WorkerStatus) SetStatusCode(sc StatusCode) {
	ws.statusCode = sc
}

//StatusCode 返回状态码
func (ws *WorkerStatus) StatusCode() StatusCode {
	return ws.statusCode
}

//StatusText 返回状态信息
func (ws *WorkerStatus) StatusText() string {
	return GetStatusText(ws.statusCode)
}



================================================
FILE: requester/downloader/utils.go
================================================
package downloader

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	mathrand "math/rand"
	"mime"
	"net/url"
	"path"
	"regexp"
	"strconv"
	"time"
)

var (
	// ContentRangeRE Content-Range 正则
	ContentRangeRE = regexp.MustCompile(`^.*? \d*?-\d*?/(\d*?)$`)

	// ranSource 随机数种子
	ranSource = mathrand.NewSource(time.Now().UnixNano())

	// ran 一个随机数实例
	ran = mathrand.New(ranSource)
)

// RandomNumber 生成指定区间随机数
func RandomNumber(min, max int) int {
	if min > max {
		min, max = max, min
	}
	return ran.Intn(max-min) + min
}

// GetFileName 获取文件名
func GetFileName(uri string, client *requester.HTTPClient) (filename string, err error) {
	if client == nil {
		client = requester.NewHTTPClient()
	}

	resp, err := client.Req("HEAD", uri, nil, nil)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		return "", err
	}

	_, params, err := mime.ParseMediaType(resp.Header.Get("Content-Disposition"))
	if err != nil {
		pcsverbose.Verbosef("DEBUG: GetFileName ParseMediaType error: %s\n", err)
		return path.Base(uri), nil
	}

	filename, err = url.QueryUnescape(params["filename"])
	if err != nil {
		return
	}

	if filename == "" {
		filename = path.Base(uri)
	}

	return
}

// ParseContentRange 解析Content-Range
func ParseContentRange(contentRange string) (contentLength int64) {
	raw := ContentRangeRE.FindStringSubmatch(contentRange)
	if len(raw) < 2 {
		return -1
	}

	c, err := strconv.ParseInt(raw[1], 10, 64)
	if err != nil {
		return -1
	}
	return c
}

func fixCacheSize(size *int) {
	if *size < 1024 {
		*size = 1024
	}
}



================================================
FILE: requester/downloader/worker.go
================================================
package downloader

import (
	"context"
	"errors"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio/speeds"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"io"
	"net/http"
	"sync"
)

type (
	//Worker 工作单元
	Worker struct {
		totalSize    int64 // 整个文件的大小, worker请求range时会获取尝试获取该值, 如果不匹配, 则返回错误
		wrange       *transfer.Range
		speedsStat   *speeds.Speeds
		id           int    //id
		url          string //下载地址
		referer      string //来源地址
		acceptRanges string
		client       *requester.HTTPClient
		firstResp    *http.Response // 第一个响应
		writerAt     io.WriterAt
		writeMu      *sync.Mutex
		execMu       sync.Mutex

		pauseChan              chan struct{}
		workerCancelFunc       context.CancelFunc
		resetFunc              context.CancelFunc
		readRespBodyCancelFunc func()
		err                    error //错误信息
		status                 WorkerStatus
		downloadStatus         *transfer.DownloadStatus //总的下载状态
	}

	// WorkerList worker列表
	WorkerList []*Worker
)

// Duplicate 构造新的列表
func (wl WorkerList) Duplicate() WorkerList {
	n := make(WorkerList, len(wl))
	copy(n, wl)
	return n
}

//NewWorker 初始化Worker
func NewWorker(id int, durl string, writerAt io.WriterAt) *Worker {
	return &Worker{
		id:       id,
		url:      durl,
		writerAt: writerAt,
	}
}

//ID 返回worker ID
func (wer *Worker) ID() int {
	return wer.id
}

func (wer *Worker) lazyInit() {
	if wer.client == nil {
		wer.client = requester.NewHTTPClient()
	}
	if wer.pauseChan == nil {
		wer.pauseChan = make(chan struct{})
	}
	if wer.wrange == nil {
		wer.wrange = &transfer.Range{}
	}
	if wer.wrange.LoadBegin() == 0 && wer.wrange.LoadEnd() == 0 {
		// 取消多线程下载
		wer.acceptRanges = ""
		wer.wrange.StoreEnd(-2)
	}
	if wer.speedsStat == nil {
		wer.speedsStat = &speeds.Speeds{}
	}
}

// SetTotalSize 设置整个文件的大小, worker请求range时会获取尝试获取该值, 如果不匹配, 则返回错误
func (wer *Worker) SetTotalSize(size int64) {
	wer.totalSize = size
}

//SetClient 设置http客户端
func (wer *Worker) SetClient(c *requester.HTTPClient) {
	wer.client = c
}

//SetAcceptRange 设置AcceptRange
func (wer *Worker) SetAcceptRange(acceptRanges string) {
	wer.acceptRanges = acceptRanges
}

//SetRange 设置请求范围
func (wer *Worker) SetRange(r *transfer.Range) {
	if wer.wrange == nil {
		wer.wrange = r
		return
	}
	wer.wrange.StoreBegin(r.LoadBegin())
	wer.wrange.StoreEnd(r.LoadEnd())
}

//SetReferer 设置来源
func (wer *Worker) SetReferer(referer string) {
	wer.referer = referer
}

//SetWriteMutex 设置数据写锁
func (wer *Worker) SetWriteMutex(mu *sync.Mutex) {
	wer.writeMu = mu
}

//SetDownloadStatus 增加其他需要统计的数据
func (wer *Worker) SetDownloadStatus(downloadStatus *transfer.DownloadStatus) {
	wer.downloadStatus = downloadStatus
}

//GetStatus 返回下载状态
func (wer *Worker) GetStatus() WorkerStatuser {
	// 空接口与空指针不等价
	return &wer.status
}

//GetRange 返回worker范围
func (wer *Worker) GetRange() *transfer.Range {
	return wer.wrange
}

//GetSpeedsPerSecond 获取每秒的速度
func (wer *Worker) GetSpeedsPerSecond() int64 {
	return wer.speedsStat.GetSpeeds()
}

//Pause 暂停下载
func (wer *Worker) Pause() {
	wer.lazyInit()
	if wer.acceptRanges == "" {
		pcsverbose.Verbosef("WARNING: worker unsupport pause")
		return
	}

	if wer.status.statusCode == StatusCodePaused {
		return
	}
	wer.pauseChan <- struct{}{}
	wer.status.statusCode = StatusCodePaused
}

//Resume 恢复下载
func (wer *Worker) Resume() {
	if wer.status.statusCode != StatusCodePaused {
		return
	}
	go wer.Execute()
}

//Cancel 取消下载
func (wer *Worker) Cancel() error {
	if wer.workerCancelFunc == nil {
		return errors.New("cancelFunc not set")
	}
	wer.workerCancelFunc()
	if wer.readRespBodyCancelFunc != nil {
		wer.readRespBodyCancelFunc()
	}
	return nil
}

//Reset 重设连接
func (wer *Worker) Reset() {
	if wer.resetFunc == nil {
		pcsverbose.Verbosef("DEBUG: worker: resetFunc not set")
		return
	}
	wer.resetFunc()
	if wer.readRespBodyCancelFunc != nil {
		wer.readRespBodyCancelFunc()
	}
	wer.ClearStatus()
	go wer.Execute()
}

// Canceled 是否已经取消
func (wer *Worker) Canceled() bool {
	return wer.status.statusCode == StatusCodeCanceled
}

//Completed 是否已经完成
func (wer *Worker) Completed() bool {
	switch wer.status.statusCode {
	case StatusCodeSuccessed, StatusCodeCanceled:
		return true
	default:
		return false
	}
}

//Failed 是否失败
func (wer *Worker) Failed() bool {
	switch wer.status.statusCode {
	case StatusCodeFailed, StatusCodeInternalError, StatusCodeTooManyConnections, StatusCodeNetError:
		return true
	default:
		return false
	}
}

//ClearStatus 清空状态
func (wer *Worker) ClearStatus() {
	wer.status.statusCode = StatusCodeInit
}

//Err 返回worker错误
func (wer *Worker) Err() error {
	return wer.err
}

//Execute 执行任务
func (wer *Worker) Execute() {
	wer.lazyInit()

	wer.execMu.Lock()
	defer wer.execMu.Unlock()

	wer.status.statusCode = StatusCodeInit
	single := wer.acceptRanges == ""

	// 如果已暂停, 退出
	if wer.status.statusCode == StatusCodePaused {
		return
	}

	if !single {
		// 已完成
		if rlen := wer.wrange.Len(); rlen <= 0 {
			if rlen < 0 {
				pcsverbose.Verbosef("DEBUG: RangeLen is negative at begin: %v, %d\n", wer.wrange, wer.wrange.Len())
			}
			wer.status.statusCode = StatusCodeSuccessed
			return
		}
	}

	workerCancelCtx, workerCancelFunc := context.WithCancel(context.Background())
	wer.workerCancelFunc = workerCancelFunc
	resetCtx, resetFunc := context.WithCancel(context.Background())
	wer.resetFunc = resetFunc

	header := map[string]string{}
	if wer.referer != "" {
		header["Referer"] = wer.referer
	}
	//检测是否支持range
	if wer.acceptRanges != "" && wer.wrange.Len() >= 0 {
		header["Range"] = fmt.Sprintf("%s=%d-%d", wer.acceptRanges, wer.wrange.LoadBegin(), wer.wrange.LoadEnd()-1)
	}

	wer.status.statusCode = StatusCodePending

	var resp *http.Response
	if wer.firstResp != nil {
		resp = wer.firstResp // 使用第一个连接
	} else {
		resp, wer.err = wer.client.Req(http.MethodGet, wer.url, nil, header)
	}
	if resp != nil {
		defer func() {
			resp.Body.Close()
			wer.firstResp = nil // 去掉第一个连接
		}()
		wer.readRespBodyCancelFunc = func() {
			resp.Body.Close()
		}
	}
	if wer.err != nil {
		wer.status.statusCode = StatusCodeNetError
		return
	}

	// 判断响应状态
	switch resp.StatusCode {
	case 200, 206:
		// do nothing, continue
	case 416: //Requested Range Not Satisfiable
		fallthrough
	case 403: // Forbidden
		fallthrough
	case 406: // Not Acceptable
		wer.status.statusCode = StatusCodeNetError
		wer.err = errors.New(resp.Status)
		return
	case 429, 509: // Too Many Requests
		wer.status.SetStatusCode(StatusCodeTooManyConnections)
		wer.err = errors.New(resp.Status)
		return
	default:
		wer.status.statusCode = StatusCodeNetError
		wer.err = fmt.Errorf("unexpected http status code, %d, %s", resp.StatusCode, resp.Status)
		return
	}

	var (
		contentLength = resp.ContentLength
		rangeLength   = wer.wrange.Len()
	)

	if !single {
		// 检查请求长度
		if contentLength != rangeLength && wer.firstResp == nil { // 跳过检查第一个连接
			wer.status.statusCode = StatusCodeNetError
			wer.err = fmt.Errorf("Content-Length is unexpected: %d, need %d", contentLength, rangeLength)
			return
		}
		// 检查总大小
		if wer.totalSize > 0 {
			total := ParseContentRange(resp.Header.Get("Content-Range"))
			if total > 0 {
				if total != wer.totalSize {
					wer.status.statusCode = StatusCodeInternalError // 这里设置为内部错误, 强制停止下载
					wer.err = fmt.Errorf("Content-Range total length is unexpected: %d, need %d", total, wer.totalSize)
					return
				}
			}
		}
	}

	var (
		buf       = cachepool.SyncPool.Get().([]byte)
		n, nn     int
		n64, nn64 int64
	)
	defer cachepool.SyncPool.Put(buf)

	for {
		select {
		case <-workerCancelCtx.Done(): //取消
			wer.status.statusCode = StatusCodeCanceled
			return
		case <-resetCtx.Done(): //重设连接
			wer.status.statusCode = StatusCodeReseted
			return
		case <-wer.pauseChan: //暂停
			return
		default:
			wer.status.statusCode = StatusCodeDownloading

			// 初始化数据
			var readErr error
			n = 0

			// 读取数据
			for n < len(buf) && readErr == nil && (single || wer.wrange.Len() > 0) {
				nn, readErr = resp.Body.Read(buf[n:])
				nn64 = int64(nn)

				// 更新速度统计
				if wer.downloadStatus != nil {
					wer.downloadStatus.AddSpeedsDownloaded(nn64) // 限速在这里阻塞
				}
				wer.speedsStat.Add(nn64)
				n += nn
			}

			if n > 0 && readErr == io.EOF {
				readErr = io.ErrUnexpectedEOF
			}

			n64 = int64(n)

			// 非单线程模式下
			if !single {
				rangeLength = wer.wrange.Len()

				// 已完成 (未雨绸缪)
				if rangeLength <= 0 {
					wer.status.statusCode = StatusCodeCanceled
					wer.err = errors.New("worker already complete")
					return
				}

				if n64 > rangeLength {
					// 数据大小不正常
					n64 = rangeLength
					n = int(rangeLength)
					readErr = io.EOF
				}
			}

			// 写入数据
			if wer.writerAt != nil {
				wer.status.statusCode = StatusCodeWaitToWrite
				if wer.writeMu != nil {
					wer.writeMu.Lock() // 加锁, 减轻硬盘的压力
				}
				_, wer.err = wer.writerAt.WriteAt(buf[:n], wer.wrange.Begin) // 写入数据
				if wer.err != nil {
					if wer.writeMu != nil {
						wer.writeMu.Unlock() //解锁
					}
					wer.status.statusCode = StatusCodeInternalError
					return
				}

				if wer.writeMu != nil {
					wer.writeMu.Unlock() //解锁
				}
				wer.status.statusCode = StatusCodeDownloading
			}

			// 更新下载统计数据
			wer.wrange.AddBegin(n64)
			if wer.downloadStatus != nil {
				wer.downloadStatus.AddDownloaded(n64)
				if single {
					wer.downloadStatus.AddTotalSize(n64)
				}
			}

			if readErr != nil {
				rlen := wer.wrange.Len()
				switch {
				case single && readErr == io.ErrUnexpectedEOF:
					// 单线程判断下载成功
					fallthrough
				case readErr == io.EOF:
					fallthrough
				case rlen <= 0:
					// 下载完成
					// 小于0可能是因为 worker 被 duplicate
					wer.status.statusCode = StatusCodeSuccessed
					if rlen < 0 {
						pcsverbose.Verbosef("DEBUG: RangeLen is negative at end: %v, %d\n", wer.wrange, wer.wrange.Len())
					}
					return
				default:
					// 其他错误, 返回
					wer.status.statusCode = StatusCodeFailed
					wer.err = readErr
					return
				}
			}
		}
	}
}



================================================
FILE: requester/downloader/writer.go
================================================
package downloader

import (
	"io"
	"os"
)

type (
	// Fder 获取fd接口
	Fder interface {
		Fd() uintptr
	}

	// Writer 下载器数据输出接口
	Writer interface {
		io.WriterAt
	}
)

// NewDownloaderWriterByFilename 创建下载器数据输出接口, 类似于os.OpenFile
func NewDownloaderWriterByFilename(name string, flag int, perm os.FileMode) (writer Writer, file *os.File, err error) {
	file, err = os.OpenFile(name, flag, perm)
	if err != nil {
		return
	}

	writer = file
	return
}



================================================
FILE: requester/multipartreader/multipartreader.go
================================================
// Package multipartreader helps you encode large files in MIME multipart format
// without reading the entire content into memory.
package multipartreader

import (
	"errors"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"io"
	"mime/multipart"
	"strings"
	"sync"
	"sync/atomic"
)

type (
	// MultipartReader MIME multipart format
	MultipartReader struct {
		length      int64
		contentType string
		boundary    string

		formBody  string
		parts     []*part
		part64s   []*part64
		formClose string

		mu          sync.Mutex
		closed      bool
		multiReader io.Reader
	}

	part struct {
		form      string
		readerlen rio.ReaderLen
	}

	part64 struct {
		form        string
		readerlen64 rio.ReaderLen64
	}
)

// NewMultipartReader 返回初始化的 *MultipartReader
func NewMultipartReader() (mr *MultipartReader) {
	builder := &strings.Builder{}
	writer := multipart.NewWriter(builder)
	mr = &MultipartReader{
		contentType: writer.FormDataContentType(),
		boundary:    writer.Boundary(),
	}

	mr.length += int64(builder.Len())
	mr.formBody = builder.String()
	return
}

// AddFormFeild 增加 form 表单
func (mr *MultipartReader) AddFormFeild(fieldname string, readerlen rio.ReaderLen) {
	if readerlen == nil {
		return
	}

	mpart := &part{
		form:      fmt.Sprintf("--%s\r\nContent-Disposition: form-data; name=\"%s\"\r\n\r\n", mr.boundary, fieldname),
		readerlen: readerlen,
	}
	atomic.AddInt64(&mr.length, int64(len(mpart.form)+mpart.readerlen.Len()))
	mr.parts = append(mr.parts, mpart)
}

// AddFormFile 增加 form 文件表单
func (mr *MultipartReader) AddFormFile(fieldname, filename string, readerlen64 rio.ReaderLen64) {
	if readerlen64 == nil {
		return
	}

	mpart64 := &part64{
		form:        fmt.Sprintf("--%s\r\nContent-Disposition: form-data; name=\"%s\"; filename=\"%s\"\r\n\r\n", mr.boundary, fieldname, filename),
		readerlen64: readerlen64,
	}
	atomic.AddInt64(&mr.length, int64(len(mpart64.form))+mpart64.readerlen64.Len())
	mr.part64s = append(mr.part64s, mpart64)
}

//CloseMultipart 关闭multipartreader
func (mr *MultipartReader) CloseMultipart() error {
	mr.mu.Lock()
	defer mr.mu.Unlock()
	if mr.closed {
		return errors.New("multipartreader already closed")
	}

	mr.formClose = "\r\n--" + mr.boundary + "--\r\n"
	atomic.AddInt64(&mr.length, int64(len(mr.formClose)))

	numReaders := 0
	if mr.formBody != "" {
		numReaders++
	}
	numReaders += 2*len(mr.parts) + 2*len(mr.part64s)
	if mr.formClose != "" {
		numReaders++
	}

	readers := make([]io.Reader, 0, numReaders)
	readers = append(readers, strings.NewReader(mr.formBody))
	for k := range mr.parts {
		readers = append(readers, strings.NewReader(mr.parts[k].form), mr.parts[k].readerlen)
	}
	for k := range mr.part64s {
		readers = append(readers, strings.NewReader(mr.part64s[k].form), mr.part64s[k].readerlen64)
	}
	readers = append(readers, strings.NewReader(mr.formClose))
	mr.multiReader = io.MultiReader(readers...)

	mr.closed = true
	return nil
}

//ContentType 返回Content-Type
func (mr *MultipartReader) ContentType() string {
	return mr.contentType
}

func (mr *MultipartReader) Read(p []byte) (n int, err error) {
	if !mr.closed {
		return 0, errors.New("multipartreader not closed")
	}
	n, err = mr.multiReader.Read(p)
	return n, err
}

// Len 返回表单内容总长度
func (mr *MultipartReader) Len() int64 {
	return atomic.LoadInt64(&mr.length)
}



================================================
FILE: requester/rio/buf.go
================================================
package rio

import (
	"unsafe"
)

// Buffer 为固定长度的 Buf, 实现 io.WriterAt 接口
type Buffer struct {
	Buf []byte
}

// NewBuffer 初始化 Buffer
func NewBuffer(buf []byte) *Buffer {
	return &Buffer{
		Buf: buf,
	}
}

// ReadAt 实现 io.ReadAt 接口
// 不进行越界检查
func (b *Buffer) ReadAt(p []byte, off int64) (n int, err error) {
	n = copy(p, b.Buf[off:])
	return n, nil
}

// WriteAt 实现 io.WriterAt 接口
// 不进行越界检查
func (b *Buffer) WriteAt(p []byte, off int64) (n int, err error) {
	n = copy(b.Buf[off:], p)
	return n, nil
}

// Bytes 返回 buf
func (b *Buffer) Bytes() []byte {
	return b.Buf
}

func (b *Buffer) String() string {
	return *(*string)(unsafe.Pointer(&b.Buf))
}



================================================
FILE: requester/rio/file.go
================================================
package rio

import (
	cryptorand "crypto/rand"
	"io"
	"os"
	"sync/atomic"
)

type (
	fileReadedlen64 struct {
		readed int64
		f      *os.File
	}

	rdReadedlen64 struct {
		readed int64
		size   int64
		rd     io.Reader
	}
)

// NewFileReaderLen64 *os.File 实现 ReadedLen64 接口
func NewFileReaderLen64(f *os.File) ReaderLen64 {
	if f == nil {
		return nil
	}

	return &fileReadedlen64{
		f: f,
	}
}

// NewFileReaderAtLen64 *os.File 实现 ReaderAtLen64 接口
func NewFileReaderAtLen64(f *os.File) ReaderAtLen64 {
	if f == nil {
		return nil
	}

	return &fileReadedlen64{
		f: f,
	}
}

func NewCryptoRandReaderAtLen64(size int64) ReaderAtLen64 {
	return &rdReadedlen64{
		rd:   cryptorand.Reader,
		size: size,
	}
}

// Read 读文件, 并记录已读取数据量
func (fr *fileReadedlen64) Read(b []byte) (n int, err error) {
	n, err = fr.f.Read(b)
	atomic.AddInt64(&fr.readed, int64(n))
	return n, err
}

// ReadAt 读文件, 不记录已读取数据量
func (fr *fileReadedlen64) ReadAt(b []byte, off int64) (n int, err error) {
	n, err = fr.f.ReadAt(b, off)
	return n, err
}

// Len 返回文件的大小
func (fr *fileReadedlen64) Len() int64 {
	info, err := fr.f.Stat()
	if err != nil {
		return 0
	}
	return info.Size() - fr.readed
}

func (rr *rdReadedlen64) Read(b []byte) (n int, err error) {
	n, err = rr.ReadAt(b, 0)
	atomic.AddInt64(&rr.readed, int64(n))
	return n, err
}

func (rr *rdReadedlen64) ReadAt(b []byte, off int64) (n int, err error) {
	n, err = rr.rd.Read(b)
	return n, err
}

func (rr *rdReadedlen64) Len() int64 {
	return rr.size - rr.readed
}



================================================
FILE: requester/rio/multi.go
================================================
package rio

import (
	"io"
)

// MultiReaderLen 合并多个ReaderLen
func MultiReaderLen(readerLens ...ReaderLen) ReaderLen {
	// TODO: 和copy对比
	r := make([]io.Reader, 0, len(readerLens))
	for k := range readerLens {
		if readerLens[k] == nil {
			continue
		}
		r = append(r, readerLens[k])
	}
	return &multiReaderLen{
		mrls:        readerLens,
		multiReader: io.MultiReader(r...),
	}
}

type multiReaderLen struct {
	mrls        []ReaderLen
	multiReader io.Reader
}

func (mrl *multiReaderLen) Read(p []byte) (n int, err error) {
	return mrl.multiReader.Read(p)
}

func (mrl *multiReaderLen) Len() int {
	var i int
	for k := range mrl.mrls {
		i += mrl.mrls[k].Len()
	}
	return i
}

// MultiReaderLen64 合并多个ReaderLen64
func MultiReaderLen64(readerLen64s ...ReaderLen64) ReaderLen64 {
	// TODO: 和copy对比
	r := make([]io.Reader, 0, len(readerLen64s))
	for k := range readerLen64s {
		if readerLen64s[k] == nil {
			continue
		}
		r = append(r, readerLen64s[k])
	}
	return &multiReaderLen64{
		mrl64s:      readerLen64s,
		multiReader: io.MultiReader(r...),
	}
}

type multiReaderLen64 struct {
	mrl64s      []ReaderLen64
	multiReader io.Reader
}

func (mrl64 *multiReaderLen64) Read(p []byte) (n int, err error) {
	return mrl64.multiReader.Read(p)
}

func (mrl64 *multiReaderLen64) Len() int64 {
	var l int64
	for k := range mrl64.mrl64s {
		l += mrl64.mrl64s[k].Len()
	}
	return l
}



================================================
FILE: requester/rio/multi_test.go
================================================
package rio

import (
	"fmt"
	"io"
	"os"
	"strings"
	"testing"
)

func TestMultiReaderLen(t *testing.T) {
	rd1, rd2 := strings.NewReader("asdkfljalf"), strings.NewReader("---asva sdf")
	multi := MultiReaderLen(rd1, rd2)
	fmt.Println(multi.Len())
	io.Copy(os.Stdout, multi)
}



================================================
FILE: requester/rio/rio.go
================================================
// Package rio rquester io 工具包
package rio

import (
	"io"
)

type (
	// Lener 返回32-bit长度接口
	Lener interface {
		Len() int
	}

	// Lener64 返回64-bit长度接口
	Lener64 interface {
		Len() int64
	}

	// ReaderLen 实现io.Reader和32-bit长度接口
	ReaderLen interface {
		io.Reader
		Lener
	}

	// ReaderLen64 实现io.Reader和64-bit长度接口
	ReaderLen64 interface {
		io.Reader
		Lener64
	}

	// ReaderAtLen64 实现io.ReaderAt和64-bit长度接口
	ReaderAtLen64 interface {
		io.ReaderAt
		Lener64
	}

	// WriterLen64 实现io.Writer和64-bit长度接口
	WriterLen64 interface {
		io.Writer
		Lener64
	}

	// WriteCloserAt 实现io.WriteCloser和io.WriterAt接口
	WriteCloserAt interface {
		io.WriteCloser
		io.WriterAt
	}

	// WriteCloserLen64At 实现rio.WriteCloserAt和64-bit长度接口
	WriteCloserLen64At interface {
		WriteCloserAt
		Lener64
	}
)



================================================
FILE: requester/rio/speeds/ratelimit.go
================================================
package speeds

import (
	"sync"
	"sync/atomic"
	"time"
)

type (
	RateLimit struct {
		MaxRate int64

		count           int64
		interval        time.Duration
		ticker          *time.Ticker
		muChan          chan struct{}
		closeChan       chan struct{}
		backServiceOnce sync.Once
	}

	// AddCountFunc func() (count int64)
)

func NewRateLimit(maxRate int64) *RateLimit {
	return &RateLimit{
		MaxRate: maxRate,
	}
}

func (rl *RateLimit) SetInterval(i time.Duration) {
	if i <= 0 {
		i = 1 * time.Second
	}
	rl.interval = i
	if rl.ticker != nil {
		rl.ticker.Stop()
		rl.ticker = time.NewTicker(i)
	}
}

func (rl *RateLimit) Stop() {
	if rl.ticker != nil {
		rl.ticker.Stop()
	}
	if rl.closeChan != nil {
		close(rl.closeChan)
	}
	return
}

func (rl *RateLimit) resetChan() {
	if rl.muChan != nil {
		close(rl.muChan)
	}
	rl.muChan = make(chan struct{})
}

func (rl *RateLimit) backService() {
	if rl.interval <= 0 {
		rl.interval = 1 * time.Second
	}
	rl.ticker = time.NewTicker(rl.interval)
	rl.closeChan = make(chan struct{})
	rl.resetChan()
	go func() {
		for {
			select {
			case <-rl.ticker.C:
				rl.resetChan()
				atomic.StoreInt64(&rl.count, 0)
			case <-rl.closeChan:
				return
			}
		}
	}()
}

func (rl *RateLimit) Add(count int64) {
	rl.backServiceOnce.Do(rl.backService)
	for {
		if atomic.LoadInt64(&rl.count) >= rl.MaxRate { // 超出最大限额
			// 阻塞
			<-rl.muChan
			continue
		}
		atomic.AddInt64(&rl.count, count)
		break
	}
}



================================================
FILE: requester/rio/speeds/ratelimit_test.go
================================================
package speeds_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio/speeds"
	"testing"
	"time"
)

func TestRateLimit(t *testing.T) {
	r := speeds.NewRateLimit(100)
	fmt.Println("adding 101...")
	r.Add(101)
	fmt.Println("adding 10...")
	r.Add(10)
	fmt.Println("adding 11...")
	r.Add(11)
	fmt.Println("adding 12...")
	r.Add(12)
	fmt.Println("adding 13...")
	r.Add(13)
	fmt.Println("adding 22...")
	r.Add(22)
	fmt.Println("adding 35...")
	r.Add(35)
	fmt.Println("adding 25...")
	r.Add(25)
	fmt.Println("adding 11...")
	r.Add(11)

	r.Stop()
	time.Sleep(10e9)
}



================================================
FILE: requester/rio/speeds/speeds.go
================================================
// Package speeds 速度计算工具包
package speeds

import (
	"sync"
	"sync/atomic"
	"time"
)

type (
	// Speeds 统计速度
	Speeds struct {
		count    int64
		interval time.Duration // 刷新周期
		nowTime  time.Time
		once     sync.Once
	}
)

func (sps *Speeds) initOnce() {
	sps.once.Do(func() {
		sps.nowTime = time.Now()
		if sps.interval <= 0 {
			sps.interval = 1 * time.Second
		}
	})
}

// SetInterval 设置刷新周期
func (sps *Speeds) SetInterval(interval time.Duration) {
	if interval <= 0 {
		return
	}
	sps.interval = interval
}

// Add 原子操作, 增加数据量
func (sps *Speeds) Add(count int64) {
	// 初始化
	sps.initOnce()
	atomic.AddInt64(&sps.count, count)
}

// GetSpeeds 结束统计速度, 并返回速度
func (sps *Speeds) GetSpeeds() (speeds int64) {
	sps.initOnce()

	since := time.Since(sps.nowTime)
	if since <= 0 {
		return 0
	}
	speeds = int64(float64(atomic.LoadInt64(&sps.count)) * sps.interval.Seconds() / since.Seconds())

	// 更新下一轮
	if since >= sps.interval {
		atomic.StoreInt64(&sps.count, 0)
		sps.nowTime = time.Now()
	}
	return
}



================================================
FILE: requester/transfer/download_instanceinfo.go
================================================
package transfer

import (
	"time"
)

type (
	//DownloadInstanceInfo 状态详细信息, 用于导出状态文件
	DownloadInstanceInfo struct {
		DownloadStatus *DownloadStatus
		Ranges         RangeList
	}

	// DownloadInstanceInfoExporter 断点续传类型接口
	DownloadInstanceInfoExporter interface {
		GetInstanceInfo() *DownloadInstanceInfo
		SetInstanceInfo(*DownloadInstanceInfo)
	}
)

// GetInstanceInfo 从断点信息获取下载状态
func (m *DownloadInstanceInfoExport) GetInstanceInfo() (eii *DownloadInstanceInfo) {
	eii = &DownloadInstanceInfo{
		Ranges: m.Ranges,
	}

	var downloaded int64
	switch m.RangeGenMode {
	case RangeGenMode_BlockSize:
		downloaded = m.GenBegin - eii.Ranges.Len()
	default:
		downloaded = m.TotalSize - eii.Ranges.Len()
	}
	eii.DownloadStatus = &DownloadStatus{
		startTime:  time.Now(),
		totalSize:  m.TotalSize,
		downloaded: downloaded,
		gen:        NewRangeListGenBlockSize(m.TotalSize, m.GenBegin, m.BlockSize),
	}
	switch m.RangeGenMode {
	case RangeGenMode_BlockSize:
		eii.DownloadStatus.gen = NewRangeListGenBlockSize(m.TotalSize, m.GenBegin, m.BlockSize)
	default:
		eii.DownloadStatus.gen = NewRangeListGenDefault(m.TotalSize, m.TotalSize, len(m.Ranges), len(m.Ranges))
	}
	return eii
}

// SetInstanceInfo 从下载状态导出断点信息
func (m *DownloadInstanceInfoExport) SetInstanceInfo(eii *DownloadInstanceInfo) {
	if eii == nil {
		return
	}

	if eii.DownloadStatus != nil {
		m.TotalSize = eii.DownloadStatus.TotalSize()
		if eii.DownloadStatus.gen != nil {
			m.GenBegin = eii.DownloadStatus.gen.LoadBegin()
			m.BlockSize = eii.DownloadStatus.gen.LoadBlockSize()
			m.RangeGenMode = eii.DownloadStatus.gen.RangeGenMode()
		} else {
			m.RangeGenMode = RangeGenMode_Default
		}
	}
	m.Ranges = eii.Ranges
}



================================================
FILE: requester/transfer/download_status.go
================================================
package transfer

import (
	"github.com/felixonmars/BaiduPCS-Go/requester/rio/speeds"
	"sync"
	"sync/atomic"
	"time"
)

type (
	//DownloadStatuser 下载状态接口
	DownloadStatuser interface {
		TotalSize() int64
		Downloaded() int64
		SpeedsPerSecond() int64
		TimeElapsed() time.Duration // 已开始时间
		TimeLeft() time.Duration    // 预计剩余时间, 负数代表未知
	}

	//DownloadStatus 下载状态及统计信息
	DownloadStatus struct {
		totalSize        int64         // 总大小
		downloaded       int64         // 已下载的数据量
		speedsDownloaded int64         // 用于统计速度的downloaded
		maxSpeeds        int64         // 最大下载速度
		tmpSpeeds        int64         // 缓存的速度
		speedsStat       speeds.Speeds // 速度统计 (注意对齐)

		startTime time.Time // 开始下载的时间

		rateLimit *speeds.RateLimit // 限速控制

		gen *RangeListGen // Range生成状态
		mu  sync.Mutex
	}
)

//NewDownloadStatus 初始化DownloadStatus
func NewDownloadStatus() *DownloadStatus {
	return &DownloadStatus{
		startTime: time.Now(),
	}
}

// SetRateLimit 设置限速
func (ds *DownloadStatus) SetRateLimit(rl *speeds.RateLimit) {
	ds.rateLimit = rl
}

//SetTotalSize 返回总大小
func (ds *DownloadStatus) SetTotalSize(size int64) {
	ds.totalSize = size
}

//AddDownloaded 增加已下载数据量
func (ds *DownloadStatus) AddDownloaded(d int64) {
	atomic.AddInt64(&ds.downloaded, d)
}

//AddTotalSize 增加总大小 (不支持多线程)
func (ds *DownloadStatus) AddTotalSize(size int64) {
	ds.totalSize += size
}

//AddSpeedsDownloaded 增加已下载数据量, 用于统计速度
func (ds *DownloadStatus) AddSpeedsDownloaded(d int64) {
	if ds.rateLimit != nil {
		ds.rateLimit.Add(d)
	}
	ds.speedsStat.Add(d)
}

//SetMaxSpeeds 设置最大速度, 原子操作
func (ds *DownloadStatus) SetMaxSpeeds(speeds int64) {
	if speeds > atomic.LoadInt64(&ds.maxSpeeds) {
		atomic.StoreInt64(&ds.maxSpeeds, speeds)
	}
}

//ClearMaxSpeeds 清空统计最大速度, 原子操作
func (ds *DownloadStatus) ClearMaxSpeeds() {
	atomic.StoreInt64(&ds.maxSpeeds, 0)
}

//TotalSize 返回总大小
func (ds *DownloadStatus) TotalSize() int64 {
	return ds.totalSize
}

//Downloaded 返回已下载数据量
func (ds *DownloadStatus) Downloaded() int64 {
	return atomic.LoadInt64(&ds.downloaded)
}

// UpdateSpeeds 更新speeds
func (ds *DownloadStatus) UpdateSpeeds() {
	atomic.StoreInt64(&ds.tmpSpeeds, ds.speedsStat.GetSpeeds())
}

//SpeedsPerSecond 返回每秒速度
func (ds *DownloadStatus) SpeedsPerSecond() int64 {
	return atomic.LoadInt64(&ds.tmpSpeeds)
}

//MaxSpeeds 返回最大速度
func (ds *DownloadStatus) MaxSpeeds() int64 {
	return atomic.LoadInt64(&ds.maxSpeeds)
}

//TimeElapsed 返回花费的时间
func (ds *DownloadStatus) TimeElapsed() (elapsed time.Duration) {
	return time.Since(ds.startTime)
}

//TimeLeft 返回预计剩余时间
func (ds *DownloadStatus) TimeLeft() (left time.Duration) {
	speeds := atomic.LoadInt64(&ds.tmpSpeeds)
	if speeds <= 0 {
		left = -1
	} else {
		left = time.Duration((ds.totalSize-ds.downloaded)/(speeds)) * time.Second
	}
	return
}

// RangeListGen 返回RangeListGen
func (ds *DownloadStatus) RangeListGen() *RangeListGen {
	return ds.gen
}

// SetRangeListGen 设置RangeListGen
func (ds *DownloadStatus) SetRangeListGen(gen *RangeListGen) {
	ds.gen = gen
}



================================================
FILE: requester/transfer/rangelist.go
================================================
package transfer

import (
	"errors"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"sync"
	"sync/atomic"
)

type (
	//RangeList 请求范围列表
	RangeList []*Range

	//RangeListGen Range 生成器
	RangeListGen struct {
		total        int64
		begin        int64
		blockSize    int64
		parallel     int
		count        int // 已生成次数
		rangeGenMode RangeGenMode
		mu           sync.Mutex
	}
)

const (
	// DefaultBlockSize 默认的BlockSize
	DefaultBlockSize = 256 * converter.KB
)

var (
	// ErrUnknownRangeGenMode RangeGenMode 非法
	ErrUnknownRangeGenMode = errors.New("Unknown RangeGenMode")
)

//Len 长度
func (r *Range) Len() int64 {
	return r.LoadEnd() - r.LoadBegin()
}

//LoadBegin 读取Begin, 原子操作
func (r *Range) LoadBegin() int64 {
	return atomic.LoadInt64(&r.Begin)
}

//AddBegin 增加Begin, 原子操作
func (r *Range) AddBegin(i int64) (newi int64) {
	return atomic.AddInt64(&r.Begin, i)
}

//LoadEnd 读取End, 原子操作
func (r *Range) LoadEnd() int64 {
	return atomic.LoadInt64(&r.End)
}

//StoreBegin 储存End, 原子操作
func (r *Range) StoreBegin(end int64) {
	atomic.StoreInt64(&r.Begin, end)
}

//StoreEnd 储存End, 原子操作
func (r *Range) StoreEnd(end int64) {
	atomic.StoreInt64(&r.End, end)
}

// ShowDetails 显示Range细节
func (r *Range) ShowDetails() string {
	return fmt.Sprintf("{%d-%d}", r.LoadBegin(), r.LoadEnd())
}

//Len 获取所有的Range的剩余长度
func (rl *RangeList) Len() int64 {
	var l int64
	for _, wrange := range *rl {
		if wrange == nil {
			continue
		}
		l += wrange.Len()
	}
	return l
}

// NewRangeListGenDefault 初始化默认Range生成器, 根据parallel平均生成
func NewRangeListGenDefault(totalSize, begin int64, count, parallel int) *RangeListGen {
	return &RangeListGen{
		total:        totalSize,
		begin:        begin,
		parallel:     parallel,
		count:        count,
		rangeGenMode: RangeGenMode_Default,
	}
}

// NewRangeListGenBlockSize 初始化Range生成器, 根据blockSize生成
func NewRangeListGenBlockSize(totalSize, begin, blockSize int64) *RangeListGen {
	return &RangeListGen{
		total:        totalSize,
		begin:        begin,
		blockSize:    blockSize,
		rangeGenMode: RangeGenMode_BlockSize,
	}
}

// RangeGenMode 返回Range生成方式
func (gen *RangeListGen) RangeGenMode() RangeGenMode {
	return gen.rangeGenMode
}

// RangeCount 返回预计生成的Range数量
func (gen *RangeListGen) RangeCount() (rangeCount int) {
	switch gen.rangeGenMode {
	case RangeGenMode_Default:
		rangeCount = gen.parallel - gen.count
	case RangeGenMode_BlockSize:
		rangeCount = int((gen.total - gen.begin) / gen.blockSize)
		if gen.total%gen.blockSize != 0 {
			rangeCount++
		}
	}
	return
}

// LoadBegin 返回begin
func (gen *RangeListGen) LoadBegin() (begin int64) {
	gen.mu.Lock()
	begin = gen.begin
	gen.mu.Unlock()
	return
}

// LoadBlockSize 返回blockSize
func (gen *RangeListGen) LoadBlockSize() (blockSize int64) {
	switch gen.rangeGenMode {
	case RangeGenMode_Default:
		if gen.blockSize <= 0 {
			gen.blockSize = (gen.total - gen.begin) / int64(gen.parallel)
		}
		blockSize = gen.blockSize
	case RangeGenMode_BlockSize:
		blockSize = gen.blockSize
	}
	return
}

// IsDone 是否已分配完成
func (gen *RangeListGen) IsDone() bool {
	return gen.begin >= gen.total
}

// GenRange 生成 Range
func (gen *RangeListGen) GenRange() (index int, r *Range) {
	var (
		end int64
	)
	if gen.parallel < 1 {
		gen.parallel = 1
	}
	switch gen.rangeGenMode {
	case RangeGenMode_Default:
		gen.LoadBlockSize()
		gen.mu.Lock()
		defer gen.mu.Unlock()

		if gen.IsDone() {
			return gen.count, nil
		}

		gen.count++
		if gen.count >= gen.parallel {
			end = gen.total
		} else {
			end = gen.begin + gen.blockSize
		}
		r = &Range{
			Begin: gen.begin,
			End:   end,
		}

		gen.begin = end
		index = gen.count - 1
		return
	case RangeGenMode_BlockSize:
		if gen.blockSize <= 0 {
			gen.blockSize = DefaultBlockSize
		}
		gen.mu.Lock()
		defer gen.mu.Unlock()

		if gen.IsDone() {
			return gen.count, nil
		}

		gen.count++
		end = gen.begin + gen.blockSize
		if end >= gen.total {
			end = gen.total
		}
		r = &Range{
			Begin: gen.begin,
			End:   end,
		}
		gen.begin = end
		index = gen.count - 1
		return
	}

	return 0, nil
}



================================================
FILE: requester/transfer/transfer.pb.go
================================================
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: transfer/transfer.proto

package transfer

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// RangeGenMode 线程分配方式
type RangeGenMode int32

const (
	// RangeGenMode_Default 根据parallel平均生成
	RangeGenMode_Default RangeGenMode = 0
	// RangeGenMode_BlockSize 根据blockSize生成
	RangeGenMode_BlockSize RangeGenMode = 1
)

var RangeGenMode_name = map[int32]string{
	0: "Default",
	1: "BlockSize",
}

var RangeGenMode_value = map[string]int32{
	"Default":   0,
	"BlockSize": 1,
}

func (x RangeGenMode) String() string {
	return proto.EnumName(RangeGenMode_name, int32(x))
}

func (RangeGenMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_44038b0c710d7f2f, []int{0}
}

//Range 请求范围
type Range struct {
	Begin                int64    `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End                  int64    `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_44038b0c710d7f2f, []int{0}
}

func (m *Range) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Range.Unmarshal(m, b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Range.Marshal(b, m, deterministic)
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return xxx_messageInfo_Range.Size(m)
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetBegin() int64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *Range) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

// DownloadInstanceInfoExport 断点续传
type DownloadInstanceInfoExport struct {
	RangeGenMode         RangeGenMode `protobuf:"varint,1,opt,name=range_gen_mode,json=rangeGenMode,proto3,enum=transfer.RangeGenMode" json:"range_gen_mode,omitempty"`
	TotalSize            int64        `protobuf:"varint,2,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	GenBegin             int64        `protobuf:"varint,3,opt,name=gen_begin,json=genBegin,proto3" json:"gen_begin,omitempty"`
	BlockSize            int64        `protobuf:"varint,4,opt,name=block_size,json=blockSize,proto3" json:"block_size,omitempty"`
	Ranges               []*Range     `protobuf:"bytes,5,rep,name=ranges,proto3" json:"ranges,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *DownloadInstanceInfoExport) Reset()         { *m = DownloadInstanceInfoExport{} }
func (m *DownloadInstanceInfoExport) String() string { return proto.CompactTextString(m) }
func (*DownloadInstanceInfoExport) ProtoMessage()    {}
func (*DownloadInstanceInfoExport) Descriptor() ([]byte, []int) {
	return fileDescriptor_44038b0c710d7f2f, []int{1}
}

func (m *DownloadInstanceInfoExport) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DownloadInstanceInfoExport.Unmarshal(m, b)
}
func (m *DownloadInstanceInfoExport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DownloadInstanceInfoExport.Marshal(b, m, deterministic)
}
func (m *DownloadInstanceInfoExport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadInstanceInfoExport.Merge(m, src)
}
func (m *DownloadInstanceInfoExport) XXX_Size() int {
	return xxx_messageInfo_DownloadInstanceInfoExport.Size(m)
}
func (m *DownloadInstanceInfoExport) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadInstanceInfoExport.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadInstanceInfoExport proto.InternalMessageInfo

func (m *DownloadInstanceInfoExport) GetRangeGenMode() RangeGenMode {
	if m != nil {
		return m.RangeGenMode
	}
	return RangeGenMode_Default
}

func (m *DownloadInstanceInfoExport) GetTotalSize() int64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *DownloadInstanceInfoExport) GetGenBegin() int64 {
	if m != nil {
		return m.GenBegin
	}
	return 0
}

func (m *DownloadInstanceInfoExport) GetBlockSize() int64 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *DownloadInstanceInfoExport) GetRanges() []*Range {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func init() {
	proto.RegisterEnum("transfer.RangeGenMode", RangeGenMode_name, RangeGenMode_value)
	proto.RegisterType((*Range)(nil), "transfer.Range")
	proto.RegisterType((*DownloadInstanceInfoExport)(nil), "transfer.DownloadInstanceInfoExport")
}

func init() { proto.RegisterFile("transfer/transfer.proto", fileDescriptor_44038b0c710d7f2f) }

var fileDescriptor_44038b0c710d7f2f = []byte{
	// 260 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x90, 0x41, 0x4b, 0xc3, 0x40,
	0x10, 0x85, 0x8d, 0x31, 0xb5, 0x99, 0xd6, 0x1a, 0x16, 0xd1, 0xa0, 0x14, 0x4a, 0x2f, 0x96, 0x1e,
	0x5a, 0xa8, 0x57, 0x4f, 0xa5, 0x22, 0x3d, 0x78, 0x89, 0x3f, 0x20, 0x6c, 0x9a, 0x49, 0x08, 0xc6,
	0x99, 0xb2, 0x59, 0x51, 0xfa, 0x63, 0xfd, 0x2d, 0x92, 0x49, 0x23, 0xa1, 0xb7, 0x7d, 0x6f, 0x78,
	0xef, 0x7d, 0x2c, 0xdc, 0x59, 0xa3, 0xa9, 0xca, 0xd0, 0x2c, 0xdb, 0xc7, 0x62, 0x6f, 0xd8, 0xb2,
	0xea, 0xb7, 0x7a, 0xba, 0x04, 0x2f, 0xd2, 0x94, 0xa3, 0xba, 0x01, 0x2f, 0xc1, 0xbc, 0xa0, 0xd0,
	0x99, 0x38, 0x33, 0x37, 0x6a, 0x84, 0x0a, 0xc0, 0x45, 0x4a, 0xc3, 0x73, 0xf1, 0xea, 0xe7, 0xf4,
	0xd7, 0x81, 0xfb, 0x0d, 0x7f, 0x53, 0xc9, 0x3a, 0xdd, 0x52, 0x65, 0x35, 0xed, 0x70, 0x4b, 0x19,
	0xbf, 0xfc, 0xec, 0xd9, 0x58, 0xf5, 0x0c, 0x23, 0x53, 0xf7, 0xc5, 0x39, 0x52, 0xfc, 0xc9, 0x29,
	0x4a, 0xdf, 0x68, 0x75, 0xbb, 0xf8, 0x47, 0x90, 0xbd, 0x57, 0xa4, 0x37, 0x4e, 0x31, 0x1a, 0x9a,
	0x8e, 0x52, 0x63, 0x00, 0xcb, 0x56, 0x97, 0x71, 0x55, 0x1c, 0xf0, 0xb8, 0xea, 0x8b, 0xf3, 0x5e,
	0x1c, 0x50, 0x3d, 0x80, 0x5f, 0xd7, 0x36, 0x9c, 0xae, 0x5c, 0xfb, 0x39, 0xd2, 0x5a, 0x50, 0xc7,
	0x00, 0x49, 0xc9, 0xbb, 0x8f, 0x26, 0x7b, 0xd1, 0x64, 0xc5, 0x91, 0xec, 0x23, 0xf4, 0x64, 0xaa,
	0x0a, 0xbd, 0x89, 0x3b, 0x1b, 0xac, 0xae, 0x4f, 0x80, 0xa2, 0xe3, 0x79, 0x3e, 0x87, 0x61, 0x97,
	0x50, 0x0d, 0xe0, 0x72, 0x83, 0x99, 0xfe, 0x2a, 0x6d, 0x70, 0xa6, 0xae, 0xc0, 0x5f, 0xb7, 0x95,
	0x81, 0x93, 0xf4, 0xe4, 0x3b, 0x9f, 0xfe, 0x02, 0x00, 0x00, 0xff, 0xff, 0xe8, 0x5c, 0x09, 0xcc,
	0x69, 0x01, 0x00, 0x00,
}



================================================
FILE: requester/transfer/transfer.proto
================================================
syntax = "proto3";

package transfer;

// RangeGenMode 线程分配方式
enum RangeGenMode {
    // RangeGenMode_Default 根据parallel平均生成
	Default = 0;
	// RangeGenMode_BlockSize 根据blockSize生成
	BlockSize = 1;
}

//Range 请求范围
message Range {
    int64 begin = 1;
    int64 end = 2;
}

// DownloadInstanceInfoExport 断点续传
message DownloadInstanceInfoExport {
    RangeGenMode range_gen_mode = 1;
    int64 total_size = 2;  // 总大小
    int64 gen_begin = 3;
    int64 block_size = 4;
    repeated Range ranges = 5;
}



================================================
FILE: requester/uploader/block.go
================================================
package uploader

import (
	"bufio"
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio/speeds"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"io"
	"os"
	"sync"
)

type (
	// SplitUnit 将 io.ReaderAt 分割单元
	SplitUnit interface {
		Readed64
		io.Seeker
		Range() transfer.Range
		Left() int64
	}

	fileBlock struct {
		readRange     transfer.Range
		readed        int64
		readerAt      io.ReaderAt
		speedsStatRef *speeds.Speeds
		rateLimit     *speeds.RateLimit
		mu            sync.Mutex
	}

	bufioFileBlock struct {
		*fileBlock
		bufio *bufio.Reader
	}
)

// SplitBlock 文件分块
func SplitBlock(fileSize, blockSize int64) (blockList []*BlockState) {
	gen := transfer.NewRangeListGenBlockSize(fileSize, 0, blockSize)
	rangeCount := gen.RangeCount()
	blockList = make([]*BlockState, 0, rangeCount)
	for i := 0; i < rangeCount; i++ {
		id, r := gen.GenRange()
		blockList = append(blockList, &BlockState{
			ID:    id,
			Range: *r,
		})
	}
	return
}

// NewBufioSplitUnit io.ReaderAt实现SplitUnit接口, 有Buffer支持
func NewBufioSplitUnit(readerAt io.ReaderAt, readRange transfer.Range, speedsStat *speeds.Speeds, rateLimit *speeds.RateLimit) SplitUnit {
	su := &fileBlock{
		readerAt:      readerAt,
		readRange:     readRange,
		speedsStatRef: speedsStat,
		rateLimit:     rateLimit,
	}
	return &bufioFileBlock{
		fileBlock: su,
		bufio:     bufio.NewReaderSize(su, BufioReadSize),
	}
}

func (bfb *bufioFileBlock) Read(b []byte) (n int, err error) {
	return bfb.bufio.Read(b) // 间接调用fileBlock 的Read
}

// Read 只允许一个线程读同一个文件
func (fb *fileBlock) Read(b []byte) (n int, err error) {
	fb.mu.Lock()
	defer fb.mu.Unlock()

	left := int(fb.Left())
	if left <= 0 {
		return 0, io.EOF
	}

	if len(b) > left {
		n, err = fb.readerAt.ReadAt(b[:left], fb.readed+fb.readRange.Begin)
	} else {
		n, err = fb.readerAt.ReadAt(b, fb.readed+fb.readRange.Begin)
	}

	n64 := int64(n)
	fb.readed += n64
	if fb.rateLimit != nil {
		fb.rateLimit.Add(n64) // 限速阻塞
	}
	if fb.speedsStatRef != nil {
		fb.speedsStatRef.Add(n64)
	}
	return
}

func (fb *fileBlock) Seek(offset int64, whence int) (int64, error) {
	fb.mu.Lock()
	defer fb.mu.Unlock()

	switch whence {
	case os.SEEK_SET:
		fb.readed = offset
	case os.SEEK_CUR:
		fb.readed += offset
	case os.SEEK_END:
		fb.readed = fb.readRange.End - fb.readRange.Begin + offset
	default:
		return 0, fmt.Errorf("unsupport whence: %d", whence)
	}
	if fb.readed < 0 {
		fb.readed = 0
	}
	return fb.readed, nil
}

func (fb *fileBlock) Len() int64 {
	return fb.readRange.End - fb.readRange.Begin
}

func (fb *fileBlock) Left() int64 {
	return fb.readRange.End - fb.readRange.Begin - fb.readed
}

func (fb *fileBlock) Range() transfer.Range {
	return fb.readRange
}

func (fb *fileBlock) Readed() int64 {
	return fb.readed
}



================================================
FILE: requester/uploader/block_test.go
================================================
package uploader_test

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/cachepool"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
	"github.com/felixonmars/BaiduPCS-Go/requester/uploader"
	"io"
	"testing"
)

var (
	blockList = uploader.SplitBlock(10000, 999)
)

func TestSplitBlock(t *testing.T) {
	for k, e := range blockList {
		fmt.Printf("%d %#v\n", k, e)
	}
}

func TestSplitUnitRead(t *testing.T) {
	var size int64 = 65536*2+3432
	buffer := rio.NewBuffer(cachepool.RawMallocByteSlice(int(size)))
	unit := uploader.NewBufioSplitUnit(buffer, transfer.Range{Begin: 2, End: size}, nil, nil)

	buf := cachepool.RawMallocByteSlice(1022)
	for {
		n, err := unit.Read(buf)
		if err != nil {
			if err == io.EOF {
				break
			}
			t.Fatalf("read error: %s\n", err)
		}
		fmt.Printf("n: %d, left: %d\n", n, unit.Left())
	}
}



================================================
FILE: requester/uploader/error.go
================================================
package uploader

type (
	// MultiError 多线程上传的错误
	MultiError struct {
		Err error
		// IsRetry 是否重试,
		Terminated bool
	}
)

func (me *MultiError) Error() string {
	return me.Err.Error()
}



================================================
FILE: requester/uploader/example.go
================================================
package uploader

import (
	"fmt"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
)

// DoUpload 执行上传
func DoUpload(uploadURL string, readerlen64 rio.ReaderLen64, checkFunc CheckFunc) {
	u := NewUploader(uploadURL, readerlen64)
	u.SetCheckFunc(checkFunc)

	exitChan := make(chan struct{})

	u.OnExecute(func() {
		statusChan := u.GetStatusChan()
		for {
			select {
			case <-exitChan:
				return
			case v, ok := <-statusChan:
				if !ok {
					return
				}

				fmt.Printf("\r ↑ %s/%s %s/s in %s ............",
					converter.ConvertFileSize(v.Uploaded(), 2),
					converter.ConvertFileSize(v.TotalSize(), 2),
					converter.ConvertFileSize(v.SpeedsPerSecond(), 2),
					v.TimeElapsed(),
				)
			}
		}
	})

	u.Execute()
	close(exitChan)

	return
}



================================================
FILE: requester/uploader/instance_state.go
================================================
package uploader

import (
	"github.com/felixonmars/BaiduPCS-Go/requester/transfer"
)

type (
	// BlockState 文件区块信息
	BlockState struct {
		ID       int            `json:"id"`
		Range    transfer.Range `json:"range"`
		CheckSum string         `json:"checksum"`
	}

	// InstanceState 上传断点续传信息
	InstanceState struct {
		BlockList []*BlockState `json:"block_list"`
	}
)

func (muer *MultiUploader) getWorkerListByInstanceState(is *InstanceState) workerList {
	workers := make(workerList, 0, len(is.BlockList))
	for _, blockState := range is.BlockList {
		if blockState.CheckSum == "" {
			workers = append(workers, &worker{
				id:         blockState.ID,
				partOffset: blockState.Range.Begin,
				splitUnit:  NewBufioSplitUnit(muer.file, blockState.Range, muer.speedsStat, muer.rateLimit),
				checksum:   blockState.CheckSum,
			})
		} else {
			// 已经完成的, 也要加入 (可继续优化)
			workers = append(workers, &worker{
				id:         blockState.ID,
				partOffset: blockState.Range.Begin,
				splitUnit: &fileBlock{
					readRange: blockState.Range,
					readed:    blockState.Range.End - blockState.Range.Begin,
					readerAt:  muer.file,
				},
				checksum: blockState.CheckSum,
			})
		}
	}
	return workers
}



================================================
FILE: requester/uploader/multiuploader.go
================================================
package uploader

import (
	"context"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio/speeds"
	"sync"
	"time"
)

type (
	// MultiUpload 支持多线程的上传, 可用于断点续传
	MultiUpload interface {
		Precreate() (perr error)
		TmpFile(ctx context.Context, partseq int, partOffset int64, readerlen64 rio.ReaderLen64) (checksum string, terr error)
		CreateSuperFile(checksumList ...string) (cerr error)
	}

	// MultiUploader 多线程上传
	MultiUploader struct {
		onExecuteEvent      requester.Event        //开始上传事件
		onSuccessEvent      requester.Event        //成功上传事件
		onFinishEvent       requester.Event        //结束上传事件
		onCancelEvent       requester.Event        //取消上传事件
		onErrorEvent        requester.EventOnError //上传出错事件
		onUploadStatusEvent UploadStatusFunc       //上传状态事件

		instanceState *InstanceState

		multiUpload MultiUpload       // 上传体接口
		file        rio.ReaderAtLen64 // 上传
		config      *MultiUploaderConfig
		workers     workerList
		speedsStat  *speeds.Speeds
		rateLimit   *speeds.RateLimit

		executeTime             time.Time
		finished                chan struct{}
		canceled                chan struct{}
		closeCanceledOnce       sync.Once
		updateInstanceStateChan chan struct{}
	}

	// MultiUploaderConfig 多线程上传配置
	MultiUploaderConfig struct {
		Parallel  int   // 上传并发量
		BlockSize int64 // 上传分块
		MaxRate   int64 // 限制最大上传速度
	}
)

// NewMultiUploader 初始化上传
func NewMultiUploader(multiUpload MultiUpload, file rio.ReaderAtLen64, config *MultiUploaderConfig) *MultiUploader {
	return &MultiUploader{
		multiUpload: multiUpload,
		file:        file,
		config:      config,
	}
}

// SetInstanceState 设置InstanceState, 断点续传信息
func (muer *MultiUploader) SetInstanceState(is *InstanceState) {
	muer.instanceState = is
}

func (muer *MultiUploader) lazyInit() {
	if muer.finished == nil {
		muer.finished = make(chan struct{}, 1)
	}
	if muer.canceled == nil {
		muer.canceled = make(chan struct{})
	}
	if muer.updateInstanceStateChan == nil {
		muer.updateInstanceStateChan = make(chan struct{}, 1)
	}
	if muer.config == nil {
		muer.config = &MultiUploaderConfig{}
	}
	if muer.config.Parallel <= 0 {
		muer.config.Parallel = 4
	}
	if muer.config.BlockSize <= 0 {
		muer.config.BlockSize = 1 * converter.GB
	}
	if muer.speedsStat == nil {
		muer.speedsStat = &speeds.Speeds{}
	}
}

func (muer *MultiUploader) check() {
	if muer.file == nil {
		panic("file is nil")
	}
	if muer.multiUpload == nil {
		panic("multiUpload is nil")
	}
}

// Execute 执行上传
func (muer *MultiUploader) Execute() {
	muer.check()
	muer.lazyInit()

	// 初始化限速
	if muer.config.MaxRate > 0 {
		muer.rateLimit = speeds.NewRateLimit(muer.config.MaxRate)
		defer muer.rateLimit.Stop()
	}

	// 分配任务
	if muer.instanceState != nil {
		muer.workers = muer.getWorkerListByInstanceState(muer.instanceState)
		uploaderVerbose.Infof("upload task CREATED from instance state\n")
	} else {
		muer.workers = muer.getWorkerListByInstanceState(&InstanceState{
			BlockList: SplitBlock(muer.file.Len(), muer.config.BlockSize),
		})

		uploaderVerbose.Infof("upload task CREATED: block size: %d, num: %d\n", muer.config.BlockSize, len(muer.workers))
	}

	// 开始上传
	muer.executeTime = time.Now()
	pcsutil.Trigger(muer.onExecuteEvent)

	muer.uploadStatusEvent()

	err := muer.upload()

	// 完成
	muer.finished <- struct{}{}
	if err != nil {
		if err == context.Canceled {
			if muer.onCancelEvent != nil {
				muer.onCancelEvent()
			}
		} else if muer.onErrorEvent != nil {
			muer.onErrorEvent(err)
		}
	} else {
		pcsutil.TriggerOnSync(muer.onSuccessEvent)
	}
	pcsutil.TriggerOnSync(muer.onFinishEvent)
}

// InstanceState 返回断点续传信息
func (muer *MultiUploader) InstanceState() *InstanceState {
	blockStates := make([]*BlockState, 0, len(muer.workers))
	for _, wer := range muer.workers {
		blockStates = append(blockStates, &BlockState{
			ID:       wer.id,
			Range:    wer.splitUnit.Range(),
			CheckSum: wer.checksum,
		})
	}
	return &InstanceState{
		BlockList: blockStates,
	}
}

// Cancel 取消上传
func (muer *MultiUploader) Cancel() {
	close(muer.canceled)
}

//OnExecute 设置开始上传事件
func (muer *MultiUploader) OnExecute(onExecuteEvent requester.Event) {
	muer.onExecuteEvent = onExecuteEvent
}

//OnSuccess 设置成功上传事件
func (muer *MultiUploader) OnSuccess(onSuccessEvent requester.Event) {
	muer.onSuccessEvent = onSuccessEvent
}

//OnFinish 设置结束上传事件
func (muer *MultiUploader) OnFinish(onFinishEvent requester.Event) {
	muer.onFinishEvent = onFinishEvent
}

//OnCancel 设置取消上传事件
func (muer *MultiUploader) OnCancel(onCancelEvent requester.Event) {
	muer.onCancelEvent = onCancelEvent
}

//OnError 设置上传发生错误事件
func (muer *MultiUploader) OnError(onErrorEvent requester.EventOnError) {
	muer.onErrorEvent = onErrorEvent
}

//OnUploadStatusEvent 设置上传状态事件
func (muer *MultiUploader) OnUploadStatusEvent(f UploadStatusFunc) {
	muer.onUploadStatusEvent = f
}



================================================
FILE: requester/uploader/multiworker.go
================================================
package uploader

import (
	"context"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/waitgroup"
	"github.com/oleiade/lane"
	"os"
)

type (
	worker struct {
		id         int
		partOffset int64
		splitUnit  SplitUnit
		checksum   string
	}

	workerList []*worker
)

// CheckSumList 返回所以worker的checksum
// TODO: 实现sort
func (werl *workerList) CheckSumList() []string {
	checksumList := make([]string, 0, len(*werl))
	for _, wer := range *werl {
		checksumList = append(checksumList, wer.checksum)
	}
	return checksumList
}

func (werl *workerList) Readed() int64 {
	var readed int64
	for _, wer := range *werl {
		readed += wer.splitUnit.Readed()
	}
	return readed
}

func (muer *MultiUploader) upload() (uperr error) {
	err := muer.multiUpload.Precreate()
	if err != nil {
		return err
	}

	var (
		uploadDeque = lane.NewDeque()
	)

	// 加入队列
	for _, wer := range muer.workers {
		if wer.checksum == "" {
			uploadDeque.Append(wer)
		}
	}

	for {
		wg := waitgroup.NewWaitGroup(muer.config.Parallel)
		for {
			e := uploadDeque.Shift()
			if e == nil { // 任务为空
				break
			}

			wer := e.(*worker)
			wg.AddDelta()
			go func() {
				defer wg.Done()

				var (
					ctx, cancel = context.WithCancel(context.Background())
					doneChan    = make(chan struct{})
					checksum    string
					terr        error
				)
				go func() {
					checksum, terr = muer.multiUpload.TmpFile(ctx, int(wer.id), wer.partOffset, wer.splitUnit)
					close(doneChan)
				}()
				select {
				case <-muer.canceled:
					cancel()
					return
				case <-doneChan:
					// continue
				}
				cancel()
				if terr != nil {
					if me, ok := terr.(*MultiError); ok {
						if me.Terminated { // 终止
							muer.closeCanceledOnce.Do(func() { // 只关闭一次
								close(muer.canceled)
							})
							uperr = me.Err
							return
						}
					}

					uploaderVerbose.Warnf("upload err: %s, id: %d\n", terr, wer.id)
					wer.splitUnit.Seek(0, os.SEEK_SET)
					uploadDeque.Append(wer)
					return
				}
				wer.checksum = checksum

				// 通知更新
				if muer.updateInstanceStateChan != nil && len(muer.updateInstanceStateChan) < cap(muer.updateInstanceStateChan) {
					muer.updateInstanceStateChan <- struct{}{}
				}
			}()
		}
		wg.Wait()

		// 没有任务了
		if uploadDeque.Size() == 0 {
			break
		}
	}

	select {
	case <-muer.canceled:
		if uperr != nil {
			return uperr
		}
		return context.Canceled
	default:
	}

	cerr := muer.multiUpload.CreateSuperFile(muer.workers.CheckSumList()...)
	if cerr != nil {
		return cerr
	}

	return
}



================================================
FILE: requester/uploader/readed.go
================================================
package uploader

import (
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"sync/atomic"
)

type (
	// Readed64 增加获取已读取数据量, 用于统计速度
	Readed64 interface {
		rio.ReaderLen64
		Readed() int64
	}

	readed64 struct {
		readed int64
		rio.ReaderLen64
	}
)

// NewReaded64 实现Readed64接口
func NewReaded64(rl rio.ReaderLen64) Readed64 {
	return &readed64{
		readed:      0,
		ReaderLen64: rl,
	}
}

func (r64 *readed64) Read(p []byte) (n int, err error) {
	n, err = r64.ReaderLen64.Read(p)
	atomic.AddInt64(&r64.readed, int64(n))
	return n, err
}

func (r64 *readed64) Readed() int64 {
	return atomic.LoadInt64(&r64.readed)
}



================================================
FILE: requester/uploader/status.go
================================================
package uploader

import (
	"time"
)

type (
	// Status 上传状态接口
	Status interface {
		TotalSize() int64           // 总大小
		Uploaded() int64            // 已上传数据
		SpeedsPerSecond() int64     // 每秒的上传速度
		TimeElapsed() time.Duration // 上传时间
	}

	// UploadStatus 上传状态
	UploadStatus struct {
		totalSize       int64         // 总大小
		uploaded        int64         // 已上传数据
		speedsPerSecond int64         // 每秒的上传速度
		timeElapsed     time.Duration // 上传时间
	}

	UploadStatusFunc func(status Status, updateChan <-chan struct{})
)

// TotalSize 返回总大小
func (us *UploadStatus) TotalSize() int64 {
	return us.totalSize
}

// Uploaded 返回已上传数据
func (us *UploadStatus) Uploaded() int64 {
	return us.uploaded
}

// SpeedsPerSecond 返回每秒的上传速度
func (us *UploadStatus) SpeedsPerSecond() int64 {
	return us.speedsPerSecond
}

// TimeElapsed 返回上传时间
func (us *UploadStatus) TimeElapsed() time.Duration {
	return us.timeElapsed
}

// GetStatusChan 获取上传状态
func (u *Uploader) GetStatusChan() <-chan Status {
	c := make(chan Status)

	go func() {
		for {
			select {
			case <-u.finished:
				close(c)
				return
			default:
				if !u.executed {
					time.Sleep(1 * time.Second)
					continue
				}

				old := u.readed64.Readed()
				time.Sleep(1 * time.Second) // 每秒统计

				readed := u.readed64.Readed()
				c <- &UploadStatus{
					totalSize:       u.readed64.Len(),
					uploaded:        readed,
					speedsPerSecond: readed - old,
					timeElapsed:     time.Since(u.executeTime) / 1e7 * 1e7,
				}
			}
		}
	}()
	return c
}

func (muer *MultiUploader) uploadStatusEvent() {
	if muer.onUploadStatusEvent == nil {
		return
	}

	go func() {
		ticker := time.NewTicker(1 * time.Second) // 每秒统计
		defer ticker.Stop()
		for {
			select {
			case <-muer.finished:
				return
			case <-ticker.C:
				readed := muer.workers.Readed()
				muer.onUploadStatusEvent(&UploadStatus{
					totalSize:       muer.file.Len(),
					uploaded:        readed,
					speedsPerSecond: muer.speedsStat.GetSpeeds(),
					timeElapsed:     time.Since(muer.executeTime) / 1e8 * 1e8,
				}, muer.updateInstanceStateChan)
			}
		}
	}()
}



================================================
FILE: requester/uploader/uploader.go
================================================
// Package uploader 上传包
package uploader

import (
	"github.com/felixonmars/BaiduPCS-Go/pcsutil"
	"github.com/felixonmars/BaiduPCS-Go/pcsutil/converter"
	"github.com/felixonmars/BaiduPCS-Go/pcsverbose"
	"github.com/felixonmars/BaiduPCS-Go/requester"
	"github.com/felixonmars/BaiduPCS-Go/requester/rio"
	"net/http"
	"time"
)

const (
	// BufioReadSize bufio 缓冲区大小, 用于上传时读取文件
	BufioReadSize = int(64 * converter.KB) // 64KB
)

type (
	//CheckFunc 上传完成的检测函数
	CheckFunc func(resp *http.Response, uploadErr error)

	// Uploader 上传
	Uploader struct {
		url         string   // 上传地址
		readed64    Readed64 // 要上传的对象
		contentType string

		client *requester.HTTPClient

		executeTime time.Time
		executed    bool
		finished    chan struct{}

		checkFunc CheckFunc
		onExecute func()
		onFinish  func()
	}
)

var (
	uploaderVerbose = pcsverbose.New("UPLOADER")
)

// NewUploader 返回 uploader 对象, url: 上传地址, readerlen64: 实现 rio.ReaderLen64 接口的对象, 例如文件
func NewUploader(url string, readerlen64 rio.ReaderLen64) (uploader *Uploader) {
	uploader = &Uploader{
		url:      url,
		readed64: NewReaded64(readerlen64),
	}

	return
}

func (u *Uploader) lazyInit() {
	if u.finished == nil {
		u.finished = make(chan struct{})
	}
	if u.client == nil {
		u.client = requester.NewHTTPClient()
	}
	u.client.SetTimeout(0)
	u.client.SetResponseHeaderTimeout(0)
}

// SetClient 设置http客户端
func (u *Uploader) SetClient(c *requester.HTTPClient) {
	u.client = c
}

//SetContentType 设置Content-Type
func (u *Uploader) SetContentType(contentType string) {
	u.contentType = contentType
}

//SetCheckFunc 设置上传完成的检测函数
func (u *Uploader) SetCheckFunc(checkFunc CheckFunc) {
	u.checkFunc = checkFunc
}

// Execute 执行上传, 收到返回值信号则为上传结束
func (u *Uploader) Execute() {
	pcsutil.Trigger(u.onExecute)

	// 开始上传
	u.executeTime = time.Now()
	u.executed = true
	resp, _, err := u.execute()

	// 上传结束
	close(u.finished)

	if u.checkFunc != nil {
		u.checkFunc(resp, err)
	}

	pcsutil.Trigger(u.onFinish) // 触发上传结束的事件
}

func (u *Uploader) execute() (resp *http.Response, code int, err error) {
	u.lazyInit()
	header := map[string]string{}
	if u.contentType != "" {
		header["Content-Type"] = u.contentType
	}

	resp, err = u.client.Req(http.MethodPost, u.url, u.readed64, header)
	if err != nil {
		return nil, 2, err
	}

	return resp, 0, nil
}

// OnExecute 任务开始时触发的事件
func (u *Uploader) OnExecute(fn func()) {
	u.onExecute = fn
}

// OnFinish 任务完成时触发的事件
func (u *Uploader) OnFinish(fn func()) {
	u.onFinish = fn
}



================================================
FILE: .github/RELEASE_TEMPLATE.md
================================================
# 更新日志: 

1. 修复文件md5显示错误
2. 修复无法上传
3. 修复分享列表获取不到密码
4. 更新上传、下载处理流程，优化重试的判断条件
5. 更新download命令, 移除之前的-stream -share -locate等参数，新增-mode参数, 设置下载模式
6. 更新默认的下载模式mode为locate, 参见 [#858](https://github.com/iikira/BaiduPCS-Go/issues/858)
7. 移除后台下载(bg)功能

个人项目bug在所难免! 欢迎提 issue 和 pull request!!.

# 下载说明

## 解释 CPU架构

|amd|arm| mips| 说明 |
|-----|----------------|------------------|------------------|
|amd64, x64 |arm64   | mips64, mips64le |适用于64位CPU或操作系统的计算机|
|386, x86 |armv5, armv7  | mips, mipsle |适用于32位CPU或操作系统的计算机|

## 注意区别 `arm` 和 `amd`, 不要搞错了!!!!

## 下载

* PC/电脑: 
    请选择对应的系统 (windows, linux, darwin(苹果系统), freebsd), 对应的CPU架构 (一般情况下是 amd), 对应的CPU或操作系统位数 (详见上表), 下载.

* Android: 
    选择对应的CPU架构 (一般情况下是 arm, 除了少数手机的CPU架构要选 amd, 例如联想K800, 联想K900等), 对应的CPU或操作系统位数  (详见上表), 下载.

* iOS:
    无需选择CPU架构，选择 darwin-ios 下载解压后即可使用. 注意: armv7s架构的设备 (iPhone 5, iPhone 5c, iPad 4) 或 iOS 系统版本低于5.0, 可能无法正常运行.

## 注意

Android 5.0 以上的设备请不要下载使用linux版本的, 否则网络请求可能会出现问题.

相关的关键词, 均能在文件名中找到. 

文件格式均为zip压缩包格式, 切勿未解压程序就直接运行!! 程序解压之后才可以正常使用.


