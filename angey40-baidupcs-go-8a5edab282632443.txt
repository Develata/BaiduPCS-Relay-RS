Directory structure:
└── angey40-baidupcs-go/
    ├── README.md
    ├── build.sh
    ├── LICENSE
    ├── main.go
    ├── baidupcs/
    │   ├── baidupcs.go
    │   ├── download.go
    │   ├── error.go
    │   ├── file_directory.go
    │   ├── quota.go
    │   ├── rm_mkdir.go
    │   └── util.go
    ├── command/
    │   ├── cd.go
    │   ├── command.go
    │   ├── download.go
    │   ├── ls.go
    │   ├── meta.go
    │   ├── quota.go
    │   ├── rm_mkdir.go
    │   └── util.go
    ├── config/
    │   ├── check_bduss.go
    │   ├── config.go
    │   ├── deleter.go
    │   ├── get_checker.go
    │   └── seter.go
    ├── downloader/
    │   ├── downloader.go
    │   ├── downloader_block.go
    │   ├── downloader_config.go
    │   ├── example.go
    │   ├── fetch.go
    │   ├── http_client.go
    │   └── resume_breakpoint.go
    └── util/
        ├── convert.go
        ├── error.go
        ├── log_colorable_prefix.go
        ├── regexp_pre.go
        ├── tieba_client_signature.go
        ├── time.go
        ├── unsafe_strconv_test.go
        ├── util.go
        ├── wait_group.go
        └── wait_group_test.go

================================================
FILE: README.md
================================================
[Binary file]


================================================
FILE: build.sh
================================================
name="BaiduPCS-Go"
version="beta-v2"

Build(){
    echo "Building $1..."
    export GOOS=$2 GOARCH=$3 GO386=sse2 CGO_ENABLED=0
    if [ $2 = "windows" ];then
        go build -ldflags "-s -w" -o "out/$1/$name.exe"
    else
        go build -ldflags "-s -w" -o "out/$1/$name"
    fi
    mkdir "out/$1/download"
    cd out
    zip -q -r "$1.zip" "$1"
    cd ..
    echo Done!
}

ArmBuild(){
    echo "Building $1..."
    export GOOS=$2 GOARCH=$3 GOARM=$4 CGO_ENABLED=1
    go build -ldflags '-s -w -linkmode=external -extldflags=-pie' -o "out/$1/$name"
    if [ $2 = "darwin" -a $3 = "arm64" ];then
        ldid -S "out/$1/$name"
    fi
    mkdir "out/$1/download"
    cd out
    zip -q -r "$1.zip" "$1"
    cd ..
    echo Done!
}

# android
export NDK_INSTALL=$ANDROID_NDK_ROOT/bin
# CC=$NDK_INSTALL/arm-linux-androideabi/bin/arm-linux-androideabi-gcc ArmBuild $name-$version"-android-16-armv5" android arm 5
# CC=$NDK_INSTALL/arm-linux-androideabi/bin/arm-linux-androideabi-gcc ArmBuild $name-$version"-android-16-armv6" android arm 6
CC=$NDK_INSTALL/arm-linux-androideabi/bin/arm-linux-androideabi-gcc ArmBuild $name-$version"-android-16-armv7" android arm 7
CC=$NDK_INSTALL/aarch64-linux-android/bin/aarch64-linux-android-gcc ArmBuild $name-$version"-android-21-arm64" android arm64 7
CC=$NDK_INSTALL/i686-linux-android/bin/i686-linux-android-gcc ArmBuild $name-$version"-android-16-386" android 386 7
CC=$NDK_INSTALL/x86_64-linux-android/bin/x86_64-linux-android-gcc ArmBuild $name-$version"-android-21-amd64" android amd64 7

# ios 
CC=/usr/local/go/misc/ios/clangwrap.sh ArmBuild $name-$version"-darwin-ios-5.0-armv7" darwin arm 7
CC=/usr/local/go/misc/ios/clangwrap.sh ArmBuild $name-$version"-darwin-ios-5.0-arm64" darwin arm64 7

# OS X / macOS
Build $name-$version"-darwin-osx-amd64" darwin amd64
# Build $name-$version"-darwin-osx-386" darwin 386

# Windows
Build $name-$version"-windows-x86" windows 386
Build $name-$version"-windows-x64" windows amd64

# Linux
Build $name-$version"-linux-386" linux 386
Build $name-$version"-linux-amd64" linux amd64
Build $name-$version"-linux-arm" linux arm
Build $name-$version"-linux-arm64" linux arm64
# Build $name-$version"-linux-mips" linux mips
# Build $name-$version"-linux-mips64" linux mips64
# Build $name-$version"-linux-mipsel" linux mipsle
# Build $name-$version"-linux-mips64el" linux mips64le
# Build $name-$version"-linux-ppc64" linux ppc64
# Build $name-$version"-linux-ppc64le" linux ppc64le
# Build $name-$version"-linux-s390x" linux s390x

# other
# $name-$version
# Build $name-$version"-solaris-amd64" solaris amd64
Build $name-$version"-freebsd-386" freebsd 386
# Build $name-$version"-freebsd-amd64" freebsd amd64
# Build $name-$version"-freebsd-arm" freebsd arm
# Build $name-$version"-netbsd-386" netbsd	386
# Build $name-$version"-netbsd-amd64" netbsd amd64
# Build $name-$version"-netbsd-arm" netbsd	arm
# Build $name-$version"-openbsd-386" openbsd 386
# Build $name-$version"-openbsd-amd64" openbsd	amd64
# Build $name-$version"-openbsd-arm" openbsd arm
# Build $name-$version"-plan9-386" plan9 386
# Build $name-$version"-plan9-amd64" plan9 amd64
# Build $name-$version"-plan9-arm" plan9 arm
# Build $name-$version"-nacl-386" nacl 386
# Build $name-$version"-nacl-amd64p32" nacl amd64p32
# Build $name-$version"-nacl-arm" nacl arm
# Build $name-$version"-dragonflybsd-amd64" dragonfly amd64



================================================
FILE: LICENSE
================================================
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.




================================================
FILE: main.go
================================================
[Binary file]


================================================
FILE: baidupcs/baidupcs.go
================================================
package baidupcs

import (
	"fmt"
	"net/url"
)

var (
	appid = 260149
)

// PCSApi 百度 PCS API 详情
type PCSApi struct {
	url   url.URL
	bduss string

	writed bool
}

// NewPCS 提供 百度BDUSS, 返回 PCSApi 指针对象
func NewPCS(bduss string) *PCSApi {
	return &PCSApi{
		url: url.URL{
			Scheme:   "http",
			Host:     "pcs.baidu.com",
			Path:     "/rest/2.0/pcs/",
			RawQuery: fmt.Sprintf("app_id=%d", appid)},
		bduss:  bduss,
		writed: false,
	}
}

func (p *PCSApi) addItem(subPath, method string, param ...map[string]string) {
	if p.writed {
		panic("addItem: Already writed")
	}
	p.url.Path += subPath
	uv := p.url.Query()
	uv.Set("method", method)
	for k := range param {
		for k2 := range param[k] {
			uv.Set(k2, param[k][k2])
		}
	}
	p.url.RawQuery = uv.Encode()
	p.writed = true
}



================================================
FILE: baidupcs/download.go
================================================
package baidupcs

import (
	"fmt"
	"github.com/iikira/BaiduPCS-Go/config"
	"github.com/iikira/BaiduPCS-Go/downloader"
	"github.com/iikira/BaiduPCS-Go/util"
	"net/http"
	"net/http/cookiejar"
	"os"
	"strings"
	"time"
)

// FileDownload 下载网盘内文件
func (p PCSApi) FileDownload(path string, size int64) (err error) {
	// addItem 放在最后
	p.addItem("file", "download", map[string]string{
		"path": path,
	})

	h := downloader.NewHTTPClient()
	jar, _ := cookiejar.New(nil)
	jar.SetCookies(&p.url, []*http.Cookie{
		&http.Cookie{
			Name:  "BDUSS",
			Value: p.bduss,
		},
	})
	h.SetCookiejar(jar)
	h.SetKeepAlive(true)
	h.SetTimeout(2 * time.Minute)

	fileDl, err := downloader.NewFileDl(h, p.url.String(), pcsconfig.GetSavePath(path), size)
	if err != nil {
		return err
	}

	pa := make(chan struct{})

	var exit = make(chan bool)

	fileDl.OnStart(func() {
		t1 := time.Now()
	for_1:
		for {
			status := fileDl.GetStatus()

			select {
			case <-exit:
				break for_1
			default:
				time.Sleep(time.Second * 1)
				fmt.Printf("\r%v/%v %v/s time: %s %v",
					pcsutil.ConvertFileSize(status.Downloaded, 2),
					pcsutil.ConvertFileSize(fileDl.Size, 2),
					pcsutil.ConvertFileSize(status.Speeds, 2),
					time.Since(t1)/1000000*1000000,
					"[DOWNLOADING]"+strings.Repeat(" ", 10),
				)
				os.Stdout.Sync()
			}
		}
	})

	fileDl.OnFinish(func() {
		exit <- true
		pa <- struct{}{}
	})

	fileDl.Start()
	<-pa
	fmt.Printf("\n\n下载完成, 保存位置: %s\n\n", pcsconfig.GetSavePath(path))
	return nil
}



================================================
FILE: baidupcs/error.go
================================================
package baidupcs



================================================
FILE: baidupcs/file_directory.go
================================================
package baidupcs

import (
	"fmt"
	"github.com/bitly/go-simplejson"
	"github.com/iikira/BaiduPCS-Go/downloader"
	"github.com/iikira/BaiduPCS-Go/util"
)

// FileDirectory 文件或目录的详细信息
type FileDirectory struct {
	FsID        int64
	Path        string
	Filename    string
	Ctime       int64
	MD5         string
	Size        int64
	Isdir       bool
	Ifhassubdir bool
}

// FileDirectoryList FileDirectory 的 数组
type FileDirectoryList []FileDirectory

// FilesDirectoriesMeta 获取单个文件/目录的元信息
//
// 可用信息: 是否是目录isdir 是否含有子目录ifhassubdir 修改时间mtime 文件大小size
func (p PCSApi) FilesDirectoriesMeta(path string) (data FileDirectory, err error) {
	if path == "" {
		path = "/"
	}

	p.addItem("file", "meta", map[string]string{
		"path": path,
	})

	h := downloader.NewHTTPClient()
	body, err := h.Fetch("GET", p.url.String(), nil, map[string]string{
		"Cookie": "BDUSS=" + p.bduss,
	})
	if err != nil {
		return
	}

	json, err := simplejson.NewJson(body)

	code, err := checkErr(json)
	if err != nil {
		err = fmt.Errorf("获取单个文件/目录的元信息遇到错误, 路径: %s, 错误代码: %d, 消息: %s", path, code, err)
		return
	}

	json = json.Get("list").GetIndex(0)

	data = FileDirectory{
		FsID:        json.Get("fs_id").MustInt64(),
		Path:        json.Get("path").MustString(),
		Filename:    json.Get("server_filename").MustString(),
		Ctime:       json.Get("ctime").MustInt64(),
		MD5:         json.Get("md5").MustString(),
		Size:        json.Get("size").MustInt64(),
		Isdir:       pcsutil.IntToBool(json.Get("isdir").MustInt()),
		Ifhassubdir: pcsutil.IntToBool(json.Get("ifhassubdir").MustInt()),
	}

	return
}

// FileList 获取目录下的文件列表
func (p PCSApi) FileList(path string) (data FileDirectoryList, err error) {
	if path == "" {
		path = "/"
	}

	p.addItem("file", "list", map[string]string{
		"path":  path,
		"by":    "name",
		"order": "asc",
		"limit": "0-2147483647",
	})

	h := downloader.NewHTTPClient()
	body, err := h.Fetch("GET", p.url.String(), nil, map[string]string{
		"Cookie": "BDUSS=" + p.bduss,
	})
	if err != nil {
		return
	}

	json, err := simplejson.NewJson(body)
	if err != nil {
		return
	}

	code, err := checkErr(json)
	if err != nil {
		return nil, fmt.Errorf("获取目录下的文件列表遇到错误, 路径: %s, 错误代码: %d, 消息: %s", path, code, err)
	}

	json = json.Get("list")

	for i := 0; ; i++ {
		index := json.GetIndex(i)
		fsID := index.Get("fs_id").MustInt64()
		if fsID == 0 {
			break
		}
		data = append(data, FileDirectory{
			FsID:     fsID,
			Path:     index.Get("path").MustString(),
			Filename: index.Get("server_filename").MustString(),
			Ctime:    index.Get("ctime").MustInt64(),
			MD5:      index.Get("md5").MustString(),
			Size:     index.Get("size").MustInt64(),
			Isdir:    pcsutil.IntToBool(index.Get("isdir").MustInt()),
		})
	}
	return
}

func (f FileDirectory) String() string {
	if f.Isdir {
		return fmt.Sprintf("类型: 目录 \n目录名称: %s \n目录路径: %s \nfs_id: %d \n创建时间: %s \n是否含有子目录: %t\n",
			f.Filename,
			f.Path,
			f.FsID,
			pcsutil.FormatTime(f.Ctime),
			f.Ifhassubdir,
		)
	}

	return fmt.Sprintf("类型: 文件 \n文件名: %s \n文件路径: %s \n文件大小: %d \nmd5: %s \nfs_id: %d \n创建时间: %s \n",
		f.Filename,
		f.Path,
		f.Size,
		f.MD5,
		f.FsID,
		pcsutil.FormatTime(f.Ctime),
	)
}

// TotalSize 获取总文件大小
func (f *FileDirectoryList) TotalSize() int64 {
	var size int64
	for k := range *f {
		size += (*f)[k].Size
	}
	return size
}

// Count 获取文件总数和目录总数
func (f *FileDirectoryList) Count() (fileN, directoryN int64) {
	for k := range *f {
		if (*f)[k].Isdir {
			directoryN++
		} else {
			fileN++
		}
	}
	return
}



================================================
FILE: baidupcs/quota.go
================================================
package baidupcs

import (
	"fmt"
	"github.com/bitly/go-simplejson"
	"github.com/iikira/BaiduPCS-Go/downloader"
)

// QuotaInfo 获取当前用户空间配额信息
func (p PCSApi) QuotaInfo() (quota, used int64, err error) {
	p.addItem("quota", "info")

	h := downloader.NewHTTPClient()
	body, err := h.Fetch("GET", p.url.String(), nil, map[string]string{
		"Cookie": "BDUSS=" + p.bduss,
	})
	if err != nil {
		return
	}

	json, err := simplejson.NewJson(body)
	if err != nil {
		return
	}

	code, err := checkErr(json)
	if err != nil {
		return 0, 0, fmt.Errorf("获取当前用户空间配额信息, 错误代码: %d, 消息: %s", code, err)
	}

	quota = json.Get("quota").MustInt64()
	used = json.Get("used").MustInt64()

	return
}



================================================
FILE: baidupcs/rm_mkdir.go
================================================
[Binary file]


================================================
FILE: baidupcs/util.go
================================================
package baidupcs

import (
	"errors"
	"github.com/bitly/go-simplejson"
)

func checkErr(json *simplejson.Json) (code int, msg error) {
	codeJSON, ok1 := json.CheckGet("error_code")
	msgJSON, ok2 := json.CheckGet("error_msg")
	if !ok1 && !ok2 { // 没有错误
		return 0, nil
	}

	errCode := codeJSON.MustInt()
	errMsg := msgJSON.MustString()
	switch errCode {
	case 31045: // user not exists
		errMsg = "操作失败, 可能BDUSS已过期, 请尝试运行 login 命令重新登录, 消息: " + errMsg
	}
	return errCode, errors.New(errMsg)
}



================================================
FILE: command/cd.go
================================================
package baidupcscmd

import (
	"fmt"
	"github.com/iikira/BaiduPCS-Go/config"
)

// RunChangeDirectory 执行更改工作目录
func RunChangeDirectory(path string) {
	path, err := toAbsPath(path)
	if err != nil {
		fmt.Println(err)
		return
	}

	data, err := info.FilesDirectoriesMeta(path)
	if err != nil {
		fmt.Println(err)
		return
	}

	if !data.Isdir {
		fmt.Printf("错误: %s 不是一个目录 (文件夹)\n", path)
		return
	}

	pcsconfig.ActiveBaiduUser.Workdir = path
	pcsconfig.Config.Save()

	fmt.Printf("改变工作目录: %s\n", path)
}



================================================
FILE: command/command.go
================================================
package baidupcscmd

import (
	"github.com/iikira/BaiduPCS-Go/baidupcs"
	"github.com/iikira/BaiduPCS-Go/config"
	"os"
)

var (
	info = new(baidupcs.PCSApi)
)

func init() {
	ReloadInfo()
}

// ReloadInfo 重载配置
func ReloadInfo() {
	pcsconfig.Reload()
	info = baidupcs.NewPCS(pcsconfig.ActiveBaiduUser.BDUSS)
}

// ReloadIfInConsole 程序在 Console 模式下才回重载配置
func ReloadIfInConsole() {
	if len(os.Args) == 1 {
		ReloadInfo()
	}
}



================================================
FILE: command/download.go
================================================
package baidupcscmd

import (
	"fmt"
	"github.com/iikira/BaiduPCS-Go/config"
	"github.com/iikira/BaiduPCS-Go/downloader"
	"github.com/iikira/BaiduPCS-Go/util"
	"os"
)

// RunDownload 执行下载网盘内文件
func RunDownload(paths ...string) {
	downloader.SetCacheSize(2048)
	downloader.SetMaxParallel(pcsconfig.Config.MaxParallel)

	paths = getAllPaths(paths...)

	fmt.Println()
	for k := range paths {
		fmt.Printf("添加下载任务: %s\n", paths[k])
	}
	fmt.Println()

	for k, path := range paths {
		downloadInfo, err := info.FilesDirectoriesMeta(path)
		if err != nil {
			fmt.Println(err)
			continue
		}

		fmt.Printf("[ %d / %d ] %s\n", k+1, len(paths), downloadInfo.String())

		// 如果是一个目录, 递归下载该目录下的所有文件
		if downloadInfo.Isdir {
			fmt.Printf("即将下载目录: %s\n\n", path)

			fileN, directoryN, size := recurseFDCountTotalSize(path)
			statText := fmt.Sprintf("统计: 目录总数: %d, 文件总数: %d, 文件总大小: %s\n\n",
				directoryN,
				fileN,
				pcsutil.ConvertFileSize(size),
			)

			fmt.Printf(statText)
			downloadDirectory(path)
			fmt.Printf("目录 %s 下载完成, %s", path, statText)
			continue
		}

		fmt.Printf("即将开始下载文件\n\n")

		err = info.FileDownload(path, downloadInfo.Size)
		if err != nil {
			fmt.Printf("下载文件时发生错误: %s (跳过...)\n\n", err)
		}
	}
}

func downloadDirectory(path string) {
	di, err := info.FileList(path)
	if err != nil {
		fmt.Println("发生错误,", err)
	}

	// 遇到空目录, 则创建目录
	if len(di) == 0 {
		os.MkdirAll(pcsconfig.GetSavePath(path), 0777)
		return
	}

	for k := range di {
		if di[k].Isdir {
			downloadDirectory(di[k].Path)
			continue
		}

		// 如果文件存在, 跳过
		if pcsconfig.CheckFileExist(di[k].Path) {
			fmt.Printf("文件已存在 (自动跳过): %s\n\n", pcsconfig.GetSavePath(di[k].Path))
			continue
		}

		fmt.Println(di[k])
		fmt.Printf("即将开始下载文件: %s\n\n", di[k].Filename)

		err = info.FileDownload(di[k].Path, di[k].Size)
		if err != nil {
			fmt.Println(err)
		}
		fmt.Println("------------------------------------------------------------")
	}
}



================================================
FILE: command/ls.go
================================================
package baidupcscmd

import (
	"fmt"
	"github.com/iikira/BaiduPCS-Go/util"
	"os"
	"text/template"
)

// RunLs 执行列目录
func RunLs(path string) {
	path, err := toAbsPath(path)
	if err != nil {
		fmt.Println(err)
		return
	}
	files, err := info.FileList(path)

	if err != nil {
		fmt.Println(err)
		return
	}

	if len(files) == 0 {
		RunGetMeta(path)
		return
	}

	for k := range files {
		if files[k].Isdir {
			files[k].Path += "/"
		}
	}

	tmpl, err := template.New("ls").Funcs(
		template.FuncMap{
			"convertFileSize": func(size int64) string {
				res := pcsutil.ConvertFileSize(size)
				if res == "0" {
					return "-       "
				}
				return res
			},
			"timeFmt": pcsutil.FormatTime,
			"totalSize": func() string {
				return pcsutil.ConvertFileSize(files.TotalSize())
			},
			"fdCount": func() string {
				fN, dN := files.Count()
				return fmt.Sprintf("文件总数: %d,\t目录总数: %d", fN, dN)
			},
		},
	).Parse(
		`
文件大小	创建日期		文件(目录)
------------------------------------------------------------------------------{{range .}}
{{convertFileSize .Size}}	{{timeFmt .Ctime}}	{{.Path}} {{end}}
------------------------------------------------------------------------------
总大小: {{totalSize}}	{{fdCount}}
`)
	if err != nil {
		panic(err)
	}

	err = tmpl.Execute(os.Stdout, files)
	if err != nil {
		panic(err)
	}
}



================================================
FILE: command/meta.go
================================================
package baidupcscmd

import (
	"fmt"
)

// RunGetMeta 执行 获取单个文件/目录的元信息
func RunGetMeta(path string) {
	p, err := toAbsPath(path)
	if err != nil {
		fmt.Println(err)
		return
	}

	data, err := info.FilesDirectoriesMeta(p)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println()
	fmt.Println(data)
}



================================================
FILE: command/quota.go
================================================
package baidupcscmd

import (
	"fmt"
	"github.com/iikira/BaiduPCS-Go/util"
)

// RunGetQuota 执行 获取当前用户空间配额信息, 并输出
func RunGetQuota() {
	quota, used, err := info.QuotaInfo()
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("总空间: %s, 已用空间: %s, 比率: %f%%\n",
		pcsutil.ConvertFileSize(quota),
		pcsutil.ConvertFileSize(used),
		100*float64(used)/float64(quota),
	)
}



================================================
FILE: command/rm_mkdir.go
================================================
package baidupcscmd

import (
	"fmt"
)

// RunRemove 执行 批量删除文件/目录
func RunRemove(paths ...string) {
	paths = getAllPaths(paths...)

	pnt := func() {
		for k := range paths {
			fmt.Printf("%d: %s\n", k+1, paths[k])
		}
	}

	err := info.Remove(paths...)
	if err != nil {
		fmt.Println(err)
		fmt.Println("操作失败, 以下文件/目录删除失败: ")
		pnt()
		return
	}

	fmt.Println("操作成功, 以下文件/目录已删除: ")
	pnt()
}

// RunMkdir 执行 创建目录
func RunMkdir(path string) {
	path = getAbsPath(path)

	err := info.Mkdir(path)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println("创建目录成功:", path)
}



================================================
FILE: command/util.go
================================================
package baidupcscmd

import (
	"fmt"
	"github.com/iikira/BaiduPCS-Go/config"
	fpath "path"
	"regexp"
	"strings"
)

var (
	patternRE = regexp.MustCompile(`[\[\]\*\?]`)
)

// getAbsPath 获取绝对路径, 忽略通配符
func getAbsPath(path string) string {
	if !fpath.IsAbs(path) {
		path = fpath.Dir(pcsconfig.ActiveBaiduUser.Workdir + "/" + path + "/")
	}
	return path
}

func getAllPaths(paths ...string) (_paths []string) {
	for k := range paths {
		_paths = append(_paths, parsePath(paths[k])...)
	}
	return
}

func toAbsPath(path string) (string, error) {
	p := parsePath(path)
	if len(p) == 0 {
		return "", fmt.Errorf("文件路径匹配失败, 请检查通配符")
	}
	return p[0], nil
}

// parsePath 递归解析通配符
func parsePath(path string) (paths []string) {
	path = getAbsPath(path)

	if !patternRE.MatchString(path) {
		paths = []string{path}
		return
	}

	if _, err := fpath.Match(path, ""); err != nil {
		return nil
	}

	names := strings.Split(path, "/")

	for k := range names {
		if names[k] == "" || !patternRE.MatchString(names[k]) {
			continue
		}

		pfiles, err := info.FileList(strings.Join(names[:k], "/"))
		if err != nil {
			fmt.Println(err)
			return nil
		}

		for k2 := range pfiles {
			ok, _ := fpath.Match(names[k], pfiles[k2].Filename)
			if ok {
				if k >= len(names)-1 {
					paths = append(paths, strings.Join(names[:k], "/")+"/"+pfiles[k2].Filename)
				} else if pfiles[k2].Isdir {
					paths = append(paths, parsePath(pfiles[k2].Path+"/"+strings.Join(names[k+1:], "/"))...)
				}
			}
		}
		break
	}

	return
}

func recurseFDCountTotalSize(path string) (fileN, directoryN, size int64) {
	di, err := info.FileList(path)
	if err != nil {
		fmt.Println(err)
	}

	for k := range di {
		if di[k].Isdir {
			f, d, s := recurseFDCountTotalSize(di[k].Path)
			fileN += f
			directoryN += d
			size += s
		}
	}
	f, d := di.Count()
	s := di.TotalSize()
	fileN += f
	directoryN += d
	size += s
	return
}



================================================
FILE: config/check_bduss.go
================================================
package pcsconfig

import (
	"fmt"
	"github.com/bitly/go-simplejson"
	"github.com/iikira/BaiduPCS-Go/downloader"
	"github.com/iikira/BaiduPCS-Go/util"
	"strconv"
)

type Baidu struct {
	UID   uint64 `json:"uid"`
	Name  string `json:"name"`
	BDUSS string `json:"bduss"`

	Workdir string `json:"workdir"`
}

// NewWithBDUSS 检测BDUSS有效性, 同时获取百度详细信息
func NewWithBDUSS(bduss string) (*Baidu, error) {
	h := downloader.NewHTTPClient()
	timestamp := pcsutil.BeijingTimeOption("")
	post := map[string]string{
		"bdusstoken":  bduss + "|null",
		"channel_id":  "",
		"channel_uid": "",
		"stErrorNums": "0",
		"subapp_type": "mini",
		"timestamp":   timestamp + "922",
	}
	pcsutil.TiebaClientSignature(post)

	header := map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
		"Cookie":       "ka=open",
		"net":          "1",
		"User-Agent":   "bdtb for Android 6.9.2.1",
		"client_logid": timestamp + "416",
		"Connection":   "Keep-Alive",
	}

	body, err := h.Fetch("POST", "http://tieba.baidu.com/c/s/login", post, header) // 获取百度ID的TBS，UID，BDUSS等
	if err != nil {
		return nil, fmt.Errorf("检测BDUSS有效性失败, %s", err)
	}

	json, err := simplejson.NewJson(body)
	if err != nil {
		return nil, fmt.Errorf("检测BDUSS有效性json解析出错: %s", err)
	}

	errCode := json.Get("error_code").MustString()
	errMsg := json.Get("error_msg").MustString()

	switch errCode {
	case "0":
	case "1":
		return nil, fmt.Errorf("检测BDUSS有效性错误, 百度BDUSS格式不正确或者已过期")
	default:
		return nil, fmt.Errorf("检测BDUSS有效性错误代码: %s, 消息: %s", errCode, errMsg)
	}

	uidStr := json.GetPath("user", "id").MustString()
	uid, _ := strconv.ParseUint(uidStr, 10, 64)

	username, err := GetUserNameByUID(uid)
	if err != nil {
		return nil, err
	}

	return &Baidu{
		UID:     uid,
		Name:    username,
		BDUSS:   bduss,
		Workdir: "/",
	}, nil
}

func GetUserNameByUID(uid uint64) (username string, err error) {
	rawQuery := "has_plist=0&need_post_count=1&rn=1&uid=" + fmt.Sprint(uid)
	urlStr := "http://c.tieba.baidu.com/c/u/user/profile?" + pcsutil.TiebaClientRawQuerySignature(rawQuery)
	body, err := downloader.HTTPGet(urlStr)
	if err != nil {
		return "", err
	}
	json, err := simplejson.NewJson(body)
	if err != nil {
		return "", err
	}
	userJSON := json.GetPath("user")
	username = userJSON.Get("name").MustString()
	return
}



================================================
FILE: config/config.go
================================================
package pcsconfig

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
)

var (
	// Config 配置信息, 由外部调用
	Config = new(PCSConfig)

	// ActiveBaiduUser 当前百度帐号
	ActiveBaiduUser *Baidu

	configFileName = "pcs_config.json"

	// SaveDir 保存文件的目录
	SaveDir = "download/"
)

// PCSConfig 配置详情
type PCSConfig struct {
	BaiduActiveUID uint64   `json:"baidu_active_uid"`
	BaiduUserList  []*Baidu `json:"baidu_user_list"`
	MaxParallel    int      `json:"max_parallel"`
}

// Init 初始化配置
func Init() {
	// 检查配置
	cfg, err := loadConfig()
	if err != nil {
		fmt.Printf("错误: %s, 自动初始化配置文件\n", err)

		cfg = &PCSConfig{
			BaiduActiveUID: 0,
			MaxParallel:    100,
		}

		err = cfg.Save()
		if err != nil {
			fmt.Println(err)
		}
	}
	Config = cfg

	if UpdateActiveBaiduUser() != nil {
		ActiveBaiduUser = new(Baidu)
	}
}

func loadConfig() (*PCSConfig, error) {
	data, err := ioutil.ReadFile(configFileName)
	if err != nil {
		return nil, err
	}
	conf := new(PCSConfig)
	err = json.Unmarshal(data, conf)
	if err != nil {
		return nil, err
	}
	return conf, nil
}

// Reload 从配置文件重载更新 Config
func Reload() error {
	cfg, err := loadConfig()
	if err != nil {
		return err
	}
	Config = cfg

	// 更新 当前百度帐号
	return UpdateActiveBaiduUser()
}

// Save 保存配置信息到配置文件, 并重载配置
func (c *PCSConfig) Save() error {
	data, err := json.MarshalIndent(c, "", "\t")
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(configFileName, data, 0666)
	if err != nil {
		return err
	}

	return Reload()
}

// UpdateActiveBaiduUser 更新 当前百度帐号
func UpdateActiveBaiduUser() error {
	baidu, err := Config.GetBaiduUserByUID(Config.BaiduActiveUID)
	if err == nil {
		ActiveBaiduUser = baidu
		return nil
	}
	return err
}



================================================
FILE: config/deleter.go
================================================
package pcsconfig

import (
	"fmt"
)

func (c *PCSConfig) DeleteBaiduUserByUID(uid uint64) bool {
	for k := range c.BaiduUserList {
		if c.BaiduUserList[k].UID == uid {
			c.BaiduUserList = append(c.BaiduUserList[:k], c.BaiduUserList[k+1:]...)

			// 修改 正在使用的 百度帐号
			if c.BaiduActiveUID == uid {
				if len(c.BaiduUserList) != 0 {
					c.BaiduActiveUID = c.BaiduUserList[0].UID
				} else {
					c.BaiduActiveUID = 0
				}
			}

			err := c.Save()
			if err != nil {
				fmt.Println(err)
				return false
			}
			return true
		}
	}
	return false
}



================================================
FILE: config/get_checker.go
================================================
package pcsconfig

import (
	"bytes"
	"fmt"
	"github.com/iikira/BaiduPCS-Go/downloader"
	"os"
	"path/filepath"
)

func (c *PCSConfig) GetBaiduUserByUID(uid uint64) (*Baidu, error) {
	for k := range c.BaiduUserList {
		if uid == c.BaiduUserList[k].UID {
			return c.BaiduUserList[k], nil
		}
	}
	return nil, fmt.Errorf("未找到百度帐号")
}

func (c *PCSConfig) GetAllBaiduUser() string {
	var s bytes.Buffer
	s.WriteString("\nindex\t\tuid\t用户名\n")

	for k := range c.BaiduUserList {
		s.WriteString(fmt.Sprintf("%4d", k) + "\t" + fmt.Sprintf("%11d", c.BaiduUserList[k].UID) + "\t" + c.BaiduUserList[k].Name + "\n")
	}
	s.WriteString("\n")
	return s.String()
}

func (c *PCSConfig) CheckUIDExist(uid uint64) bool {
	for k := range c.BaiduUserList {
		if uid == c.BaiduUserList[k].UID {
			return true
		}
	}
	return false
}

// GetSavePath 根据提供的网盘文件路径 path, 返回本地储存路径
func GetSavePath(path string) string {
	return filepath.Dir(fmt.Sprintf("%s/%d_%s%s/..",
		SaveDir,
		ActiveBaiduUser.UID,
		ActiveBaiduUser.Name,
		path,
	))
}

// CheckFileExist 检查本地文件是否与网盘的文件重名
func CheckFileExist(path string) bool {
	savePath := GetSavePath(path)
	if _, err := os.Stat(savePath); err == nil {
		if _, err = os.Stat(savePath + downloader.DownloadingFileSuffix); err != nil {
			return true
		}
	}
	return false
}



================================================
FILE: config/seter.go
================================================
package pcsconfig

import (
	"fmt"
)

// SetBDUSS 设置百度 bduss 并保存
func (c *PCSConfig) SetBDUSS(bduss string) (username string, err error) {
	b, err := NewWithBDUSS(bduss)
	if err != nil {
		return "", err
	}
	if c.CheckUIDExist(b.UID) {
		return "", fmt.Errorf("登录失败, 用户 %s 已存在", b.Name)
	}
	c.BaiduUserList = append(c.BaiduUserList, b)
	c.BaiduActiveUID = b.UID
	return b.Name, c.Save()
}



================================================
FILE: downloader/downloader.go
================================================
/*
 Copyright 2015 Bluek404

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

 补充: 此 inplememt 基于 https://github.com/Bluek404/downloader
 针对百度网盘下载, 做出一些修改

 增加功能: 线程控制
 删去功能: 暂停下载, 恢复下载
*/

package downloader

import (
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"time"
)

var parallel int

// FileDl 下载详情
type FileDl struct {
	URL  string   // 下载地址
	Size int64    // 文件大小
	File *os.File // 要写入的文件

	BlockList blockList // 用于记录未下载的文件块起始位置

	*HTTPClient // http client

	onStart  func()
	onFinish func()
	onError  func(int, error)

	status status // 下载状态
}

// NewFileDl 创建新的文件下载
//
// 如果 size <= 0 则自动获取文件大小
func NewFileDl(h *HTTPClient, url, savePath string, size int64) (*FileDl, error) {

	// 获取文件信息
	request, err := http.NewRequest("HEAD", url, nil)
	if err != nil {
		return nil, err
	}

	resp, err := h.Client.Do(request)
	if err != nil {
		return nil, err
	}

	if savePath == "" {
		finds := FileNameRE.FindStringSubmatch(
			resp.Header.Get("Content-Disposition"),
		)
		if len(finds) >= 2 {
			savePath = finds[1]
		} else {
			// 找不到文件名, 凑合吧
			savePath = filepath.Base(url)
		}
	}

	// 如果文件存在, 取消下载
	if _, err = os.Stat(savePath); err == nil {
		if _, err = os.Stat(savePath + DownloadingFileSuffix); err != nil {
			return nil, fmt.Errorf("文件已存在: %s", savePath)
		}
	}

	// 检测要保存下载内容的目录是否存在
	// 不存在则创建该目录
	if _, err = os.Stat(filepath.Dir(savePath)); err != nil {
		err = os.MkdirAll(filepath.Dir(savePath), 0777)
		if err != nil {
			return nil, err
		}
	}

	// 移除旧的断点续传文件
	if _, err = os.Stat(savePath); err != nil {
		if _, err = os.Stat(savePath + DownloadingFileSuffix); err == nil {
			os.Remove(savePath + DownloadingFileSuffix)
		}
	}

	// 检测要下载的文件是否存在
	// 如果存在, 则打开文件
	// 不存在则创建文件
	file, err := os.OpenFile(savePath, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return nil, err
	}

	if size != resp.ContentLength {
		size = resp.ContentLength
	}

	resp.Body.Close()

	f := &FileDl{
		URL:        url,
		Size:       size,
		File:       file,
		HTTPClient: h,
	}

	return f, nil
}

// Start 开始下载
func (f *FileDl) Start() {
	// 控制线程
	parallel = maxParallel

	// 如果文件不大, 或者线程数设置过高, 则调低线程数
	if int64(maxParallel) > f.Size/int64(10*cacheSize) {
		parallel = int(f.Size/int64(10*cacheSize)) + 1
	}

	if err := f.loadBreakPoint(); err != nil {
		if f.Size <= 0 { // 获取不到文件的大小, 关闭多线程下载 (暂时)
			f.BlockList = append(f.BlockList, Block{
				Begin: 0,
				End:   -1,
			})
		} else {
			blockSize := f.Size / int64(parallel)
			var begin int64
			// 数据平均分配给各个线程
			for i := 0; i < parallel; i++ {
				var end = (int64(i) + 1) * blockSize
				f.BlockList = append(f.BlockList, Block{
					Begin: begin,
					End:   end,
				})
				begin = end + 1
			}
			// 将余出数据分配给最后一个线程
			f.BlockList[parallel-1].End += f.Size - f.BlockList[parallel-1].End
			f.BlockList[parallel-1].Final = true
		}
	}

	go func() {
		f.touch(f.onStart)
		// 开始下载
		err := f.download()
		if err != nil {
			f.touchOnError(0, err)
			return
		}
	}()
}

func (f *FileDl) download() error {
	f.startGetSpeeds() // 启用速度监测

	for i := range f.BlockList {
		go func(id int) {
			f.downloadBlockFn(id)
		}(i)
	}
	<-f.blockMonitor()

	f.touch(f.onFinish)

	f.File.Close()

	return nil
}

func (f *FileDl) startGetSpeeds() {
	go func() {
		var old = f.status.Downloaded
		for {
			time.Sleep(time.Second * 1)
			f.status.Speeds = f.status.Downloaded - old
			old = f.status.Downloaded

			if f.status.Speeds > f.status.MaxSpeeds {
				f.status.MaxSpeeds = f.status.Speeds
			}
		}
	}()
}

// GetStatus 获取下载统计信息
func (f FileDl) GetStatus() status {
	return f.status
}

// OnStart 任务开始时触发的事件
func (f *FileDl) OnStart(fn func()) {
	f.onStart = fn
}

// OnFinish 任务完成时触发的事件
func (f *FileDl) OnFinish(fn func()) {
	f.onFinish = fn
}

// OnError 任务出错时触发的事件
//
// errCode为错误码，errStr为错误描述
func (f *FileDl) OnError(fn func(int, error)) {
	f.onError = fn
}

// 用于触发事件
func (f FileDl) touch(fn func()) {
	if fn != nil {
		go fn()
	}
}

// 触发Error事件
func (f FileDl) touchOnError(errCode int, err error) {
	if f.onError != nil {
		go f.onError(errCode, err)
	}
}

// status 状态
type status struct {
	Downloaded int64 `json:"downloaded"`
	Speeds     int64
	MaxSpeeds  int64
}



================================================
FILE: downloader/downloader_block.go
================================================
[Binary file]


================================================
FILE: downloader/downloader_config.go
================================================
package downloader

import (
	"regexp"
)

var (
	maxParallel       = 5
	cacheSize   int64 = 2048

	// FileNameRE 正则表达式: 匹配文件名
	FileNameRE = regexp.MustCompile("filename=\"(.*?)\"")
)

// SetMaxParallel 设置最大线程
func SetMaxParallel(t int) {
	if t <= 0 {
		panic("downloader.SetMaxParallel: zero or negative parallel")
	}
	maxParallel = t
}

// SetCacheSize 设置缓冲大小
func SetCacheSize(size int64) {
	if size < 1024 {
		cacheSize = 1024
		return
	}
	cacheSize = size
}



================================================
FILE: downloader/example.go
================================================
package downloader

import (
	"fmt"
	"os"
	"strings"
	"time"
)

// DoDownload 简单网络下载器, 使用默认下载线程,
// 通过调用 SetMaxThread 来修改默认下载线程
func DoDownload(url string, fileName string, sizeofFile int64) {
	h := NewHTTPClient()
	fileDl, err := NewFileDl(h, url, fileName, sizeofFile)
	if err != nil {
		return
	}

	done := make(chan struct{})

	var exit = make(chan bool)
	fileDl.OnStart(func() {
		fmt.Println("download started")
		format := "\r%v/%v [%s] %v byte/s %v"

	for_1:
		for {
			status := fileDl.GetStatus()
			var i = float64(status.Downloaded) / float64(fileDl.Size) * 50
			h := strings.Repeat("=", int(i)) + strings.Repeat(" ", 50-int(i))

			select {
			case <-exit:
				fmt.Printf(format, status.Downloaded, fileDl.Size, h, 0, "[FINISH]")
				fmt.Println("\ndownload finished")
				break for_1
			default:
				time.Sleep(time.Second * 1)
				fmt.Printf(format, status.Downloaded, fileDl.Size, h, status.Speeds, "[DOWNLOADING]")
				os.Stdout.Sync()
			}
		}
	})

	fileDl.OnFinish(func() {
		exit <- true
		done <- struct{}{}
	})

	fileDl.OnError(func(errCode int, e error) {
		err = e
	})

	fileDl.Start()
	<-done
}



================================================
FILE: downloader/fetch.go
================================================
package downloader

import (
	"bytes"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// HTTPGet 简单实现 http 访问 GET 请求
func HTTPGet(urlStr string) (body []byte, err error) {
	resp, err := http.Get(urlStr)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	return ioutil.ReadAll(resp.Body)
}

// Fetch 实现 http／https 访问 和 GET／POST 请求，
// 根据给定的 method (GET, POST, HEAD, PUT 等等), urlStr (网址),
// post (post 数据), header (header 请求头数据), 进行网站访问。
// 返回值分别为 网站主体, 错误
func (h *HTTPClient) Fetch(method string, urlStr string, post interface{}, header map[string]string) (body []byte, err error) {
	var (
		req   *http.Request
		obody io.Reader
	)

	if post != nil {
		switch value := post.(type) {
		case map[string]string:
			query := url.Values{}
			for k := range value {
				query.Set(k, value[k])
			}
			obody = strings.NewReader(query.Encode())
		case string:
			obody = strings.NewReader(value)
		case []byte:
			obody = bytes.NewReader(value[:])
		}
	}
	req, err = http.NewRequest(method, urlStr, obody)
	if err != nil {
		return nil, err
	}

	if header != nil {
		for key := range header {
			req.Header.Add(key, header[key])
		}
	}

	resp, err := h.Client.Do(req)
	if err != nil {
		return nil, err
	}

	body, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	return
}



================================================
FILE: downloader/http_client.go
================================================
package downloader

import (
	"crypto/tls"
	"net/http"
	"net/http/cookiejar"
	"time"
)

// HTTPClient http client
type HTTPClient struct {
	Client http.Client
}

// NewHTTPClient 返回 HTTPClient 的指针,
// 预设了一些配置
func NewHTTPClient() *HTTPClient {
	return &HTTPClient{
		Client: http.Client{
			Transport: &http.Transport{
				TLSClientConfig: &tls.Config{
					InsecureSkipVerify: true,
				},
				TLSHandshakeTimeout:   10 * time.Second,
				DisableKeepAlives:     false,
				DisableCompression:    false,
				ResponseHeaderTimeout: 10 * time.Second,
				ExpectContinueTimeout: 10 * time.Second,
			},
		},
	}
}

// SetCookiejar 设置 cookie
func (h *HTTPClient) SetCookiejar(c *cookiejar.Jar) {
	h.Client.Jar = c
}

// ClearCookiejar 清空 cookie
func (h *HTTPClient) ClearCookiejar() {
	h.Client.Jar, _ = cookiejar.New(nil)
}

// SetHTTPSecure 是否启用 https 安全检查
func (h *HTTPClient) SetHTTPSecure(b bool) {
	h.Client.Transport.(*http.Transport).TLSClientConfig.InsecureSkipVerify = !b
}

// SetKeepAlive 设置 Keep-Alive
func (h *HTTPClient) SetKeepAlive(b bool) {
	h.Client.Transport.(*http.Transport).DisableKeepAlives = !b
}

//SetGzip 是否启用Gzip
func (h *HTTPClient) SetGzip(b bool) {
	h.Client.Transport.(*http.Transport).DisableCompression = !b
}

//SetResponseHeaderTimeout 设置目标服务器响应超时时间
func (h *HTTPClient) SetResponseHeaderTimeout(t time.Duration) {
	h.Client.Transport.(*http.Transport).ResponseHeaderTimeout = t
}

// SetTimeout 设置 http 请求超时时间 默认30s
func (h *HTTPClient) SetTimeout(t time.Duration) {
	h.Client.Timeout = t
}



================================================
FILE: downloader/resume_breakpoint.go
================================================
package downloader

import (
	"encoding/json"
	"io/ioutil"
)

var (
	// DownloadingFileSuffix 断点续传临时文件后缀
	DownloadingFileSuffix = ".baidupcs_go_downloading"
)

type downloadStatus struct {
	Downloaded int64     `json:"downloaded"`
	BlockList  blockList `json:"block_list"`
}

// recordBreakPoint 保存下载断点到文件, 用于断点续传
func (f *FileDl) recordBreakPoint() error {
	byt, err := json.Marshal(downloadStatus{
		Downloaded: f.status.Downloaded,
		BlockList:  f.BlockList,
	})
	if err != nil {
		return err
	}
	return ioutil.WriteFile(f.File.Name()+DownloadingFileSuffix, byt, 0644)
}

// loadBreakPoint 尝试从文件载入下载断点
func (f *FileDl) loadBreakPoint() error {
	byt, err := ioutil.ReadFile(f.File.Name() + DownloadingFileSuffix)
	if err != nil {
		return err
	}
	downloadStatus := new(downloadStatus)
	err = json.Unmarshal(byt, downloadStatus)
	if err != nil {
		return err
	}
	f.status.Downloaded = downloadStatus.Downloaded
	f.BlockList = downloadStatus.BlockList
	return nil
}



================================================
FILE: util/convert.go
================================================
package pcsutil

import (
	"fmt"
	"time"
)

const (
	b = (int64)(1 << (10 * iota))
	kb
	mb
	gb
	tb
	pb
)

// ConvertFileSize 文件大小格式化输出
func ConvertFileSize(size int64, precision ...int) string {
	p := 6
	if len(precision) == 1 {
		p = precision[0]
	}
	pint := fmt.Sprint(p)
	if size <= 0 {
		return "0"
	}
	if size < kb {
		return fmt.Sprintf("%."+pint+"fB", float64(size)/float64(b))
	}
	if size < mb {
		return fmt.Sprintf("%."+pint+"fKB", float64(size)/float64(kb))
	}
	if size < gb {
		return fmt.Sprintf("%."+pint+"fMB", float64(size)/float64(mb))
	}
	if size < tb {
		return fmt.Sprintf("%."+pint+"fGB", float64(size)/float64(gb))
	}
	if size < pb {
		return fmt.Sprintf("%."+pint+"fTB", float64(size)/float64(tb))
	}
	return fmt.Sprintf("%."+pint+"fPB", float64(size)/float64(pb))
}

// IntToBool int 类型转换为 bool
func IntToBool(i int) bool {
	if i == 0 {
		return false
	}
	return true
}

// FormatTime 讲 Unix 时间戳, 转换为字符串
func FormatTime(t int64) string {
	return time.Unix(t, 0).Format("2006-01-02 03:04:05")
}



================================================
FILE: util/error.go
================================================
package pcsutil

import (
	"log"
	"os"
)

// PrintErrIfExist 简易错误处理, 如果 err 存在, 就只向屏幕输出 err 。
func PrintErrIfExist(err error) {
	if err != nil {
		log.Println(err)
	}
}

// PrintErrAndExit 简易错误处理, 如果 err 存在, 向屏幕输出 err 并退出, annotate 是加在 err 之前的注释信息。
func PrintErrAndExit(annotate string, err error) {
	if err != nil {
		log.Println(annotate, err)
		os.Exit(1)
	}
}



================================================
FILE: util/log_colorable_prefix.go
================================================
package pcsutil

import (
	"fmt"
	"github.com/fatih/color"
	"log"
)

var (
	// ErrorColor 设置输出错误的颜色
	ErrorColor = color.New(color.FgRed).SprintFunc()
)

// 自定义log writer
type logWriter struct{}

func (logWriter) Write(bytes []byte) (int, error) {
	return fmt.Fprint(color.Output, "["+BeijingTimeOption("Refer")+"] "+string(bytes))
}

// SetLogPrefix 设置日志输出的时间前缀
func SetLogPrefix() {
	log.SetFlags(0)
	log.SetOutput(new(logWriter))
}



================================================
FILE: util/regexp_pre.go
================================================
package pcsutil

import (
	"regexp"
)

var (
	// HTTPSRE https regexp
	HTTPSRE = regexp.MustCompile("^https")
	// ChinaPhoneRE https regexp
	ChinaPhoneRE = regexp.MustCompile("^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\\d{8}$")
)



================================================
FILE: util/tieba_client_signature.go
================================================
package pcsutil

import (
	"bytes"
	"sort"
	"strings"
)

// TiebaClientSignature 根据给定贴吧客户端的 post (post数据指针) 进行签名, 以通过百度服务器验证。返回值为: sign 签名字符串
func TiebaClientSignature(post map[string]string) {
	if post == nil {
		return
	}
	// 预设
	post["_client_type"] = "2"
	post["_client_version"] = "6.9.2.1"
	post["_phone_imei"] = "860983036542682"
	post["from"] = "mini_ad_wandoujia"
	post["model"] = "HUAWEI NXT-AL10"
	post["cuid"] = "61464018582906C485355A89D105ECFB|286245630389068"
	var keys []string
	for key := range post {
		keys = append(keys, key)
	}
	sort.Sort(sort.StringSlice(keys))

	var bb bytes.Buffer
	for _, key := range keys {
		bb.WriteString(key + "=" + post[key])
	}
	bb.WriteString("tiebaclient!!!")
	post["sign"] = Md5Encrypt(bb.Bytes()[:])
}

// TiebaClientRawQuerySignature 给 rawQuery 进行贴吧客户端签名
func TiebaClientRawQuerySignature(rawQuery string) (sign string) {
	return rawQuery + "&sign=" + Md5Encrypt(strings.Replace(rawQuery, "&", "", -1)+"tiebaclient!!!")
}



================================================
FILE: util/time.go
================================================
package pcsutil

import (
	"fmt"
	"time"
)

var (
	// CSTLocation CST Location
	CSTLocation = time.FixedZone("CST", 8*3600)
)

/*
BeijingTimeOption 根据给定的 get 返回时间格式.

	get:        时间格式

	"Refer":    2017-7-21 12:02:32.000
	"printLog": 2017-7-21_12:02:32
	"day":      21
	"ymd":      2017-7-21
	"hour":     12
	默认时间戳:   1500609752
*/
func BeijingTimeOption(get string) string {
	//获取北京（东八区）时间
	CSTLoc := time.FixedZone("CST", 8*3600) // 东8区
	now := time.Now().In(CSTLoc)
	year, mon, day := now.Date()
	hour, min, sec := now.Clock()
	millisecond := now.Nanosecond() / 1e6
	switch get {
	case "Refer":
		return fmt.Sprintf("%d-%d-%d %02d:%02d:%02d.%03d", year, mon, day, hour, min, sec, millisecond)
	case "printLog":
		return fmt.Sprintf("%d-%d-%d_%02dh%02dm%02ds", year, mon, day, hour, min, sec)
	case "day":
		return fmt.Sprint(day)
	case "ymd":
		return fmt.Sprintf("%d-%d-%d", year, mon, day)
	case "hour":
		return fmt.Sprint(hour)
	default:
		return fmt.Sprint(time.Now().Unix())
	}
}



================================================
FILE: util/unsafe_strconv_test.go
================================================
// go test -test.bench=".*"
package pcsutil

import (
	"testing"
)

var str = "asddsadfaalkdjsksajdfkashjkdfhashfliuhsadifhasifhaishdfiashdihaisdfhiuassfasdff"

func BenchmarkToBytes(b *testing.B) {
	for i := 0; i <= b.N; i++ {
		_ = ToBytes(str)
	}
}

func BenchmarkBytes(b *testing.B) {
	for i := 0; i <= b.N; i++ {
		_ = []byte(str)
	}
}



================================================
FILE: util/util.go
================================================
package pcsutil

import (
	"compress/gzip"
	"crypto/md5"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"net/http/cookiejar"
	"net/url"
	"os"
	"strings"
	"unsafe"
)

var (
	// PipeInput 命令中是否为管道输入
	PipeInput bool
)

func init() {
	fileInfo, err := os.Stdin.Stat()
	if err != nil {
		return
	}
	PipeInput = (fileInfo.Mode() & os.ModeNamedPipe) == os.ModeNamedPipe
}

// ToString 将 []byte 转换为 string
func ToString(p []byte) string {
	return *(*string)(unsafe.Pointer(&p))
}

// ToBytes 将 string 转换为 []byte
func ToBytes(str string) []byte {
	return *(*[]byte)(unsafe.Pointer(&str))
}

// GetURLCookieString 返回cookie字串
func GetURLCookieString(urlString string, jar *cookiejar.Jar) string {
	url, _ := url.Parse(urlString)
	cookies := jar.Cookies(url)
	cookieString := ""
	for _, v := range cookies {
		cookieString += v.String() + "; "
	}
	cookieString = strings.TrimRight(cookieString, "; ")
	return cookieString
}

// Md5Encrypt 对 str 进行md5加密, 返回值为 str 加密后的密文
func Md5Encrypt(str interface{}) string {
	md5Ctx := md5.New()
	switch value := str.(type) {
	case string:
		md5Ctx.Write([]byte(str.(string)))
	case *string:
		md5Ctx.Write([]byte(*str.(*string)))
	case []byte:
		md5Ctx.Write(str.([]byte))
	case *[]byte:
		md5Ctx.Write(*str.(*[]byte))
	default:
		fmt.Println("MD5Encrypt: undefined type:", value)
		return ""
	}
	return fmt.Sprintf("%X", md5Ctx.Sum(nil))
}

// DecompressGZIP 对 io.Reader 数据, 进行 gzip 解压
func DecompressGZIP(r io.Reader) ([]byte, error) {
	gzipReader, err := gzip.NewReader(r)
	if err != nil {
		return nil, err
	}
	gzipReader.Close()
	return ioutil.ReadAll(gzipReader)
}

// FlagProvided 检测命令行是否提供名为 name 的 flag, 支持多个name(names)
func FlagProvided(names ...string) bool {
	if len(names) == 0 {
		return false
	}
	var targetFlag *flag.Flag
	for _, name := range names {
		targetFlag = flag.Lookup(name)
		if targetFlag == nil {
			return false
		}
		if targetFlag.DefValue == targetFlag.Value.String() {
			return false
		}
	}
	return true
}



================================================
FILE: util/wait_group.go
================================================
package pcsutil

import "sync"

// WaitGroup 在 sync.WaitGroup 的基础上, 新增线程控制功能
type WaitGroup struct {
	wg sync.WaitGroup
	p  chan struct{}
}

// NewWaitGroup returns a pointer to a new `WaitGroup` object.
// parallel 为最大并发数, 0 代表无限制
func NewWaitGroup(parallel int) (w *WaitGroup) {
	w = &WaitGroup{}
	if parallel <= 0 {
		return
	}
	w.p = make(chan struct{}, parallel)
	return
}

// AddDelta 在 sync.WaitGroup 的基础上, 新增线程控制功能
func (w *WaitGroup) AddDelta() {
	w.wg.Add(1)
	if w.p == nil {
		return
	}
	w.p <- struct{}{}
}

// Done 在 sync.WaitGroup 的基础上, 新增线程控制功能
func (w *WaitGroup) Done() {
	w.wg.Done()
	if w.p == nil {
		return
	}
	<-w.p
}

// Wait 参照 sync.WaitGroup 的 Wait 方法
func (w *WaitGroup) Wait() {
	w.wg.Wait()
}

// Parallel 返回当前正在进行的任务数量
func (w *WaitGroup) Parallel() int {
	return len(w.p)
}



================================================
FILE: util/wait_group_test.go
================================================
package pcsutil

import (
	"fmt"
	"testing"
	"time"
)

func TestWg(t *testing.T) {
	wg := NewWaitGroup(2)
	for i := 0; i < 60; i++ {
		wg.AddDelta()
		go func() {
			fmt.Println(i, wg.Parallel())
			time.Sleep(1e9)
			wg.Done()
		}()
	}
	wg.Wait()
}


